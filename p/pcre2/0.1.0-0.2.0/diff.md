# Comparing `tmp/pcre2-0.1.0.tar.gz` & `tmp/pcre2-0.2.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pcre2-0.1.0.tar", last modified: Tue Nov  8 02:35:38 2022, max compression
+gzip compressed data, was "pcre2-0.2.0.tar", last modified: Sun Apr 16 23:23:24 2023, max compression
```

## Comparing `pcre2-0.1.0.tar` & `pcre2-0.2.0.tar`

### file list

```diff
@@ -1,472 +1,499 @@
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.376777 pcre2-0.1.0/
--rw-r--r--   0 runner    (1001) docker     (121)      706 2022-11-08 02:35:23.000000 pcre2-0.1.0/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     1518 2022-11-08 02:35:23.000000 pcre2-0.1.0/LICENSE
--rwxr-xr-x   0 runner    (1001) docker     (121)      720 2022-11-08 02:35:23.000000 pcre2-0.1.0/Makefile
--rw-r--r--   0 runner    (1001) docker     (121)     4082 2022-11-08 02:35:38.376777 pcre2-0.1.0/PKG-INFO
--rwxr-xr-x   0 runner    (1001) docker     (121)     3128 2022-11-08 02:35:23.000000 pcre2-0.1.0/README.md
--rwxr-xr-x   0 runner    (1001) docker     (121)      130 2022-11-08 02:35:23.000000 pcre2-0.1.0/pyproject.toml
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.300776 pcre2-0.1.0/requirements/
--rw-r--r--   0 runner    (1001) docker     (121)       46 2022-11-08 02:35:23.000000 pcre2-0.1.0/requirements/build-requirements.txt
--rw-r--r--   0 runner    (1001) docker     (121)       12 2022-11-08 02:35:23.000000 pcre2-0.1.0/requirements/test-requirements.txt
--rw-r--r--   0 runner    (1001) docker     (121)       38 2022-11-08 02:35:38.376777 pcre2-0.1.0/setup.cfg
--rwxr-xr-x   0 runner    (1001) docker     (121)     1472 2022-11-08 02:35:23.000000 pcre2-0.1.0/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.300776 pcre2-0.1.0/src/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.304777 pcre2-0.1.0/src/libpcre2/
--rw-r--r--   0 runner    (1001) docker     (121)       40 2022-11-08 02:35:24.000000 pcre2-0.1.0/src/libpcre2/.git
--rw-r--r--   0 runner    (1001) docker     (121)      833 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/.gitignore
--rwxr-xr-x   0 runner    (1001) docker     (121)     7049 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/132html
--rw-r--r--   0 runner    (1001) docker     (121)      749 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/AUTHORS
--rw-r--r--   0 runner    (1001) docker     (121)    45339 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)       97 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/COPYING
--rw-r--r--   0 runner    (1001) docker     (121)   127124 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/ChangeLog
--rwxr-xr-x   0 runner    (1001) docker     (121)     1697 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/CheckMan
--rwxr-xr-x   0 runner    (1001) docker     (121)     2941 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/CleanTxt
--rwxr-xr-x   0 runner    (1001) docker     (121)      643 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/Detrail
--rw-r--r--   0 runner    (1001) docker     (121)    38599 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/HACKING
--rw-r--r--   0 runner    (1001) docker     (121)     3477 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/LICENCE
--rw-r--r--   0 runner    (1001) docker     (121)    26173 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/Makefile.am
--rw-r--r--   0 runner    (1001) docker     (121)    15110 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/NEWS
--rw-r--r--   0 runner    (1001) docker     (121)    18447 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/NON-AUTOTOOLS-BUILD
--rwxr-xr-x   0 runner    (1001) docker     (121)     6924 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/PrepareRelease
--rw-r--r--   0 runner    (1001) docker     (121)    43547 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/README
--rw-r--r--   0 runner    (1001) docker     (121)     2381 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/README.md
--rwxr-xr-x   0 runner    (1001) docker     (121)    41349 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/RunGrepTest
--rw-r--r--   0 runner    (1001) docker     (121)    35213 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/RunGrepTest.bat
--rwxr-xr-x   0 runner    (1001) docker     (121)    25709 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/RunTest
--rw-r--r--   0 runner    (1001) docker     (121)    13862 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/RunTest.bat
--rwxr-xr-x   0 runner    (1001) docker     (121)     1250 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/autogen.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.304777 pcre2-0.1.0/src/libpcre2/cmake/
--rw-r--r--   0 runner    (1001) docker     (121)     1327 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/cmake/COPYING-CMAKE-SCRIPTS
--rw-r--r--   0 runner    (1001) docker     (121)      556 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/cmake/FindEditline.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     2410 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/cmake/FindPackageHandleStandardArgs.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     1287 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/cmake/FindReadline.cmake
--rw-r--r--   0 runner    (1001) docker     (121)      542 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/cmake/pcre2-config-version.cmake.in
--rw-r--r--   0 runner    (1001) docker     (121)     5062 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/cmake/pcre2-config.cmake.in
--rw-r--r--   0 runner    (1001) docker     (121)     1586 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/config-cmake.h.in
--rw-r--r--   0 runner    (1001) docker     (121)    41805 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/configure.ac
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.312777 pcre2-0.1.0/src/libpcre2/doc/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.324777 pcre2-0.1.0/src/libpcre2/doc/html/
--rw-r--r--   0 runner    (1001) docker     (121)    18447 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/NON-AUTOTOOLS-BUILD.txt
--rw-r--r--   0 runner    (1001) docker     (121)    43547 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/README.txt
--rw-r--r--   0 runner    (1001) docker     (121)    13975 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/index.html
--rw-r--r--   0 runner    (1001) docker     (121)     3498 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2-config.html
--rw-r--r--   0 runner    (1001) docker     (121)     9909 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2.html
--rw-r--r--   0 runner    (1001) docker     (121)     2431 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_callout_enumerate.html
--rw-r--r--   0 runner    (1001) docker     (121)     1370 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_code_copy.html
--rw-r--r--   0 runner    (1001) docker     (121)     1491 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_code_copy_with_tables.html
--rw-r--r--   0 runner    (1001) docker     (121)     1243 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_code_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     4556 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_compile.html
--rw-r--r--   0 runner    (1001) docker     (121)     1176 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_compile_context_copy.html
--rw-r--r--   0 runner    (1001) docker     (121)     1271 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_compile_context_create.html
--rw-r--r--   0 runner    (1001) docker     (121)     1233 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_compile_context_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     3575 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_config.html
--rw-r--r--   0 runner    (1001) docker     (121)     1157 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_convert_context_copy.html
--rw-r--r--   0 runner    (1001) docker     (121)     1251 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_convert_context_create.html
--rw-r--r--   0 runner    (1001) docker     (121)     1214 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_convert_context_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     1249 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_converted_pattern_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     3865 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_dfa_match.html
--rw-r--r--   0 runner    (1001) docker     (121)     1225 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_general_context_copy.html
--rw-r--r--   0 runner    (1001) docker     (121)     1486 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_general_context_create.html
--rw-r--r--   0 runner    (1001) docker     (121)     1172 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_general_context_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     1745 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_error_message.html
--rw-r--r--   0 runner    (1001) docker     (121)     1505 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_mark.html
--rw-r--r--   0 runner    (1001) docker     (121)     1053 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_match_data_size.html
--rw-r--r--   0 runner    (1001) docker     (121)     1072 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_ovector_count.html
--rw-r--r--   0 runner    (1001) docker     (121)     1148 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_ovector_pointer.html
--rw-r--r--   0 runner    (1001) docker     (121)     1430 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_startchar.html
--rw-r--r--   0 runner    (1001) docker     (121)     2238 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_compile.html
--rw-r--r--   0 runner    (1001) docker     (121)     1328 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_free_unused_memory.html
--rw-r--r--   0 runner    (1001) docker     (121)     2143 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_match.html
--rw-r--r--   0 runner    (1001) docker     (121)     2562 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_stack_assign.html
--rw-r--r--   0 runner    (1001) docker     (121)     1825 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_stack_create.html
--rw-r--r--   0 runner    (1001) docker     (121)     1223 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_stack_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     1647 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_maketables.html
--rw-r--r--   0 runner    (1001) docker     (121)     1223 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_maketables_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     3673 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match.html
--rw-r--r--   0 runner    (1001) docker     (121)     1164 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_context_copy.html
--rw-r--r--   0 runner    (1001) docker     (121)     1261 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_context_create.html
--rw-r--r--   0 runner    (1001) docker     (121)     1223 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_context_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     1755 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_data_create.html
--rw-r--r--   0 runner    (1001) docker     (121)     1930 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_data_create_from_pattern.html
--rw-r--r--   0 runner    (1001) docker     (121)     1417 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_data_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     2663 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_pattern_convert.html
--rw-r--r--   0 runner    (1001) docker     (121)     4816 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_pattern_info.html
--rw-r--r--   0 runner    (1001) docker     (121)     2547 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_serialize_decode.html
--rw-r--r--   0 runner    (1001) docker     (121)     2721 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_serialize_encode.html
--rw-r--r--   0 runner    (1001) docker     (121)     1187 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_serialize_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     1634 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_serialize_get_number_of_codes.html
--rw-r--r--   0 runner    (1001) docker     (121)     1199 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_bsr.html
--rw-r--r--   0 runner    (1001) docker     (121)     1276 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_callout.html
--rw-r--r--   0 runner    (1001) docker     (121)     1437 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_character_tables.html
--rw-r--r--   0 runner    (1001) docker     (121)     1713 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_compile_extra_options.html
--rw-r--r--   0 runner    (1001) docker     (121)     1664 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_compile_recursion_guard.html
--rw-r--r--   0 runner    (1001) docker     (121)     1080 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_depth_limit.html
--rw-r--r--   0 runner    (1001) docker     (121)     1365 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_glob_escape.html
--rw-r--r--   0 runner    (1001) docker     (121)     1336 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_glob_separator.html
--rw-r--r--   0 runner    (1001) docker     (121)     1076 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_heap_limit.html
--rw-r--r--   0 runner    (1001) docker     (121)     1067 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_match_limit.html
--rw-r--r--   0 runner    (1001) docker     (121)     1336 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_max_pattern_length.html
--rw-r--r--   0 runner    (1001) docker     (121)     1566 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_newline.html
--rw-r--r--   0 runner    (1001) docker     (121)     1073 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_offset_limit.html
--rw-r--r--   0 runner    (1001) docker     (121)     1122 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_parens_nest_limit.html
--rw-r--r--   0 runner    (1001) docker     (121)     1097 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_recursion_limit.html
--rw-r--r--   0 runner    (1001) docker     (121)     1245 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_recursion_memory_management.html
--rw-r--r--   0 runner    (1001) docker     (121)     1331 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_substitute_callout.html
--rw-r--r--   0 runner    (1001) docker     (121)     4953 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substitute.html
--rw-r--r--   0 runner    (1001) docker     (121)     2059 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_copy_byname.html
--rw-r--r--   0 runner    (1001) docker     (121)     1860 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_copy_bynumber.html
--rw-r--r--   0 runner    (1001) docker     (121)     1196 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     2187 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_get_byname.html
--rw-r--r--   0 runner    (1001) docker     (121)     2023 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_get_bynumber.html
--rw-r--r--   0 runner    (1001) docker     (121)     1364 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_length_byname.html
--rw-r--r--   0 runner    (1001) docker     (121)     1518 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_length_bynumber.html
--rw-r--r--   0 runner    (1001) docker     (121)     1211 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_list_free.html
--rw-r--r--   0 runner    (1001) docker     (121)     2136 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_list_get.html
--rw-r--r--   0 runner    (1001) docker     (121)     1837 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_nametable_scan.html
--rw-r--r--   0 runner    (1001) docker     (121)     1645 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_number_from_name.html
--rw-r--r--   0 runner    (1001) docker     (121)   188192 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2api.html
--rw-r--r--   0 runner    (1001) docker     (121)    26987 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2build.html
--rw-r--r--   0 runner    (1001) docker     (121)    20379 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2callout.html
--rw-r--r--   0 runner    (1001) docker     (121)    11484 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2compat.html
--rw-r--r--   0 runner    (1001) docker     (121)     7892 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2convert.html
--rw-r--r--   0 runner    (1001) docker     (121)    20854 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2demo.html
--rw-r--r--   0 runner    (1001) docker     (121)    52631 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2grep.html
--rw-r--r--   0 runner    (1001) docker     (121)    21785 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2jit.html
--rw-r--r--   0 runner    (1001) docker     (121)     3239 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2limits.html
--rw-r--r--   0 runner    (1001) docker     (121)    11153 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2matching.html
--rw-r--r--   0 runner    (1001) docker     (121)    18580 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2partial.html
--rw-r--r--   0 runner    (1001) docker     (121)   167849 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2pattern.html
--rw-r--r--   0 runner    (1001) docker     (121)    11845 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2perform.html
--rw-r--r--   0 runner    (1001) docker     (121)    15881 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2posix.html
--rw-r--r--   0 runner    (1001) docker     (121)     3905 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2sample.html
--rw-r--r--   0 runner    (1001) docker     (121)    10059 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2serialize.html
--rw-r--r--   0 runner    (1001) docker     (121)    22770 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2syntax.html
--rw-r--r--   0 runner    (1001) docker     (121)    94238 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2test.html
--rw-r--r--   0 runner    (1001) docker     (121)    21071 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/html/pcre2unicode.html
--rw-r--r--   0 runner    (1001) docker     (121)    13975 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/index.html.src
--rw-r--r--   0 runner    (1001) docker     (121)     2577 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2-config.1
--rw-r--r--   0 runner    (1001) docker     (121)     2929 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2-config.txt
--rw-r--r--   0 runner    (1001) docker     (121)     8896 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2.3
--rw-r--r--   0 runner    (1001) docker     (121)   576203 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2.txt
--rw-r--r--   0 runner    (1001) docker     (121)     1890 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_callout_enumerate.3
--rw-r--r--   0 runner    (1001) docker     (121)      879 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_code_copy.3
--rw-r--r--   0 runner    (1001) docker     (121)      975 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_code_copy_with_tables.3
--rw-r--r--   0 runner    (1001) docker     (121)      748 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_code_free.3
--rw-r--r--   0 runner    (1001) docker     (121)     3991 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_compile.3
--rw-r--r--   0 runner    (1001) docker     (121)      674 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_compile_context_copy.3
--rw-r--r--   0 runner    (1001) docker     (121)      766 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_compile_context_create.3
--rw-r--r--   0 runner    (1001) docker     (121)      729 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_compile_context_free.3
--rw-r--r--   0 runner    (1001) docker     (121)     3193 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_config.3
--rw-r--r--   0 runner    (1001) docker     (121)      666 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_convert_context_copy.3
--rw-r--r--   0 runner    (1001) docker     (121)      757 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_convert_context_create.3
--rw-r--r--   0 runner    (1001) docker     (121)      724 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_convert_context_free.3
--rw-r--r--   0 runner    (1001) docker     (121)      757 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_converted_pattern_free.3
--rw-r--r--   0 runner    (1001) docker     (121)     3438 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_dfa_match.3
--rw-r--r--   0 runner    (1001) docker     (121)      722 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_general_context_copy.3
--rw-r--r--   0 runner    (1001) docker     (121)      977 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_general_context_create.3
--rw-r--r--   0 runner    (1001) docker     (121)      669 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_general_context_free.3
--rw-r--r--   0 runner    (1001) docker     (121)     1233 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_get_error_message.3
--rw-r--r--   0 runner    (1001) docker     (121)     1010 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_get_mark.3
--rw-r--r--   0 runner    (1001) docker     (121)      551 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_get_match_data_size.3
--rw-r--r--   0 runner    (1001) docker     (121)      575 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_get_ovector_count.3
--rw-r--r--   0 runner    (1001) docker     (121)      648 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_get_ovector_pointer.3
--rw-r--r--   0 runner    (1001) docker     (121)      936 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_get_startchar.3
--rw-r--r--   0 runner    (1001) docker     (121)     1706 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_compile.3
--rw-r--r--   0 runner    (1001) docker     (121)      825 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_free_unused_memory.3
--rw-r--r--   0 runner    (1001) docker     (121)     1592 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_match.3
--rw-r--r--   0 runner    (1001) docker     (121)     1992 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_stack_assign.3
--rw-r--r--   0 runner    (1001) docker     (121)     1304 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_stack_create.3
--rw-r--r--   0 runner    (1001) docker     (121)      705 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_stack_free.3
--rw-r--r--   0 runner    (1001) docker     (121)     1108 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_maketables.3
--rw-r--r--   0 runner    (1001) docker     (121)      713 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_maketables_free.3
--rw-r--r--   0 runner    (1001) docker     (121)     3278 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_match.3
--rw-r--r--   0 runner    (1001) docker     (121)      664 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_match_context_copy.3
--rw-r--r--   0 runner    (1001) docker     (121)      758 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_match_context_create.3
--rw-r--r--   0 runner    (1001) docker     (121)      721 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_match_context_free.3
--rw-r--r--   0 runner    (1001) docker     (121)     1245 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_match_data_create.3
--rw-r--r--   0 runner    (1001) docker     (121)     1407 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_match_data_create_from_pattern.3
--rw-r--r--   0 runner    (1001) docker     (121)      913 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_match_data_free.3
--rw-r--r--   0 runner    (1001) docker     (121)     2140 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_pattern_convert.3
--rw-r--r--   0 runner    (1001) docker     (121)     4529 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_pattern_info.3
--rw-r--r--   0 runner    (1001) docker     (121)     2016 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_serialize_decode.3
--rw-r--r--   0 runner    (1001) docker     (121)     2191 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_serialize_encode.3
--rw-r--r--   0 runner    (1001) docker     (121)      685 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_serialize_free.3
--rw-r--r--   0 runner    (1001) docker     (121)     1110 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_serialize_get_number_of_codes.3
--rw-r--r--   0 runner    (1001) docker     (121)      710 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_bsr.3
--rw-r--r--   0 runner    (1001) docker     (121)      777 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_callout.3
--rw-r--r--   0 runner    (1001) docker     (121)      912 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_character_tables.3
--rw-r--r--   0 runner    (1001) docker     (121)     1362 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_compile_extra_options.3
--rw-r--r--   0 runner    (1001) docker     (121)     1151 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_compile_recursion_guard.3
--rw-r--r--   0 runner    (1001) docker     (121)      580 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_depth_limit.3
--rw-r--r--   0 runner    (1001) docker     (121)      878 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_glob_escape.3
--rw-r--r--   0 runner    (1001) docker     (121)      846 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_glob_separator.3
--rw-r--r--   0 runner    (1001) docker     (121)      577 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_heap_limit.3
--rw-r--r--   0 runner    (1001) docker     (121)      569 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_match_limit.3
--rw-r--r--   0 runner    (1001) docker     (121)      830 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_max_pattern_length.3
--rw-r--r--   0 runner    (1001) docker     (121)     1063 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_newline.3
--rw-r--r--   0 runner    (1001) docker     (121)      576 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_offset_limit.3
--rw-r--r--   0 runner    (1001) docker     (121)      618 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_parens_nest_limit.3
--rw-r--r--   0 runner    (1001) docker     (121)      592 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_recursion_limit.3
--rw-r--r--   0 runner    (1001) docker     (121)      723 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_recursion_memory_management.3
--rw-r--r--   0 runner    (1001) docker     (121)      824 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_set_substitute_callout.3
--rw-r--r--   0 runner    (1001) docker     (121)     4722 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substitute.3
--rw-r--r--   0 runner    (1001) docker     (121)     1538 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_copy_byname.3
--rw-r--r--   0 runner    (1001) docker     (121)     1335 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_copy_bynumber.3
--rw-r--r--   0 runner    (1001) docker     (121)      693 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_free.3
--rw-r--r--   0 runner    (1001) docker     (121)     1667 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_get_byname.3
--rw-r--r--   0 runner    (1001) docker     (121)     1501 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_get_bynumber.3
--rw-r--r--   0 runner    (1001) docker     (121)      849 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_length_byname.3
--rw-r--r--   0 runner    (1001) docker     (121)     1002 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_length_bynumber.3
--rw-r--r--   0 runner    (1001) docker     (121)      704 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_list_free.3
--rw-r--r--   0 runner    (1001) docker     (121)     1620 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_list_get.3
--rw-r--r--   0 runner    (1001) docker     (121)     1319 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_nametable_scan.3
--rw-r--r--   0 runner    (1001) docker     (121)     1128 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_number_from_name.3
--rw-r--r--   0 runner    (1001) docker     (121)   179277 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2api.3
--rw-r--r--   0 runner    (1001) docker     (121)    23665 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2build.3
--rw-r--r--   0 runner    (1001) docker     (121)    18823 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2callout.3
--rw-r--r--   0 runner    (1001) docker     (121)    10848 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2compat.3
--rw-r--r--   0 runner    (1001) docker     (121)     6652 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2convert.3
--rw-r--r--   0 runner    (1001) docker     (121)    20352 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2demo.3
--rw-r--r--   0 runner    (1001) docker     (121)    49635 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2grep.1
--rw-r--r--   0 runner    (1001) docker     (121)    58934 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2grep.txt
--rw-r--r--   0 runner    (1001) docker     (121)    19870 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2jit.3
--rw-r--r--   0 runner    (1001) docker     (121)     2717 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2limits.3
--rw-r--r--   0 runner    (1001) docker     (121)     9718 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2matching.3
--rw-r--r--   0 runner    (1001) docker     (121)    17050 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2partial.3
--rw-r--r--   0 runner    (1001) docker     (121)   163283 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2pattern.3
--rw-r--r--   0 runner    (1001) docker     (121)    10717 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2perform.3
--rw-r--r--   0 runner    (1001) docker     (121)    14289 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2posix.3
--rw-r--r--   0 runner    (1001) docker     (121)     3348 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2sample.3
--rw-r--r--   0 runner    (1001) docker     (121)     8941 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2serialize.3
--rw-r--r--   0 runner    (1001) docker     (121)    19207 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2syntax.3
--rw-r--r--   0 runner    (1001) docker     (121)    89708 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2test.1
--rw-r--r--   0 runner    (1001) docker     (121)    97972 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2test.txt
--rw-r--r--   0 runner    (1001) docker     (121)    20259 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/doc/pcre2unicode.3
--rw-r--r--   0 runner    (1001) docker     (121)     2381 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/index.md
--rw-r--r--   0 runner    (1001) docker     (121)      406 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/libpcre2-16.pc.in
--rw-r--r--   0 runner    (1001) docker     (121)      406 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/libpcre2-32.pc.in
--rw-r--r--   0 runner    (1001) docker     (121)      403 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/libpcre2-8.pc.in
--rw-r--r--   0 runner    (1001) docker     (121)      342 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/libpcre2-posix.pc.in
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.324777 pcre2-0.1.0/src/libpcre2/m4/
--rw-r--r--   0 runner    (1001) docker     (121)    12534 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/m4/ax_pthread.m4
--rw-r--r--   0 runner    (1001) docker     (121)     4059 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/m4/pcre2_visibility.m4
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.328777 pcre2-0.1.0/src/libpcre2/maint/
--rw-r--r--   0 runner    (1001) docker     (121)    11730 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/GenerateCommon.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     5510 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/GenerateTest26.py
--rwxr-xr-x   0 runner    (1001) docker     (121)    33845 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/GenerateUcd.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     3212 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/GenerateUcpHeader.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7303 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/GenerateUcpTables.py
--rwxr-xr-x   0 runner    (1001) docker     (121)    14070 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/ManyConfigTests
--rw-r--r--   0 runner    (1001) docker     (121)    21719 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/README
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.336777 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/
--rw-r--r--   0 runner    (1001) docker     (121)    26690 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/BidiMirroring.txt
--rw-r--r--   0 runner    (1001) docker     (121)    84688 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/CaseFolding.txt
--rw-r--r--   0 runner    (1001) docker     (121)   169291 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/DerivedBidiClass.txt
--rw-r--r--   0 runner    (1001) docker     (121)  1040794 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/DerivedCoreProperties.txt
--rw-r--r--   0 runner    (1001) docker     (121)   265751 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/DerivedGeneralCategory.txt
--rw-r--r--   0 runner    (1001) docker     (121)    95663 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/GraphemeBreakProperty.txt
--rw-r--r--   0 runner    (1001) docker     (121)   130164 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/PropList.txt
--rw-r--r--   0 runner    (1001) docker     (121)     8825 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/PropertyAliases.txt
--rw-r--r--   0 runner    (1001) docker     (121)    76759 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/PropertyValueAliases.txt
--rw-r--r--   0 runner    (1001) docker     (121)    21969 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/ScriptExtensions.txt
--rw-r--r--   0 runner    (1001) docker     (121)   181635 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/Scripts.txt
--rw-r--r--   0 runner    (1001) docker     (121)  1897793 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/UnicodeData.txt
--rw-r--r--   0 runner    (1001) docker     (121)   109396 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/emoji-data.txt
--rw-r--r--   0 runner    (1001) docker     (121)     3624 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/pcre2_chartables.c.non-standard
--rw-r--r--   0 runner    (1001) docker     (121)    29322 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/ucptest.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.336777 pcre2-0.1.0/src/libpcre2/maint/ucptestdata/
--rw-r--r--   0 runner    (1001) docker     (121)     1675 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/ucptestdata/testinput1
--rw-r--r--   0 runner    (1001) docker     (121)      332 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/ucptestdata/testinput2
--rw-r--r--   0 runner    (1001) docker     (121)    50905 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/ucptestdata/testoutput1
--rw-r--r--   0 runner    (1001) docker     (121)    32875 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/ucptestdata/testoutput2
--rw-r--r--   0 runner    (1001) docker     (121)     8629 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/maint/utf8.c
--rw-r--r--   0 runner    (1001) docker     (121)     2346 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/pcre2-config.in
--rw-r--r--   0 runner    (1001) docker     (121)      435 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/pcre2_fuzzer.dict
--rw-r--r--   0 runner    (1001) docker     (121)       37 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/pcre2_fuzzer.options
--rwxr-xr-x   0 runner    (1001) docker     (121)    11365 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/perltest.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.352777 pcre2-0.1.0/src/libpcre2/src/
--rw-r--r--   0 runner    (1001) docker     (121)    17215 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/config.h.generic
--rw-r--r--   0 runner    (1001) docker     (121)    16359 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/config.h.in
--rw-r--r--   0 runner    (1001) docker     (121)    47257 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2.h.generic
--rw-r--r--   0 runner    (1001) docker     (121)    47299 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2.h.in
--rw-r--r--   0 runner    (1001) docker     (121)    40417 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_auto_possess.c
--rw-r--r--   0 runner    (1001) docker     (121)     8105 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_chartables.c.dist
--rw-r--r--   0 runner    (1001) docker     (121)   353430 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_compile.c
--rw-r--r--   0 runner    (1001) docker     (121)     7740 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_config.c
--rw-r--r--   0 runner    (1001) docker     (121)    15120 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_context.c
--rw-r--r--   0 runner    (1001) docker     (121)    30950 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_convert.c
--rw-r--r--   0 runner    (1001) docker     (121)   141379 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_dfa_match.c
--rw-r--r--   0 runner    (1001) docker     (121)     9752 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_dftables.c
--rw-r--r--   0 runner    (1001) docker     (121)    13322 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_error.c
--rw-r--r--   0 runner    (1001) docker     (121)     4819 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_extuni.c
--rw-r--r--   0 runner    (1001) docker     (121)     6825 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_find_bracket.c
--rw-r--r--   0 runner    (1001) docker     (121)    12627 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_fuzzsupport.c
--rw-r--r--   0 runner    (1001) docker     (121)    93702 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)    37643 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_intmodedep.h
--rw-r--r--   0 runner    (1001) docker     (121)   446600 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_jit_compile.c
--rw-r--r--   0 runner    (1001) docker     (121)     6409 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_jit_match.c
--rw-r--r--   0 runner    (1001) docker     (121)     6951 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_jit_misc.c
--rw-r--r--   0 runner    (1001) docker     (121)     8400 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_jit_neon_inc.h
--rw-r--r--   0 runner    (1001) docker     (121)    55392 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_jit_simd_inc.h
--rw-r--r--   0 runner    (1001) docker     (121)   108063 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_jit_test.c
--rw-r--r--   0 runner    (1001) docker     (121)     6563 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_maketables.c
--rw-r--r--   0 runner    (1001) docker     (121)   227653 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_match.c
--rw-r--r--   0 runner    (1001) docker     (121)     5448 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_match_data.c
--rw-r--r--   0 runner    (1001) docker     (121)     6356 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_newline.c
--rw-r--r--   0 runner    (1001) docker     (121)     3741 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_ord2utf.c
--rw-r--r--   0 runner    (1001) docker     (121)    11738 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_pattern_info.c
--rw-r--r--   0 runner    (1001) docker     (121)    24151 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_printint.c
--rw-r--r--   0 runner    (1001) docker     (121)    11928 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_script_run.c
--rw-r--r--   0 runner    (1001) docker     (121)    10048 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_serialize.c
--rw-r--r--   0 runner    (1001) docker     (121)     6166 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_string_utils.c
--rw-r--r--   0 runner    (1001) docker     (121)    53574 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_study.c
--rw-r--r--   0 runner    (1001) docker     (121)    30050 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_substitute.c
--rw-r--r--   0 runner    (1001) docker     (121)    18244 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_substring.c
--rw-r--r--   0 runner    (1001) docker     (121)     9690 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_tables.c
--rw-r--r--   0 runner    (1001) docker     (121)   331374 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_ucd.c
--rw-r--r--   0 runner    (1001) docker     (121)    10214 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_ucp.h
--rw-r--r--   0 runner    (1001) docker     (121)    60761 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_ucptables.c
--rw-r--r--   0 runner    (1001) docker     (121)    12896 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_valid_utf.c
--rw-r--r--   0 runner    (1001) docker     (121)     8933 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2_xclass.c
--rw-r--r--   0 runner    (1001) docker     (121)    20174 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2demo.c
--rw-r--r--   0 runner    (1001) docker     (121)   127939 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2grep.c
--rw-r--r--   0 runner    (1001) docker     (121)    15596 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2posix.c
--rw-r--r--   0 runner    (1001) docker     (121)     6677 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2posix.h
--rw-r--r--   0 runner    (1001) docker     (121)   309469 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/pcre2test.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.356777 pcre2-0.1.0/src/libpcre2/src/sljit/
--rw-r--r--   0 runner    (1001) docker     (121)     6381 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitConfig.h
--rw-r--r--   0 runner    (1001) docker     (121)    29580 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitConfigInternal.h
--rw-r--r--   0 runner    (1001) docker     (121)    12753 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitExecAllocator.c
--rw-r--r--   0 runner    (1001) docker     (121)    85839 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitLir.c
--rw-r--r--   0 runner    (1001) docker     (121)    70784 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitLir.h
--rw-r--r--   0 runner    (1001) docker     (121)    93279 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeARM_32.c
--rw-r--r--   0 runner    (1001) docker     (121)    66818 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeARM_64.c
--rw-r--r--   0 runner    (1001) docker     (121)    83880 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeARM_T2_32.c
--rw-r--r--   0 runner    (1001) docker     (121)    25019 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeMIPS_32.c
--rw-r--r--   0 runner    (1001) docker     (121)    26885 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeMIPS_64.c
--rw-r--r--   0 runner    (1001) docker     (121)    80455 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeMIPS_common.c
--rw-r--r--   0 runner    (1001) docker     (121)    10597 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativePPC_32.c
--rw-r--r--   0 runner    (1001) docker     (121)    17614 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativePPC_64.c
--rw-r--r--   0 runner    (1001) docker     (121)    81119 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativePPC_common.c
--rw-r--r--   0 runner    (1001) docker     (121)    98862 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeS390X.c
--rw-r--r--   0 runner    (1001) docker     (121)    11158 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeSPARC_32.c
--rw-r--r--   0 runner    (1001) docker     (121)    53665 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeSPARC_common.c
--rw-r--r--   0 runner    (1001) docker     (121)    40460 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeX86_32.c
--rw-r--r--   0 runner    (1001) docker     (121)    27613 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeX86_64.c
--rw-r--r--   0 runner    (1001) docker     (121)    89364 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeX86_common.c
--rw-r--r--   0 runner    (1001) docker     (121)    13815 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitProtExecAllocator.c
--rw-r--r--   0 runner    (1001) docker     (121)    10430 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitUtils.c
--rw-r--r--   0 runner    (1001) docker     (121)     6858 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/src/sljit/sljitWXExecAllocator.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.372777 pcre2-0.1.0/src/libpcre2/testdata/
--rw-r--r--   0 runner    (1001) docker     (121)       45 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepbinary
--rw-r--r--   0 runner    (1001) docker     (121)       41 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepfilelist
--rw-r--r--   0 runner    (1001) docker     (121)    37385 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepinput
--rw-r--r--   0 runner    (1001) docker     (121)      813 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepinput3
--rw-r--r--   0 runner    (1001) docker     (121)      205 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepinput8
--rw-r--r--   0 runner    (1001) docker     (121)      275 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepinputM
--rw-r--r--   0 runner    (1001) docker     (121)      262 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepinputv
--rw-r--r--   0 runner    (1001) docker     (121)      550 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepinputx
--rw-r--r--   0 runner    (1001) docker     (121)      211 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/greplist
--rw-r--r--   0 runner    (1001) docker     (121)    26113 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepoutput
--rw-r--r--   0 runner    (1001) docker     (121)      823 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepoutput8
--rw-r--r--   0 runner    (1001) docker     (121)      995 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepoutputC
--rw-r--r--   0 runner    (1001) docker     (121)      659 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepoutputCN
--rw-r--r--   0 runner    (1001) docker     (121)      608 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/grepoutputN
--rw-r--r--   0 runner    (1001) docker     (121)        8 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/greppatN4
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testbtables
--rw-r--r--   0 runner    (1001) docker     (121)   121298 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput1
--rw-r--r--   0 runner    (1001) docker     (121)    10013 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput10
--rw-r--r--   0 runner    (1001) docker     (121)    14268 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput11
--rw-r--r--   0 runner    (1001) docker     (121)     8668 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput12
--rw-r--r--   0 runner    (1001) docker     (121)      318 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput13
--rw-r--r--   0 runner    (1001) docker     (121)     1580 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput14
--rw-r--r--   0 runner    (1001) docker     (121)     4005 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput15
--rw-r--r--   0 runner    (1001) docker     (121)      231 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput16
--rw-r--r--   0 runner    (1001) docker     (121)    22780 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput17
--rw-r--r--   0 runner    (1001) docker     (121)     1983 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput18
--rw-r--r--   0 runner    (1001) docker     (121)      474 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput19
--rw-r--r--   0 runner    (1001) docker     (121)   102428 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput2
--rw-r--r--   0 runner    (1001) docker     (121)     1404 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput20
--rw-r--r--   0 runner    (1001) docker     (121)      424 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput21
--rw-r--r--   0 runner    (1001) docker     (121)     1900 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput22
--rw-r--r--   0 runner    (1001) docker     (121)      207 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput23
--rw-r--r--   0 runner    (1001) docker     (121)     4168 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput24
--rw-r--r--   0 runner    (1001) docker     (121)      578 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput25
--rw-r--r--   0 runner    (1001) docker     (121)    36839 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput26
--rw-r--r--   0 runner    (1001) docker     (121)     1433 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput3
--rw-r--r--   0 runner    (1001) docker     (121)    56941 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput4
--rw-r--r--   0 runner    (1001) docker     (121)    41955 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput5
--rw-r--r--   0 runner    (1001) docker     (121)    91095 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput6
--rw-r--r--   0 runner    (1001) docker     (121)    37662 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput7
--rw-r--r--   0 runner    (1001) docker     (121)     7236 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput8
--rw-r--r--   0 runner    (1001) docker     (121)    12377 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinput9
--rw-r--r--   0 runner    (1001) docker     (121)     2019 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testinputEBC
--rw-r--r--   0 runner    (1001) docker     (121)   162121 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput1
--rw-r--r--   0 runner    (1001) docker     (121)    49890 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput10
--rw-r--r--   0 runner    (1001) docker     (121)    26114 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput11-16
--rw-r--r--   0 runner    (1001) docker     (121)    25133 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput11-32
--rw-r--r--   0 runner    (1001) docker     (121)    47311 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput12-16
--rw-r--r--   0 runner    (1001) docker     (121)    47052 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput12-32
--rw-r--r--   0 runner    (1001) docker     (121)      399 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput13
--rw-r--r--   0 runner    (1001) docker     (121)     2603 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput14-16
--rw-r--r--   0 runner    (1001) docker     (121)     2707 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput14-32
--rw-r--r--   0 runner    (1001) docker     (121)     3936 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput14-8
--rw-r--r--   0 runner    (1001) docker     (121)    11422 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput15
--rw-r--r--   0 runner    (1001) docker     (121)      461 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput16
--rw-r--r--   0 runner    (1001) docker     (121)    28781 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput17
--rw-r--r--   0 runner    (1001) docker     (121)     3759 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput18
--rw-r--r--   0 runner    (1001) docker     (121)      557 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput19
--rw-r--r--   0 runner    (1001) docker     (121)   373895 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput2
--rw-r--r--   0 runner    (1001) docker     (121)     2439 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput20
--rw-r--r--   0 runner    (1001) docker     (121)     1778 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput21
--rw-r--r--   0 runner    (1001) docker     (121)     3243 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput22-16
--rw-r--r--   0 runner    (1001) docker     (121)     3100 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput22-32
--rw-r--r--   0 runner    (1001) docker     (121)     3343 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput22-8
--rw-r--r--   0 runner    (1001) docker     (121)      281 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput23
--rw-r--r--   0 runner    (1001) docker     (121)     8059 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput24
--rw-r--r--   0 runner    (1001) docker     (121)      596 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput25
--rw-r--r--   0 runner    (1001) docker     (121)    45832 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput26
--rw-r--r--   0 runner    (1001) docker     (121)     2889 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput3
--rw-r--r--   0 runner    (1001) docker     (121)     2897 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput3A
--rw-r--r--   0 runner    (1001) docker     (121)     2961 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput3B
--rw-r--r--   0 runner    (1001) docker     (121)    86598 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput4
--rw-r--r--   0 runner    (1001) docker     (121)   109564 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput5
--rw-r--r--   0 runner    (1001) docker     (121)   128671 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput6
--rw-r--r--   0 runner    (1001) docker     (121)    93917 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput7
--rw-r--r--   0 runner    (1001) docker     (121)    28795 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput8-16-2
--rw-r--r--   0 runner    (1001) docker     (121)    28636 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput8-16-3
--rw-r--r--   0 runner    (1001) docker     (121)    28636 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput8-16-4
--rw-r--r--   0 runner    (1001) docker     (121)    28641 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput8-32-2
--rw-r--r--   0 runner    (1001) docker     (121)    28641 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput8-32-3
--rw-r--r--   0 runner    (1001) docker     (121)    28641 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput8-32-4
--rw-r--r--   0 runner    (1001) docker     (121)    28767 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput8-8-2
--rw-r--r--   0 runner    (1001) docker     (121)    28616 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput8-8-3
--rw-r--r--   0 runner    (1001) docker     (121)    28617 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput8-8-4
--rw-r--r--   0 runner    (1001) docker     (121)    16861 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutput9
--rw-r--r--   0 runner    (1001) docker     (121)     2880 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/testoutputEBC
--rw-r--r--   0 runner    (1001) docker     (121)      127 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/valgrind-jit.supp
--rw-r--r--   0 runner    (1001) docker     (121)     1416 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/wintestinput3
--rw-r--r--   0 runner    (1001) docker     (121)     3094 2022-11-08 02:35:25.000000 pcre2-0.1.0/src/libpcre2/testdata/wintestoutput3
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.372777 pcre2-0.1.0/src/pcre2/
--rw-r--r--   0 runner    (1001) docker     (121)     1405 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/CMakeLists.txt
--rwxr-xr-x   0 runner    (1001) docker     (121)      200 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/consts.pxd
--rw-r--r--   0 runner    (1001) docker     (121)     3545 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/consts.pyx
--rwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/exceptions.pxd
--rwxr-xr-x   0 runner    (1001) docker     (121)     1894 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/exceptions.pyx
--rwxr-xr-x   0 runner    (1001) docker     (121)    19367 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/libpcre2.pxd
--rw-r--r--   0 runner    (1001) docker     (121)      527 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/match.pxd
--rw-r--r--   0 runner    (1001) docker     (121)     7782 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/match.pyx
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/methods.pxd
--rw-r--r--   0 runner    (1001) docker     (121)     2271 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/methods.pyx
--rw-r--r--   0 runner    (1001) docker     (121)     1019 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/pattern.pxd
--rw-r--r--   0 runner    (1001) docker     (121)    14185 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/pattern.pyx
--rw-r--r--   0 runner    (1001) docker     (121)      516 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/scanner.pxd
--rw-r--r--   0 runner    (1001) docker     (121)     6172 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/scanner.pyx
--rwxr-xr-x   0 runner    (1001) docker     (121)      503 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/utils.pxd
--rwxr-xr-x   0 runner    (1001) docker     (121)     3362 2022-11-08 02:35:23.000000 pcre2-0.1.0/src/pcre2/utils.pyx
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-08 02:35:38.372777 pcre2-0.1.0/src/pcre2.egg-info/
--rw-r--r--   0 runner    (1001) docker     (121)     4082 2022-11-08 02:35:38.000000 pcre2-0.1.0/src/pcre2.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)    17420 2022-11-08 02:35:38.000000 pcre2-0.1.0/src/pcre2.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (121)        1 2022-11-08 02:35:38.000000 pcre2-0.1.0/src/pcre2.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (121)        6 2022-11-08 02:35:38.000000 pcre2-0.1.0/src/pcre2.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:24.008842 pcre2-0.2.0/
+-rw-r--r--   0 runner    (1001) docker     (123)      774 2023-04-16 23:23:10.000000 pcre2-0.2.0/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1518 2023-04-16 23:23:10.000000 pcre2-0.2.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)      718 2023-04-16 23:23:10.000000 pcre2-0.2.0/Makefile
+-rw-r--r--   0 runner    (1001) docker     (123)     5111 2023-04-16 23:23:24.008842 pcre2-0.2.0/PKG-INFO
+-rwxr-xr-x   0 runner    (1001) docker     (123)     4157 2023-04-16 23:23:10.000000 pcre2-0.2.0/README.md
+-rwxr-xr-x   0 runner    (1001) docker     (123)      130 2023-04-16 23:23:10.000000 pcre2-0.2.0/pyproject.toml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.940841 pcre2-0.2.0/requirements/
+-rw-r--r--   0 runner    (1001) docker     (123)       46 2023-04-16 23:23:10.000000 pcre2-0.2.0/requirements/build-requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       22 2023-04-16 23:23:10.000000 pcre2-0.2.0/requirements/test-requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-16 23:23:24.008842 pcre2-0.2.0/setup.cfg
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1472 2023-04-16 23:23:10.000000 pcre2-0.2.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.936841 pcre2-0.2.0/src/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.944841 pcre2-0.2.0/src/libpcre2/
+-rw-r--r--   0 runner    (1001) docker     (123)      127 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/.bazelrc
+-rw-r--r--   0 runner    (1001) docker     (123)       40 2023-04-16 23:23:11.000000 pcre2-0.2.0/src/libpcre2/.git
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.936841 pcre2-0.2.0/src/libpcre2/.github/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.944841 pcre2-0.2.0/src/libpcre2/.github/workflows/
+-rw-r--r--   0 runner    (1001) docker     (123)     2509 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/.github/workflows/build.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      651 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/.github/workflows/cifuzz.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     2411 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/.github/workflows/codeql.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     1859 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/.github/workflows/scorecards.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      926 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/.gitignore
+-rwxr-xr-x   0 runner    (1001) docker     (123)     7049 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/132html
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/AUTHORS
+-rw-r--r--   0 runner    (1001) docker     (123)     1802 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/BUILD.bazel
+-rw-r--r--   0 runner    (1001) docker     (123)    47411 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       97 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/COPYING
+-rw-r--r--   0 runner    (1001) docker     (123)   132205 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/ChangeLog
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1697 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/CheckMan
+-rwxr-xr-x   0 runner    (1001) docker     (123)     2941 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/CleanTxt
+-rwxr-xr-x   0 runner    (1001) docker     (123)      643 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/Detrail
+-rw-r--r--   0 runner    (1001) docker     (123)    38839 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/HACKING
+-rw-r--r--   0 runner    (1001) docker     (123)     3477 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/LICENCE
+-rw-r--r--   0 runner    (1001) docker     (123)      183 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/MODULE.bazel
+-rw-r--r--   0 runner    (1001) docker     (123)    26887 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/Makefile.am
+-rw-r--r--   0 runner    (1001) docker     (123)    16034 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/NEWS
+-rw-r--r--   0 runner    (1001) docker     (123)    18701 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/NON-AUTOTOOLS-BUILD
+-rwxr-xr-x   0 runner    (1001) docker     (123)     7039 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/PrepareRelease
+-rw-r--r--   0 runner    (1001) docker     (123)    43984 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/README
+-rw-r--r--   0 runner    (1001) docker     (123)     2385 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/README.md
+-rwxr-xr-x   0 runner    (1001) docker     (123)    52594 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/RunGrepTest
+-rw-r--r--   0 runner    (1001) docker     (123)    35213 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/RunGrepTest.bat
+-rwxr-xr-x   0 runner    (1001) docker     (123)    26723 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/RunTest
+-rw-r--r--   0 runner    (1001) docker     (123)    13860 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/RunTest.bat
+-rw-r--r--   0 runner    (1001) docker     (123)       19 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/WORKSPACE.bazel
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1250 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/autogen.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.944841 pcre2-0.2.0/src/libpcre2/cmake/
+-rw-r--r--   0 runner    (1001) docker     (123)     1327 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/cmake/COPYING-CMAKE-SCRIPTS
+-rw-r--r--   0 runner    (1001) docker     (123)      556 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/cmake/FindEditline.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     2410 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/cmake/FindPackageHandleStandardArgs.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     1287 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/cmake/FindReadline.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      542 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/cmake/pcre2-config-version.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (123)     5062 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/cmake/pcre2-config.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (123)     1586 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/config-cmake.h.in
+-rw-r--r--   0 runner    (1001) docker     (123)    41823 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/configure.ac
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.960842 pcre2-0.2.0/src/libpcre2/doc/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.972842 pcre2-0.2.0/src/libpcre2/doc/html/
+-rw-r--r--   0 runner    (1001) docker     (123)    18701 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/NON-AUTOTOOLS-BUILD.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    43984 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/README.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    13975 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/index.html
+-rw-r--r--   0 runner    (1001) docker     (123)     3498 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2-config.html
+-rw-r--r--   0 runner    (1001) docker     (123)     9909 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2.html
+-rw-r--r--   0 runner    (1001) docker     (123)     2431 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_callout_enumerate.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1370 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_code_copy.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1491 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_code_copy_with_tables.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1243 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_code_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     5149 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_compile.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1176 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_compile_context_copy.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1271 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_compile_context_create.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1233 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_compile_context_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     3575 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_config.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1157 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_convert_context_copy.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1251 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_convert_context_create.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1214 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_convert_context_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1249 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_converted_pattern_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     3865 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_dfa_match.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1225 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_general_context_copy.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1486 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_general_context_create.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1172 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_general_context_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1745 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_error_message.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1505 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_mark.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1053 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_match_data_size.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_ovector_count.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1148 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_ovector_pointer.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1430 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_startchar.html
+-rw-r--r--   0 runner    (1001) docker     (123)     2238 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_compile.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1328 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_free_unused_memory.html
+-rw-r--r--   0 runner    (1001) docker     (123)     2143 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_match.html
+-rw-r--r--   0 runner    (1001) docker     (123)     2562 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_stack_assign.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1825 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_stack_create.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1223 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_stack_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1647 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_maketables.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1223 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_maketables_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     3673 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1164 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_context_copy.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1261 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_context_create.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1223 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_context_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1755 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_data_create.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1931 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_data_create_from_pattern.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1417 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_data_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     2663 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_pattern_convert.html
+-rw-r--r--   0 runner    (1001) docker     (123)     4816 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_pattern_info.html
+-rw-r--r--   0 runner    (1001) docker     (123)     2547 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_serialize_decode.html
+-rw-r--r--   0 runner    (1001) docker     (123)     2721 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_serialize_encode.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1187 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_serialize_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1634 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_serialize_get_number_of_codes.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1199 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_bsr.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1276 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_callout.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1437 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_character_tables.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1713 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_compile_extra_options.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1664 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_compile_recursion_guard.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_depth_limit.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1365 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_glob_escape.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1336 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_glob_separator.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1076 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_heap_limit.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1067 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_match_limit.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1336 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_max_pattern_length.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1566 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_newline.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1073 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_offset_limit.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_parens_nest_limit.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1097 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_recursion_limit.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1245 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_recursion_memory_management.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1331 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_substitute_callout.html
+-rw-r--r--   0 runner    (1001) docker     (123)     4953 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substitute.html
+-rw-r--r--   0 runner    (1001) docker     (123)     2059 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_copy_byname.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1860 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_copy_bynumber.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1196 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     2187 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_get_byname.html
+-rw-r--r--   0 runner    (1001) docker     (123)     2023 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_get_bynumber.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1364 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_length_byname.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1518 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_length_bynumber.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1211 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_list_free.html
+-rw-r--r--   0 runner    (1001) docker     (123)     2136 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_list_get.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1837 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_nametable_scan.html
+-rw-r--r--   0 runner    (1001) docker     (123)     1645 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_number_from_name.html
+-rw-r--r--   0 runner    (1001) docker     (123)   188125 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2api.html
+-rw-r--r--   0 runner    (1001) docker     (123)    26891 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2build.html
+-rw-r--r--   0 runner    (1001) docker     (123)    20379 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2callout.html
+-rw-r--r--   0 runner    (1001) docker     (123)    11484 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2compat.html
+-rw-r--r--   0 runner    (1001) docker     (123)     7892 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2convert.html
+-rw-r--r--   0 runner    (1001) docker     (123)    20854 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2demo.html
+-rw-r--r--   0 runner    (1001) docker     (123)    53381 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2grep.html
+-rw-r--r--   0 runner    (1001) docker     (123)    21785 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2jit.html
+-rw-r--r--   0 runner    (1001) docker     (123)     3454 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2limits.html
+-rw-r--r--   0 runner    (1001) docker     (123)    11153 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2matching.html
+-rw-r--r--   0 runner    (1001) docker     (123)    18580 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2partial.html
+-rw-r--r--   0 runner    (1001) docker     (123)   167849 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2pattern.html
+-rw-r--r--   0 runner    (1001) docker     (123)    12802 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2perform.html
+-rw-r--r--   0 runner    (1001) docker     (123)    15881 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2posix.html
+-rw-r--r--   0 runner    (1001) docker     (123)     3905 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2sample.html
+-rw-r--r--   0 runner    (1001) docker     (123)    10059 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2serialize.html
+-rw-r--r--   0 runner    (1001) docker     (123)    22770 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2syntax.html
+-rw-r--r--   0 runner    (1001) docker     (123)    94312 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2test.html
+-rw-r--r--   0 runner    (1001) docker     (123)    21071 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/html/pcre2unicode.html
+-rw-r--r--   0 runner    (1001) docker     (123)    13975 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/index.html.src
+-rw-r--r--   0 runner    (1001) docker     (123)     2577 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2-config.1
+-rw-r--r--   0 runner    (1001) docker     (123)     2929 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2-config.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     8896 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2.3
+-rw-r--r--   0 runner    (1001) docker     (123)   577237 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1890 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_callout_enumerate.3
+-rw-r--r--   0 runner    (1001) docker     (123)      879 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_code_copy.3
+-rw-r--r--   0 runner    (1001) docker     (123)      975 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_code_copy_with_tables.3
+-rw-r--r--   0 runner    (1001) docker     (123)      748 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_code_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)     4572 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_compile.3
+-rw-r--r--   0 runner    (1001) docker     (123)      674 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_compile_context_copy.3
+-rw-r--r--   0 runner    (1001) docker     (123)      766 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_compile_context_create.3
+-rw-r--r--   0 runner    (1001) docker     (123)      729 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_compile_context_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)     3193 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_config.3
+-rw-r--r--   0 runner    (1001) docker     (123)      666 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_convert_context_copy.3
+-rw-r--r--   0 runner    (1001) docker     (123)      757 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_convert_context_create.3
+-rw-r--r--   0 runner    (1001) docker     (123)      724 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_convert_context_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)      757 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_converted_pattern_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)     3438 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_dfa_match.3
+-rw-r--r--   0 runner    (1001) docker     (123)      722 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_general_context_copy.3
+-rw-r--r--   0 runner    (1001) docker     (123)      977 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_general_context_create.3
+-rw-r--r--   0 runner    (1001) docker     (123)      669 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_general_context_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1233 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_get_error_message.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1010 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_get_mark.3
+-rw-r--r--   0 runner    (1001) docker     (123)      551 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_get_match_data_size.3
+-rw-r--r--   0 runner    (1001) docker     (123)      575 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_get_ovector_count.3
+-rw-r--r--   0 runner    (1001) docker     (123)      648 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_get_ovector_pointer.3
+-rw-r--r--   0 runner    (1001) docker     (123)      936 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_get_startchar.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1706 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_compile.3
+-rw-r--r--   0 runner    (1001) docker     (123)      825 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_free_unused_memory.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1592 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_match.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1992 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_stack_assign.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1304 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_stack_create.3
+-rw-r--r--   0 runner    (1001) docker     (123)      705 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_stack_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1108 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_maketables.3
+-rw-r--r--   0 runner    (1001) docker     (123)      713 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_maketables_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)     3278 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_match.3
+-rw-r--r--   0 runner    (1001) docker     (123)      664 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_match_context_copy.3
+-rw-r--r--   0 runner    (1001) docker     (123)      758 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_match_context_create.3
+-rw-r--r--   0 runner    (1001) docker     (123)      721 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_match_context_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1245 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_match_data_create.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1408 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_match_data_create_from_pattern.3
+-rw-r--r--   0 runner    (1001) docker     (123)      913 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_match_data_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)     2140 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_pattern_convert.3
+-rw-r--r--   0 runner    (1001) docker     (123)     4529 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_pattern_info.3
+-rw-r--r--   0 runner    (1001) docker     (123)     2016 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_serialize_decode.3
+-rw-r--r--   0 runner    (1001) docker     (123)     2191 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_serialize_encode.3
+-rw-r--r--   0 runner    (1001) docker     (123)      685 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_serialize_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1110 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_serialize_get_number_of_codes.3
+-rw-r--r--   0 runner    (1001) docker     (123)      710 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_bsr.3
+-rw-r--r--   0 runner    (1001) docker     (123)      777 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_callout.3
+-rw-r--r--   0 runner    (1001) docker     (123)      912 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_character_tables.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1362 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_compile_extra_options.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1151 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_compile_recursion_guard.3
+-rw-r--r--   0 runner    (1001) docker     (123)      580 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_depth_limit.3
+-rw-r--r--   0 runner    (1001) docker     (123)      878 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_glob_escape.3
+-rw-r--r--   0 runner    (1001) docker     (123)      846 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_glob_separator.3
+-rw-r--r--   0 runner    (1001) docker     (123)      577 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_heap_limit.3
+-rw-r--r--   0 runner    (1001) docker     (123)      569 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_match_limit.3
+-rw-r--r--   0 runner    (1001) docker     (123)      830 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_max_pattern_length.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1063 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_newline.3
+-rw-r--r--   0 runner    (1001) docker     (123)      576 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_offset_limit.3
+-rw-r--r--   0 runner    (1001) docker     (123)      618 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_parens_nest_limit.3
+-rw-r--r--   0 runner    (1001) docker     (123)      592 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_recursion_limit.3
+-rw-r--r--   0 runner    (1001) docker     (123)      723 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_recursion_memory_management.3
+-rw-r--r--   0 runner    (1001) docker     (123)      824 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_set_substitute_callout.3
+-rw-r--r--   0 runner    (1001) docker     (123)     4722 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substitute.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1538 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_copy_byname.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1335 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_copy_bynumber.3
+-rw-r--r--   0 runner    (1001) docker     (123)      693 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1667 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_get_byname.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1501 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_get_bynumber.3
+-rw-r--r--   0 runner    (1001) docker     (123)      849 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_length_byname.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_length_bynumber.3
+-rw-r--r--   0 runner    (1001) docker     (123)      704 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_list_free.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1620 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_list_get.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1319 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_nametable_scan.3
+-rw-r--r--   0 runner    (1001) docker     (123)     1128 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_number_from_name.3
+-rw-r--r--   0 runner    (1001) docker     (123)   179183 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2api.3
+-rw-r--r--   0 runner    (1001) docker     (123)    23565 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2build.3
+-rw-r--r--   0 runner    (1001) docker     (123)    18823 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2callout.3
+-rw-r--r--   0 runner    (1001) docker     (123)    10848 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2compat.3
+-rw-r--r--   0 runner    (1001) docker     (123)     6652 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2convert.3
+-rw-r--r--   0 runner    (1001) docker     (123)    20411 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2demo.3
+-rw-r--r--   0 runner    (1001) docker     (123)    50359 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2grep.1
+-rw-r--r--   0 runner    (1001) docker     (123)    59677 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2grep.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    19870 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2jit.3
+-rw-r--r--   0 runner    (1001) docker     (123)     2922 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2limits.3
+-rw-r--r--   0 runner    (1001) docker     (123)     9718 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2matching.3
+-rw-r--r--   0 runner    (1001) docker     (123)    17050 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2partial.3
+-rw-r--r--   0 runner    (1001) docker     (123)   163283 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2pattern.3
+-rw-r--r--   0 runner    (1001) docker     (123)    11650 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2perform.3
+-rw-r--r--   0 runner    (1001) docker     (123)    14289 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2posix.3
+-rw-r--r--   0 runner    (1001) docker     (123)     3348 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2sample.3
+-rw-r--r--   0 runner    (1001) docker     (123)     8941 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2serialize.3
+-rw-r--r--   0 runner    (1001) docker     (123)    19207 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2syntax.3
+-rw-r--r--   0 runner    (1001) docker     (123)    89779 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2test.1
+-rw-r--r--   0 runner    (1001) docker     (123)    98062 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2test.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    20259 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/doc/pcre2unicode.3
+-rw-r--r--   0 runner    (1001) docker     (123)     2385 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/index.md
+-rw-r--r--   0 runner    (1001) docker     (123)      406 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/libpcre2-16.pc.in
+-rw-r--r--   0 runner    (1001) docker     (123)      406 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/libpcre2-32.pc.in
+-rw-r--r--   0 runner    (1001) docker     (123)      403 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/libpcre2-8.pc.in
+-rw-r--r--   0 runner    (1001) docker     (123)      342 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/libpcre2-posix.pc.in
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.972842 pcre2-0.2.0/src/libpcre2/m4/
+-rw-r--r--   0 runner    (1001) docker     (123)    12534 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/m4/ax_pthread.m4
+-rw-r--r--   0 runner    (1001) docker     (123)     4059 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/m4/pcre2_visibility.m4
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.972842 pcre2-0.2.0/src/libpcre2/maint/
+-rw-r--r--   0 runner    (1001) docker     (123)    11730 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/GenerateCommon.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5510 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/GenerateTest26.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)    33845 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/GenerateUcd.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3212 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/GenerateUcpHeader.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     7303 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/GenerateUcpTables.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)    14070 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/ManyConfigTests
+-rw-r--r--   0 runner    (1001) docker     (123)    21693 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/README
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.980842 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/
+-rw-r--r--   0 runner    (1001) docker     (123)    26690 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/BidiMirroring.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    84688 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/CaseFolding.txt
+-rw-r--r--   0 runner    (1001) docker     (123)   169291 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/DerivedBidiClass.txt
+-rw-r--r--   0 runner    (1001) docker     (123)  1040794 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/DerivedCoreProperties.txt
+-rw-r--r--   0 runner    (1001) docker     (123)   265751 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/DerivedGeneralCategory.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    95663 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/GraphemeBreakProperty.txt
+-rw-r--r--   0 runner    (1001) docker     (123)   130164 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/PropList.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     8825 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/PropertyAliases.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    76759 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/PropertyValueAliases.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    21969 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/ScriptExtensions.txt
+-rw-r--r--   0 runner    (1001) docker     (123)   181635 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/Scripts.txt
+-rw-r--r--   0 runner    (1001) docker     (123)  1897793 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/UnicodeData.txt
+-rw-r--r--   0 runner    (1001) docker     (123)   109396 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/emoji-data.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3624 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/pcre2_chartables.c.non-standard
+-rw-r--r--   0 runner    (1001) docker     (123)    29256 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/ucptest.c
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.980842 pcre2-0.2.0/src/libpcre2/maint/ucptestdata/
+-rw-r--r--   0 runner    (1001) docker     (123)     1675 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/ucptestdata/testinput1
+-rw-r--r--   0 runner    (1001) docker     (123)      332 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/ucptestdata/testinput2
+-rw-r--r--   0 runner    (1001) docker     (123)    44440 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/ucptestdata/testoutput1
+-rw-r--r--   0 runner    (1001) docker     (123)    45256 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/ucptestdata/testoutput2
+-rw-r--r--   0 runner    (1001) docker     (123)     8629 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/maint/utf8.c
+-rw-r--r--   0 runner    (1001) docker     (123)     2346 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/pcre2-config.in
+-rw-r--r--   0 runner    (1001) docker     (123)      435 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/pcre2_fuzzer.dict
+-rw-r--r--   0 runner    (1001) docker     (123)       37 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/pcre2_fuzzer.options
+-rwxr-xr-x   0 runner    (1001) docker     (123)    11366 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/perltest.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.988842 pcre2-0.2.0/src/libpcre2/src/
+-rw-r--r--   0 runner    (1001) docker     (123)    17396 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/config.h.generic
+-rw-r--r--   0 runner    (1001) docker     (123)    16528 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/config.h.in
+-rw-r--r--   0 runner    (1001) docker     (123)    47257 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2.h.generic
+-rw-r--r--   0 runner    (1001) docker     (123)    47299 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2.h.in
+-rw-r--r--   0 runner    (1001) docker     (123)    40417 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_auto_possess.c
+-rw-r--r--   0 runner    (1001) docker     (123)     8105 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_chartables.c.dist
+-rw-r--r--   0 runner    (1001) docker     (123)   353717 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_compile.c
+-rw-r--r--   0 runner    (1001) docker     (123)     7740 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_config.c
+-rw-r--r--   0 runner    (1001) docker     (123)    15240 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_context.c
+-rw-r--r--   0 runner    (1001) docker     (123)    30881 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_convert.c
+-rw-r--r--   0 runner    (1001) docker     (123)   141635 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_dfa_match.c
+-rw-r--r--   0 runner    (1001) docker     (123)     9752 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_dftables.c
+-rw-r--r--   0 runner    (1001) docker     (123)    13322 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_error.c
+-rw-r--r--   0 runner    (1001) docker     (123)     4819 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_extuni.c
+-rw-r--r--   0 runner    (1001) docker     (123)     6825 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_find_bracket.c
+-rw-r--r--   0 runner    (1001) docker     (123)    12627 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_fuzzsupport.c
+-rw-r--r--   0 runner    (1001) docker     (123)    93685 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_internal.h
+-rw-r--r--   0 runner    (1001) docker     (123)    37605 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_intmodedep.h
+-rw-r--r--   0 runner    (1001) docker     (123)   446534 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_jit_compile.c
+-rw-r--r--   0 runner    (1001) docker     (123)     6409 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_jit_match.c
+-rw-r--r--   0 runner    (1001) docker     (123)     7061 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_jit_misc.c
+-rw-r--r--   0 runner    (1001) docker     (123)     8439 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_jit_neon_inc.h
+-rw-r--r--   0 runner    (1001) docker     (123)    55393 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_jit_simd_inc.h
+-rw-r--r--   0 runner    (1001) docker     (123)   108119 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_jit_test.c
+-rw-r--r--   0 runner    (1001) docker     (123)     6563 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_maketables.c
+-rw-r--r--   0 runner    (1001) docker     (123)   228188 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_match.c
+-rw-r--r--   0 runner    (1001) docker     (123)     5772 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_match_data.c
+-rw-r--r--   0 runner    (1001) docker     (123)     6356 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_newline.c
+-rw-r--r--   0 runner    (1001) docker     (123)     3741 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_ord2utf.c
+-rw-r--r--   0 runner    (1001) docker     (123)    11738 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_pattern_info.c
+-rw-r--r--   0 runner    (1001) docker     (123)    24151 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_printint.c
+-rw-r--r--   0 runner    (1001) docker     (123)    11928 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_script_run.c
+-rw-r--r--   0 runner    (1001) docker     (123)    10048 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_serialize.c
+-rw-r--r--   0 runner    (1001) docker     (123)     6166 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_string_utils.c
+-rw-r--r--   0 runner    (1001) docker     (123)    53574 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_study.c
+-rw-r--r--   0 runner    (1001) docker     (123)    30176 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_substitute.c
+-rw-r--r--   0 runner    (1001) docker     (123)    18244 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_substring.c
+-rw-r--r--   0 runner    (1001) docker     (123)     9690 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_tables.c
+-rw-r--r--   0 runner    (1001) docker     (123)   331374 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_ucd.c
+-rw-r--r--   0 runner    (1001) docker     (123)    10214 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_ucp.h
+-rw-r--r--   0 runner    (1001) docker     (123)    60761 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_ucptables.c
+-rw-r--r--   0 runner    (1001) docker     (123)    12896 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_valid_utf.c
+-rw-r--r--   0 runner    (1001) docker     (123)     8933 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2_xclass.c
+-rw-r--r--   0 runner    (1001) docker     (123)    20174 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2demo.c
+-rw-r--r--   0 runner    (1001) docker     (123)   131385 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2grep.c
+-rw-r--r--   0 runner    (1001) docker     (123)    15307 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2posix.c
+-rw-r--r--   0 runner    (1001) docker     (123)     7294 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2posix.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5550 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2posix_test.c
+-rw-r--r--   0 runner    (1001) docker     (123)   312105 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/pcre2test.c
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:23.992842 pcre2-0.2.0/src/libpcre2/src/sljit/
+-rw-r--r--   0 runner    (1001) docker     (123)     5958 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitConfig.h
+-rw-r--r--   0 runner    (1001) docker     (123)    28880 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitConfigInternal.h
+-rw-r--r--   0 runner    (1001) docker     (123)    12753 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitExecAllocator.c
+-rw-r--r--   0 runner    (1001) docker     (123)    97523 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitLir.c
+-rw-r--r--   0 runner    (1001) docker     (123)    80453 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitLir.h
+-rw-r--r--   0 runner    (1001) docker     (123)   111239 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeARM_32.c
+-rw-r--r--   0 runner    (1001) docker     (123)    74993 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeARM_64.c
+-rw-r--r--   0 runner    (1001) docker     (123)    99494 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeARM_T2_32.c
+-rw-r--r--   0 runner    (1001) docker     (123)    10689 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeMIPS_32.c
+-rw-r--r--   0 runner    (1001) docker     (123)    10140 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeMIPS_64.c
+-rw-r--r--   0 runner    (1001) docker     (123)   125383 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeMIPS_common.c
+-rw-r--r--   0 runner    (1001) docker     (123)    11883 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativePPC_32.c
+-rw-r--r--   0 runner    (1001) docker     (123)    19248 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativePPC_64.c
+-rw-r--r--   0 runner    (1001) docker     (123)    90305 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativePPC_common.c
+-rw-r--r--   0 runner    (1001) docker     (123)     3003 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeRISCV_32.c
+-rw-r--r--   0 runner    (1001) docker     (123)     6232 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeRISCV_64.c
+-rw-r--r--   0 runner    (1001) docker     (123)    89275 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeRISCV_common.c
+-rw-r--r--   0 runner    (1001) docker     (123)   111238 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeS390X.c
+-rw-r--r--   0 runner    (1001) docker     (123)    35996 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeX86_32.c
+-rw-r--r--   0 runner    (1001) docker     (123)    30653 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeX86_64.c
+-rw-r--r--   0 runner    (1001) docker     (123)    96024 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeX86_common.c
+-rw-r--r--   0 runner    (1001) docker     (123)    13815 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitProtExecAllocator.c
+-rw-r--r--   0 runner    (1001) docker     (123)    10430 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitUtils.c
+-rw-r--r--   0 runner    (1001) docker     (123)     6225 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/src/sljit/sljitWXExecAllocator.c
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:24.004842 pcre2-0.2.0/src/libpcre2/testdata/
+-rw-r--r--   0 runner    (1001) docker     (123)       45 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepbinary
+-rw-r--r--   0 runner    (1001) docker     (123)       41 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepfilelist
+-rw-r--r--   0 runner    (1001) docker     (123)    37385 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepinput
+-rw-r--r--   0 runner    (1001) docker     (123)      813 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepinput3
+-rw-r--r--   0 runner    (1001) docker     (123)      205 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepinput8
+-rw-r--r--   0 runner    (1001) docker     (123)      313 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepinputC.bz2
+-rw-r--r--   0 runner    (1001) docker     (123)      311 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepinputC.gz
+-rw-r--r--   0 runner    (1001) docker     (123)      275 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepinputM
+-rw-r--r--   0 runner    (1001) docker     (123)      262 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepinputv
+-rw-r--r--   0 runner    (1001) docker     (123)      550 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepinputx
+-rw-r--r--   0 runner    (1001) docker     (123)      211 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/greplist
+-rw-r--r--   0 runner    (1001) docker     (123)      550 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepnot.bz2
+-rw-r--r--   0 runner    (1001) docker     (123)    33689 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepoutput
+-rw-r--r--   0 runner    (1001) docker     (123)      823 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepoutput8
+-rw-r--r--   0 runner    (1001) docker     (123)     1225 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepoutputC
+-rw-r--r--   0 runner    (1001) docker     (123)      859 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepoutputCN
+-rw-r--r--   0 runner    (1001) docker     (123)      430 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepoutputCNU
+-rw-r--r--   0 runner    (1001) docker     (123)      466 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepoutputCU
+-rw-r--r--   0 runner    (1001) docker     (123)       26 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepoutputCbz2
+-rw-r--r--   0 runner    (1001) docker     (123)       13 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepoutputCgz
+-rw-r--r--   0 runner    (1001) docker     (123)      685 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepoutputN
+-rw-r--r--   0 runner    (1001) docker     (123)       83 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/grepoutputUN
+-rw-r--r--   0 runner    (1001) docker     (123)        8 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/greppatN4
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testbtables
+-rw-r--r--   0 runner    (1001) docker     (123)   121298 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput1
+-rw-r--r--   0 runner    (1001) docker     (123)    10013 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput10
+-rw-r--r--   0 runner    (1001) docker     (123)    14268 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput11
+-rw-r--r--   0 runner    (1001) docker     (123)     8668 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput12
+-rw-r--r--   0 runner    (1001) docker     (123)      318 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput13
+-rw-r--r--   0 runner    (1001) docker     (123)     1580 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput14
+-rw-r--r--   0 runner    (1001) docker     (123)     4203 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput15
+-rw-r--r--   0 runner    (1001) docker     (123)      231 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput16
+-rw-r--r--   0 runner    (1001) docker     (123)    22780 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput17
+-rw-r--r--   0 runner    (1001) docker     (123)     2039 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput18
+-rw-r--r--   0 runner    (1001) docker     (123)      501 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput19
+-rw-r--r--   0 runner    (1001) docker     (123)   102537 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput2
+-rw-r--r--   0 runner    (1001) docker     (123)     1404 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput20
+-rw-r--r--   0 runner    (1001) docker     (123)      424 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput21
+-rw-r--r--   0 runner    (1001) docker     (123)     1900 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput22
+-rw-r--r--   0 runner    (1001) docker     (123)      207 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput23
+-rw-r--r--   0 runner    (1001) docker     (123)     4168 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput24
+-rw-r--r--   0 runner    (1001) docker     (123)      578 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput25
+-rw-r--r--   0 runner    (1001) docker     (123)    36839 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput26
+-rw-r--r--   0 runner    (1001) docker     (123)     1433 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput3
+-rw-r--r--   0 runner    (1001) docker     (123)    56941 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput4
+-rw-r--r--   0 runner    (1001) docker     (123)    41955 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput5
+-rw-r--r--   0 runner    (1001) docker     (123)    91095 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput6
+-rw-r--r--   0 runner    (1001) docker     (123)    37662 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput7
+-rw-r--r--   0 runner    (1001) docker     (123)     7236 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput8
+-rw-r--r--   0 runner    (1001) docker     (123)    12377 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinput9
+-rw-r--r--   0 runner    (1001) docker     (123)     2019 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinputEBC
+-rw-r--r--   0 runner    (1001) docker     (123)      367 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testinputheap
+-rw-r--r--   0 runner    (1001) docker     (123)   162121 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput1
+-rw-r--r--   0 runner    (1001) docker     (123)    49890 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput10
+-rw-r--r--   0 runner    (1001) docker     (123)    26114 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput11-16
+-rw-r--r--   0 runner    (1001) docker     (123)    25133 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput11-32
+-rw-r--r--   0 runner    (1001) docker     (123)    47311 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput12-16
+-rw-r--r--   0 runner    (1001) docker     (123)    47052 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput12-32
+-rw-r--r--   0 runner    (1001) docker     (123)      399 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput13
+-rw-r--r--   0 runner    (1001) docker     (123)     2603 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput14-16
+-rw-r--r--   0 runner    (1001) docker     (123)     2707 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput14-32
+-rw-r--r--   0 runner    (1001) docker     (123)     3936 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput14-8
+-rw-r--r--   0 runner    (1001) docker     (123)    11321 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput15
+-rw-r--r--   0 runner    (1001) docker     (123)      461 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput16
+-rw-r--r--   0 runner    (1001) docker     (123)    28781 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput17
+-rw-r--r--   0 runner    (1001) docker     (123)     3861 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput18
+-rw-r--r--   0 runner    (1001) docker     (123)      622 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput19
+-rw-r--r--   0 runner    (1001) docker     (123)   374052 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput2
+-rw-r--r--   0 runner    (1001) docker     (123)     2439 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput20
+-rw-r--r--   0 runner    (1001) docker     (123)     1778 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput21
+-rw-r--r--   0 runner    (1001) docker     (123)     3243 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput22-16
+-rw-r--r--   0 runner    (1001) docker     (123)     3100 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput22-32
+-rw-r--r--   0 runner    (1001) docker     (123)     3343 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput22-8
+-rw-r--r--   0 runner    (1001) docker     (123)      281 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput23
+-rw-r--r--   0 runner    (1001) docker     (123)     8059 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput24
+-rw-r--r--   0 runner    (1001) docker     (123)      596 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput25
+-rw-r--r--   0 runner    (1001) docker     (123)    45832 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput26
+-rw-r--r--   0 runner    (1001) docker     (123)     2889 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput3
+-rw-r--r--   0 runner    (1001) docker     (123)     2897 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput3A
+-rw-r--r--   0 runner    (1001) docker     (123)     2961 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput3B
+-rw-r--r--   0 runner    (1001) docker     (123)    86598 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput4
+-rw-r--r--   0 runner    (1001) docker     (123)   109564 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput5
+-rw-r--r--   0 runner    (1001) docker     (123)   128671 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput6
+-rw-r--r--   0 runner    (1001) docker     (123)    93917 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput7
+-rw-r--r--   0 runner    (1001) docker     (123)    28795 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput8-16-2
+-rw-r--r--   0 runner    (1001) docker     (123)    28636 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput8-16-3
+-rw-r--r--   0 runner    (1001) docker     (123)    28636 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput8-16-4
+-rw-r--r--   0 runner    (1001) docker     (123)    28641 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput8-32-2
+-rw-r--r--   0 runner    (1001) docker     (123)    28641 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput8-32-3
+-rw-r--r--   0 runner    (1001) docker     (123)    28641 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput8-32-4
+-rw-r--r--   0 runner    (1001) docker     (123)    28767 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput8-8-2
+-rw-r--r--   0 runner    (1001) docker     (123)    28616 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput8-8-3
+-rw-r--r--   0 runner    (1001) docker     (123)    28617 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput8-8-4
+-rw-r--r--   0 runner    (1001) docker     (123)    16861 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutput9
+-rw-r--r--   0 runner    (1001) docker     (123)     2880 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutputEBC
+-rw-r--r--   0 runner    (1001) docker     (123)      907 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutputheap-16
+-rw-r--r--   0 runner    (1001) docker     (123)      907 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutputheap-32
+-rw-r--r--   0 runner    (1001) docker     (123)      906 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/testoutputheap-8
+-rw-r--r--   0 runner    (1001) docker     (123)      127 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/valgrind-jit.supp
+-rw-r--r--   0 runner    (1001) docker     (123)     1416 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/wintestinput3
+-rw-r--r--   0 runner    (1001) docker     (123)     3094 2023-04-16 23:23:12.000000 pcre2-0.2.0/src/libpcre2/testdata/wintestoutput3
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:24.008842 pcre2-0.2.0/src/pcre2/
+-rw-r--r--   0 runner    (1001) docker     (123)     1405 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/CMakeLists.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)      222 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/consts.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)     3545 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/consts.pyx
+-rwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/exceptions.pxd
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1894 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/exceptions.pyx
+-rwxr-xr-x   0 runner    (1001) docker     (123)    19367 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/libpcre2.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)      527 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/match.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)     7782 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/match.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/methods.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)     2271 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/methods.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)     1019 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/pattern.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)    14388 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/pattern.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)      516 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/scanner.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)     6172 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/scanner.pyx
+-rwxr-xr-x   0 runner    (1001) docker     (123)      503 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/utils.pxd
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3362 2023-04-16 23:23:10.000000 pcre2-0.2.0/src/pcre2/utils.pyx
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:24.008842 pcre2-0.2.0/src/pcre2.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     5111 2023-04-16 23:23:23.000000 pcre2-0.2.0/src/pcre2.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    18256 2023-04-16 23:23:23.000000 pcre2-0.2.0/src/pcre2.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-16 23:23:23.000000 pcre2-0.2.0/src/pcre2.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        6 2023-04-16 23:23:23.000000 pcre2-0.2.0/src/pcre2.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-16 23:23:24.008842 pcre2-0.2.0/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)     1716 2023-04-16 23:23:10.000000 pcre2-0.2.0/tests/test_match.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4503 2023-04-16 23:23:10.000000 pcre2-0.2.0/tests/test_pattern.py
```

### Comparing `pcre2-0.1.0/CMakeLists.txt` & `pcre2-0.2.0/CMakeLists.txt`

 * *Files 13% similar despite different names*

```diff
@@ -11,17 +11,19 @@
 # Set PCRE2 options.
 set(PCRE2_SUPPORT_JIT ON CACHE BOOL "" FORCE)
 set(PCRE2_NEVER_BACKSLASH_C ON CACHE BOOL "" FORCE)
 
 # Always make a release build.
 set(CMAKE_BUILD_TYPE Release)
 
-# Build PCRE2 library as static.
-set(BUILD_SHARED_LIBS OFF)
+# Build PCRE2 library as both shared and static.
+set(BUILD_STATIC_LIBS ON)
+set(BUILD_SHARED_LIBS ON)
 add_subdirectory(src/libpcre2)
 
 # Build Cython code as shared.
+set(BUILD_STATIC_LIBS OFF)
 set(BUILD_SHARED_LIBS ON)
 add_subdirectory(src/pcre2)
 
 # Include PCRE2 header for Cython API.
 install(FILES ${PCRE2_INCLUDE_DIR}/pcre2.h DESTINATION src/pcre2)
```

### Comparing `pcre2-0.1.0/LICENSE` & `pcre2-0.2.0/LICENSE`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/Makefile` & `pcre2-0.2.0/Makefile`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 init:
 	git submodule update --init
 	python3 -m venv ./.venv
 	./.venv/bin/pip install -r ./requirements/build-requirements.txt
 	./.venv/bin/pip install -r ./requirements/test-requirements.txt
 	./.venv/bin/pip install .
 
-rebuild:
+build:
 	./.venv/bin/pip install . --force-reinstall
 
 clean:
 	rm -rf ./dist
 	rm -rf ./build
 	rm -rf ./_skbuild
 	find ./src/pcre2 -type f -name '*.c' -print0 | xargs -0 rm -vf
```

### Comparing `pcre2-0.1.0/PKG-INFO` & `pcre2-0.2.0/PKG-INFO`

 * *Files 19% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pcre2
-Version: 0.1.0
+Version: 0.2.0
 Summary: Python bindings for the PCRE2 regular expression library
 Home-page: https://github.com/grtetrault/pcre2.py
 Author: Garrett Tetrault
 License: BSD 3-Clause License
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: BSD License
@@ -22,52 +22,57 @@
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 # PCRE2.py: Python bindings for the PCRE2 regular expression library
 
 This project contains Python bindings for [PCRE2](https://github.com/PCRE2Project/pcre2).
 PCRE2 is the revised API for the Perl-compatible regular expressions (PCRE) library created by Philip Hazel.
-For source code, see the [official PCRE2 repository](https://github.com/PCRE2Project/pcre2).
+For original source code, see the [official PCRE2 repository](https://github.com/PCRE2Project/pcre2).
 
 ## Installation
 
 From PyPI:
 ```
 pip install pcre2
 ```
 
-If a wheel is not available for your platform, the source for PCRE2 is downloaded over HTTP from [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases/) and built. Building requires:
+If a wheel is not available for your platform, the module will be built from source.
+Building requires:
 
-* `autoconf`
+* `cmake`
 * C compiler toolchain, such as `gcc` and `make`
 * `libtool`
 * Python headers
 
 ## Usage
 
 Regular expressions are compiled with `pcre2.compile()` which accepts both unicode strings and bytes-like objects.
 This returns a `Pattern` object.
 Expressions can be compiled with a number of options (combined with the bitwise-or operator) and can be JIT compiled,
 
 ```python
 >>> import pcre2
 >>> expr = r'(?<head>\w+)\s+(?<tail>\w+)'
 >>> patn = pcre2.compile(expr, options=pcre2.I, jit=True)
->>> patn.jit_compile()  # Patterns can also be JIT compiled after initialization.
+>>> # Patterns can also be JIT compiled after initialization.
+>>> patn.jit_compile()
 ```
 
 Inspection of `Pattern` objects is done as follows,
 
 ```python
 >>> patn.jit_size
 980
 >>> patn.name_dict()
 {1: 'head', 2: 'tail'}
 >>> patn.options
 524296
+>>> # Deeper inspection into options is available.
+>>> pcre2.CompileOption.decompose(patn.options)
+[<CompileOption.CASELESS: 0x8>, <CompileOption.UTF: 0x80000>]
 ```
 
 Once compiled, `Pattern` objects can be used to match against strings.
 Matching return a `Match` object, which has several functions to view results,
 
 ```python
 >>> subj = 'foo bar buzz bazz'
@@ -86,31 +91,44 @@
 'bar foo buzz bazz'
 >>> patn.substitute(repl, subj, options=pcre2.G) # Global substitutions are also supported.
 'bar foo bazz buzz'
 >>> match.expand(repl)
 'bar foo buzz bazz'
 ```
 
-Additionally, `Pattern` objects support for scanning over subjects for all non-overlapping matches,
+Additionally, `Pattern` objects support scanning over subjects for all non-overlapping matches,
 
 ```python
 >>> for match in patn.scan(subj):
 ...     print(match.substring('head'))
 ...
 foo
 buzz
 ```
 
 ## Performance
 
-PCRE2 provides aa fast regular expression library, particularly with JIT compilation enabled.
+PCRE2 provides a fast regular expression library, particularly with JIT compilation enabled.
 Below are the `regex-redux` benchmark results included in this repository,
 
 | Script              | Number of runs | Total time | Real time  | User time   | System time   |
 | ------------------- | -------------- | ---------- | ---------- | ----------- | ------------- |
-| `vanilla.py `       |             10 |     51.470 |      5.147 |      11.409 |         0.533 |
-| `hand_optimized.py` |             10 |     12.310 |      1.231 |       2.484 |         0.212 |
-| `pcre2_module.py`   |             10 |     14.040 |      1.404 |       2.309 |         0.548 |
+| `baseline.py`       |             10 |      3.020 |      0.302 |       0.020 |         0.086 |
+| `vanilla.py`        |             10 |     51.380 |      5.138 |      11.408 |         0.529 |
+| `hand_optimized.py` |             10 |     13.190 |      1.319 |       2.846 |         0.344 |
+| `pcre2_module.py`   |             10 |     13.670 |      1.367 |       2.269 |         0.532 |
  
+Script descriptions are as follows,
+
+| Script              | Description                                                          |
+| ------------------- | -------------------------------------------------------------------- |
+| `baseline.py`       | Reads input file and outputs stored expected output                  |
+| `vanilla.py`        | Pure Python version                                                  |
+| `hand_optimized.py` | Manually written Python `ctypes` bindings for shared PCRE2 C library |
+| `pcre2_module.py`   | Implementation using Python bindings written here                    |
+
 Tests were performed on an M2 Macbook Air.
+Note that to run benchmarks locally, [Git LFS](https://git-lfs.com/) must be installed to download the input dataset.
+Additionally, a Python virtual environment must be created, and the package built
+with `make init` and `make build` respectively.
 For more information on this benchmark, see [The Computer Language Benchmarks Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/regexredux.html).
 See source code of benchmark scripts for details and original sources.
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: pcre2 Version: 0.1.0 Summary: Python bindings for
+Metadata-Version: 2.1 Name: pcre2 Version: 0.2.0 Summary: Python bindings for
 the PCRE2 regular expression library Home-page: https://github.com/grtetrault/
 pcre2.py Author: Garrett Tetrault License: BSD 3-Clause License Classifier:
 Development Status :: 3 - Alpha Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: BSD License Classifier: Programming
 Language :: C Classifier: Programming Language :: Cython Classifier:
 Programming Language :: Python :: 3.6 Classifier: Programming Language ::
 Python :: 3.7 Classifier: Programming Language :: Python :: 3.8 Classifier:
@@ -10,43 +10,55 @@
 Python :: 3.10 Classifier: Programming Language :: Python :: 3.11 Classifier:
 Operating System :: MacOS :: MacOS X Classifier: Operating System :: POSIX ::
 Linux Classifier: Operating System :: Microsoft :: Windows Description-Content-
 Type: text/markdown License-File: LICENSE # PCRE2.py: Python bindings for the
 PCRE2 regular expression library This project contains Python bindings for
 [PCRE2](https://github.com/PCRE2Project/pcre2). PCRE2 is the revised API for
 the Perl-compatible regular expressions (PCRE) library created by Philip Hazel.
-For source code, see the [official PCRE2 repository](https://github.com/
-PCRE2Project/pcre2). ## Installation From PyPI: ``` pip install pcre2 ``` If a
-wheel is not available for your platform, the source for PCRE2 is downloaded
-over HTTP from [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases/
-) and built. Building requires: * `autoconf` * C compiler toolchain, such as
+For original source code, see the [official PCRE2 repository](https://
+github.com/PCRE2Project/pcre2). ## Installation From PyPI: ``` pip install
+pcre2 ``` If a wheel is not available for your platform, the module will be
+built from source. Building requires: * `cmake` * C compiler toolchain, such as
 `gcc` and `make` * `libtool` * Python headers ## Usage Regular expressions are
 compiled with `pcre2.compile()` which accepts both unicode strings and bytes-
 like objects. This returns a `Pattern` object. Expressions can be compiled with
 a number of options (combined with the bitwise-or operator) and can be JIT
 compiled, ```python >>> import pcre2 >>> expr = r'(?
-\w+)\s+(?\w+)' >>> patn = pcre2.compile(expr, options=pcre2.I, jit=True) >>>
-patn.jit_compile() # Patterns can also be JIT compiled after initialization.
+\w+)\s+(?\w+)' >>> patn = pcre2.compile(expr, options=pcre2.I, jit=True) >>> #
+Patterns can also be JIT compiled after initialization. >>> patn.jit_compile()
 ``` Inspection of `Pattern` objects is done as follows, ```python >>>
 patn.jit_size 980 >>> patn.name_dict() {1: 'head', 2: 'tail'} >>> patn.options
-524296 ``` Once compiled, `Pattern` objects can be used to match against
-strings. Matching return a `Match` object, which has several functions to view
-results, ```python >>> subj = 'foo bar buzz bazz' >>> match = patn.match(subj)
->>> match.substring() 'foo bar' >>> match.start(), match.end() (8, 17) ```
-Substitution is also supported, both from `Pattern` and `Match` objects,
-```python >>> repl = '$2 $1' >>> patn.substitute(repl, subj) 'bar foo buzz
-bazz' >>> patn.substitute(repl, subj, options=pcre2.G) # Global substitutions
-are also supported. 'bar foo bazz buzz' >>> match.expand(repl) 'bar foo buzz
-bazz' ``` Additionally, `Pattern` objects support for scanning over subjects
-for all non-overlapping matches, ```python >>> for match in patn.scan(subj):
-... print(match.substring('head')) ... foo buzz ``` ## Performance PCRE2
-provides aa fast regular expression library, particularly with JIT compilation
-enabled. Below are the `regex-redux` benchmark results included in this
-repository, | Script | Number of runs | Total time | Real time | User time |
-System time | | ------------------- | -------------- | ---------- | ---------
-- | ----------- | ------------- | | `vanilla.py ` | 10 | 51.470 | 5.147 |
-11.409 | 0.533 | | `hand_optimized.py` | 10 | 12.310 | 1.231 | 2.484 | 0.212 |
-| `pcre2_module.py` | 10 | 14.040 | 1.404 | 2.309 | 0.548 | Tests were
-performed on an M2 Macbook Air. For more information on this benchmark, see
-[The Computer Language Benchmarks Game](https://benchmarksgame-
-team.pages.debian.net/benchmarksgame/performance/regexredux.html). See source
-code of benchmark scripts for details and original sources.
+524296 >>> # Deeper inspection into options is available. >>>
+pcre2.CompileOption.decompose(patn.options) [
+CASELESS: 0x8>,
+UTF: 0x80000>] ``` Once compiled, `Pattern` objects can be used to match
+against strings. Matching return a `Match` object, which has several functions
+to view results, ```python >>> subj = 'foo bar buzz bazz' >>> match =
+patn.match(subj) >>> match.substring() 'foo bar' >>> match.start(), match.end()
+(8, 17) ``` Substitution is also supported, both from `Pattern` and `Match`
+objects, ```python >>> repl = '$2 $1' >>> patn.substitute(repl, subj) 'bar foo
+buzz bazz' >>> patn.substitute(repl, subj, options=pcre2.G) # Global
+substitutions are also supported. 'bar foo bazz buzz' >>> match.expand(repl)
+'bar foo buzz bazz' ``` Additionally, `Pattern` objects support scanning over
+subjects for all non-overlapping matches, ```python >>> for match in patn.scan
+(subj): ... print(match.substring('head')) ... foo buzz ``` ## Performance
+PCRE2 provides a fast regular expression library, particularly with JIT
+compilation enabled. Below are the `regex-redux` benchmark results included in
+this repository, | Script | Number of runs | Total time | Real time | User time
+| System time | | ------------------- | -------------- | ---------- | ---------
+- | ----------- | ------------- | | `baseline.py` | 10 | 3.020 | 0.302 | 0.020
+| 0.086 | | `vanilla.py` | 10 | 51.380 | 5.138 | 11.408 | 0.529 | |
+`hand_optimized.py` | 10 | 13.190 | 1.319 | 2.846 | 0.344 | | `pcre2_module.py`
+| 10 | 13.670 | 1.367 | 2.269 | 0.532 | Script descriptions are as follows, |
+Script | Description | | ------------------- | --------------------------------
+------------------------------------ | | `baseline.py` | Reads input file and
+outputs stored expected output | | `vanilla.py` | Pure Python version | |
+`hand_optimized.py` | Manually written Python `ctypes` bindings for shared
+PCRE2 C library | | `pcre2_module.py` | Implementation using Python bindings
+written here | Tests were performed on an M2 Macbook Air. Note that to run
+benchmarks locally, [Git LFS](https://git-lfs.com/) must be installed to
+download the input dataset. Additionally, a Python virtual environment must be
+created, and the package built with `make init` and `make build` respectively.
+For more information on this benchmark, see [The Computer Language Benchmarks
+Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/
+regexredux.html). See source code of benchmark scripts for details and original
+sources.
```

### Comparing `pcre2-0.1.0/README.md` & `pcre2-0.2.0/README.md`

 * *Files 22% similar despite different names*

```diff
@@ -1,49 +1,54 @@
 # PCRE2.py: Python bindings for the PCRE2 regular expression library
 
 This project contains Python bindings for [PCRE2](https://github.com/PCRE2Project/pcre2).
 PCRE2 is the revised API for the Perl-compatible regular expressions (PCRE) library created by Philip Hazel.
-For source code, see the [official PCRE2 repository](https://github.com/PCRE2Project/pcre2).
+For original source code, see the [official PCRE2 repository](https://github.com/PCRE2Project/pcre2).
 
 ## Installation
 
 From PyPI:
 ```
 pip install pcre2
 ```
 
-If a wheel is not available for your platform, the source for PCRE2 is downloaded over HTTP from [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases/) and built. Building requires:
+If a wheel is not available for your platform, the module will be built from source.
+Building requires:
 
-* `autoconf`
+* `cmake`
 * C compiler toolchain, such as `gcc` and `make`
 * `libtool`
 * Python headers
 
 ## Usage
 
 Regular expressions are compiled with `pcre2.compile()` which accepts both unicode strings and bytes-like objects.
 This returns a `Pattern` object.
 Expressions can be compiled with a number of options (combined with the bitwise-or operator) and can be JIT compiled,
 
 ```python
 >>> import pcre2
 >>> expr = r'(?<head>\w+)\s+(?<tail>\w+)'
 >>> patn = pcre2.compile(expr, options=pcre2.I, jit=True)
->>> patn.jit_compile()  # Patterns can also be JIT compiled after initialization.
+>>> # Patterns can also be JIT compiled after initialization.
+>>> patn.jit_compile()
 ```
 
 Inspection of `Pattern` objects is done as follows,
 
 ```python
 >>> patn.jit_size
 980
 >>> patn.name_dict()
 {1: 'head', 2: 'tail'}
 >>> patn.options
 524296
+>>> # Deeper inspection into options is available.
+>>> pcre2.CompileOption.decompose(patn.options)
+[<CompileOption.CASELESS: 0x8>, <CompileOption.UTF: 0x80000>]
 ```
 
 Once compiled, `Pattern` objects can be used to match against strings.
 Matching return a `Match` object, which has several functions to view results,
 
 ```python
 >>> subj = 'foo bar buzz bazz'
@@ -62,31 +67,44 @@
 'bar foo buzz bazz'
 >>> patn.substitute(repl, subj, options=pcre2.G) # Global substitutions are also supported.
 'bar foo bazz buzz'
 >>> match.expand(repl)
 'bar foo buzz bazz'
 ```
 
-Additionally, `Pattern` objects support for scanning over subjects for all non-overlapping matches,
+Additionally, `Pattern` objects support scanning over subjects for all non-overlapping matches,
 
 ```python
 >>> for match in patn.scan(subj):
 ...     print(match.substring('head'))
 ...
 foo
 buzz
 ```
 
 ## Performance
 
-PCRE2 provides aa fast regular expression library, particularly with JIT compilation enabled.
+PCRE2 provides a fast regular expression library, particularly with JIT compilation enabled.
 Below are the `regex-redux` benchmark results included in this repository,
 
 | Script              | Number of runs | Total time | Real time  | User time   | System time   |
 | ------------------- | -------------- | ---------- | ---------- | ----------- | ------------- |
-| `vanilla.py `       |             10 |     51.470 |      5.147 |      11.409 |         0.533 |
-| `hand_optimized.py` |             10 |     12.310 |      1.231 |       2.484 |         0.212 |
-| `pcre2_module.py`   |             10 |     14.040 |      1.404 |       2.309 |         0.548 |
+| `baseline.py`       |             10 |      3.020 |      0.302 |       0.020 |         0.086 |
+| `vanilla.py`        |             10 |     51.380 |      5.138 |      11.408 |         0.529 |
+| `hand_optimized.py` |             10 |     13.190 |      1.319 |       2.846 |         0.344 |
+| `pcre2_module.py`   |             10 |     13.670 |      1.367 |       2.269 |         0.532 |
  
+Script descriptions are as follows,
+
+| Script              | Description                                                          |
+| ------------------- | -------------------------------------------------------------------- |
+| `baseline.py`       | Reads input file and outputs stored expected output                  |
+| `vanilla.py`        | Pure Python version                                                  |
+| `hand_optimized.py` | Manually written Python `ctypes` bindings for shared PCRE2 C library |
+| `pcre2_module.py`   | Implementation using Python bindings written here                    |
+
 Tests were performed on an M2 Macbook Air.
+Note that to run benchmarks locally, [Git LFS](https://git-lfs.com/) must be installed to download the input dataset.
+Additionally, a Python virtual environment must be created, and the package built
+with `make init` and `make build` respectively.
 For more information on this benchmark, see [The Computer Language Benchmarks Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/regexredux.html).
 See source code of benchmark scripts for details and original sources.
```

#### html2text {}

```diff
@@ -1,40 +1,52 @@
 # PCRE2.py: Python bindings for the PCRE2 regular expression library This
 project contains Python bindings for [PCRE2](https://github.com/PCRE2Project/
 pcre2). PCRE2 is the revised API for the Perl-compatible regular expressions
-(PCRE) library created by Philip Hazel. For source code, see the [official
-PCRE2 repository](https://github.com/PCRE2Project/pcre2). ## Installation From
-PyPI: ``` pip install pcre2 ``` If a wheel is not available for your platform,
-the source for PCRE2 is downloaded over HTTP from [PCRE2 releases](https://
-github.com/PCRE2Project/pcre2/releases/) and built. Building requires: *
-`autoconf` * C compiler toolchain, such as `gcc` and `make` * `libtool` *
-Python headers ## Usage Regular expressions are compiled with `pcre2.compile()`
-which accepts both unicode strings and bytes-like objects. This returns a
-`Pattern` object. Expressions can be compiled with a number of options
-(combined with the bitwise-or operator) and can be JIT compiled, ```python >>>
-import pcre2 >>> expr = r'(?
-\w+)\s+(?\w+)' >>> patn = pcre2.compile(expr, options=pcre2.I, jit=True) >>>
-patn.jit_compile() # Patterns can also be JIT compiled after initialization.
+(PCRE) library created by Philip Hazel. For original source code, see the
+[official PCRE2 repository](https://github.com/PCRE2Project/pcre2). ##
+Installation From PyPI: ``` pip install pcre2 ``` If a wheel is not available
+for your platform, the module will be built from source. Building requires: *
+`cmake` * C compiler toolchain, such as `gcc` and `make` * `libtool` * Python
+headers ## Usage Regular expressions are compiled with `pcre2.compile()` which
+accepts both unicode strings and bytes-like objects. This returns a `Pattern`
+object. Expressions can be compiled with a number of options (combined with the
+bitwise-or operator) and can be JIT compiled, ```python >>> import pcre2 >>>
+expr = r'(?
+\w+)\s+(?\w+)' >>> patn = pcre2.compile(expr, options=pcre2.I, jit=True) >>> #
+Patterns can also be JIT compiled after initialization. >>> patn.jit_compile()
 ``` Inspection of `Pattern` objects is done as follows, ```python >>>
 patn.jit_size 980 >>> patn.name_dict() {1: 'head', 2: 'tail'} >>> patn.options
-524296 ``` Once compiled, `Pattern` objects can be used to match against
-strings. Matching return a `Match` object, which has several functions to view
-results, ```python >>> subj = 'foo bar buzz bazz' >>> match = patn.match(subj)
->>> match.substring() 'foo bar' >>> match.start(), match.end() (8, 17) ```
-Substitution is also supported, both from `Pattern` and `Match` objects,
-```python >>> repl = '$2 $1' >>> patn.substitute(repl, subj) 'bar foo buzz
-bazz' >>> patn.substitute(repl, subj, options=pcre2.G) # Global substitutions
-are also supported. 'bar foo bazz buzz' >>> match.expand(repl) 'bar foo buzz
-bazz' ``` Additionally, `Pattern` objects support for scanning over subjects
-for all non-overlapping matches, ```python >>> for match in patn.scan(subj):
-... print(match.substring('head')) ... foo buzz ``` ## Performance PCRE2
-provides aa fast regular expression library, particularly with JIT compilation
-enabled. Below are the `regex-redux` benchmark results included in this
-repository, | Script | Number of runs | Total time | Real time | User time |
-System time | | ------------------- | -------------- | ---------- | ---------
-- | ----------- | ------------- | | `vanilla.py ` | 10 | 51.470 | 5.147 |
-11.409 | 0.533 | | `hand_optimized.py` | 10 | 12.310 | 1.231 | 2.484 | 0.212 |
-| `pcre2_module.py` | 10 | 14.040 | 1.404 | 2.309 | 0.548 | Tests were
-performed on an M2 Macbook Air. For more information on this benchmark, see
-[The Computer Language Benchmarks Game](https://benchmarksgame-
-team.pages.debian.net/benchmarksgame/performance/regexredux.html). See source
-code of benchmark scripts for details and original sources.
+524296 >>> # Deeper inspection into options is available. >>>
+pcre2.CompileOption.decompose(patn.options) [
+CASELESS: 0x8>,
+UTF: 0x80000>] ``` Once compiled, `Pattern` objects can be used to match
+against strings. Matching return a `Match` object, which has several functions
+to view results, ```python >>> subj = 'foo bar buzz bazz' >>> match =
+patn.match(subj) >>> match.substring() 'foo bar' >>> match.start(), match.end()
+(8, 17) ``` Substitution is also supported, both from `Pattern` and `Match`
+objects, ```python >>> repl = '$2 $1' >>> patn.substitute(repl, subj) 'bar foo
+buzz bazz' >>> patn.substitute(repl, subj, options=pcre2.G) # Global
+substitutions are also supported. 'bar foo bazz buzz' >>> match.expand(repl)
+'bar foo buzz bazz' ``` Additionally, `Pattern` objects support scanning over
+subjects for all non-overlapping matches, ```python >>> for match in patn.scan
+(subj): ... print(match.substring('head')) ... foo buzz ``` ## Performance
+PCRE2 provides a fast regular expression library, particularly with JIT
+compilation enabled. Below are the `regex-redux` benchmark results included in
+this repository, | Script | Number of runs | Total time | Real time | User time
+| System time | | ------------------- | -------------- | ---------- | ---------
+- | ----------- | ------------- | | `baseline.py` | 10 | 3.020 | 0.302 | 0.020
+| 0.086 | | `vanilla.py` | 10 | 51.380 | 5.138 | 11.408 | 0.529 | |
+`hand_optimized.py` | 10 | 13.190 | 1.319 | 2.846 | 0.344 | | `pcre2_module.py`
+| 10 | 13.670 | 1.367 | 2.269 | 0.532 | Script descriptions are as follows, |
+Script | Description | | ------------------- | --------------------------------
+------------------------------------ | | `baseline.py` | Reads input file and
+outputs stored expected output | | `vanilla.py` | Pure Python version | |
+`hand_optimized.py` | Manually written Python `ctypes` bindings for shared
+PCRE2 C library | | `pcre2_module.py` | Implementation using Python bindings
+written here | Tests were performed on an M2 Macbook Air. Note that to run
+benchmarks locally, [Git LFS](https://git-lfs.com/) must be installed to
+download the input dataset. Additionally, a Python virtual environment must be
+created, and the package built with `make init` and `make build` respectively.
+For more information on this benchmark, see [The Computer Language Benchmarks
+Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/
+regexredux.html). See source code of benchmark scripts for details and original
+sources.
```

### Comparing `pcre2-0.1.0/setup.py` & `pcre2-0.2.0/setup.py`

 * *Files 0% similar despite different names*

```diff
@@ -12,15 +12,15 @@
         long_description = f.read()
 
     return long_description
 
 
 skbuild.setup(
     name = "pcre2",
-    version = "0.1.0",
+    version = "0.2.0",
     description = "Python bindings for the PCRE2 regular expression library",
     long_description = get_long_desciption(),
     long_description_content_type = "text/markdown",
     license = "BSD 3-Clause License",
     author = "Garrett Tetrault",
     url = "https://github.com/grtetrault/pcre2.py",
     classifiers = [
```

### Comparing `pcre2-0.1.0/src/libpcre2/.gitignore` & `pcre2-0.2.0/src/libpcre2/.gitignore`

 * *Files 15% similar despite different names*

```diff
@@ -1,16 +1,20 @@
 # Public .gitignore file for PCRE2
 
 *.a
+*.gcda
+*.gcno
 *.lo
 *.la
 *.pc
 *.o
 *~
 
+*-coverage*
+
 __pycache__
 .deps
 .libs
 
 INSTALL
 Makefile
 Makefile.in
@@ -33,14 +37,17 @@
 ltmain.sh
 missing
 pcre2-config
 pcre2_dftables
 pcre2_jit_test
 pcre2_jit_test.log
 pcre2_jit_test.trs
+pcre2posix_test
+pcre2posix_test.log
+pcre2posix_test.trs
 pcre2demo
 pcre2fuzzcheck
 pcre2grep
 pcre2test
 test-driver
 test-suite.log
 test3input
@@ -71,8 +78,10 @@
 src/.deps
 src/.dirstamp
 src/config.h
 src/pcre2.h
 src/pcre2_chartables.c
 src/stamp-h1
 
+/bazel-*
+
 # End
```

### Comparing `pcre2-0.1.0/src/libpcre2/132html` & `pcre2-0.2.0/src/libpcre2/132html`

 * *Files 0% similar despite different names*

```diff
@@ -90,15 +90,15 @@
     if (/^\.br/ || /^\.in/)
       {
       print STDERR "\n*** Deprecated macro encountered - rewrite needed\n";
       print STDERR "*** $_\n";
       die "*** Processing abandoned\n";
       }
 
-    # Instead of .br, relevent "literal" sections are enclosed in .nf/.fi.
+    # Instead of .br, relevant "literal" sections are enclosed in .nf/.fi.
 
     elsif (/^\.nf/)
       {
       $innf = 1;
       }
 
     elsif (/^\.fi/)
```

### Comparing `pcre2-0.1.0/src/libpcre2/AUTHORS` & `pcre2-0.2.0/src/libpcre2/AUTHORS`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/CMakeLists.txt` & `pcre2-0.2.0/src/libpcre2/CMakeLists.txt`

 * *Files 2% similar despite different names*

```diff
@@ -95,20 +95,20 @@
 # 2020-05-25 PH added a check for Intel CET
 # 2020-12-03 PH altered the definition of pcre2test as suggested by Daniel
 # 2021-06-29 JWSB added the option to build static library with PIC.
 # 2021-07-05 JWSB modified such both the static and shared library can be
 #            build in one go.
 # 2021-08-28 PH increased minimum version
 # 2021-08-28 PH added test for realpath()
-
-PROJECT(PCRE2 C)
+# 2022-12-10 PH added support for pcre2posix_test
 
 # Increased minimum to 2.8.5 to support GNUInstallDirs.
-# Increased minimum to 3.0.0 because older than 2.8.12 is deprecated.
-CMAKE_MINIMUM_REQUIRED(VERSION 3.0.0)
+# Increased minimum to 3.1 to support imported targets.
+CMAKE_MINIMUM_REQUIRED(VERSION 3.1)
+PROJECT(PCRE2 C)
 
 # Set policy CMP0026 to avoid warnings for the use of LOCATION in
 # GET_TARGET_PROPERTY. This should no longer be required.
 # CMAKE_POLICY(SET CMP0026 OLD)
 
 # With a recent cmake, you can provide a rootdir to look for non
 # standard installed library dependencies, but to do so, the policy
@@ -378,15 +378,21 @@
 ENDIF(PCRE2_NEVER_BACKSLASH_C)
 
 IF(PCRE2_SUPPORT_UNICODE)
         SET(SUPPORT_UNICODE 1)
 ENDIF(PCRE2_SUPPORT_UNICODE)
 
 IF(PCRE2_SUPPORT_JIT)
-        SET(SUPPORT_JIT 1)
+	SET(SUPPORT_JIT 1)
+	IF(UNIX)
+		FIND_PACKAGE(Threads REQUIRED)
+		IF(CMAKE_USE_PTHREADS_INIT)
+			SET(REQUIRE_PTHREAD 1)
+		ENDIF(CMAKE_USE_PTHREADS_INIT)
+	ENDIF(UNIX)
 ENDIF(PCRE2_SUPPORT_JIT)
 
 IF(PCRE2_SUPPORT_JIT_SEALLOC)
         SET(CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE)
 	CHECK_SYMBOL_EXISTS(mkostemp stdlib.h REQUIRED)
         UNSET(CMAKE_REQUIRED_DEFINITIONS)
         IF(${REQUIRED})
@@ -648,14 +654,16 @@
       WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
       COMMENT Using pcre2posix coff info in mingw build)
     SET(PCRE2POSIX_SOURCES ${PCRE2POSIX_SOURCES} ${PROJECT_SOURCE_DIR}/pcre2posix.o)
   ENDIF(EXISTS ${PROJECT_SOURCE_DIR}/pcre2posix.rc)
 ENDIF(MINGW AND BUILD_SHARED_LIBS)
 
 IF(MSVC AND BUILD_SHARED_LIBS)
+  SET(dll_pdb_files ${PROJECT_BINARY_DIR}/pcre2-posix.pdb ${dll_pdb_files})
+  SET(dll_pdb_debug_files ${PROJECT_BINARY_DIR}/pcre2-posixd.pdb ${dll_pdb_debug_files})
   IF (EXISTS ${PROJECT_SOURCE_DIR}/pcre2.rc)
     SET(PCRE2_SOURCES ${PCRE2_SOURCES} pcre2.rc)
   ENDIF(EXISTS ${PROJECT_SOURCE_DIR}/pcre2.rc)
 
   IF (EXISTS ${PROJECT_SOURCE_DIR}/pcre2posix.rc)
     SET(PCRE2POSIX_SOURCES ${PCRE2POSIX_SOURCES} pcre2posix.rc)
   ENDIF (EXISTS ${PROJECT_SOURCE_DIR}/pcre2posix.rc)
@@ -693,24 +701,29 @@
     SET_TARGET_PROPERTIES(pcre2-8-static PROPERTIES
       COMPILE_DEFINITIONS PCRE2_CODE_UNIT_WIDTH=8
       MACHO_COMPATIBILITY_VERSION "${LIBPCRE2_8_MACHO_COMPATIBILITY_VERSION}"
       MACHO_CURRENT_VERSION "${LIBPCRE2_8_MACHO_CURRENT_VERSION}"
       VERSION ${LIBPCRE2_8_VERSION}
       SOVERSION ${LIBPCRE2_8_SOVERSION})
     TARGET_COMPILE_DEFINITIONS(pcre2-8-static PUBLIC PCRE2_STATIC)
+    TARGET_INCLUDE_DIRECTORIES(pcre2-8-static PUBLIC ${PROJECT_BINARY_DIR})
+    IF(REQUIRE_PTHREAD)
+        TARGET_LINK_LIBRARIES(pcre2-8-static Threads::Threads)
+    ENDIF(REQUIRE_PTHREAD)
     SET(targets ${targets} pcre2-8-static)
     ADD_LIBRARY(pcre2-posix-static STATIC ${PCRE2POSIX_HEADERS} ${PCRE2POSIX_SOURCES})
     SET_TARGET_PROPERTIES(pcre2-posix-static PROPERTIES
       COMPILE_DEFINITIONS PCRE2_CODE_UNIT_WIDTH=8
       MACHO_COMPATIBILITY_VERSION "${LIBPCRE2_POSIX_MACHO_COMPATIBILITY_VERSION}"
       MACHO_CURRENT_VERSION "${LIBPCRE2_POSIX_MACHO_CURRENT_VERSION}"
       VERSION ${LIBPCRE2_POSIX_VERSION}
       SOVERSION ${LIBPCRE2_POSIX_SOVERSION})
     TARGET_LINK_LIBRARIES(pcre2-posix-static pcre2-8-static)
     TARGET_COMPILE_DEFINITIONS(pcre2-posix-static PUBLIC PCRE2_STATIC)
+    TARGET_INCLUDE_DIRECTORIES(pcre2-posix-static PUBLIC ${PROJECT_BINARY_DIR})
     SET(targets ${targets} pcre2-posix-static)
 
     IF(MSVC)
       SET_TARGET_PROPERTIES(pcre2-8-static PROPERTIES OUTPUT_NAME pcre2-8-static)
       SET_TARGET_PROPERTIES(pcre2-posix-static PROPERTIES OUTPUT_NAME pcre2-posix-static)
     ELSE(MSVC)
       SET_TARGET_PROPERTIES(pcre2-8-static PROPERTIES OUTPUT_NAME pcre2-8)
@@ -719,32 +732,39 @@
     IF(PCRE2_STATIC_PIC)
       SET_TARGET_PROPERTIES(pcre2-8-static pcre2-posix-static PROPERTIES POSITION_INDEPENDENT_CODE 1)
     ENDIF(PCRE2_STATIC_PIC)
   ENDIF(BUILD_STATIC_LIBS)
 
   IF(BUILD_SHARED_LIBS)
     ADD_LIBRARY(pcre2-8-shared SHARED ${PCRE2_HEADERS} ${PCRE2_SOURCES} ${PROJECT_BINARY_DIR}/config.h)
+    TARGET_INCLUDE_DIRECTORIES(pcre2-8-shared PUBLIC ${PROJECT_BINARY_DIR})
     SET_TARGET_PROPERTIES(pcre2-8-shared PROPERTIES
       COMPILE_DEFINITIONS PCRE2_CODE_UNIT_WIDTH=8
       MACHO_COMPATIBILITY_VERSION "${LIBPCRE2_8_MACHO_COMPATIBILITY_VERSION}"
       MACHO_CURRENT_VERSION "${LIBPCRE2_8_MACHO_CURRENT_VERSION}"
       VERSION ${LIBPCRE2_8_VERSION}
       SOVERSION ${LIBPCRE2_8_SOVERSION}
       OUTPUT_NAME pcre2-8)
+    IF(REQUIRE_PTHREAD)
+        TARGET_LINK_LIBRARIES(pcre2-8-shared Threads::Threads)
+    ENDIF(REQUIRE_PTHREAD)
     SET(targets ${targets} pcre2-8-shared)
     ADD_LIBRARY(pcre2-posix-shared SHARED ${PCRE2POSIX_HEADERS} ${PCRE2POSIX_SOURCES})
+    TARGET_INCLUDE_DIRECTORIES(pcre2-posix-shared PUBLIC ${PROJECT_BINARY_DIR})
     SET_TARGET_PROPERTIES(pcre2-posix-shared PROPERTIES
       COMPILE_DEFINITIONS PCRE2_CODE_UNIT_WIDTH=8
       MACHO_COMPATIBILITY_VERSION "${LIBPCRE2_POSIX_MACHO_COMPATIBILITY_VERSION}"
       MACHO_CURRENT_VERSION "${LIBPCRE2_POSIX_MACHO_CURRENT_VERSION}"
       VERSION ${LIBPCRE2_POSIX_VERSION}
       SOVERSION ${LIBPCRE2_POSIX_SOVERSION}
       OUTPUT_NAME pcre2-posix)
     TARGET_LINK_LIBRARIES(pcre2-posix-shared pcre2-8-shared)
     SET(targets ${targets} pcre2-posix-shared)
+    SET(dll_pdb_files ${PROJECT_BINARY_DIR}/pcre2-8.pdb ${dll_pdb_files})
+    SET(dll_pdb_debug_files ${PROJECT_BINARY_DIR}/pcre2-8d.pdb ${dll_pdb_debug_files})
 
     IF(MINGW)
       IF(NON_STANDARD_LIB_PREFIX)
         SET_TARGET_PROPERTIES(pcre2-8-shared pcre2-posix-shared PROPERTIES PREFIX "")
       ENDIF(NON_STANDARD_LIB_PREFIX)
       IF(NON_STANDARD_LIB_SUFFIX)
         SET_TARGET_PROPERTIES(pcre2-8-shared pcre2-posix-shared PROPERTIES SUFFIX "-0.dll")
@@ -762,43 +782,53 @@
 ENDIF(PCRE2_BUILD_PCRE2_8)
 
 # 16-bit library
 
 IF(PCRE2_BUILD_PCRE2_16)
   IF(BUILD_STATIC_LIBS)
     ADD_LIBRARY(pcre2-16-static STATIC ${PCRE2_HEADERS} ${PCRE2_SOURCES} ${PROJECT_BINARY_DIR}/config.h)
+    TARGET_INCLUDE_DIRECTORIES(pcre2-16-static PUBLIC ${PROJECT_BINARY_DIR})
     SET_TARGET_PROPERTIES(pcre2-16-static PROPERTIES
       COMPILE_DEFINITIONS PCRE2_CODE_UNIT_WIDTH=16
       MACHO_COMPATIBILITY_VERSION "${LIBPCRE2_32_MACHO_COMPATIBILITY_VERSION}"
       MACHO_CURRENT_VERSION "${LIBPCRE2_32_MACHO_CURRENT_VERSION}"
       VERSION ${LIBPCRE2_16_VERSION}
       SOVERSION ${LIBPCRE2_16_SOVERSION})
     TARGET_COMPILE_DEFINITIONS(pcre2-16-static PUBLIC PCRE2_STATIC)
+    IF(REQUIRE_PTHREAD)
+      TARGET_LINK_LIBRARIES(pcre2-16-static Threads::Threads)
+    ENDIF(REQUIRE_PTHREAD)
     SET(targets ${targets} pcre2-16-static)
 
     IF(MSVC)
       SET_TARGET_PROPERTIES(pcre2-16-static PROPERTIES OUTPUT_NAME pcre2-16-static)
     ELSE(MSVC)
       SET_TARGET_PROPERTIES(pcre2-16-static PROPERTIES OUTPUT_NAME pcre2-16)
     ENDIF(MSVC)
     IF(PCRE2_STATIC_PIC)
       SET_TARGET_PROPERTIES(pcre2-16-static PROPERTIES POSITION_INDEPENDENT_CODE 1)
     ENDIF(PCRE2_STATIC_PIC)
   ENDIF(BUILD_STATIC_LIBS)
 
   IF(BUILD_SHARED_LIBS)
     ADD_LIBRARY(pcre2-16-shared SHARED ${PCRE2_HEADERS} ${PCRE2_SOURCES} ${PROJECT_BINARY_DIR}/config.h)
+    TARGET_INCLUDE_DIRECTORIES(pcre2-16-shared PUBLIC ${PROJECT_BINARY_DIR})
     SET_TARGET_PROPERTIES(pcre2-16-shared PROPERTIES
       COMPILE_DEFINITIONS PCRE2_CODE_UNIT_WIDTH=16
       MACHO_COMPATIBILITY_VERSION "${LIBPCRE2_32_MACHO_COMPATIBILITY_VERSION}"
       MACHO_CURRENT_VERSION "${LIBPCRE2_32_MACHO_CURRENT_VERSION}"
       VERSION ${LIBPCRE2_16_VERSION}
       SOVERSION ${LIBPCRE2_16_SOVERSION}
       OUTPUT_NAME pcre2-16)
+    IF(REQUIRE_PTHREAD)
+      TARGET_LINK_LIBRARIES(pcre2-16-shared Threads::Threads)
+    ENDIF(REQUIRE_PTHREAD)
     SET(targets ${targets} pcre2-16-shared)
+    SET(dll_pdb_files ${PROJECT_BINARY_DIR}/pcre2-16.pdb ${dll_pdb_files})
+    SET(dll_pdb_debug_files ${PROJECT_BINARY_DIR}/pcre2-16d.pdb ${dll_pdb_debug_files})
 
     IF(MINGW)
       IF(NON_STANDARD_LIB_PREFIX)
         SET_TARGET_PROPERTIES(pcre2-16-shared PROPERTIES PREFIX "")
       ENDIF(NON_STANDARD_LIB_PREFIX)
       IF(NON_STANDARD_LIB_SUFFIX)
         SET_TARGET_PROPERTIES(pcre2-16-shared PROPERTIES SUFFIX "-0.dll")
@@ -814,43 +844,53 @@
 ENDIF(PCRE2_BUILD_PCRE2_16)
 
 # 32-bit library
 
 IF(PCRE2_BUILD_PCRE2_32)
   IF(BUILD_STATIC_LIBS)
     ADD_LIBRARY(pcre2-32-static STATIC ${PCRE2_HEADERS} ${PCRE2_SOURCES} ${PROJECT_BINARY_DIR}/config.h)
+    TARGET_INCLUDE_DIRECTORIES(pcre2-32-static PUBLIC ${PROJECT_BINARY_DIR})
     SET_TARGET_PROPERTIES(pcre2-32-static PROPERTIES
       COMPILE_DEFINITIONS PCRE2_CODE_UNIT_WIDTH=32
       MACHO_COMPATIBILITY_VERSION "${LIBPCRE2_32_MACHO_COMPATIBILITY_VERSION}"
       MACHO_CURRENT_VERSION "${LIBPCRE2_32_MACHO_CURRENT_VERSION}"
       VERSION ${LIBPCRE2_32_VERSION}
       SOVERSION ${LIBPCRE2_32_SOVERSION})
     TARGET_COMPILE_DEFINITIONS(pcre2-32-static PUBLIC PCRE2_STATIC)
+    IF(REQUIRE_PTHREAD)
+      TARGET_LINK_LIBRARIES(pcre2-32-static Threads::Threads)
+    ENDIF(REQUIRE_PTHREAD)
     SET(targets ${targets} pcre2-32-static)
 
     IF(MSVC)
       SET_TARGET_PROPERTIES(pcre2-32-static PROPERTIES OUTPUT_NAME pcre2-32-static)
     ELSE(MSVC)
       SET_TARGET_PROPERTIES(pcre2-32-static PROPERTIES OUTPUT_NAME pcre2-32)
     ENDIF(MSVC)
     IF(PCRE2_STATIC_PIC)
       SET_TARGET_PROPERTIES(pcre2-32-static PROPERTIES POSITION_INDEPENDENT_CODE 1)
     ENDIF(PCRE2_STATIC_PIC)
   ENDIF(BUILD_STATIC_LIBS)
 
   IF(BUILD_SHARED_LIBS)
     ADD_LIBRARY(pcre2-32-shared SHARED ${PCRE2_HEADERS} ${PCRE2_SOURCES} ${PROJECT_BINARY_DIR}/config.h)
+    TARGET_INCLUDE_DIRECTORIES(pcre2-32-shared PUBLIC ${PROJECT_BINARY_DIR})
     SET_TARGET_PROPERTIES(pcre2-32-shared PROPERTIES
       COMPILE_DEFINITIONS PCRE2_CODE_UNIT_WIDTH=32
       MACHO_COMPATIBILITY_VERSION "${LIBPCRE2_32_MACHO_COMPATIBILITY_VERSION}"
       MACHO_CURRENT_VERSION "${LIBPCRE2_32_MACHO_CURRENT_VERSION}"
       VERSION ${LIBPCRE2_32_VERSION}
       SOVERSION ${LIBPCRE2_32_SOVERSION}
       OUTPUT_NAME pcre2-32)
+    IF(REQUIRE_PTHREAD)
+      TARGET_LINK_LIBRARIES(pcre2-32-shared Threads::Threads)
+    ENDIF(REQUIRE_PTHREAD)
     SET(targets ${targets} pcre2-32-shared)
+    SET(dll_pdb_files ${PROJECT_BINARY_DIR}/pcre2-32.pdb ${dll_pdb_files})
+    SET(dll_pdb_debug_files ${PROJECT_BINARY_DIR}/pcre2-32d.pdb ${dll_pdb_debug_files})
 
     IF(MINGW)
       IF(NON_STANDARD_LIB_PREFIX)
         SET_TARGET_PROPERTIES(pcre2-32-shared PROPERTIES PREFIX "")
       ENDIF(NON_STANDARD_LIB_PREFIX)
       IF(NON_STANDARD_LIB_SUFFIX)
         SET_TARGET_PROPERTIES(pcre2-32-shared PROPERTIES SUFFIX "-0.dll")
@@ -898,18 +938,24 @@
     LIST(APPEND PCRE2TEST_LIBS pcre2-16)
   ENDIF(PCRE2_BUILD_PCRE2_16)
   IF(PCRE2_BUILD_PCRE2_32)
     LIST(APPEND PCRE2TEST_LIBS pcre2-32)
   ENDIF(PCRE2_BUILD_PCRE2_32)
   TARGET_LINK_LIBRARIES(pcre2test ${PCRE2TEST_LIBS} ${PCRE2TEST_LINKER_FLAGS})
 
+  IF(PCRE2_BUILD_PCRE2_8)
+    ADD_EXECUTABLE(pcre2posix_test src/pcre2posix_test.c)
+    SET(targets ${targets} pcre2posix_test)
+    TARGET_LINK_LIBRARIES(pcre2posix_test pcre2-posix pcre2-8)
+  ENDIF(PCRE2_BUILD_PCRE2_8)
+
   IF(PCRE2_SUPPORT_JIT)
     ADD_EXECUTABLE(pcre2_jit_test src/pcre2_jit_test.c)
     SET(targets ${targets} pcre2_jit_test)
-    SET(PCRE2_JIT_TEST_LIBS )
+    SET(PCRE2_JIT_TEST_LIBS)
     IF(PCRE2_BUILD_PCRE2_8)
       LIST(APPEND PCRE2_JIT_TEST_LIBS pcre2-8)
     ENDIF(PCRE2_BUILD_PCRE2_8)
     IF(PCRE2_BUILD_PCRE2_16)
       LIST(APPEND PCRE2_JIT_TEST_LIBS pcre2-16)
     ENDIF(PCRE2_BUILD_PCRE2_16)
     IF(PCRE2_BUILD_PCRE2_32)
@@ -1013,14 +1059,19 @@
 
   # Changed to accommodate testing whichever location was just built
 
   IF(PCRE2_SUPPORT_JIT)
     ADD_TEST(pcre2_jit_test pcre2_jit_test)
   ENDIF(PCRE2_SUPPORT_JIT)
 
+  IF(PCRE2_BUILD_PCRE2_8)
+    ADD_TEST(pcre2posix_test pcre2posix_test)
+  ENDIF(PCRE2_BUILD_PCRE2_8)
+
+
 ENDIF(PCRE2_BUILD_TESTS)
 
 # Installation
 
 SET(CMAKE_INSTALL_ALWAYS 1)
 
 INSTALL(TARGETS ${targets}
@@ -1049,26 +1100,16 @@
 FILE(GLOB man3 ${PROJECT_SOURCE_DIR}/doc/*.3)
 
 INSTALL(FILES ${man1} DESTINATION man/man1)
 INSTALL(FILES ${man3} DESTINATION man/man3)
 INSTALL(FILES ${html} DESTINATION share/doc/pcre2/html)
 
 IF(MSVC AND INSTALL_MSVC_PDB)
- INSTALL(FILES ${PROJECT_BINARY_DIR}/pcre2-8.pdb
-               ${PROJECT_BINARY_DIR}/pcre2-16.pdb
-               ${PROJECT_BINARY_DIR}/pcre2-32.pdb
-               ${PROJECT_BINARY_DIR}/pcre2-posix.pdb
-         DESTINATION bin
-         CONFIGURATIONS RelWithDebInfo)
- INSTALL(FILES ${PROJECT_BINARY_DIR}/pcre2-8d.pdb
-               ${PROJECT_BINARY_DIR}/pcre2-16d.pdb
-               ${PROJECT_BINARY_DIR}/pcre2-32d.pdb
-               ${PROJECT_BINARY_DIR}/pcre2-posixd.pdb
-         DESTINATION bin
-         CONFIGURATIONS Debug)
+ INSTALL(FILES ${dll_pdb_files} DESTINATION bin CONFIGURATIONS RelWithDebInfo)
+ INSTALL(FILES ${dll_pdb_debug_files} DESTINATION bin CONFIGURATIONS Debug)
 ENDIF(MSVC AND INSTALL_MSVC_PDB)
 
 # Help, only for nice output
 IF(BUILD_STATIC_LIBS)
   SET(BUILD_STATIC_LIBS ON)
 ELSE(BUILD_STATIC_LIBS)
   SET(BUILD_STATIC_LIBS OFF)
```

### Comparing `pcre2-0.1.0/src/libpcre2/ChangeLog` & `pcre2-0.2.0/src/libpcre2/ChangeLog`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,122 @@
-Change Log for PCRE2
---------------------
+Change Log for PCRE2 - see also the Git log
+-------------------------------------------
+
+
+Version 10.42 11-December-2022
+------------------------------
+
+1. Change 19 of 10.41 wasn't quite right; it put the definition of a default,
+empty value for PCRE2_CALL_CONVENTION in src/pcre2posix.c instead of
+src/pcre2posix.h, which meant that programs that included pcre2posix.h but not
+pcre2.h failed to compile.
+
+2. To catch similar issues to the above in future, a new small test program
+that includes pcre2posix.h but not pcre2.h has been added to the test suite.
+
+3. When the -S option of pcre2test was used to set a stack size greater than
+the allowed maximum, the error message displayed the hard limit incorrectly.
+This was pointed out on GitHub pull request #171, but the suggested patch
+didn't cope with all cases. Some further modification was required.
+
+4. Supplying an ovector count of more than 65535 to pcre2_match_data_create()
+caused a crash because the field in the match data block is only 16 bits. A
+maximum of 65535 is now silently applied.
+
+5. Merged @carenas patch #175 which fixes #86 - segfault on aarch64 (ARM),
+
+
+Version 10.41 06-December-2022
+------------------------------
+
+1. Add fflush() before and after a fork callout in pcre2grep to get its output
+to be the same on all systems. (There were previously ordering differences in
+Alpine Linux).
+
+2. Merged patch from @carenas (GitHub #110) for pthreads support in CMake.
+
+3. SSF scorecards grumbled about possible overflow in an expression in
+pcre2test. It never would have overflowed in practice, but some casts have been
+added and at the some time there's been some tidying of fprints that output
+size_t values.
+
+4. PR #94 showed up an unused enum in pcre2_convert.c, which is now removed.
+
+5. Minor code re-arrangement to remove gcc warning about realloc() in
+pcre2test.
+
+6. Change a number of int variables that hold buffer and line lengths in
+pcre2grep to PCRE2_SIZE (aka size_t).
+
+7. Added an #ifdef to cut out a call to PRIV(jit_free) when JIT is not
+supported (even though that function would do nothing in that case) at the
+request of a user who doesn't even want to link with pcre_jit_compile.o. Also
+tidied up an untidy #ifdef arrangement in pcre2test.
+
+8. Fixed an issue in the backtracking optimization of character repeats in
+JIT. Furthermore optimize star repetitions, not just plus repetitions.
+
+9. Removed the use of an initial backtracking frames vector on the system stack
+in pcre2_match() so that it now always uses the heap. (In a multi-thread
+environment with very small stacks there had been an issue.) This also is
+tidier for JIT matching, which didn't need that vector. The heap vector is now
+remembered in the match data block and re-used if that block itself is re-used.
+It is freed with the match data block.
+
+10. Adjusted the find_limits code in pcre2test to work with change 9 above.
+
+11. Added find_limits_noheap to pcre2test, because the heap limits are now
+different in different environments and so cannot be included in the standard
+tests.
+
+12. Created a test for pcre2_match() heap processing that is not part of the
+tests run by 'make check', but can be run manually. The current output is from
+a 64-bit system.
+
+13. Implemented -Z aka --null in pcre2grep.
+
+14. A minor change to pcre2test and the addition of several new pcre2grep tests
+have improved LCOV coverage statistics. At the same time, code in pcre2grep and
+elsewhere that can never be obeyed in normal testing has been excluded from
+coverage.
+
+15. Fixed a bug in pcre2grep that could cause an extra newline to be written
+after output generaed by --output.
+
+16. If a file has a .bz2 extension but is not in fact compressed, pcre2grep
+should process it as a plain text file. A bug stopped this happening; now fixed
+and added to the tests.
+
+17. When pcre2grep was running not in UTF mode, if a string specified by
+--output or obtained from a callout in a pattern contained a character (byte)
+greater than 127, it was incorrectly output in UTF-8 format.
+
+18. Added some casts after warnings from Clang sanitize.
+
+19. Merged patch from cbouc (GitHub #139): 4 function prototypes were missing
+PCRE2_CALL_CONVENTION in src/pcre2posix.h. All function prototypes returning
+pointers had out of place PCRE2_CALL_CONVENTION in src/pcre2.h.*. These
+produced errors when building for Windows with #define PCRE2_CALL_CONVENTION
+__stdcall.
+
+20. A negative repeat value in a pcre2test subject line was not being
+diagnosed, leading to infinite looping.
+
+21. Updated RunGrepTest to discard the warning that Bash now gives when setting
+LC_CTYPE to a bad value (because older versions didn't).
+
+22. Updated pcre2grep so that it behaves like GNU grep when matching more than
+one pattern and a later pattern matches at an earlier point in the subject when
+the matched substrings are being identified by colour or by offsets.
+
+23. Updated the PrepareRelease script so that the man page that it makes for
+the pcre2demo demonstration program is more standard and does not cause errors
+when processed by lexgrog or mandb -c (GitHub issue #160).
+
+24. The JIT compiler was updated.
 
 
 Version 10.40 15-April-2022
 ---------------------------
 
 1. Merged patch from @carenas (GitHub #35, 7db87842) to fix pcre2grep incorrect
 handling of multiple passes.
@@ -88,15 +201,15 @@
 
 22. An item such as [Aa] is optimized into a caseless single character match.
 When this was quantified (e.g. [Aa]{2}) and was also the last literal item in a
 pattern, the optimizing "must be present for a match" character check was not
 being flagged as caseless, causing some matches that should have succeeded to
 fail.
 
-23. Fixed a unicode properrty matching issue in JIT. The character was not
+23. Fixed a unicode property matching issue in JIT. The character was not
 fully read in caseless matching.
 
 24. Fixed an issue affecting recursions in JIT caused by duplicated data
 transfers.
 
 25. Merged patch from @carenas (GitHub #96) which fixes some problems with
 pcre2test and readline/readedit:
@@ -115,18 +228,18 @@
 
   Visual Studio 2013 includes support for %zu and %td, so let newer
   versions of it avoid the fallback, and while at it, make sure that
   the first check is for DISABLE_PERCENT_ZT so it will be always
   honoured if chosen.
 
   prtdiff_t is signed, so use a signed type instead, and make sure
-  that an appropiate width is chosen if pointers are 64bit wide and
+  that an appropriate width is chosen if pointers are 64bit wide and
   long is not (ex: Windows 64bit).
 
-  IMHO removing the cast (and therefore the positibilty of truncation)
+  IMHO removing the cast (and therefore the possibilty of truncation)
   make the code cleaner and the fallback is likely portable enough
   with all 64-bit POSIX systems doing LP64 except for Windows.
 
 3. Merged patch from @carenas (GitHub #29) to update to Unicode 14.0.0.
 
 4. Merged patch from @carenas (GitHub #30):
 
@@ -169,15 +282,15 @@
   Reformat slightly to make it C89 compatible again.
 
 
 Version 10.38 01-October-2021
 -----------------------------
 
 1. Fix invalid single character repetition issues in JIT when the repetition
-is inside a capturing bracket and the bracket is preceeded by character
+is inside a capturing bracket and the bracket is preceded by character
 literals.
 
 2. Installed revised CMake configuration files provided by Jan-Willem Blokland.
 This extends the CMake build system to build both static and shared libraries
 in one go, builds the static library with PIC, and exposes PCRE2 libraries
 using the CMake config files. JWB provided these notes:
 
@@ -409,15 +522,15 @@
 
 5. Added PCRE2_SUBSTITUTE_LITERAL.
 
 6. Avoid some VS compiler warnings.
 
 7. Added PCRE2_SUBSTITUTE_MATCHED.
 
-8. Added (?* and (?<* as synonms for (*napla: and (*naplb: to match another
+8. Added (?* and (?<* as synonyms for (*napla: and (*naplb: to match another
 regex engine. The Perl regex folks are aware of this usage and have made a note
 about it.
 
 9. When an assertion is repeated, PCRE2 used to limit the maximum repetition to
 1, believing that repeating an assertion is pointless. However, if a positive
 assertion contains capturing groups, repetition can be useful. In any case, an
 assertion could always be wrapped in a repeated group. The only restriction
@@ -840,15 +953,15 @@
 36. Disable SSE2 JIT optimizations in x86 CPUs when SSE2 is not available.
 Patch by Guillem Jover.
 
 37. Changed expressions such as 1<<10 to 1u<<10 in many places because compiler
 warnings were reported.
 
 38. Using the clang compiler with sanitizing options causes runtime complaints
-about truncation for statments such as x = ~x when x is an 8-bit value; it
+about truncation for statements such as x = ~x when x is an 8-bit value; it
 seems to compute ~x as a 32-bit value. Changing such statements to x = 255 ^ x
 gets rid of the warnings. There were also two missing casts in pcre2test.
 
 
 Version 10.32 10-September-2018
 -------------------------------
```

### Comparing `pcre2-0.1.0/src/libpcre2/CheckMan` & `pcre2-0.2.0/src/libpcre2/CheckMan`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/CleanTxt` & `pcre2-0.2.0/src/libpcre2/CleanTxt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/Detrail` & `pcre2-0.2.0/src/libpcre2/Detrail`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/HACKING` & `pcre2-0.2.0/src/libpcre2/HACKING`

 * *Files 2% similar despite different names*

```diff
@@ -4,16 +4,16 @@
 These are very rough technical notes that record potentially useful information
 about PCRE2 internals. PCRE2 is a library based on the original PCRE library,
 but with a revised (and incompatible) API. To avoid confusion, the original
 library is referred to as PCRE1 below. For information about testing PCRE2, see
 the pcre2test documentation and the comment at the head of the RunTest file.
 
 PCRE1 releases were up to 8.3x when PCRE2 was developed, and later bug fix
-releases remain in the 8.xx series. PCRE2 releases started at 10.00 to avoid
-confusion with PCRE1.
+releases carried on the 8.xx series, up to the final 8.45 release. PCRE2
+releases started at 10.00 to avoid confusion with PCRE1.
 
 
 Historical note 1
 -----------------
 
 Many years ago I implemented some regular expression functions to an algorithm
 suggested by Martin Richards. The rather simple patterns were not Unix-like in
@@ -34,16 +34,16 @@
 
 Historical note 2
 -----------------
 
 By contrast, the code originally written by Henry Spencer (which was
 subsequently heavily modified for Perl) compiles the expression twice: once in
 a dummy mode in order to find out how much store will be needed, and then for
-real. (The Perl version probably doesn't do this any more; I'm talking about
-the original library.) The execution function operates by backtracking and
+real. (The Perl version may or may not still do this; I'm talking about the
+original library.) The execution function operates by backtracking and
 maximizing (or, optionally, minimizing, in Perl) the amount of the subject that
 matches individual wild portions of the pattern. This is an "NFA algorithm" in
 Friedl's terminology.
 
 
 OK, here's the real stuff
 -------------------------
@@ -147,16 +147,16 @@
 bounded by the length of the pattern (with one exception). The code is written
 so that each item in the pattern uses no more vector elements than the number
 of code units in the item itself. The exception is the aforementioned large
 32-bit number handling. For this reason, 32-bit non-UTF patterns are scanned in
 advance to check for such values. When auto-callouts are enabled, the generous
 assumption is made that there will be a callout for each pattern code unit
 (which of course is only actually true if all code units are literals) plus one
-at the end. There is a default parsed pattern vector on the system stack, but
-if this is not big enough, heap memory is used.
+at the end. A default parsed pattern vector is defined on the system stack, to
+minimize memory handling, but if this is not big enough, heap memory is used.
 
 As before, the actual compiling function is run twice, the first time to
 determine the amount of memory needed for the final compiled pattern. It
 now processes the parsed pattern vector, not the pattern itself, although some
 of the parsed items refer to strings in the pattern - for example, group
 names. As escapes and comments have already been processed, the code is a bit
 simpler than before.
@@ -183,40 +183,40 @@
 META_ATOMIC           (?> start of atomic group
 META_CIRCUMFLEX       ^ metacharacter
 META_CLASS            [ start of non-empty class
 META_CLASS_EMPTY      [] empty class - only with PCRE2_ALLOW_EMPTY_CLASS
 META_CLASS_EMPTY_NOT  [^] negative empty class - ditto
 META_CLASS_END        ] end of non-empty class
 META_CLASS_NOT        [^ start non-empty negative class
-META_COMMIT           (*COMMIT)
+META_COMMIT           (*COMMIT) - no argument (see below for with argument)
 META_COND_ASSERT      (?(?assertion)
 META_DOLLAR           $ metacharacter
 META_DOT              . metacharacter
 META_END              End of pattern (this value is 0x80000000)
 META_FAIL             (*FAIL)
 META_KET              ) closing parenthesis
 META_LOOKAHEAD        (?= start of lookahead
 META_LOOKAHEAD_NA     (*napla: start of non-atomic lookahead
 META_LOOKAHEADNOT     (?! start of negative lookahead
 META_NOCAPTURE        (?: no capture parens
 META_PLUS             +
 META_PLUS_PLUS        ++
 META_PLUS_QUERY       +?
-META_PRUNE            (*PRUNE) - no argument
+META_PRUNE            (*PRUNE) - no argument (see below for with argument)
 META_QUERY            ?
 META_QUERY_PLUS       ?+
 META_QUERY_QUERY      ??
 META_RANGE_ESCAPED    hyphen in class range with at least one escape
 META_RANGE_LITERAL    hyphen in class range defined literally
-META_SKIP             (*SKIP) - no argument
-META_THEN             (*THEN) - no argument
+META_SKIP             (*SKIP) - no argument (see below for with argument)
+META_THEN             (*THEN) - no argument (see below for with argument)
 
 The two RANGE values occur only in character classes. They are positioned
 between two literals that define the start and end of the range. In an EBCDIC
-evironment it is necessary to know whether either of the range values was
+environment it is necessary to know whether either of the range values was
 specified as an escape. In an ASCII/Unicode environment the distinction is not
 relevant.
 
 The following have data in the lower 16 bits, and may be followed by other data
 elements:
 
 META_ALT              | alternation
@@ -225,25 +225,24 @@
 META_ESCAPE           non-literal escape sequence
 META_RECURSE          recursion call
 
 If the data for META_ALT is non-zero, it is inside a lookbehind, and the data
 is the length of its branch, for which OP_REVERSE must be generated.
 
 META_BACKREF, META_CAPTURE, and META_RECURSE have the capture group number as
-their data in the lower 16 bits of the element.
+their data in the lower 16 bits of the element. META_RECURSE is followed by an
+offset, for use in error messages.
 
 META_BACKREF is followed by an offset if the back reference group number is 10
-or more. The offsets of the first ocurrences of references to groups whose
+or more. The offsets of the first occurrences of references to groups whose
 numbers are less than 10 are put in cb->small_ref_offset[] (only the first
 occurrence is useful). On 64-bit systems this avoids using more than two parsed
 pattern elements for items such as \3. The offset is used when an error occurs
 because the reference is to a non-existent group.
 
-META_RECURSE is always followed by an offset, for use in error messages.
-
 META_ESCAPE has an ESC_xxx value as its data. For ESC_P and ESC_p, the next
 element contains the 16-bit type and data property values, packed together.
 ESC_g and ESC_k are used only for named references - numerical ones are turned
 into META_RECURSE or META_BACKREF as appropriate. ESC_g and ESC_k are followed
 by a length and an offset into the pattern to specify the name.
 
 The following have one data item that follows in the next vector element:
@@ -287,17 +286,17 @@
 of the main word contain the length of the first branch of the lookbehind
 group; this is used when generating OP_REVERSE for that branch.
 
 META_LOOKBEHIND       (?<=      start of lookbehind
 META_LOOKBEHIND_NA    (*naplb:  start of non-atomic lookbehind
 META_LOOKBEHINDNOT    (?<!      start of negative lookbehind
 
-The following are followed by two elements, the minimum and maximum. Repeat
-values are limited to 65535 (MAX_REPEAT). A maximum value of "unlimited" is
-represented by UNLIMITED_REPEAT, which is bigger than MAX_REPEAT:
+The following are followed by two elements, the minimum and maximum. The
+maximum value is limited to 65535 (MAX_REPEAT). A maximum value of "unlimited"
+is represented by UNLIMITED_REPEAT, which is bigger than MAX_REPEAT:
 
 META_MINMAX           {n,m}  repeat
 META_MINMAX_PLUS      {n,m}+ repeat
 META_MINMAX_QUERY     {n,m}? repeat
 
 This one is followed by three elements. The first is 0 for '>' and 1 for '>=';
 the next two are the major and minor numbers:
@@ -343,19 +342,19 @@
 ever active at once. I believe some other regex matchers work this way. JIT
 support is not available for this kind of matching.
 
 
 Changeable options
 ------------------
 
-The /i, /m, or /s options (PCRE2_CASELESS, PCRE2_MULTILINE, PCRE2_DOTALL, and
-others) may be changed in the middle of patterns by items such as (?i). Their
-processing is handled entirely at compile time by generating different opcodes
-for the different settings. The runtime functions do not need to keep track of
-an option's state.
+The /i, /m, or /s options (PCRE2_CASELESS, PCRE2_MULTILINE, PCRE2_DOTALL) and
+some others may be changed in the middle of patterns by items such as (?i).
+Their processing is handled entirely at compile time by generating different
+opcodes for the different settings. The runtime functions do not need to keep
+track of an option's state.
 
 PCRE2_DUPNAMES, PCRE2_EXTENDED, PCRE2_EXTENDED_MORE, and PCRE2_NO_AUTO_CAPTURE
 are tracked and processed during the parsing pre-pass. The others are handled
 from META_OPTIONS items during the main compile phase.
 
 
 Format of compiled patterns
@@ -368,15 +367,15 @@
 data that follows it.
 
 In many cases listed below, LINK_SIZE data values are specified for offsets
 within the compiled pattern. LINK_SIZE always specifies a number of bytes. The
 default value for LINK_SIZE is 2, except for the 32-bit library, where it can
 only be 4. The 8-bit library can be compiled to used 3-byte or 4-byte values,
 and the 16-bit library can be compiled to use 4-byte values, though this
-impairs performance. Specifing a LINK_SIZE larger than 2 for these libraries is
+impairs performance. Specifying a LINK_SIZE larger than 2 for these libraries is
 necessary only when patterns whose compiled length is greater than 65535 code
 units are going to be processed. When a LINK_SIZE value uses more than one code
 unit, the most significant unit is first.
 
 In this description, we assume the "normal" compilation options. Data values
 that are counts (e.g. quantifiers) are always two bytes long in 8-bit mode
 (most significant byte first), and one code unit in 16-bit and 32-bit modes.
@@ -433,15 +432,15 @@
 (PCRE2_ALLOW_EMPTY_CLASS is set).
 
 
 Backtracking control verbs
 --------------------------
 
 Verbs with no arguments generate opcodes with no following data (as listed
-in the section above). 
+in the section above).
 
 (*MARK:NAME) generates OP_MARK followed by the mark name, preceded by a
 length in one code unit, and followed by a binary zero. The name length is
 limited by the size of the code unit.
 
 (*ACCEPT:NAME) and (*FAIL:NAME) are compiled as (*MARK:NAME)(*ACCEPT) and
 (*MARK:NAME)(*FAIL) respectively.
@@ -464,16 +463,16 @@
 used for a positive class, and OP_NOT or OP_NOTI for a negative one (that is,
 for something like [^a]).
 
 Caseless matching (positive or negative) of characters that have more than two
 case-equivalent code points (which is possible only in UTF mode) is handled by
 compiling a Unicode property item (see below), with the pseudo-property
 PT_CLIST. The value of this property is an offset in a vector called
-"ucd_caseless_sets" which identifies the start of a short list of equivalent
-characters, terminated by the value NOTACHAR (0xffffffff).
+"ucd_caseless_sets" which identifies the start of a short list of case
+equivalent characters, terminated by the value NOTACHAR (0xffffffff).
 
 
 Repeating single characters
 ---------------------------
 
 The common repeats (*, +, ?), when applied to a single character, use the
 following opcodes, which come in caseful and caseless versions:
@@ -542,17 +541,17 @@
 
 OP_PROP and OP_NOTPROP are used for positive and negative matches of a
 character by testing its Unicode property (the \p and \P escape sequences).
 Each is followed by two code units that encode the desired property as a type
 and a value. The types are a set of #defines of the form PT_xxx, and the values
 are enumerations of the form ucp_xx, defined in the pcre2_ucp.h source file.
 The value is relevant only for PT_GC (General Category), PT_PC (Particular
-Category), PT_SC (Script), PT_BIDICL (Bidi Class), and the pseudo-property
-PT_CLIST, which is used to identify a list of case-equivalent characters when
-there are three or more.
+Category), PT_SC (Script), PT_BIDICL (Bidi Class), PT_BOOL (Boolean property),
+and the pseudo-property PT_CLIST, which is used to identify a list of
+case-equivalent characters when there are three or more (see above).
 
 Repeats of these items use the OP_TYPESTAR etc. set of opcodes, followed by
 three code units: OP_PROP or OP_NOTPROP, and then the desired property type and
 value.
 
 
 Character classes
@@ -662,17 +661,17 @@
 opcode. Each OP_ALT is followed by a LINK_SIZE value giving the offset to the
 next one, or to the final opcode. For capturing brackets, the bracket number is
 a count that immediately follows the offset.
 
 There are several opcodes that mark the end of a subpattern group. OP_KET is
 used for subpatterns that do not repeat indefinitely, OP_KETRMIN and
 OP_KETRMAX are used for indefinite repetitions, minimally or maximally
-respectively, and OP_KETRPOS for possessive repetitions (see below for more 
+respectively, and OP_KETRPOS for possessive repetitions (see below for more
 details). All four are followed by a LINK_SIZE value giving (as a positive
-number) the offset back to the matching bracket opcode.
+number) the offset back to the matching opening bracket opcode.
 
 If a subpattern is quantified such that it is permitted to match zero times, it
 is preceded by one of OP_BRAZERO, OP_BRAMINZERO, or OP_SKIPZERO. These are
 single-unit opcodes that tell the matcher that skipping the following
 subpattern entirely is a valid match. In the case of the first two, not
 skipping the pattern is also valid (greedy and non-greedy). The third is used
 when a pattern has the quantifier {0,0}. It cannot be entirely discarded,
@@ -715,15 +714,15 @@
 
 
 Assertions
 ----------
 
 Forward assertions are also just like other subpatterns, but starting with one
 of the opcodes OP_ASSERT, OP_ASSERT_NA (non-atomic assertion), or
-OP_ASSERT_NOT. Backward assertions use the opcodes OP_ASSERTBACK, 
+OP_ASSERT_NOT. Backward assertions use the opcodes OP_ASSERTBACK,
 OP_ASSERTBACK_NA, and OP_ASSERTBACK_NOT, and the first opcode inside the
 assertion is OP_REVERSE, followed by a count of the number of characters to
 move back the pointer in the subject string. In ASCII or UTF-32 mode, the count
 is also the number of code units, but in UTF-8/16 mode each character may
 occupy more than one code unit. A separate count is present in each alternative
 of a lookbehind assertion, allowing each branch to have a different (but fixed)
 length.
@@ -824,8 +823,8 @@
 ---------------------
 
 The last opcode that is defined in pcre2_internal.h is OP_TABLE_LENGTH. This is
 not a real opcode, but is used to check at compile time that tables indexed by
 opcode are the correct length, in order to catch updating errors.
 
 Philip Hazel
-December 2021
+April 2022
```

### Comparing `pcre2-0.1.0/src/libpcre2/LICENCE` & `pcre2-0.2.0/src/libpcre2/LICENCE`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/Makefile.am` & `pcre2-0.2.0/src/libpcre2/Makefile.am`

 * *Files 2% similar despite different names*

```diff
@@ -448,17 +448,18 @@
   src/sljit/sljitNativeARM_T2_32.c \
   src/sljit/sljitNativeMIPS_32.c \
   src/sljit/sljitNativeMIPS_64.c \
   src/sljit/sljitNativeMIPS_common.c \
   src/sljit/sljitNativePPC_32.c \
   src/sljit/sljitNativePPC_64.c \
   src/sljit/sljitNativePPC_common.c \
+  src/sljit/sljitNativeRISCV_32.c \
+  src/sljit/sljitNativeRISCV_64.c \
+  src/sljit/sljitNativeRISCV_common.c \
   src/sljit/sljitNativeS390X.c \
-  src/sljit/sljitNativeSPARC_32.c \
-  src/sljit/sljitNativeSPARC_common.c \
   src/sljit/sljitNativeX86_32.c \
   src/sljit/sljitNativeX86_64.c \
   src/sljit/sljitNativeX86_common.c \
   src/sljit/sljitProtExecAllocator.c \
   src/sljit/sljitUtils.c \
   src/sljit/sljitWXExecAllocator.c
 
@@ -549,14 +550,25 @@
 pcre2fuzzcheck_LDADD += $(GCOV_LIBS)
 endif # WITH_GCOV
 endif # WITH FUZZ_SUPPORT
 endif # WITH_PCRE2_8
 
 ## -------- Testing ----------
 
+## If the 8-bit library is enabled, build the POSIX wrapper test program and
+## arrange for it to run.
+
+if WITH_PCRE2_8
+TESTS += pcre2posix_test
+noinst_PROGRAMS += pcre2posix_test
+pcre2posix_test_SOURCES = src/pcre2posix_test.c
+pcre2posix_test_CFLAGS = $(AM_CFLAGS)
+pcre2posix_test_LDADD = libpcre2-posix.la libpcre2-8.la
+endif # WITH_PCRE2_8
+
 ## If JIT support is enabled, arrange for the JIT test program to run.
 
 if WITH_JIT
 TESTS += pcre2_jit_test
 noinst_PROGRAMS += pcre2_jit_test
 pcre2_jit_test_SOURCES = src/pcre2_jit_test.c
 pcre2_jit_test_CFLAGS = $(AM_CFLAGS)
@@ -627,23 +639,31 @@
 
 EXTRA_DIST += \
   testdata/grepbinary \
   testdata/grepfilelist \
   testdata/grepinput \
   testdata/grepinput3 \
   testdata/grepinput8 \
+  testdata/grepinputC.bz2 \
+  testdata/grepinputC.gz \
   testdata/grepinputM \
   testdata/grepinputv \
   testdata/grepinputx \
   testdata/greplist \
+  testdata/grepnot.bz2 \
   testdata/grepoutput \
   testdata/grepoutput8 \
   testdata/grepoutputC \
   testdata/grepoutputCN \
+  testdata/grepoutputCNU \
+  testdata/grepoutputCU \
+  testdata/grepoutputCbz2 \
+  testdata/grepoutputCgz \
   testdata/grepoutputN \
+  testdata/grepoutputUN \
   testdata/greppatN4 \
   testdata/testbtables \
   testdata/testinput1 \
   testdata/testinput2 \
   testdata/testinput3 \
   testdata/testinput4 \
   testdata/testinput5 \
@@ -665,14 +685,15 @@
   testdata/testinput21 \
   testdata/testinput22 \
   testdata/testinput23 \
   testdata/testinput24 \
   testdata/testinput25 \
   testdata/testinput26 \
   testdata/testinputEBC \
+  testdata/testinputheap \
   testdata/testoutput1 \
   testdata/testoutput2 \
   testdata/testoutput3 \
   testdata/testoutput3A \
   testdata/testoutput3B \
   testdata/testoutput4 \
   testdata/testoutput5 \
@@ -708,14 +729,17 @@
   testdata/testoutput22-32 \
   testdata/testoutput22-8 \
   testdata/testoutput23 \
   testdata/testoutput24 \
   testdata/testoutput25 \
   testdata/testoutput26 \
   testdata/testoutputEBC \
+  testdata/testoutputheap-16 \
+  testdata/testoutputheap-32 \
+  testdata/testoutputheap-8 \
   testdata/valgrind-jit.supp \
   testdata/wintestinput3 \
   testdata/wintestoutput3 \
   perltest.sh
 
 # RunTest and RunGrepTest should clean up after themselves, but just in case
 # they don't, add their working files to CLEANFILES.
@@ -734,15 +758,15 @@
         testtemp2grep \
         testtrygrep \
         testNinputgrep
 
 ## ------------ End of testing -------------
 
 
-# PCRE2 demonstration program. Not built automatcally. The point is that the
+# PCRE2 demonstration program. Not built automatically. The point is that the
 # users should build it themselves. So just distribute the source.
 
 EXTRA_DIST += src/pcre2demo.c
 
 
 # We have .pc files for pkg-config users.
```

### Comparing `pcre2-0.1.0/src/libpcre2/NEWS` & `pcre2-0.2.0/src/libpcre2/NEWS`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,34 @@
 News about PCRE2 releases
 -------------------------
 
 
+Version 10.42 11-December-2022
+------------------------------
+
+This is an unexpectedly early release to fix a problem that was introduced in
+10.41. ChangeLog number 19 (GitHub #139) added the default definition of
+PCRE2_CALL_CONVENTION to pcre2posix.c instead of pcre2posix.h, which meant that
+programs including pcre2posix.h but not pcre2.h couldn't compile. A new test
+that checks this case has been added.
+
+A couple of other minor issues are also fixed, and a patch for an intermittent
+JIT fault is also included. See ChangeLog and the Git log.
+
+
+Version 10.41 06-December-2022
+------------------------------
+
+This is another mainly bug-fixing and code-tidying release. There is one
+significant upgrade to pcre2grep: it now behaves like GNU grep when matching
+more than one pattern and a later pattern matches at an earlier point in the
+subject when the matched substrings are being identified by colour or by
+offsets.
+
+
 Version 10.40 15-April-2022
 ---------------------------
 
 This is mostly a bug-fixing and code-tidying release. However, there are some
 extensions to Unicode property handling:
 
 * Added support for Bidi_Class and a number of binary Unicode properties,
```

### Comparing `pcre2-0.1.0/src/libpcre2/NON-AUTOTOOLS-BUILD` & `pcre2-0.2.0/src/libpcre2/NON-AUTOTOOLS-BUILD`

 * *Files 1% similar despite different names*

```diff
@@ -65,15 +65,15 @@
      configure/make world, this is handled automatically.) When upgrading to a
      new release, you are strongly advised to review src/config.h.generic
      before re-using what you had previously.
 
      Note also that the src/config.h.generic file is created from a config.h
      that was generated by Autotools, which automatically includes settings of
      a number of macros that are not actually used by PCRE2 (for example,
-     HAVE_MEMORY_H).
+     HAVE_DLFCN_H).
 
  (2) Copy or rename the file src/pcre2.h.generic as src/pcre2.h.
 
  (3) EITHER:
        Copy or rename file src/pcre2_chartables.c.dist as
        src/pcre2_chartables.c.
 
@@ -117,29 +117,30 @@
        pcre2_serialize.c
        pcre2_string_utils.c
        pcre2_study.c
        pcre2_substitute.c
        pcre2_substring.c
        pcre2_tables.c
        pcre2_ucd.c
+       pcre2_ucptables.c
        pcre2_valid_utf.c
        pcre2_xclass.c
 
      Make sure that you include -I. in the compiler command (or equivalent for
      an unusual compiler) so that all included PCRE2 header files are first
      sought in the src directory under the current directory. Otherwise you run
      the risk of picking up a previously-installed file from somewhere else.
 
      Note that you must compile pcre2_jit_compile.c, even if you have not
      defined SUPPORT_JIT in src/config.h, because when JIT support is not
      configured, dummy functions are compiled. When JIT support IS configured,
      pcre2_jit_compile.c #includes other files from the sljit subdirectory,
      all of whose names begin with "sljit". It also #includes
      src/pcre2_jit_match.c and src/pcre2_jit_misc.c, so you should not compile
-     these yourself.
+     those yourself.
 
      Note also that the pcre2_fuzzsupport.c file contains special code that is
      useful to those who want to run fuzzing tests on the PCRE2 library. Unless
      you are doing that, you can ignore it.
 
  (5) Now link all the compiled code into an object library in whichever form
      your system keeps such libraries. This is the basic PCRE2 C 8-bit library.
@@ -181,15 +182,19 @@
      system uses a different convention.
 
 (10) If you have built PCRE2 with SUPPORT_JIT, the JIT features can be tested
      by running pcre2test with the -jit option. This is done automatically by
      the RunTest script. You might also like to build and run the freestanding
      JIT test program, src/pcre2_jit_test.c.
 
-(11) If you want to use the pcre2grep command, compile and link
+(11) The pcre2test program tests the POSIX wrapper library, but there is also a
+     freestanding test program in src/pcre2posix_test.c. It must be linked with
+     both the pcre2posix library and the 8-bit PCRE2 library.
+
+(12) If you want to use the pcre2grep command, compile and link
      src/pcre2grep.c; it uses only the basic 8-bit PCRE2 library (it does not
      need the pcre2posix library). If you have built the PCRE2 library with JIT
      support by defining SUPPORT_JIT in src/config.h, you can also define
      SUPPORT_PCRE2GREP_JIT, which causes pcre2grep to make use of JIT (unless
      it is run with --no-jit). If you define SUPPORT_PCRE2GREP_JIT without
      defining SUPPORT_JIT, pcre2grep does not try to make use of JIT.
 
@@ -302,15 +307,15 @@
     directory such as C:\pcre2. You should ensure your local date and time
     is not earlier than the file dates in your source dir if the release is
     very new.
 
 3.  Create a new, empty build directory, preferably a subdirectory of the
     source dir. For example, C:\pcre2\pcre2-xx\build.
 
-4.  Run cmake-gui from the Shell envirornment of your build tool, for example,
+4.  Run cmake-gui from the Shell environment of your build tool, for example,
     Msys for Msys/MinGW or Visual Studio Command Prompt for VC/VC++. Do not try
     to start Cmake from the Windows Start menu, as this can lead to errors.
 
 5.  Enter C:\pcre2\pcre2-xx and C:\pcre2\pcre2-xx\build for the source and
     build directories, respectively.
 
 6.  Hit the "Configure" button.
@@ -369,15 +374,15 @@
 To run only a particular test with RunTest.Bat provide a test number argument.
 
 Otherwise:
 
 1. Copy RunTest.bat into the directory where pcre2test.exe and pcre2grep.exe
    have been created.
 
-2. Edit RunTest.bat to indentify the full or relative location of
+2. Edit RunTest.bat to identify the full or relative location of
    the pcre2 source (wherein which the testdata folder resides), e.g.:
 
    set srcdir=C:\pcre2\pcre2-10.00
 
 3. In a Windows command environment, chdir to the location of your bat and
    exe programs.
 
@@ -401,10 +406,10 @@
 
   http://www.cbttape.org
 
 Everything in that location, source and executable, is in EBCDIC and native
 z/OS file formats. The port provides an API for LE languages such as COBOL and
 for the z/OS and z/VM versions of the Rexx languages.
 
-===========================
-Last Updated: 28 April 2021
-===========================
+==============================
+Last Updated: 10 December 2022
+==============================
```

### Comparing `pcre2-0.1.0/src/libpcre2/PrepareRelease` & `pcre2-0.2.0/src/libpcre2/PrepareRelease`

 * *Files 2% similar despite different names*

```diff
@@ -90,15 +90,18 @@
 
 # Make pcre2demo.3 from the pcre2demo.c source file
 
 echo "Making pcre2demo.3"
 perl <<"END" >pcre2demo.3
   open(IN, "../src/pcre2demo.c") || die "Failed to open src/pcre2demo.c\n";
   open(OUT, ">pcre2demo.3") || die "Failed to open pcre2demo.3\n";
-  print OUT ".\\\" Start example.\n" .
+  print OUT ".SH NAME\n" .
+            "// - A demonstration C program for PCRE2 - //\n" .
+            ".sp\n" .  
+            ".\\\" Start example.\n" .
             ".de EX\n" .
             ".  nr mE \\\\n(.f\n" .
             ".  nf\n" .
             ".  nh\n" .
             ".  ft CW\n" .
             "..\n" .
             ".\n" .
```

### Comparing `pcre2-0.1.0/src/libpcre2/README` & `pcre2-0.2.0/src/libpcre2/README`

 * *Files 1% similar despite different names*

```diff
@@ -4,24 +4,24 @@
 PCRE2 is a re-working of the original PCRE1 library to provide an entirely new
 API. Since its initial release in 2015, there has been further development of
 the code and it now differs from PCRE1 in more than just the API. There are new
 features, and the internals have been improved. The original PCRE1 library is
 now obsolete and no longer maintained. The latest release of PCRE2 is available
 in .tar.gz, tar.bz2, or .zip form from this GitHub repository:
 
-https://github.com/PhilipHazel/pcre2/releases
+https://github.com/PCRE2Project/pcre2/releases
 
 There is a mailing list for discussion about the development of PCRE2 at
 pcre2-dev@googlegroups.com. You can subscribe by sending an email to
 pcre2-dev+subscribe@googlegroups.com.
 
 You can access the archives and also subscribe or manage your subscription
 here:
 
-https://groups.google.com/pcre2-dev
+https://groups.google.com/g/pcre2-dev
 
 Please read the NEWS file if you are upgrading from a previous release. The
 contents of this README file are:
 
   The PCRE2 APIs
   Documentation for PCRE2
   Contributions by users of PCRE2
@@ -371,18 +371,18 @@
   Enabling libreadline causes the -lreadline option to be added to the
   pcre2test build. In many operating environments with a sytem-installed
   readline library this is sufficient. However, in some environments (e.g. if
   an unmodified distribution version of readline is in use), it may be
   necessary to specify something like LIBS="-lncurses" as well. This is
   because, to quote the readline INSTALL, "Readline uses the termcap functions,
   but does not link with the termcap or curses library itself, allowing
-  applications which link with readline the to choose an appropriate library."
-  If you get error messages about missing functions tgetstr, tgetent, tputs,
-  tgetflag, or tgoto, this is the problem, and linking with the ncurses library
-  should fix it.
+  applications which link with readline the option to choose an appropriate
+  library." If you get error messages about missing functions tgetstr, tgetent,
+  tputs, tgetflag, or tgoto, this is the problem, and linking with the ncurses
+  library should fix it.
 
 . The C99 standard defines formatting modifiers z and t for size_t and
   ptrdiff_t values, respectively. By default, PCRE2 uses these modifiers in
   environments other than Microsoft Visual Studio versions earlier than 2013
   when __STDC_VERSION__ is defined and has a value greater than or equal to
   199901L (indicating C99). However, there is at least one environment that
   claims to be C99 but does not support these modifiers. If
@@ -396,25 +396,25 @@
   LLVMFuzzerTestOneInput() whose arguments are a pointer to a string and the
   length of the string. When called, this function tries to compile the string
   as a pattern, and if that succeeds, to match it. This is done both with no
   options and with some random options bits that are generated from the string.
   Setting --enable-fuzz-support also causes a binary called pcre2fuzzcheck to
   be created. This is normally run under valgrind or used when PCRE2 is
   compiled with address sanitizing enabled. It calls the fuzzing function and
-  outputs information about it is doing. The input strings are specified by
-  arguments: if an argument starts with "=" the rest of it is a literal input
-  string. Otherwise, it is assumed to be a file name, and the contents of the
-  file are the test string.
+  outputs information about what it is doing. The input strings are specified
+  by arguments: if an argument starts with "=" the rest of it is a literal
+  input string. Otherwise, it is assumed to be a file name, and the contents
+  of the file are the test string.
 
 . Releases before 10.30 could be compiled with --disable-stack-for-recursion,
   which caused pcre2_match() to use individual blocks on the heap for
   backtracking instead of recursive function calls (which use the stack). This
-  is now obsolete since pcre2_match() was refactored always to use the heap (in
-  a much more efficient way than before). This option is retained for backwards
-  compatibility, but has no effect other than to output a warning.
+  is now obsolete because pcre2_match() was refactored always to use the heap
+  (in a much more efficient way than before). This option is retained for
+  backwards compatibility, but has no effect other than to output a warning.
 
 The "configure" script builds the following files for the basic C library:
 
 . Makefile             the makefile that builds the library
 . src/config.h         build-time configuration options for the library
 . src/pcre2.h          the public PCRE2 header file
 . pcre2-config         script that shows the building settings such as CFLAGS
@@ -434,16 +434,17 @@
 script that can be run to recreate the configuration, and config.log, which
 contains compiler output from tests that "configure" runs.
 
 Once "configure" has run, you can run "make". This builds whichever of the
 libraries libpcre2-8, libpcre2-16 and libpcre2-32 are configured, and a test
 program called pcre2test. If you enabled JIT support with --enable-jit, another
 test program called pcre2_jit_test is built as well. If the 8-bit library is
-built, libpcre2-posix and the pcre2grep command are also built. Running
-"make" with the -j option may speed up compilation on multiprocessor systems.
+built, libpcre2-posix, pcre2posix_test, and the pcre2grep command are also
+built. Running "make" with the -j option may speed up compilation on
+multiprocessor systems.
 
 The command "make check" runs all the appropriate tests. Details of the PCRE2
 tests are given below in a separate section of this document. The -j option of
 "make" can also be used when running the tests.
 
 You can use "make install" to install PCRE2 into live directories on your
 system. The following are installed (file names are all relative to the
@@ -587,17 +588,19 @@
 
 
 Testing PCRE2
 -------------
 
 To test the basic PCRE2 library on a Unix-like system, run the RunTest script.
 There is another script called RunGrepTest that tests the pcre2grep command.
-When JIT support is enabled, a third test program called pcre2_jit_test is
-built. Both the scripts and all the program tests are run if you obey "make
-check". For other environments, see the instructions in NON-AUTOTOOLS-BUILD.
+When the 8-bit library is built, a test program for the POSIX wrapper, called
+pcre2posix_test, is compiled, and when JIT support is enabled, a test program
+called pcre2_jit_test is built. The scripts and the program tests are all run
+when you obey "make check". For other environments, see the instructions in
+NON-AUTOTOOLS-BUILD.
 
 The RunTest script runs the pcre2test test program (which is documented in its
 own man page) on each of the relevant testinput files in the testdata
 directory, and compares the output with the contents of the corresponding
 testoutput files. RunTest uses a file called testtry to hold the main output
 from pcre2test. Other files whose names begin with "test" are used as working
 files in some tests.
@@ -691,15 +694,15 @@
 Test 13 checks the handling of non-UTF characters greater than 255 by
 pcre2_dfa_match() in 16-bit and 32-bit modes.
 
 Test 14 contains some special UTF and UCP tests that give different output for
 different code unit widths.
 
 Test 15 contains a number of tests that must not be run with JIT. They check,
-among other non-JIT things, the match-limiting features of the intepretive
+among other non-JIT things, the match-limiting features of the interpretive
 matcher.
 
 Test 16 is run only when JIT support is not available. It checks that an
 attempt to use JIT has the expected behaviour.
 
 Test 17 is run only when JIT support is available. It checks JIT complete and
 partial modes, match-limiting under JIT, and other JIT-specific features.
@@ -712,14 +715,17 @@
 
 Tests 21 and 22 test \C support when the use of \C is not locked out, without
 and with UTF support, respectively. Test 23 tests \C when it is locked out.
 
 Tests 24 and 25 test the experimental pattern conversion functions, without and
 with UTF support, respectively.
 
+Test 26 checks Unicode property support using tests that are generated
+automatically from the Unicode data tables.
+
 
 Character tables
 ----------------
 
 For speed, PCRE2 uses four tables for manipulating and identifying characters
 whose code point values are less than 256. By default, a set of tables that is
 built into the library is used. The pcre2_maketables() function can be called
@@ -815,35 +821,39 @@
   src/pcre2_serialize.c    )
   src/pcre2_string_utils.c )
   src/pcre2_study.c        )
   src/pcre2_substitute.c   )
   src/pcre2_substring.c    )
   src/pcre2_tables.c       )
   src/pcre2_ucd.c          )
+  src/pcre2_ucptables.c    )
   src/pcre2_valid_utf.c    )
   src/pcre2_xclass.c       )
 
   src/pcre2_printint.c     debugging function that is used by pcre2test,
   src/pcre2_fuzzsupport.c  function for (optional) fuzzing support
 
   src/config.h.in          template for config.h, when built by "configure"
   src/pcre2.h.in           template for pcre2.h when built by "configure"
   src/pcre2posix.h         header for the external POSIX wrapper API
   src/pcre2_internal.h     header for internal use
   src/pcre2_intmodedep.h   a mode-specific internal header
+  src/pcre2_jit_neon_inc.h header used by JIT
+  src/pcre2_jit_simd_inc.h header used by JIT
   src/pcre2_ucp.h          header for Unicode property handling
 
   sljit/*                  source files for the JIT compiler
 
 (B) Source files for programs that use PCRE2:
 
   src/pcre2demo.c          simple demonstration of coding calls to PCRE2
   src/pcre2grep.c          source of a grep utility that uses PCRE2
   src/pcre2test.c          comprehensive test program
   src/pcre2_jit_test.c     JIT test program
+  src/pcre2posix_test.c    POSIX wrapper API test program
 
 (C) Auxiliary files:
 
   132html                  script to turn "man" pages into HTML
   AUTHORS                  information about the author of PCRE2
   ChangeLog                log of changes to the code
   CleanTxt                 script to clean nroff output for txt man pages
@@ -907,8 +917,8 @@
                           )   for use in non-"configure" environments
   src/config.h.generic    ) a version of config.h for use in non-"configure"
                           )   environments
 
 Philip Hazel
 Email local part: Philip.Hazel
 Email domain: gmail.com
-Last updated: 15 April 2022
+Last updated: 10 December 2022
```

### Comparing `pcre2-0.1.0/src/libpcre2/README.md` & `pcre2-0.2.0/src/libpcre2/README.md`

 * *Files 11% similar despite different names*

```diff
@@ -10,37 +10,37 @@
 PCRE2 was first released in 2015 to replace the API in the original PCRE 
 library, which is now obsolete and no longer maintained. As well as a more
 flexible API, the code of PCRE2 has been much improved since the fork.
  
 ## Download
 
 As well as downloading from the 
-[GitHub site](https://github.com/PhilipHazel/pcre2), you can download PCRE2 
+[GitHub site](https://github.com/PCRE2Project/pcre2), you can download PCRE2 
 or the older, unmaintained PCRE1 library from an 
 [*unofficial* mirror](https://sourceforge.net/projects/pcre/files/) at SourceForge.
 
 You can check out the PCRE2 source code via Git or Subversion:
 
-    git clone https://github.com/PhilipHazel/pcre2.git
-    svn co    https://github.com/PhilipHazel/pcre2.git
+    git clone https://github.com/PCRE2Project/pcre2.git
+    svn co    https://github.com/PCRE2Project/pcre2.git
 
 ## Contributed Ports
 
 If you just need the command-line PCRE2 tools on Windows, precompiled binary
 versions are available at this 
 [Rexegg page](http://www.rexegg.com/pcregrep-pcretest.html).
 
 A PCRE2 port for z/OS, a mainframe operating system which uses EBCDIC as its
 default character encoding, can be found at 
 [http://www.cbttape.org](http://www.cbttape.org/) (File 939).
 
 ## Documentation
 
 You can read the PCRE2 documentation 
-[here](https://philiphazel.github.io/pcre2/doc/html/index.html).
+[here](https://PCRE2Project.github.io/pcre2/doc/html/index.html).
 
 Comparisons to Perl's regular expression semantics can be found in the
 community authored Wikipedia entry for PCRE.
 
 There is a curated summary of changes for each PCRE release, copies of
 documentation from older releases, and other useful information from the third
 party authored
```

### Comparing `pcre2-0.1.0/src/libpcre2/RunGrepTest` & `pcre2-0.2.0/src/libpcre2/RunGrepTest`

 * *Files 18% similar despite different names*

```diff
@@ -64,14 +64,35 @@
 # option as well.
 
 cf="diff"
 diff -b  /dev/null /dev/null 2>/dev/null && cf="diff -b"
 diff -u  /dev/null /dev/null 2>/dev/null && cf="diff -u"
 diff -ub /dev/null /dev/null 2>/dev/null && cf="diff -ub"
 
+# Add a -a (always treat as text) if available. This was added in an attempt
+# to get more detail from an Alpine Linux test failure on GitHub.
+
+$cf -a /dev/null /dev/null 2>/dev/null && cf="$cf -a"
+
+# Some tests involve NUL characters. It seems impossible to handle them easily
+# in many operating systems. An earlier version of this script used sed to
+# translate NUL into the string ZERO, but this didn't work on Solaris (aka
+# SunOS), where the version of sed explicitly doesn't like them, and also MacOS
+# (Darwin), OpenBSD, FreeBSD, NetBSD, and some Linux distributions like Alpine,
+# even when using GNU sed. A user suggested using tr instead, which
+# necessitates translating to a single character. However, on (some versions
+# of?) Solaris, the normal "tr" cannot handle binary zeros, but if
+# /usr/xpg4/bin/tr is available, it can do so, so test for that.
+
+if [ -x /usr/xpg4/bin/tr ] ; then
+  tr=/usr/xpg4/bin/tr
+else
+  tr=tr
+fi
+
 # If this test is being run from "make check", $srcdir will be set. If not, set
 # it to the current or parent directory, whichever one contains the test data.
 # Subsequently, we run most of the pcre2grep tests in the source directory so
 # that the file names in the output are always the same.
 
 if [ -z "$srcdir" -o ! -d "$srcdir/testdata" ] ; then
   if [ -d "./testdata" ] ; then
@@ -250,15 +271,15 @@
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 35 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -L -r --include=grepinputx --include grepinput8 --exclude-dir='^\.' 'fox' ./testdata | sort) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 36 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep -L -r --include=grepinput --exclude 'grepinput$' --exclude=grepinput8 --exclude=grepinputM --exclude-dir='^\.' 'fox' ./testdata | sort) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -L -r --include='grepinput[^C]' --exclude 'grepinput$' --exclude=grepinput8 --exclude=grepinputM --exclude-dir='^\.' 'fox' ./testdata | sort) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 37 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep  '^(a+)*\d' ./testdata/grepinput) >>testtrygrep 2>teststderrgrep
 echo "RC=$?" >>testtrygrep
 echo "======== STDERR ========" >>testtrygrep
 cat teststderrgrep >>testtrygrep
@@ -292,15 +313,18 @@
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 45 ------------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -on -f ./testdata/greplist -e binary ./testdata/grepinput) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 46 ------------------------------" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -e 'unopened)' -e abc ./testdata/grepinput) >>testtrygrep 2>&1
 (cd $srcdir; $valgrind $vjs $pcre2grep -eabc -e '(unclosed' ./testdata/grepinput) >>testtrygrep 2>&1
+(cd $srcdir; $valgrind $vjs $pcre2grep -eabc -e xyz -e '[unclosed' ./testdata/grepinput) >>testtrygrep 2>&1
+(cd $srcdir; $valgrind $vjs $pcre2grep --regex=123 -eabc -e xyz -e '[unclosed' ./testdata/grepinput) >>testtrygrep 2>&1
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 47 ------------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -Fx "AB.VE
 elephant" ./testdata/grepinput) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
@@ -335,19 +359,19 @@
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 55 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -f./testdata/greplist --color=always ./testdata/grepinputx) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 56 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep -c lazy ./testdata/grepinput*) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -c --exclude=grepinputC lazy ./testdata/grepinput*) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 57 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep -c -l lazy ./testdata/grepinput*) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -c -l --exclude=grepinputC lazy ./testdata/grepinput*) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 58 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep --regex=PATTERN ./testdata/grepinput) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 59 -----------------------------" >>testtrygrep
@@ -363,15 +387,15 @@
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 62 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $pcre2grep --match-limit=1000 --no-jit -M 'This is a file(.|\R)*file.' ./testdata/grepinput) >>testtrygrep 2>&1
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 63 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $pcre2grep --recursion-limit=1000 --no-jit -M 'This is a file(.|\R)*file.' ./testdata/grepinput) >>testtrygrep 2>&1
+(cd $srcdir; $valgrind $pcre2grep --recursion-limit=1K --no-jit -M 'This is a file(.|\R)*file.' ./testdata/grepinput) >>testtrygrep 2>&1
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 64 ------------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -o1 '(?<=PAT)TERN (ap(pear)s)' ./testdata/grepinput) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 65 ------------------------------" >>testtrygrep
@@ -502,33 +526,33 @@
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 95 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep --file-list ./testdata/grepfilelist --exclude grepinputv "fox|complete") >>testtrygrep 2>&1
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 96 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep -L -r --include-dir=testdata --exclude '^(?!grepinput)' --exclude=grepinputM 'fox' ./test* | sort) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -L -r --include-dir=testdata --exclude '^(?!grepinput)' --exclude=grepinput[MC] 'fox' ./test* | sort) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 97 -----------------------------" >>testtrygrep
 echo "grepinput$" >testtemp1grep
 echo "grepinput8" >>testtemp1grep
-(cd $srcdir; $valgrind $vjs $pcre2grep -L -r --include=grepinput --exclude=grepinputM --exclude-from $builddir/testtemp1grep --exclude-dir='^\.' 'fox' ./testdata | sort) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -L -r --include=grepinput --exclude=grepinput[MC] --exclude-from $builddir/testtemp1grep --exclude-dir='^\.' 'fox' ./testdata | sort) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 98 -----------------------------" >>testtrygrep
 echo "grepinput$" >testtemp1grep
 echo "grepinput8" >>testtemp1grep
-(cd $srcdir; $valgrind $vjs $pcre2grep -L -r --exclude=grepinput3 --exclude=grepinputM --include=grepinput --exclude-from $builddir/testtemp1grep --exclude-dir='^\.' 'fox' ./testdata | sort) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -L -r --exclude=grepinput3 --exclude=grepinput[MC] --include=grepinput --exclude-from $builddir/testtemp1grep --exclude-dir='^\.' 'fox' ./testdata | sort) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 99 -----------------------------" >>testtrygrep
 echo "grepinput$" >testtemp1grep
 echo "grepinput8" >testtemp2grep
-(cd $srcdir; $valgrind $vjs $pcre2grep -L -r --include grepinput --exclude=grepinputM --exclude-from $builddir/testtemp1grep --exclude-from=$builddir/testtemp2grep --exclude-dir='^\.' 'fox' ./testdata | sort) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -L -r --include grepinput --exclude=grepinput[MC] --exclude-from $builddir/testtemp1grep --exclude-from=$builddir/testtemp2grep --exclude-dir='^\.' 'fox' ./testdata | sort) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 100 ------------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -Ho2 --only-matching=1 -o3 '(\w+) binary (\w+)(\.)?' ./testdata/grepinput) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 101 ------------------------------" >>testtrygrep
@@ -562,15 +586,15 @@
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 108 ------------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -lq PATTERN ./testdata/grepinput ./testdata/grepinputx) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 109 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep -cq lazy ./testdata/grepinput*) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -cq --exclude=grepinputC lazy ./testdata/grepinput*) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 110 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep --om-separator / -Mo0 -o1 -o2 'match (\d+):\n (.)\n' testdata/grepinput) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 111 -----------------------------" >>testtrygrep
@@ -578,45 +602,57 @@
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 112 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep --file-offsets -M 'match (\d+):\n (.)\n' testdata/grepinput) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 113 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep --total-count 'the' testdata/grepinput*) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep --total-count --exclude=grepinputC 'the' testdata/grepinput*) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 114 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep -tc 'the' testdata/grepinput*) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -tc --exclude=grepinputC 'the' testdata/grepinput*) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 115 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep -tlc 'the' testdata/grepinput*) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -tlc --exclude=grepinputC 'the' testdata/grepinput*) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 116 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep --exclude=grepinputM -th 'the' testdata/grepinput*) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep --exclude=grepinput[MC] -th 'the' testdata/grepinput*) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 117 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep -tch 'the' testdata/grepinput*) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -tch --exclude=grepinputC 'the' testdata/grepinput*) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 118 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep -tL 'the' testdata/grepinput*) >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -tL --exclude=grepinputC 'the' testdata/grepinput*) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 119 -----------------------------" >>testtrygrep
 printf '123\n456\n789\n---abc\ndef\nxyz\n---\n' >testNinputgrep
 $valgrind $vjs $pcre2grep -Mo '(\n|[^-])*---' testNinputgrep >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 120 ------------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -HO '$0:$2$1$3' '(\w+) binary (\w+)(\.)?' ./testdata/grepinput) >>testtrygrep
 echo "RC=$?" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -m 1 -O '$0:$a$b$e$f$r$t$v' '(\w+) binary (\w+)(\.)?' ./testdata/grepinput) >>testtrygrep
+echo "RC=$?" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -HO '${X}' '(\w+) binary (\w+)(\.)?' ./testdata/grepinput) >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -HO 'XX$' '(\w+) binary (\w+)(\.)?' ./testdata/grepinput) >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -O '$x{12345678}' '(\w+) binary (\w+)(\.)?' ./testdata/grepinput) >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -O '$x{123Z' '(\w+) binary (\w+)(\.)?' ./testdata/grepinput) >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep --output '$x{1234}' '(\w+) binary (\w+)(\.)?' ./testdata/grepinput) >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 121 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -F '\E and (regex)' testdata/grepinputv) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 122 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -w 'cat|dog' testdata/grepinputv) >>testtrygrep
@@ -642,27 +678,32 @@
 echo "RC=$?" >>testtrygrep
 $valgrind $vjs $pcre2grep --colour=always --allow-lookaround-bsk '(?=.\K)' testNinputgrep >>testtrygrep
 echo "RC=$?" >>testtrygrep
 $valgrind $vjs $pcre2grep --colour=always --allow-lookaround-bsk '(?<=\K[ac])' testNinputgrep >>testtrygrep
 echo "RC=$?" >>testtrygrep
 $valgrind $vjs $pcre2grep --colour=always --allow-lookaround-bsk '(?=[ac]\K)' testNinputgrep >>testtrygrep
 echo "RC=$?" >>testtrygrep
+GREP_COLORS='ms=1;20' $valgrind $vjs $pcre2grep --colour=always --allow-lookaround-bsk '(?=[ac]\K)' testNinputgrep >>testtrygrep
+echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 126 -----------------------------" >>testtrygrep
 printf 'Next line pattern has binary zero\nABC\0XYZ\n' >testtemp1grep
 printf 'ABC\0XYZ\nABCDEF\nDEFABC\n' >testtemp2grep
 $valgrind $vjs $pcre2grep -a -f testtemp1grep testtemp2grep >>testtrygrep
 echo "RC=$?" >>testtrygrep
+printf 'Next line pattern is erroneous.\n^abc)(xy' >testtemp1grep
+$valgrind $vjs $pcre2grep -a -f testtemp1grep testtemp2grep >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 127 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -o --om-capture=0 'pattern()()()()' testdata/grepinput) >>testtrygrep
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 128 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep -o1 --om-capture=0 'pattern()()()()' testdata/grepinput) >>testtrygrep 2>&1
+(cd $srcdir; $valgrind $vjs $pcre2grep -m1M -o1 --om-capture=0 'pattern()()()()' testdata/grepinput) >>testtrygrep 2>&1
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 129 -----------------------------" >>testtrygrep
 (cd $srcdir; $valgrind $vjs $pcre2grep -m 2 'fox' testdata/grepinput) >>testtrygrep 2>&1
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 130 -----------------------------" >>testtrygrep
@@ -678,17 +719,147 @@
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 133 -----------------------------" >>testtrygrep
 (cd $srcdir; exec 3<testdata/grepinput; $valgrind $vjs $pcre2grep -m1 -A3 '^match' <&3; echo '---'; $valgrind $vjs $pcre2grep -m1 -A3 '^match' <&3; exec 3<&-) >>testtrygrep 2>&1
 echo "RC=$?" >>testtrygrep
 
 echo "---------------------------- Test 134 -----------------------------" >>testtrygrep
-(cd $srcdir; $valgrind $vjs $pcre2grep -m1 -O '=$x{41}$x423$o{103}$o1045=' 'fox') <$srcdir/testdata/grepinputv >>testtrygrep 2>&1
+(cd $srcdir; $valgrind $vjs $pcre2grep --max-count=1 -nH -O '=$x{41}$x423$o{103}$o1045=' 'fox' -) <$srcdir/testdata/grepinputv >>testtrygrep 2>&1
 echo "RC=$?" >>testtrygrep
 
+echo "---------------------------- Test 135 -----------------------------" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -HZ 'word' ./testdata/grepinputv) | $tr '\000' '@' >>testtrygrep
+echo "RC=$?" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -lZ 'word' ./testdata/grepinputv ./testdata/grepinputv) | $tr '\000' '@' >>testtrygrep
+echo "RC=$?" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -A 1 -B 1 -HZ 'word' ./testdata/grepinputv) | $tr '\000' '@' >>testtrygrep
+echo "RC=$?" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -MHZn 'start[\s]+end' testdata/grepinputM) >>testtrygrep
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 136 -----------------------------" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep -m1MK -o1 --om-capture=0 'pattern()()()()' testdata/grepinput) >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep --max-count=1MK -o1 --om-capture=0 'pattern()()()()' testdata/grepinput) >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 137 -----------------------------" >>testtrygrep
+printf 'Last line\nhas no newline' >testtemp1grep
+$valgrind $vjs $pcre2grep -A1 Last testtemp1grep >>testtrygrep
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 138 -----------------------------" >>testtrygrep
+printf 'AbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\nAbC\n' >testtemp1grep
+$valgrind $vjs $pcre2grep --no-jit --heap-limit=0 b testtemp1grep >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 139 -----------------------------" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep --line-buffered 'fox' testdata/grepinputv) >>testtrygrep
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 140 -----------------------------" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep --buffer-size=10 -A1 'brown' testdata/grepinputv) >>testtrygrep
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 141 -----------------------------" >>testtrygrep
+printf "$srcdir/testdata/grepinputv\n-\n" >testtemp1grep
+printf 'This is a line from stdin.' >testtemp2grep
+$valgrind $vjs $pcre2grep --file-list testtemp1grep "line from stdin" <testtemp2grep >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 142 -----------------------------" >>testtrygrep
+printf "/does/not/exist\n" >testtemp1grep
+printf 'This is a line from stdin.' >testtemp2grep
+$valgrind $vjs $pcre2grep --file-list testtemp1grep "line from stdin" >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 143 -----------------------------" >>testtrygrep
+printf 'fox|cat' >testtemp1grep
+$valgrind $vjs $pcre2grep -f - $srcdir/testdata/grepinputv <testtemp1grep >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 144 -----------------------------" >>testtrygrep
+$valgrind $vjs $pcre2grep -f /non/exist $srcdir/testdata/grepinputv >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 145 -----------------------------" >>testtrygrep
+printf '*meta*\rdog.' >testtemp1grep
+$valgrind $vjs $pcre2grep -Ncr -F -f testtemp1grep $srcdir/testdata/grepinputv >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 146 -----------------------------" >>testtrygrep
+printf 'A123B' >testtemp1grep
+$valgrind $vjs $pcre2grep -H -e '123|fox' - <testtemp1grep >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep -h -e '123|fox' - $srcdir/testdata/grepinputv <testtemp1grep >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep - $srcdir/testdata/grepinputv <testtemp1grep >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 147 -----------------------------" >>testtrygrep
+$valgrind $vjs $pcre2grep -e '123|fox' -- -nonfile >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 148 -----------------------------" >>testtrygrep
+$valgrind $vjs $pcre2grep --nonexist >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep -n-n-bad >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep --context >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep --only-matching --output=xx >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep --colour=badvalue >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep --newline=badvalue >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep -d badvalue >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep -D badvalue >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep --buffer-size=0 >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep --exclude '(badpat' abc /dev/null >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep --exclude-from /non/exist abc /dev/null >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep --include-from /non/exist abc /dev/null >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+$valgrind $vjs $pcre2grep --file-list=/non/exist abc /dev/null >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+
+echo "---------------------------- Test 149 -----------------------------" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep --binary-files=binary "dog" ./testdata/grepbinary) >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep --binary-files=wrong "dog" ./testdata/grepbinary) >>testtrygrep 2>&1
+echo "RC=$?" >>testtrygrep
+
+# This test runs the code that tests locale support. However, on some systems
+# (e.g. Alpine Linux) there is no locale support and running this test just
+# generates a "no match" result. Therefore, we test for locale support, and if
+# it is found missing, we pretend that the test has run as expected so that the
+# output matches.
+
+echo "---------------------------- Test 150 -----------------------------" >>testtrygrep
+which locale >/dev/null 2>&1
+if [ $? -ne 0 ]; then
+  echo "pcre2grep: Failed to set locale badlocale (obtained from LC_CTYPE)" >>testtrygrep
+  echo "RC=2" >>testtrygrep
+else
+
+  (cd $srcdir; unset LC_ALL; env LC_CTYPE=badlocale $valgrind $vjs $pcre2grep abc /dev/null) >>testtrygrep 2>&1
+  echo "RC=$?" >>testtrygrep
+fi
+
+echo "---------------------------- Test 151 -----------------------------" >>testtrygrep
+(cd $srcdir; $valgrind $vjs $pcre2grep --colour=always -e this -e The -e 'The wo' testdata/grepinputv) >>testtrygrep
+
+
+
+
 # Now compare the results.
 
 $cf $srcdir/testdata/grepoutput testtrygrep
 if [ $? != 0 ] ; then exit 1; fi
 
 
 # These tests require UTF-8 support
@@ -738,88 +909,137 @@
 # starts with a hyphen. These tests are run in the build directory.
 
 echo "Testing pcre2grep newline settings"
 printf 'abc\rdef\r\nghi\njkl' >testNinputgrep
 
 printf '%c--------------------------- Test N1 ------------------------------\r\n' - >testtrygrep
 $valgrind $vjs $pcre2grep -n -N CR "^(abc|def|ghi|jkl)" testNinputgrep >>testtrygrep
+$valgrind $vjs $pcre2grep -B1 -n -N CR "^def" testNinputgrep >>testtrygrep
 
 printf '%c--------------------------- Test N2 ------------------------------\r\n' - >>testtrygrep
 $valgrind $vjs $pcre2grep -n --newline=crlf "^(abc|def|ghi|jkl)" testNinputgrep >>testtrygrep
+$valgrind $vjs $pcre2grep -B1 -n -N CRLF "^ghi" testNinputgrep >>testtrygrep
 
 printf '%c--------------------------- Test N3 ------------------------------\r\n' - >>testtrygrep
 pattern=`printf 'def\rjkl'`
 $valgrind $vjs $pcre2grep -n --newline=cr -F "$pattern" testNinputgrep >>testtrygrep
 
 printf '%c--------------------------- Test N4 ------------------------------\r\n' - >>testtrygrep
 $valgrind $vjs $pcre2grep -n --newline=crlf -F -f $srcdir/testdata/greppatN4 testNinputgrep >>testtrygrep
 
 printf '%c--------------------------- Test N5 ------------------------------\r\n' - >>testtrygrep
 $valgrind $vjs $pcre2grep -n --newline=any "^(abc|def|ghi|jkl)" testNinputgrep >>testtrygrep
+$valgrind $vjs $pcre2grep -B1 -n --newline=any "^def" testNinputgrep >>testtrygrep
 
 printf '%c--------------------------- Test N6 ------------------------------\r\n' - >>testtrygrep
 $valgrind $vjs $pcre2grep -n --newline=anycrlf "^(abc|def|ghi|jkl)" testNinputgrep >>testtrygrep
-
-# This next test involves NUL characters. It seems impossible to handle them
-# easily in many operating systems. An earlier version of this script used sed
-# to translate NUL into the string ZERO, but this didn't work on Solaris (aka
-# SunOS), where the version of sed explicitly doesn't like them, and also MacOS
-# (Darwin), OpenBSD, FreeBSD, NetBSD, and some Linux distributions like Alpine,
-# even when using GNU sed. A user suggested using tr instead, which
-# necessitates translating to a single character (@). However, on (some
-# versions of?) Solaris, the normal "tr" cannot handle binary zeros, but if
-# /usr/xpg4/bin/tr is available, it can do so, so test for that.
-
-if [ -x /usr/xpg4/bin/tr ] ; then
-  tr=/usr/xpg4/bin/tr
-else
-  tr=tr
-fi
+$valgrind $vjs $pcre2grep -B1 -n --newline=anycrlf "^jkl" testNinputgrep >>testtrygrep
 
 printf '%c--------------------------- Test N7 ------------------------------\r\n' - >>testtrygrep
-printf 'abc\0def' >testNinputgrep
+printf 'xyz\0abc\0def' >testNinputgrep
 $valgrind $vjs $pcre2grep -na --newline=nul "^(abc|def)" testNinputgrep | $tr '\000' '@' >>testtrygrep
+$valgrind $vjs $pcre2grep -B1 -na --newline=nul "^(abc|def)" testNinputgrep | $tr '\000' '@' >>testtrygrep
 echo "" >>testtrygrep
 
 $cf $srcdir/testdata/grepoutputN testtrygrep
 if [ $? != 0 ] ; then exit 1; fi
 
+
+# These newline tests need UTF support.
+
+if [ $utf8 -ne 0 ] ; then
+  echo "Testing pcre2grep newline settings with UTF-8 features"
+
+  printf '%c--------------------------- Test UN1 ------------------------------\r\n' - >testtrygrep
+  printf 'abc\341\210\264def\nxyz' >testNinputgrep
+  $valgrind $vjs $pcre2grep -nau --newline=anycrlf "^(abc|def)" testNinputgrep >>testtrygrep
+  echo "" >>testtrygrep
+
+  $cf $srcdir/testdata/grepoutputUN testtrygrep
+  if [ $? != 0 ] ; then exit 1; fi
+else
+  echo "Skipping pcre2grep newline UTF-8 tests: no UTF-8 support in PCRE2 library"
+fi
+
+
 # If pcre2grep supports script callouts, run some tests on them. It is possible
 # to restrict these callouts to the non-fork case, either for security, or for
 # environments that do not support fork(). This is handled by comparing to a
 # different output.
 
 if $valgrind $vjs $pcre2grep --help | $valgrind $vjs $pcre2grep -q 'callout scripts in patterns are supported'; then
   echo "Testing pcre2grep script callouts"
   $valgrind $vjs $pcre2grep '(T)(..(.))(?C"/bin/echo|Arg1: [$1] [$2] [$3]|Arg2: $|${1}$| ($4) ($14) ($0)")()' $srcdir/testdata/grepinputv >testtrygrep
   $valgrind $vjs $pcre2grep '(T)(..(.))()()()()()()()(..)(?C"/bin/echo|Arg1: [$11] [${11}]")' $srcdir/testdata/grepinputv >>testtrygrep
   $valgrind $vjs $pcre2grep '(T)(?C"|$0:$1$n")' $srcdir/testdata/grepinputv >>testtrygrep
+  $valgrind $vjs $pcre2grep '(T)(?C"/bin/echo|$0:$1$n")' $srcdir/testdata/grepinputv >>testtrygrep
   $valgrind $vjs $pcre2grep '(T)(?C"|$1$n")(*F)' $srcdir/testdata/grepinputv >>testtrygrep
   $valgrind $vjs $pcre2grep -m1 '(T)(?C"|$0:$1:$x{41}$o{101}$n")' $srcdir/testdata/grepinputv >>testtrygrep
 
   if $valgrind $vjs $pcre2grep --help | $valgrind $vjs $pcre2grep -q 'Non-fork callout scripts in patterns are supported'; then
+    nonfork=1
     $cf $srcdir/testdata/grepoutputCN testtrygrep
   else
+    nonfork=0
     $cf $srcdir/testdata/grepoutputC testtrygrep
   fi
-
   if [ $? != 0 ] ; then exit 1; fi
+
+  # These callout tests need UTF support.
+
+  if [ $utf8 -ne 0 ] ; then
+    echo "Testing pcre2grep script callout with UTF-8 features"
+    $valgrind $vjs $pcre2grep -u '(T)(?C"|$0:$x{a6}$n")' $srcdir/testdata/grepinputv >testtrygrep
+    $valgrind $vjs $pcre2grep -u '(T)(?C"/bin/echo|$0:$x{a6}$n")' $srcdir/testdata/grepinputv >>testtrygrep
+
+    if [ $nonfork = 1 ] ; then
+      $cf $srcdir/testdata/grepoutputCNU testtrygrep
+    else
+      $cf $srcdir/testdata/grepoutputCU testtrygrep
+    fi
+    if [ $? != 0 ] ; then exit 1; fi
+  fi
 else
   echo "Script callouts are not supported"
 fi
 
+
+# Test reading .gz and .bz2 files when supported.
+
+if $valgrind $vjs $pcre2grep --help | $valgrind $vjs $pcre2grep -q '\.gz are read using zlib'; then
+  echo "Testing reading .gz file"
+  $valgrind $vjs $pcre2grep 'one|two' $srcdir/testdata/grepinputC.gz >testtrygrep
+  echo "RC=$?" >>testtrygrep
+  $cf $srcdir/testdata/grepoutputCgz testtrygrep
+  if [ $? != 0 ] ; then exit 1; fi
+fi
+
+if $valgrind $vjs $pcre2grep --help | $valgrind $vjs $pcre2grep -q '\.bz2 are read using bzlib2'; then
+  echo "Testing reading .bz2 file"
+  $valgrind $vjs $pcre2grep 'one|two' $srcdir/testdata/grepinputC.bz2 >testtrygrep
+  echo "RC=$?" >>testtrygrep
+  $valgrind $vjs $pcre2grep 'one|two' $srcdir/testdata/grepnot.bz2 >>testtrygrep
+  echo "RC=$?" >>testtrygrep
+  $cf $srcdir/testdata/grepoutputCbz2 testtrygrep
+  if [ $? != 0 ] ; then exit 1; fi
+fi
+
+
 # Finally, some tests to exercise code that is not tested above, just to be
 # sure that it runs OK. Doing this improves the coverage statistics. The output
 # is not checked.
 
 echo "Testing miscellaneous pcre2grep arguments (unchecked)"
 echo '' >testtrygrep
 checkspecial '-xxxxx' 2
 checkspecial '--help' 0
 checkspecial '--line-buffered --colour=auto abc /dev/null' 1
+checkspecial '--line-buffered --color abc /dev/null' 1
+checkspecial '-dskip abc .' 1
+checkspecial '-Dread -Dskip abc /dev/null' 1
 
 # Clean up local working files
 rm -f testNinputgrep teststderrgrep testtrygrep testtemp1grep testtemp2grep
 
 exit 0
 
 # End
```

### Comparing `pcre2-0.1.0/src/libpcre2/RunGrepTest.bat` & `pcre2-0.2.0/src/libpcre2/RunGrepTest.bat`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/RunTest` & `pcre2-0.2.0/src/libpcre2/RunTest`

 * *Files 2% similar despite different names*

```diff
@@ -13,16 +13,24 @@
 # possible to select which to test by giving "-8", "-16" or "-32" on the
 # command line.
 #
 # As well as "-nojit", "-8", "-16", and "-32", arguments for this script are
 # individual test numbers, ranges of tests such as 3-6 or 3- (meaning 3 to the
 # end), or a number preceded by ~ to exclude a test. For example, "3-15 ~10"
 # runs tests 3 to 15, excluding test 10, and just "~10" runs all the tests
-# except test 10. Whatever order the arguments are in, the tests are always run
-# in numerical order.
+# except test 10. Whatever order the arguments are in, these tests are always
+# run in numerical order.
+#
+# If no specific tests are selected (which is the case when this script is run
+# via 'make check') the default is to run all the numbered tests.
+#
+# There may also be named (as well as numbered) tests for special purposes. At
+# present there is just one, called "heap". This test's output contains the
+# sizes of heap frames and frame vectors, which depend on the environment. It
+# is therefore not run unless explicitly requested.
 #
 # Inappropriate tests are automatically skipped (with a comment to say so). For
 # example, if JIT support is not compiled, test 16 is skipped, whereas if JIT
 # support is compiled, test 15 is skipped.
 #
 # Other arguments can be one of the words "-valgrind", "-valgrind-log", or
 # "-sim" followed by an argument to run cross-compiled executables under a
@@ -78,14 +86,15 @@
 title21="Test 21: \C tests without UTF (supported for DFA matching)"
 title22="Test 22: \C tests with UTF (not supported for DFA matching)"
 title23="Test 23: \C disabled test"
 title24="Test 24: Non-UTF pattern conversion tests"
 title25="Test 25: UTF pattern conversion tests"
 title26="Test 26: Auto-generated unicode property tests"
 maxtest=26
+titleheap="Test 'heap': Environment-specific heap tests"
 
 if [ $# -eq 1 -a "$1" = "list" ]; then
   echo $title0
   echo $title1
   echo $title2 "(not UTF or UCP)"
   echo $title3
   echo $title4A $title4B
@@ -107,14 +116,19 @@
   echo $title20
   echo $title21
   echo $title22
   echo $title23
   echo $title24
   echo $title25
   echo $title26
+  echo ""
+  echo $titleheap
+  echo ""
+  echo "Numbered tests are automatically run if nothing selected."
+  echo "Named tests must be explicitly selected."
   exit 0
 fi
 
 # Set up a suitable "diff" command for comparison. Some systems
 # have a diff that lacks a -u option. Try to deal with this.
 
 cf="diff"
@@ -237,14 +251,15 @@
 do20=no
 do21=no
 do22=no
 do23=no
 do24=no
 do25=no
 do26=no
+doheap=no
 
 while [ $# -gt 0 ] ; do
   case $1 in
     0) do0=yes;;
     1) do1=yes;;
     2) do2=yes;;
     3) do3=yes;;
@@ -267,14 +282,15 @@
    20) do20=yes;;
    21) do21=yes;;
    22) do22=yes;;
    23) do23=yes;;
    24) do24=yes;;
    25) do25=yes;;
    26) do26=yes;;
+ heap) doheap=yes;;
    -8) arg8=yes;;
   -16) arg16=yes;;
   -32) arg32=yes;;
    bigstack|-bigstack) bigstack=yes;;
    nojit|-nojit) nojit=yes;;
    sim|-sim) shift; sim=$1;;
    valgrind|-valgrind) valgrind="valgrind --tool=memcheck -q --smc-check=all-non-file";;
@@ -408,24 +424,24 @@
 if [ $jit -ne 0 -a "$nojit" != "yes" ] ; then
   jitopt=-jit
   if [ "$valgrind" != "" ] ; then
     vjs="--suppressions=$testdata/valgrind-jit.supp"
   fi
 fi
 
-# If no specific tests were requested, select all. Those that are not
-# relevant will be automatically skipped.
+# If no specific tests were requested, select all the numbered tests. Those
+# that are not relevant will be automatically skipped.
 
 if [ $do0  = no -a $do1  = no -a $do2  = no -a $do3  = no -a \
      $do4  = no -a $do5  = no -a $do6  = no -a $do7  = no -a \
      $do8  = no -a $do9  = no -a $do10 = no -a $do11 = no -a \
      $do12 = no -a $do13 = no -a $do14 = no -a $do15 = no -a \
      $do16 = no -a $do17 = no -a $do18 = no -a $do19 = no -a \
      $do20 = no -a $do21 = no -a $do22 = no -a $do23 = no -a \
-     $do24 = no -a $do25 = no -a $do26 = no \
+     $do24 = no -a $do25 = no -a $do26 = no -a $doheap = no \
    ]; then
   do0=yes
   do1=yes
   do2=yes
   do3=yes
   do4=yes
   do5=yes
@@ -636,15 +652,15 @@
       checkresult $? 7 ""
     fi
   fi
 
   # Test of internal offsets and code sizes. This test is run only when there
   # is UTF/UCP support. The actual tests are mostly the same as in some of the
   # above, but in this test we inspect some offsets and sizes. This is a
-  # doublecheck for the maintainer, just in case something changes unexpectely.
+  # doublecheck for the maintainer, just in case something changes unexpectedly.
   # The output from this test is different in 8-bit, 16-bit, and 32-bit modes
   # and for different link sizes, so there are different output files for each
   # mode and link size.
 
   if [ $do8 = yes ] ; then
     echo $title8
     if [ $utf -eq 0 ] ; then
@@ -878,14 +894,23 @@
       for opt in "" $jitopt; do
         $sim $valgrind ${opt:+$vjs} ./pcre2test -q $setstack $bmode $opt $testdata/testinput26 testtry
         checkresult $? 26 "$opt"
       done
     fi
   fi
 
+  # Manually selected heap tests - output may vary in different environments,
+  # which is why that are not automatically run.
+
+  if [ $doheap = yes ] ; then
+    echo $titleheap
+    $sim $valgrind ./pcre2test -q $setstack $bmode $testdata/testinputheap testtry
+    checkresult $? heap-$bits ""
+  fi
+
 # End of loop for 8/16/32-bit tests
 done
 
 # Clean up local working files
 rm -f testbtables testSinput test3input testsaved1 testsaved2 test3output test3outputA test3outputB teststdout teststderr testtry
 
 # End
```

### Comparing `pcre2-0.1.0/src/libpcre2/RunTest.bat` & `pcre2-0.2.0/src/libpcre2/RunTest.bat`

 * *Files 0% similar despite different names*

```diff
@@ -131,17 +131,17 @@
   set do3=yes
   set do4=yes
   set do5=yes
   set do6=yes
   set do7=yes
   set do8=yes
   set do9=yes
-  set do10=yes
+  set do10=no
   set do11=yes
-  set do12=yes
+  set do12=no
   set do13=yes
   set do14=yes
   set do15=yes
   set do16=yes
   set do17=yes
   set do18=yes
   set do19=yes
```

### Comparing `pcre2-0.1.0/src/libpcre2/autogen.sh` & `pcre2-0.2.0/src/libpcre2/autogen.sh`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/cmake/COPYING-CMAKE-SCRIPTS` & `pcre2-0.2.0/src/libpcre2/cmake/COPYING-CMAKE-SCRIPTS`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/cmake/FindEditline.cmake` & `pcre2-0.2.0/src/libpcre2/cmake/FindEditline.cmake`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/cmake/FindPackageHandleStandardArgs.cmake` & `pcre2-0.2.0/src/libpcre2/cmake/FindPackageHandleStandardArgs.cmake`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/cmake/FindReadline.cmake` & `pcre2-0.2.0/src/libpcre2/cmake/FindReadline.cmake`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/cmake/pcre2-config-version.cmake.in` & `pcre2-0.2.0/src/libpcre2/cmake/pcre2-config-version.cmake.in`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/cmake/pcre2-config.cmake.in` & `pcre2-0.2.0/src/libpcre2/cmake/pcre2-config.cmake.in`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/config-cmake.h.in` & `pcre2-0.2.0/src/libpcre2/config-cmake.h.in`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/configure.ac` & `pcre2-0.2.0/src/libpcre2/configure.ac`

 * *Files 0% similar despite different names*

```diff
@@ -5,23 +5,23 @@
 dnl if a PCRE2 user writes code that uses PCRE2_MINOR as a number. There is now
 dnl a check further down that throws an error if 08 or 09 are used.
 
 dnl The PCRE2_PRERELEASE feature is for identifying release candidates. It might
 dnl be defined as -RC2, for example. For real releases, it should be empty.
 
 m4_define(pcre2_major, [10])
-m4_define(pcre2_minor, [40])
+m4_define(pcre2_minor, [42])
 m4_define(pcre2_prerelease, [])
-m4_define(pcre2_date, [2022-04-14])
+m4_define(pcre2_date, [2022-12-11])
 
 # Libtool shared library interface versions (current:revision:age)
-m4_define(libpcre2_8_version,     [11:0:11])
-m4_define(libpcre2_16_version,    [11:0:11])
-m4_define(libpcre2_32_version,    [11:0:11])
-m4_define(libpcre2_posix_version, [3:2:0])
+m4_define(libpcre2_8_version,     [11:2:11])
+m4_define(libpcre2_16_version,    [11:2:11])
+m4_define(libpcre2_32_version,    [11:2:11])
+m4_define(libpcre2_posix_version, [3:4:0])
 
 # NOTE: The CMakeLists.txt file searches for the above variables in the first
 # 50 lines of this file. Please update that if the variables above are moved.
 
 AC_PREREQ([2.60])
 AC_INIT([PCRE2],pcre2_major.pcre2_minor[]pcre2_prerelease,[],[pcre2])
 AC_CONFIG_SRCDIR([src/pcre2.h.in])
@@ -63,14 +63,16 @@
 # Check for a 64-bit integer type
 AC_TYPE_INT64_T
 
 AC_PROG_INSTALL
 LT_INIT([win32-dll])
 AC_PROG_LN_S
 
+AC_SYS_LARGEFILE
+
 # Check for GCC visibility feature
 
 PCRE2_VISIBILITY
 
 # Check for Clang __attribute__((uninitialized)) feature
 
 AC_MSG_CHECKING([for __attribute__((uninitialized))])
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/NON-AUTOTOOLS-BUILD.txt` & `pcre2-0.2.0/src/libpcre2/doc/html/NON-AUTOTOOLS-BUILD.txt`

 * *Files 1% similar despite different names*

```diff
@@ -65,15 +65,15 @@
      configure/make world, this is handled automatically.) When upgrading to a
      new release, you are strongly advised to review src/config.h.generic
      before re-using what you had previously.
 
      Note also that the src/config.h.generic file is created from a config.h
      that was generated by Autotools, which automatically includes settings of
      a number of macros that are not actually used by PCRE2 (for example,
-     HAVE_MEMORY_H).
+     HAVE_DLFCN_H).
 
  (2) Copy or rename the file src/pcre2.h.generic as src/pcre2.h.
 
  (3) EITHER:
        Copy or rename file src/pcre2_chartables.c.dist as
        src/pcre2_chartables.c.
 
@@ -117,29 +117,30 @@
        pcre2_serialize.c
        pcre2_string_utils.c
        pcre2_study.c
        pcre2_substitute.c
        pcre2_substring.c
        pcre2_tables.c
        pcre2_ucd.c
+       pcre2_ucptables.c
        pcre2_valid_utf.c
        pcre2_xclass.c
 
      Make sure that you include -I. in the compiler command (or equivalent for
      an unusual compiler) so that all included PCRE2 header files are first
      sought in the src directory under the current directory. Otherwise you run
      the risk of picking up a previously-installed file from somewhere else.
 
      Note that you must compile pcre2_jit_compile.c, even if you have not
      defined SUPPORT_JIT in src/config.h, because when JIT support is not
      configured, dummy functions are compiled. When JIT support IS configured,
      pcre2_jit_compile.c #includes other files from the sljit subdirectory,
      all of whose names begin with "sljit". It also #includes
      src/pcre2_jit_match.c and src/pcre2_jit_misc.c, so you should not compile
-     these yourself.
+     those yourself.
 
      Note also that the pcre2_fuzzsupport.c file contains special code that is
      useful to those who want to run fuzzing tests on the PCRE2 library. Unless
      you are doing that, you can ignore it.
 
  (5) Now link all the compiled code into an object library in whichever form
      your system keeps such libraries. This is the basic PCRE2 C 8-bit library.
@@ -181,15 +182,19 @@
      system uses a different convention.
 
 (10) If you have built PCRE2 with SUPPORT_JIT, the JIT features can be tested
      by running pcre2test with the -jit option. This is done automatically by
      the RunTest script. You might also like to build and run the freestanding
      JIT test program, src/pcre2_jit_test.c.
 
-(11) If you want to use the pcre2grep command, compile and link
+(11) The pcre2test program tests the POSIX wrapper library, but there is also a
+     freestanding test program in src/pcre2posix_test.c. It must be linked with
+     both the pcre2posix library and the 8-bit PCRE2 library.
+
+(12) If you want to use the pcre2grep command, compile and link
      src/pcre2grep.c; it uses only the basic 8-bit PCRE2 library (it does not
      need the pcre2posix library). If you have built the PCRE2 library with JIT
      support by defining SUPPORT_JIT in src/config.h, you can also define
      SUPPORT_PCRE2GREP_JIT, which causes pcre2grep to make use of JIT (unless
      it is run with --no-jit). If you define SUPPORT_PCRE2GREP_JIT without
      defining SUPPORT_JIT, pcre2grep does not try to make use of JIT.
 
@@ -302,15 +307,15 @@
     directory such as C:\pcre2. You should ensure your local date and time
     is not earlier than the file dates in your source dir if the release is
     very new.
 
 3.  Create a new, empty build directory, preferably a subdirectory of the
     source dir. For example, C:\pcre2\pcre2-xx\build.
 
-4.  Run cmake-gui from the Shell envirornment of your build tool, for example,
+4.  Run cmake-gui from the Shell environment of your build tool, for example,
     Msys for Msys/MinGW or Visual Studio Command Prompt for VC/VC++. Do not try
     to start Cmake from the Windows Start menu, as this can lead to errors.
 
 5.  Enter C:\pcre2\pcre2-xx and C:\pcre2\pcre2-xx\build for the source and
     build directories, respectively.
 
 6.  Hit the "Configure" button.
@@ -369,15 +374,15 @@
 To run only a particular test with RunTest.Bat provide a test number argument.
 
 Otherwise:
 
 1. Copy RunTest.bat into the directory where pcre2test.exe and pcre2grep.exe
    have been created.
 
-2. Edit RunTest.bat to indentify the full or relative location of
+2. Edit RunTest.bat to identify the full or relative location of
    the pcre2 source (wherein which the testdata folder resides), e.g.:
 
    set srcdir=C:\pcre2\pcre2-10.00
 
 3. In a Windows command environment, chdir to the location of your bat and
    exe programs.
 
@@ -401,10 +406,10 @@
 
   http://www.cbttape.org
 
 Everything in that location, source and executable, is in EBCDIC and native
 z/OS file formats. The port provides an API for LE languages such as COBOL and
 for the z/OS and z/VM versions of the Rexx languages.
 
-===========================
-Last Updated: 28 April 2021
-===========================
+==============================
+Last Updated: 10 December 2022
+==============================
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/README.txt` & `pcre2-0.2.0/src/libpcre2/doc/html/README.txt`

 * *Files 1% similar despite different names*

```diff
@@ -4,24 +4,24 @@
 PCRE2 is a re-working of the original PCRE1 library to provide an entirely new
 API. Since its initial release in 2015, there has been further development of
 the code and it now differs from PCRE1 in more than just the API. There are new
 features, and the internals have been improved. The original PCRE1 library is
 now obsolete and no longer maintained. The latest release of PCRE2 is available
 in .tar.gz, tar.bz2, or .zip form from this GitHub repository:
 
-https://github.com/PhilipHazel/pcre2/releases
+https://github.com/PCRE2Project/pcre2/releases
 
 There is a mailing list for discussion about the development of PCRE2 at
 pcre2-dev@googlegroups.com. You can subscribe by sending an email to
 pcre2-dev+subscribe@googlegroups.com.
 
 You can access the archives and also subscribe or manage your subscription
 here:
 
-https://groups.google.com/pcre2-dev
+https://groups.google.com/g/pcre2-dev
 
 Please read the NEWS file if you are upgrading from a previous release. The
 contents of this README file are:
 
   The PCRE2 APIs
   Documentation for PCRE2
   Contributions by users of PCRE2
@@ -371,18 +371,18 @@
   Enabling libreadline causes the -lreadline option to be added to the
   pcre2test build. In many operating environments with a sytem-installed
   readline library this is sufficient. However, in some environments (e.g. if
   an unmodified distribution version of readline is in use), it may be
   necessary to specify something like LIBS="-lncurses" as well. This is
   because, to quote the readline INSTALL, "Readline uses the termcap functions,
   but does not link with the termcap or curses library itself, allowing
-  applications which link with readline the to choose an appropriate library."
-  If you get error messages about missing functions tgetstr, tgetent, tputs,
-  tgetflag, or tgoto, this is the problem, and linking with the ncurses library
-  should fix it.
+  applications which link with readline the option to choose an appropriate
+  library." If you get error messages about missing functions tgetstr, tgetent,
+  tputs, tgetflag, or tgoto, this is the problem, and linking with the ncurses
+  library should fix it.
 
 . The C99 standard defines formatting modifiers z and t for size_t and
   ptrdiff_t values, respectively. By default, PCRE2 uses these modifiers in
   environments other than Microsoft Visual Studio versions earlier than 2013
   when __STDC_VERSION__ is defined and has a value greater than or equal to
   199901L (indicating C99). However, there is at least one environment that
   claims to be C99 but does not support these modifiers. If
@@ -396,25 +396,25 @@
   LLVMFuzzerTestOneInput() whose arguments are a pointer to a string and the
   length of the string. When called, this function tries to compile the string
   as a pattern, and if that succeeds, to match it. This is done both with no
   options and with some random options bits that are generated from the string.
   Setting --enable-fuzz-support also causes a binary called pcre2fuzzcheck to
   be created. This is normally run under valgrind or used when PCRE2 is
   compiled with address sanitizing enabled. It calls the fuzzing function and
-  outputs information about it is doing. The input strings are specified by
-  arguments: if an argument starts with "=" the rest of it is a literal input
-  string. Otherwise, it is assumed to be a file name, and the contents of the
-  file are the test string.
+  outputs information about what it is doing. The input strings are specified
+  by arguments: if an argument starts with "=" the rest of it is a literal
+  input string. Otherwise, it is assumed to be a file name, and the contents
+  of the file are the test string.
 
 . Releases before 10.30 could be compiled with --disable-stack-for-recursion,
   which caused pcre2_match() to use individual blocks on the heap for
   backtracking instead of recursive function calls (which use the stack). This
-  is now obsolete since pcre2_match() was refactored always to use the heap (in
-  a much more efficient way than before). This option is retained for backwards
-  compatibility, but has no effect other than to output a warning.
+  is now obsolete because pcre2_match() was refactored always to use the heap
+  (in a much more efficient way than before). This option is retained for
+  backwards compatibility, but has no effect other than to output a warning.
 
 The "configure" script builds the following files for the basic C library:
 
 . Makefile             the makefile that builds the library
 . src/config.h         build-time configuration options for the library
 . src/pcre2.h          the public PCRE2 header file
 . pcre2-config         script that shows the building settings such as CFLAGS
@@ -434,16 +434,17 @@
 script that can be run to recreate the configuration, and config.log, which
 contains compiler output from tests that "configure" runs.
 
 Once "configure" has run, you can run "make". This builds whichever of the
 libraries libpcre2-8, libpcre2-16 and libpcre2-32 are configured, and a test
 program called pcre2test. If you enabled JIT support with --enable-jit, another
 test program called pcre2_jit_test is built as well. If the 8-bit library is
-built, libpcre2-posix and the pcre2grep command are also built. Running
-"make" with the -j option may speed up compilation on multiprocessor systems.
+built, libpcre2-posix, pcre2posix_test, and the pcre2grep command are also
+built. Running "make" with the -j option may speed up compilation on
+multiprocessor systems.
 
 The command "make check" runs all the appropriate tests. Details of the PCRE2
 tests are given below in a separate section of this document. The -j option of
 "make" can also be used when running the tests.
 
 You can use "make install" to install PCRE2 into live directories on your
 system. The following are installed (file names are all relative to the
@@ -587,17 +588,19 @@
 
 
 Testing PCRE2
 -------------
 
 To test the basic PCRE2 library on a Unix-like system, run the RunTest script.
 There is another script called RunGrepTest that tests the pcre2grep command.
-When JIT support is enabled, a third test program called pcre2_jit_test is
-built. Both the scripts and all the program tests are run if you obey "make
-check". For other environments, see the instructions in NON-AUTOTOOLS-BUILD.
+When the 8-bit library is built, a test program for the POSIX wrapper, called
+pcre2posix_test, is compiled, and when JIT support is enabled, a test program
+called pcre2_jit_test is built. The scripts and the program tests are all run
+when you obey "make check". For other environments, see the instructions in
+NON-AUTOTOOLS-BUILD.
 
 The RunTest script runs the pcre2test test program (which is documented in its
 own man page) on each of the relevant testinput files in the testdata
 directory, and compares the output with the contents of the corresponding
 testoutput files. RunTest uses a file called testtry to hold the main output
 from pcre2test. Other files whose names begin with "test" are used as working
 files in some tests.
@@ -691,15 +694,15 @@
 Test 13 checks the handling of non-UTF characters greater than 255 by
 pcre2_dfa_match() in 16-bit and 32-bit modes.
 
 Test 14 contains some special UTF and UCP tests that give different output for
 different code unit widths.
 
 Test 15 contains a number of tests that must not be run with JIT. They check,
-among other non-JIT things, the match-limiting features of the intepretive
+among other non-JIT things, the match-limiting features of the interpretive
 matcher.
 
 Test 16 is run only when JIT support is not available. It checks that an
 attempt to use JIT has the expected behaviour.
 
 Test 17 is run only when JIT support is available. It checks JIT complete and
 partial modes, match-limiting under JIT, and other JIT-specific features.
@@ -712,14 +715,17 @@
 
 Tests 21 and 22 test \C support when the use of \C is not locked out, without
 and with UTF support, respectively. Test 23 tests \C when it is locked out.
 
 Tests 24 and 25 test the experimental pattern conversion functions, without and
 with UTF support, respectively.
 
+Test 26 checks Unicode property support using tests that are generated
+automatically from the Unicode data tables.
+
 
 Character tables
 ----------------
 
 For speed, PCRE2 uses four tables for manipulating and identifying characters
 whose code point values are less than 256. By default, a set of tables that is
 built into the library is used. The pcre2_maketables() function can be called
@@ -815,35 +821,39 @@
   src/pcre2_serialize.c    )
   src/pcre2_string_utils.c )
   src/pcre2_study.c        )
   src/pcre2_substitute.c   )
   src/pcre2_substring.c    )
   src/pcre2_tables.c       )
   src/pcre2_ucd.c          )
+  src/pcre2_ucptables.c    )
   src/pcre2_valid_utf.c    )
   src/pcre2_xclass.c       )
 
   src/pcre2_printint.c     debugging function that is used by pcre2test,
   src/pcre2_fuzzsupport.c  function for (optional) fuzzing support
 
   src/config.h.in          template for config.h, when built by "configure"
   src/pcre2.h.in           template for pcre2.h when built by "configure"
   src/pcre2posix.h         header for the external POSIX wrapper API
   src/pcre2_internal.h     header for internal use
   src/pcre2_intmodedep.h   a mode-specific internal header
+  src/pcre2_jit_neon_inc.h header used by JIT
+  src/pcre2_jit_simd_inc.h header used by JIT
   src/pcre2_ucp.h          header for Unicode property handling
 
   sljit/*                  source files for the JIT compiler
 
 (B) Source files for programs that use PCRE2:
 
   src/pcre2demo.c          simple demonstration of coding calls to PCRE2
   src/pcre2grep.c          source of a grep utility that uses PCRE2
   src/pcre2test.c          comprehensive test program
   src/pcre2_jit_test.c     JIT test program
+  src/pcre2posix_test.c    POSIX wrapper API test program
 
 (C) Auxiliary files:
 
   132html                  script to turn "man" pages into HTML
   AUTHORS                  information about the author of PCRE2
   ChangeLog                log of changes to the code
   CleanTxt                 script to clean nroff output for txt man pages
@@ -907,8 +917,8 @@
                           )   for use in non-"configure" environments
   src/config.h.generic    ) a version of config.h for use in non-"configure"
                           )   environments
 
 Philip Hazel
 Email local part: Philip.Hazel
 Email domain: gmail.com
-Last updated: 15 April 2022
+Last updated: 10 December 2022
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/index.html` & `pcre2-0.2.0/src/libpcre2/doc/html/index.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2-config.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2-config.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_callout_enumerate.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_callout_enumerate.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_code_copy.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_code_copy.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_code_copy_with_tables.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_code_copy_with_tables.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_code_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_code_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_compile.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_compile.html`

 * *Files 14% similar despite different names*

```diff
@@ -88,16 +88,26 @@
 </P>
 <P>
 Additional options may be set in the compile context via the
 <a href="pcre2_set_compile_extra_options.html"><b>pcre2_set_compile_extra_options</b></a>
 function.
 </P>
 <P>
-The yield of this function is a pointer to a private data structure that
-contains the compiled pattern, or NULL if an error was detected.
+If either of <i>errorcode</i> or <i>erroroffset</i> is NULL, the function returns
+NULL immediately. Otherwise, the yield of this function is a pointer to a
+private data structure that contains the compiled pattern, or NULL if an error
+was detected. In the error case, a text error message can be obtained by
+passing the value returned via the <i>errorcode</i> argument to the the
+<b>pcre2_get_error_message()</b> function. The offset (in code units) where the
+error was encountered is returned via the <i>erroroffset</i> argument.
+</P>
+<P>
+If there is no error, the value passed via <i>errorcode</i> returns the message
+"no error" if passed to <b>pcre2_get_error_message()</b>, and the value passed
+via <i>erroroffset</i> is zero.
 </P>
 <P>
 There is a complete description of the PCRE2 native API, with more detail on
 each option, in the
 <a href="pcre2api.html"><b>pcre2api</b></a>
 page, and a description of the POSIX API in the
 <a href="pcre2posix.html"><b>pcre2posix</b></a>
```

#### html2text {}

```diff
@@ -61,13 +61,21 @@
   PCRE2_UNGREEDY           Invert greediness of quantifiers
   PCRE2_USE_OFFSET_LIMIT   Enable offset limit for unanchored matching
   PCRE2_UTF                Treat pattern and subjects as UTF strings
 PCRE2 must be built with Unicode support (the default) in order to use
 PCRE2_UTF, PCRE2_UCP and related options.
 Additional options may be set in the compile context via the
 pcre2_set_compile_extra_options function.
-The yield of this function is a pointer to a private data structure that
-contains the compiled pattern, or NULL if an error was detected.
+If either of errorcode or erroroffset is NULL, the function returns NULL
+immediately. Otherwise, the yield of this function is a pointer to a private
+data structure that contains the compiled pattern, or NULL if an error was
+detected. In the error case, a text error message can be obtained by passing
+the value returned via the errorcode argument to the the
+pcre2_get_error_message() function. The offset (in code units) where the error
+was encountered is returned via the erroroffset argument.
+If there is no error, the value passed via errorcode returns the message "no
+error" if passed to pcre2_get_error_message(), and the value passed via
+erroroffset is zero.
 There is a complete description of the PCRE2 native API, with more detail on
 each option, in the pcre2api page, and a description of the POSIX API in the
 pcre2posix page.
 Return to the PCRE2_index_page.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_compile_context_copy.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_compile_context_copy.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_compile_context_create.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_compile_context_create.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_compile_context_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_compile_context_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_config.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_config.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_convert_context_copy.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_convert_context_copy.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_convert_context_create.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_convert_context_create.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_convert_context_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_convert_context_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_converted_pattern_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_converted_pattern_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_dfa_match.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_dfa_match.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_general_context_copy.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_general_context_copy.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_general_context_create.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_general_context_create.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_general_context_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_general_context_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_error_message.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_error_message.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_mark.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_mark.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_match_data_size.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_match_data_size.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_ovector_count.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_ovector_count.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_ovector_pointer.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_ovector_pointer.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_get_startchar.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_get_startchar.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_compile.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_compile.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_free_unused_memory.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_free_unused_memory.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_match.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_match.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_stack_assign.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_stack_assign.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_stack_create.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_stack_create.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_jit_stack_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_jit_stack_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_maketables.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_maketables.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_maketables_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_maketables_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_context_copy.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_context_copy.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_context_create.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_context_create.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_context_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_context_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_data_create.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_data_create.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_data_create_from_pattern.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_data_create_from_pattern.html`

 * *Files 12% similar despite different names*

```diff
@@ -29,15 +29,15 @@
 This function creates a new match data block for holding the result of a match.
 The first argument points to a compiled pattern. The number of capturing
 parentheses within the pattern is used to compute the number of pairs of
 offsets that are required in the match data block. These form the "output
 vector" (ovector) within the match data block, and are used to identify the
 matched string and any captured substrings when matching with
 <b>pcre2_match()</b>. If you are using <b>pcre2_dfa_match()</b>, which uses the
-outut vector in a different way, you should use <b>pcre2_match_data_create()</b>
+output vector in a different way, you should use <b>pcre2_match_data_create()</b>
 instead of this function.
 </P>
 <P>
 The second argument points to a general context, for custom memory management,
 or is NULL to use the same memory allocator as was used for the compiled
 pattern. The result of the function is NULL if the memory for the block could
 not be obtained.
```

#### html2text {}

```diff
@@ -12,15 +12,15 @@
 DESCRIPTION
 This function creates a new match data block for holding the result of a match.
 The first argument points to a compiled pattern. The number of capturing
 parentheses within the pattern is used to compute the number of pairs of
 offsets that are required in the match data block. These form the "output
 vector" (ovector) within the match data block, and are used to identify the
 matched string and any captured substrings when matching with pcre2_match(). If
-you are using pcre2_dfa_match(), which uses the outut vector in a different
+you are using pcre2_dfa_match(), which uses the output vector in a different
 way, you should use pcre2_match_data_create() instead of this function.
 The second argument points to a general context, for custom memory management,
 or is NULL to use the same memory allocator as was used for the compiled
 pattern. The result of the function is NULL if the memory for the block could
 not be obtained.
 There is a complete description of the PCRE2 native API in the pcre2api page
 and a description of the POSIX API in the pcre2posix page.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_match_data_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_match_data_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_pattern_convert.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_pattern_convert.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_pattern_info.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_pattern_info.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_serialize_decode.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_serialize_decode.html`

 * *Files 5% similar despite different names*

```diff
@@ -44,15 +44,15 @@
 data than slots in the list, only those compiled patterns that will fit are
 decoded. The yield of the function is the number of decoded patterns, or one of
 the following negative error codes:
 <pre>
   PCRE2_ERROR_BADDATA   <i>number_of_codes</i> is zero or less
   PCRE2_ERROR_BADMAGIC  mismatch of id bytes in <i>bytes</i>
   PCRE2_ERROR_BADMODE   mismatch of variable unit size or PCRE version
-  PCRE2_ERROR_MEMORY    memory allocation failed
+  PCRE2_ERROR_NOMEMORY  memory allocation failed
   PCRE2_ERROR_NULL      <i>codes</i> or <i>bytes</i> is NULL
 </pre>
 PCRE2_ERROR_BADMAGIC may mean that the data is corrupt, or that it was compiled
 on a system with different endianness.
 </P>
 <P>
 There is a complete description of the PCRE2 native API in the
```

#### html2text {}

```diff
@@ -24,14 +24,14 @@
 the meantime. If there are more codes in the serialized data than slots in the
 list, only those compiled patterns that will fit are decoded. The yield of the
 function is the number of decoded patterns, or one of the following negative
 error codes:
   PCRE2_ERROR_BADDATA   number_of_codes is zero or less
   PCRE2_ERROR_BADMAGIC  mismatch of id bytes in bytes
   PCRE2_ERROR_BADMODE   mismatch of variable unit size or PCRE version
-  PCRE2_ERROR_MEMORY    memory allocation failed
+  PCRE2_ERROR_NOMEMORY  memory allocation failed
   PCRE2_ERROR_NULL      codes or bytes is NULL
 PCRE2_ERROR_BADMAGIC may mean that the data is corrupt, or that it was compiled
 on a system with different endianness.
 There is a complete description of the PCRE2 native API in the pcre2api page
 and a description of the serialization functions in the pcre2serialize page.
 Return to the PCRE2_index_page.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_serialize_encode.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_serialize_encode.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_serialize_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_serialize_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_serialize_get_number_of_codes.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_serialize_get_number_of_codes.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_bsr.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_bsr.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_callout.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_callout.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_character_tables.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_character_tables.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_compile_extra_options.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_compile_extra_options.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_compile_recursion_guard.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_compile_recursion_guard.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_depth_limit.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_depth_limit.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_glob_escape.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_glob_escape.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_glob_separator.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_glob_separator.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_heap_limit.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_heap_limit.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_match_limit.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_match_limit.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_max_pattern_length.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_max_pattern_length.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_newline.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_newline.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_offset_limit.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_offset_limit.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_parens_nest_limit.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_parens_nest_limit.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_recursion_limit.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_recursion_limit.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_recursion_memory_management.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_recursion_memory_management.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_set_substitute_callout.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_set_substitute_callout.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substitute.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substitute.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_copy_byname.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_copy_byname.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_copy_bynumber.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_copy_bynumber.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_get_byname.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_get_byname.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_get_bynumber.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_get_bynumber.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_length_byname.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_length_byname.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_length_bynumber.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_length_bynumber.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_list_free.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_list_free.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_list_get.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_list_get.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_nametable_scan.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_nametable_scan.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2_substring_number_from_name.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2_substring_number_from_name.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2api.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2api.html`

 * *Files 0% similar despite different names*

```diff
@@ -1013,40 +1013,38 @@
 patterns with a lot of nested pattern recursion or lookarounds or atomic
 groups. This limit does not apply to matching with the JIT optimization, which
 has its own memory control arrangements (see the
 <a href="pcre2jit.html"><b>pcre2jit</b></a>
 documentation for more details). If the limit is reached, the negative error
 code PCRE2_ERROR_HEAPLIMIT is returned. The default limit can be set when PCRE2
 is built; if it is not, the default is set very large and is essentially
-"unlimited".
+unlimited.
 </P>
 <P>
 A value for the heap limit may also be supplied by an item at the start of a
 pattern of the form
 <pre>
   (*LIMIT_HEAP=ddd)
 </pre>
 where ddd is a decimal number. However, such a setting is ignored unless ddd is
 less than the limit set by the caller of <b>pcre2_match()</b> or, if no such
 limit is set, less than the default.
 </P>
 <P>
-The <b>pcre2_match()</b> function starts out using a 20KiB vector on the system
-stack for recording backtracking points. The more nested backtracking points
-there are (that is, the deeper the search tree), the more memory is needed.
-Heap memory is used only if the initial vector is too small. If the heap limit
-is set to a value less than 21 (in particular, zero) no heap memory will be
-used. In this case, only patterns that do not have a lot of nested backtracking
-can be successfully processed.
+The <b>pcre2_match()</b> function always needs some heap memory, so setting a
+value of zero guarantees a "heap limit exceeded" error. Details of how
+<b>pcre2_match()</b> uses the heap are given in the
+<a href="pcre2perform.html"><b>pcre2perform</b></a>
+documentation.
 </P>
 <P>
-Similarly, for <b>pcre2_dfa_match()</b>, a vector on the system stack is used
-when processing pattern recursions, lookarounds, or atomic groups, and only if
-this is not big enough is heap memory used. In this case, too, setting a value
-of zero disables the use of the heap.
+For <b>pcre2_dfa_match()</b>, a vector on the system stack is used when
+processing pattern recursions, lookarounds, or atomic groups, and only if this
+is not big enough is heap memory used. In this case, setting a value of zero
+disables the use of the heap.
 <br>
 <br>
 <b>int pcre2_set_match_limit(pcre2_match_context *<i>mcontext</i>,</b>
 <b>  uint32_t <i>value</i>);</b>
 <br>
 <br>
 The <i>match_limit</i> parameter provides a means of preventing PCRE2 from using
@@ -1085,18 +1083,18 @@
 <br>
 <br>
 <b>int pcre2_set_depth_limit(pcre2_match_context *<i>mcontext</i>,</b>
 <b>  uint32_t <i>value</i>);</b>
 <br>
 <br>
 This parameter limits the depth of nested backtracking in <b>pcre2_match()</b>.
-Each time a nested backtracking point is passed, a new memory "frame" is used
+Each time a nested backtracking point is passed, a new memory frame is used
 to remember the state of matching at that point. Thus, this parameter
 indirectly limits the amount of memory that is used in a match. However,
-because the size of each memory "frame" depends on the number of capturing
+because the size of each memory frame depends on the number of capturing
 parentheses, the actual memory limit varies from pattern to pattern. This limit
 was more useful in versions before 10.30, where function recursion was used for
 backtracking.
 </P>
 <P>
 The depth limit is not relevant, and is ignored, when matching is done using
 JIT compiled code. However, it is supported by <b>pcre2_dfa_match()</b>, which
@@ -1379,39 +1377,41 @@
 <a href="#compilecontext">above).</a>
 </P>
 <P>
 If <i>errorcode</i> or <i>erroroffset</i> is NULL, <b>pcre2_compile()</b> returns
 NULL immediately. Otherwise, the variables to which these point are set to an
 error code and an offset (number of code units) within the pattern,
 respectively, when <b>pcre2_compile()</b> returns NULL because a compilation
-error has occurred. The values are not defined when compilation is successful
-and <b>pcre2_compile()</b> returns a non-NULL value.
+error has occurred.
 </P>
 <P>
 There are nearly 100 positive error codes that <b>pcre2_compile()</b> may return
 if it finds an error in the pattern. There are also some negative error codes
 that are used for invalid UTF strings when validity checking is in force. These
 are the same as given by <b>pcre2_match()</b> and <b>pcre2_dfa_match()</b>, and
 are described in the
 <a href="pcre2unicode.html"><b>pcre2unicode</b></a>
 documentation. There is no separate documentation for the positive error codes,
 because the textual error messages that are obtained by calling the
 <b>pcre2_get_error_message()</b> function (see "Obtaining a textual error
 message"
 <a href="#geterrormessage">below)</a>
 should be self-explanatory. Macro names starting with PCRE2_ERROR_ are defined
-for both positive and negative error codes in <b>pcre2.h</b>.
+for both positive and negative error codes in <b>pcre2.h</b>. When compilation
+is successful <i>errorcode</i> is set to a value that returns the message "no
+error" if passed to <b>pcre2_get_error_message()</b>.
 </P>
 <P>
 The value returned in <i>erroroffset</i> is an indication of where in the
-pattern the error occurred. It is not necessarily the furthest point in the
-pattern that was read. For example, after the error "lookbehind assertion is
-not fixed length", the error offset points to the start of the failing
-assertion. For an invalid UTF-8 or UTF-16 string, the offset is that of the
-first code unit of the failing character.
+pattern an error occurred. When there is no error, zero is returned. A non-zero
+value is not necessarily the furthest point in the pattern that was read. For
+example, after the error "lookbehind assertion is not fixed length", the error
+offset points to the start of the failing assertion. For an invalid UTF-8 or
+UTF-16 string, the offset is that of the first code unit of the failing
+character.
 </P>
 <P>
 Some errors are not detected until the whole pattern has been scanned; in these
 cases, the offset passed back is the length of the pattern. Note that the
 offset is in code units, not characters, even in a UTF mode. It may sometimes
 point into the middle of a UTF-8 or UTF-16 character.
 </P>
@@ -2539,15 +2539,17 @@
 different lengths at the same point in the subject. The ovector should be made
 large enough to hold as many as are expected.
 </P>
 <P>
 A minimum of at least 1 pair is imposed by <b>pcre2_match_data_create()</b>, so
 it is always possible to return the overall matched string in the case of
 <b>pcre2_match()</b> or the longest match in the case of
-<b>pcre2_dfa_match()</b>.
+<b>pcre2_dfa_match()</b>. The maximum number of pairs is 65535; if the the first
+argument of <b>pcre2_match_data_create()</b> is greater than this, 65535 is
+used.
 </P>
 <P>
 The second argument of <b>pcre2_match_data_create()</b> is a pointer to a
 general context, which can specify custom memory management for obtaining the
 memory for the match data block. If you are not using custom memory management,
 pass NULL, which causes <b>malloc()</b> to be used.
 </P>
@@ -3142,19 +3144,19 @@
 <pre>
   PCRE2_ERROR_MATCHLIMIT
 </pre>
 The backtracking match limit was reached.
 <pre>
   PCRE2_ERROR_NOMEMORY
 </pre>
-If a pattern contains many nested backtracking points, heap memory is used to
-remember them. This error is given when the memory allocation function (default
-or custom) fails. Note that a different error, PCRE2_ERROR_HEAPLIMIT, is given
-if the amount of memory needed exceeds the heap limit. PCRE2_ERROR_NOMEMORY is
-also returned if PCRE2_COPY_MATCHED_SUBJECT is set and memory allocation fails.
+Heap memory is used to remember backgracking points. This error is given when
+the memory allocation function (default or custom) fails. Note that a different
+error, PCRE2_ERROR_HEAPLIMIT, is given if the amount of memory needed exceeds
+the heap limit. PCRE2_ERROR_NOMEMORY is also returned if
+PCRE2_COPY_MATCHED_SUBJECT is set and memory allocation fails.
 <pre>
   PCRE2_ERROR_NULL
 </pre>
 Either the <i>code</i>, <i>subject</i>, or <i>match_data</i> argument was passed
 as NULL.
 <pre>
   PCRE2_ERROR_RECURSELOOP
@@ -4014,14 +4016,14 @@
 Retired from University Computing Service
 <br>
 Cambridge, England.
 <br>
 </P>
 <br><a name="SEC42" href="#TOC1">REVISION</a><br>
 <P>
-Last updated: 14 December 2021
+Last updated: 27 July 2022
 <br>
-Copyright &copy; 1997-2021 University of Cambridge.
+Copyright &copy; 1997-2022 University of Cambridge.
 <br>
 <p>
 Return to the <a href="index.html">PCRE2 index page</a>.
 </p>
```

#### html2text {}

```diff
@@ -718,32 +718,28 @@
 information when running an interpretive match. This limit also applies to
 pcre2_dfa_match(), which may use the heap when processing patterns with a lot
 of nested pattern recursion or lookarounds or atomic groups. This limit does
 not apply to matching with the JIT optimization, which has its own memory
 control arrangements (see the pcre2jit documentation for more details). If the
 limit is reached, the negative error code PCRE2_ERROR_HEAPLIMIT is returned.
 The default limit can be set when PCRE2 is built; if it is not, the default is
-set very large and is essentially "unlimited".
+set very large and is essentially unlimited.
 A value for the heap limit may also be supplied by an item at the start of a
 pattern of the form
   (*LIMIT_HEAP=ddd)
 where ddd is a decimal number. However, such a setting is ignored unless ddd is
 less than the limit set by the caller of pcre2_match() or, if no such limit is
 set, less than the default.
-The pcre2_match() function starts out using a 20KiB vector on the system stack
-for recording backtracking points. The more nested backtracking points there
-are (that is, the deeper the search tree), the more memory is needed. Heap
-memory is used only if the initial vector is too small. If the heap limit is
-set to a value less than 21 (in particular, zero) no heap memory will be used.
-In this case, only patterns that do not have a lot of nested backtracking can
-be successfully processed.
-Similarly, for pcre2_dfa_match(), a vector on the system stack is used when
-processing pattern recursions, lookarounds, or atomic groups, and only if this
-is not big enough is heap memory used. In this case, too, setting a value of
-zero disables the use of the heap.
+The pcre2_match() function always needs some heap memory, so setting a value of
+zero guarantees a "heap limit exceeded" error. Details of how pcre2_match()
+uses the heap are given in the pcre2perform documentation.
+For pcre2_dfa_match(), a vector on the system stack is used when processing
+pattern recursions, lookarounds, or atomic groups, and only if this is not big
+enough is heap memory used. In this case, setting a value of zero disables the
+use of the heap.
 
 int pcre2_set_match_limit(pcre2_match_context *mcontext, uint32_t value);
 
 The match_limit parameter provides a means of preventing PCRE2 from using up
 too many computing resources when processing patterns that are not going to
 match, but which have a very large number of possibilities in their search
 trees. The classic example is a pattern that uses nested unlimited repeats.
@@ -767,20 +763,20 @@
 where ddd is a decimal number. However, such a setting is ignored unless ddd is
 less than the limit set by the caller of pcre2_match() or pcre2_dfa_match() or,
 if no such limit is set, less than the default.
 
 int pcre2_set_depth_limit(pcre2_match_context *mcontext, uint32_t value);
 
 This parameter limits the depth of nested backtracking in pcre2_match(). Each
-time a nested backtracking point is passed, a new memory "frame" is used to
+time a nested backtracking point is passed, a new memory frame is used to
 remember the state of matching at that point. Thus, this parameter indirectly
 limits the amount of memory that is used in a match. However, because the size
-of each memory "frame" depends on the number of capturing parentheses, the
-actual memory limit varies from pattern to pattern. This limit was more useful
-in versions before 10.30, where function recursion was used for backtracking.
+of each memory frame depends on the number of capturing parentheses, the actual
+memory limit varies from pattern to pattern. This limit was more useful in
+versions before 10.30, where function recursion was used for backtracking.
 The depth limit is not relevant, and is ignored, when matching is done using
 JIT compiled code. However, it is supported by pcre2_dfa_match(), which uses it
 to limit the depth of nested internal recursive function calls that implement
 atomic groups, lookaround assertions, and pattern recursions. This limits,
 indirectly, the amount of system stack that is used. It was more useful in
 versions before 10.32, when stack memory was used for local workspace vectors
 for recursive function calls. From version 10.32, only local variables are
@@ -972,32 +968,32 @@
 options can be set at the time of matching as well as at compile time.
 Some additional options and less frequently required compile-time parameters
 (for example, the newline setting) can be provided in a compile context (as
 described above).
 If errorcode or erroroffset is NULL, pcre2_compile() returns NULL immediately.
 Otherwise, the variables to which these point are set to an error code and an
 offset (number of code units) within the pattern, respectively, when
-pcre2_compile() returns NULL because a compilation error has occurred. The
-values are not defined when compilation is successful and pcre2_compile()
-returns a non-NULL value.
+pcre2_compile() returns NULL because a compilation error has occurred.
 There are nearly 100 positive error codes that pcre2_compile() may return if it
 finds an error in the pattern. There are also some negative error codes that
 are used for invalid UTF strings when validity checking is in force. These are
 the same as given by pcre2_match() and pcre2_dfa_match(), and are described in
 the pcre2unicode documentation. There is no separate documentation for the
 positive error codes, because the textual error messages that are obtained by
 calling the pcre2_get_error_message() function (see "Obtaining a textual error
 message" below) should be self-explanatory. Macro names starting with
 PCRE2_ERROR_ are defined for both positive and negative error codes in pcre2.h.
-The value returned in erroroffset is an indication of where in the pattern the
-error occurred. It is not necessarily the furthest point in the pattern that
-was read. For example, after the error "lookbehind assertion is not fixed
-length", the error offset points to the start of the failing assertion. For an
-invalid UTF-8 or UTF-16 string, the offset is that of the first code unit of
-the failing character.
+When compilation is successful errorcode is set to a value that returns the
+message "no error" if passed to pcre2_get_error_message().
+The value returned in erroroffset is an indication of where in the pattern an
+error occurred. When there is no error, zero is returned. A non-zero value is
+not necessarily the furthest point in the pattern that was read. For example,
+after the error "lookbehind assertion is not fixed length", the error offset
+points to the start of the failing assertion. For an invalid UTF-8 or UTF-16
+string, the offset is that of the first code unit of the failing character.
 Some errors are not detected until the whole pattern has been scanned; in these
 cases, the offset passed back is the length of the pattern. Note that the
 offset is in code units, not characters, even in a UTF mode. It may sometimes
 point into the middle of a UTF-8 or UTF-16 character.
 This code fragment shows a typical straightforward call to pcre2_compile():
   pcre2_code *re;
   PCRE2_SIZE erroffset;
@@ -1818,15 +1814,17 @@
 captured substring. For example, a value of 4 creates enough space to record
 the matched portion of the subject plus three captured substrings.
 When using pcre2_dfa_match() there may be multiple matched substrings of
 different lengths at the same point in the subject. The ovector should be made
 large enough to hold as many as are expected.
 A minimum of at least 1 pair is imposed by pcre2_match_data_create(), so it is
 always possible to return the overall matched string in the case of pcre2_match
-() or the longest match in the case of pcre2_dfa_match().
+() or the longest match in the case of pcre2_dfa_match(). The maximum number of
+pairs is 65535; if the the first argument of pcre2_match_data_create() is
+greater than this, 65535 is used.
 The second argument of pcre2_match_data_create() is a pointer to a general
 context, which can specify custom memory management for obtaining the memory
 for the match data block. If you are not using custom memory management, pass
 NULL, which causes malloc() to be used.
 For pcre2_match_data_create_from_pattern(), the first argument is a pointer to
 a compiled pattern. The ovector is created to be exactly the right size to hold
 all the substrings a pattern might capture when matched using pcre2_match().
@@ -2225,19 +2223,19 @@
   PCRE2_ERROR_JIT_STACKLIMIT
 This error is returned when a pattern that was successfully studied using JIT
 is being matched, but the memory available for the just-in-time processing
 stack is not large enough. See the pcre2jit documentation for more details.
   PCRE2_ERROR_MATCHLIMIT
 The backtracking match limit was reached.
   PCRE2_ERROR_NOMEMORY
-If a pattern contains many nested backtracking points, heap memory is used to
-remember them. This error is given when the memory allocation function (default
-or custom) fails. Note that a different error, PCRE2_ERROR_HEAPLIMIT, is given
-if the amount of memory needed exceeds the heap limit. PCRE2_ERROR_NOMEMORY is
-also returned if PCRE2_COPY_MATCHED_SUBJECT is set and memory allocation fails.
+Heap memory is used to remember backgracking points. This error is given when
+the memory allocation function (default or custom) fails. Note that a different
+error, PCRE2_ERROR_HEAPLIMIT, is given if the amount of memory needed exceeds
+the heap limit. PCRE2_ERROR_NOMEMORY is also returned if
+PCRE2_COPY_MATCHED_SUBJECT is set and memory allocation fails.
   PCRE2_ERROR_NULL
 Either the code, subject, or match_data argument was passed as NULL.
   PCRE2_ERROR_RECURSELOOP
 This error is returned when pcre2_match() detects a recursion loop within the
 pattern. Specifically, it means that either the whole pattern or a capture
 group has been called recursively for the second time at the same position in
 the subject string. Some simple patterns that might do this are detected and
@@ -2830,10 +2828,10 @@
 
 AUTHOR
 Philip Hazel
 Retired from University Computing Service
 Cambridge, England.
 
 REVISION
-Last updated: 14 December 2021
-Copyright  1997-2021 University of Cambridge.
+Last updated: 27 July 2022
+Copyright  1997-2022 University of Cambridge.
 Return to the PCRE2_index_page.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2build.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2build.html`

 * *Files 1% similar despite different names*

```diff
@@ -280,20 +280,19 @@
   --with-match-limit=500000
 </pre>
 to the <b>configure</b> command. This setting also applies to the
 <b>pcre2_dfa_match()</b> matching function, and to JIT matching (though the
 counting is done differently).
 </P>
 <P>
-The <b>pcre2_match()</b> function starts out using a 20KiB vector on the system
-stack to record backtracking points. The more nested backtracking points there
-are (that is, the deeper the search tree), the more memory is needed. If the
-initial vector is not large enough, heap memory is used, up to a certain limit,
-which is specified in kibibytes (units of 1024 bytes). The limit can be changed
-at run time, as described in the
+The <b>pcre2_match()</b> function uses heap memory to record backtracking
+points. The more nested backtracking points there are (that is, the deeper the
+search tree), the more memory is needed. There is an upper limit, specified in
+kibibytes (units of 1024 bytes). This limit can be changed at run time, as
+described in the
 <a href="pcre2api.html"><b>pcre2api</b></a>
 documentation. The default limit (in effect unlimited) is 20 million. You can
 change this by a setting such as
 <pre>
   --with-heap-limit=500
 </pre>
 which limits the amount of heap to 500 KiB. This limit applies only to
@@ -605,21 +604,21 @@
 <P>
 <b>pcre2api</b>(3), <b>pcre2-config</b>(3).
 </P>
 <br><a name="SEC25" href="#TOC1">AUTHOR</a><br>
 <P>
 Philip Hazel
 <br>
-University Computing Service
+Retired from University Computing Service
 <br>
 Cambridge, England.
 <br>
 </P>
 <br><a name="SEC26" href="#TOC1">REVISION</a><br>
 <P>
-Last updated: 08 December 2021
+Last updated: 27 July 2022
 <br>
-Copyright &copy; 1997-2021 University of Cambridge.
+Copyright &copy; 1997-2022 University of Cambridge.
 <br>
 <p>
 Return to the <a href="index.html">PCRE2 index page</a>.
 </p>
```

#### html2text {}

```diff
@@ -194,21 +194,20 @@
 resource used by a single call to pcre2_match(). The limit can be changed at
 run time, as described in the pcre2api documentation. The default is 10
 million, but this can be changed by adding a setting such as
   --with-match-limit=500000
 to the configure command. This setting also applies to the pcre2_dfa_match()
 matching function, and to JIT matching (though the counting is done
 differently).
-The pcre2_match() function starts out using a 20KiB vector on the system stack
-to record backtracking points. The more nested backtracking points there are
-(that is, the deeper the search tree), the more memory is needed. If the
-initial vector is not large enough, heap memory is used, up to a certain limit,
-which is specified in kibibytes (units of 1024 bytes). The limit can be changed
-at run time, as described in the pcre2api documentation. The default limit (in
-effect unlimited) is 20 million. You can change this by a setting such as
+The pcre2_match() function uses heap memory to record backtracking points. The
+more nested backtracking points there are (that is, the deeper the search
+tree), the more memory is needed. There is an upper limit, specified in
+kibibytes (units of 1024 bytes). This limit can be changed at run time, as
+described in the pcre2api documentation. The default limit (in effect
+unlimited) is 20 million. You can change this by a setting such as
   --with-heap-limit=500
 which limits the amount of heap to 500 KiB. This limit applies only to
 interpretive matching in pcre2_match() and pcre2_dfa_match(), which may also
 use the heap for internal workspace when processing complicated patterns. This
 limit does not apply when JIT (which has its own memory arrangements) is used.
 You can also explicitly limit the depth of nested backtracking in the
 pcre2_match() interpreter. This limit defaults to the value that is set for --
@@ -422,14 +421,14 @@
 give a warning.
 
 SEE_ALSO
 pcre2api(3), pcre2-config(3).
 
 AUTHOR
 Philip Hazel
-University Computing Service
+Retired from University Computing Service
 Cambridge, England.
 
 REVISION
-Last updated: 08 December 2021
-Copyright  1997-2021 University of Cambridge.
+Last updated: 27 July 2022
+Copyright  1997-2022 University of Cambridge.
 Return to the PCRE2_index_page.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2callout.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2callout.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2compat.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2compat.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2convert.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2convert.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2demo.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2demo.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2grep.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2grep.html`

 * *Files 3% similar despite different names*

```diff
@@ -67,21 +67,23 @@
 <P>
 If no files are specified, <b>pcre2grep</b> reads the standard input. The
 standard input can also be referenced by a name consisting of a single hyphen.
 For example:
 <pre>
   pcre2grep some-pattern file1 - file3
 </pre>
-Input files are searched line by line. By default, each line that matches a
+By default, input files are searched line by line. Each line that matches a
 pattern is copied to the standard output, and if there is more than one file,
 the file name is output at the start of each line, followed by a colon.
-However, there are options that can change how <b>pcre2grep</b> behaves. In
-particular, the <b>-M</b> option makes it possible to search for strings that
-span line boundaries. What defines a line boundary is controlled by the
-<b>-N</b> (<b>--newline</b>) option.
+However, there are options that can change how <b>pcre2grep</b> behaves. For
+example, the <b>-M</b> option makes it possible to search for strings that span
+line boundaries. What defines a line boundary is controlled by the <b>-N</b>
+(<b>--newline</b>) option. The <b>-h</b> and <b>-H</b> options control whether or
+not file names are shown, and the <b>-Z</b> option changes the file name
+terminator to a zero byte.
 </P>
 <P>
 The amount of memory used for buffering files that are being scanned is
 controlled by parameters that can be set by the <b>--buffer-size</b> and
 <b>--max-buffer-size</b> options. The first of these sets the size of buffer
 that is obtained at the start of processing. If an input file contains very
 long lines, a larger buffer may be needed; this is handled by automatically
@@ -102,27 +104,32 @@
 (specified by the use of <b>-e</b> and/or <b>-f</b>), each pattern is applied to
 each line in the order in which they are defined, except that all the <b>-e</b>
 patterns are tried before the <b>-f</b> patterns.
 </P>
 <P>
 By default, as soon as one pattern matches a line, no further patterns are
 considered. However, if <b>--colour</b> (or <b>--color</b>) is used to colour the
-matching substrings, or if <b>--only-matching</b>, <b>--file-offsets</b>, or
-<b>--line-offsets</b> is used to output only the part of the line that matched
-(either shown literally, or as an offset), scanning resumes immediately
-following the match, so that further matches on the same line can be found. If
-there are multiple patterns, they are all tried on the remainder of the line,
-but patterns that follow the one that matched are not tried on the earlier
-matched part of the line.
-</P>
-<P>
-This behaviour means that the order in which multiple patterns are specified
-can affect the output when one of the above options is used. This is no longer
-the same behaviour as GNU grep, which now manages to display earlier matches
-for later patterns (as long as there is no overlap).
+matching substrings, or if <b>--only-matching</b>, <b>--file-offsets</b>,
+<b>--line-offsets</b>, or <b>--output</b> is used to output only the part of the
+line that matched (either shown literally, or as an offset), the behaviour is
+different. In this situation, all the patterns are applied to the line. If
+there is more than one match, the one that begins nearest to the start of the
+subject is processed; if there is more than one match at that position, the one
+with the longest matching substring is processed; if the matching substrings
+are equal, the first match found is processed.
+</P>
+<P>
+Scanning with all the patterns resumes immediately following the match, so that
+later matches on the same line can be found. Note, however, that an overlapping
+match that starts in the middle of another match will not be processed.
+</P>
+<P>
+The above behaviour was changed at release 10.41 to be more compatible with GNU
+grep. In earlier releases, <b>pcre2grep</b> did not recognize matches from
+later patterns that were earlier in the subject.
 </P>
 <P>
 Patterns that can match an empty string are accepted, but empty string
 matches are never recognized. An example is the pattern "(super)?(man)?", in
 which all components are optional. This pattern finds all occurrences of both
 "super" and "man"; the output differs from matching with "super|man" when only
 the matching substrings are being shown.
@@ -130,22 +137,23 @@
 <P>
 If the <b>LC_ALL</b> or <b>LC_CTYPE</b> environment variable is set,
 <b>pcre2grep</b> uses the value to set a locale when calling the PCRE2 library.
 The <b>--locale</b> option can be used to override this.
 </P>
 <br><a name="SEC3" href="#TOC1">SUPPORT FOR COMPRESSED FILES</a><br>
 <P>
-It is possible to compile <b>pcre2grep</b> so that it uses <b>libz</b> or
-<b>libbz2</b> to read compressed files whose names end in <b>.gz</b> or
+Compile-time options for <b>pcre2grep</b> can set it up to use <b>libz</b> or
+<b>libbz2</b> for reading compressed files whose names end in <b>.gz</b> or
 <b>.bz2</b>, respectively. You can find out whether your <b>pcre2grep</b> binary
 has support for one or both of these file types by running it with the
 <b>--help</b> option. If the appropriate support is not present, all files are
-treated as plain text. The standard input is always so treated. When input is
-from a compressed .gz or .bz2 file, the <b>--line-buffered</b> option is
-ignored.
+treated as plain text. The standard input is always so treated. If a file with
+a <b>.gz</b> or <b>.bz2</b> extension is not in fact compressed, it is read as a
+plain text file. When input is from a compressed .gz or .bz2 file, the
+<b>--line-buffered</b> option is ignored.
 </P>
 <br><a name="SEC4" href="#TOC1">BINARY FILES</a><br>
 <P>
 By default, a file that contains a binary zero byte within the first 1024 bytes
 is identified as a binary file, and is processed specially. However, if the
 newline type is specified as NUL, that is, the line terminator is a binary
 zero, the test for a binary file is not applied. See the <b>--binary-files</b>
@@ -174,17 +182,19 @@
 </P>
 <P>
 <b>-A</b> <i>number</i>, <b>--after-context=</b><i>number</i>
 Output up to <i>number</i> lines of context after each matching line. Fewer
 lines are output if the next match or the end of the file is reached, or if the
 processing buffer size has been set too small. If file names and/or line
 numbers are being output, a hyphen separator is used instead of a colon for the
-context lines. A line containing "--" is output between each group of lines,
-unless they are in fact contiguous in the input file. The value of <i>number</i>
-is expected to be relatively small. When <b>-c</b> is used, <b>-A</b> is ignored.
+context lines (the <b>-Z</b> option can be used to change the file name
+terminator to a zero byte). A line containing "--" is output between each group
+of lines, unless they are in fact contiguous in the input file. The value of
+<i>number</i> is expected to be relatively small. When <b>-c</b> is used,
+<b>-A</b> is ignored.
 </P>
 <P>
 <b>-a</b>, <b>--text</b>
 Treat binary files as text. This is equivalent to
 <b>--binary-files</b>=<i>text</i>.
 </P>
 <P>
@@ -195,17 +205,18 @@
 </P>
 <P>
 <b>-B</b> <i>number</i>, <b>--before-context=</b><i>number</i>
 Output up to <i>number</i> lines of context before each matching line. Fewer
 lines are output if the previous match or the start of the file is within
 <i>number</i> lines, or if the processing buffer size has been set too small. If
 file names and/or line numbers are being output, a hyphen separator is used
-instead of a colon for the context lines. A line containing "--" is output
-between each group of lines, unless they are in fact contiguous in the input
-file. The value of <i>number</i> is expected to be relatively small. When
+instead of a colon for the context lines (the <b>-Z</b> option can be used to
+change the file name terminator to a zero byte). A line containing "--" is
+output between each group of lines, unless they are in fact contiguous in the
+input file. The value of <i>number</i> is expected to be relatively small. When
 <b>-c</b> is used, <b>-B</b> is ignored.
 </P>
 <P>
 <b>--binary-files=</b><i>word</i>
 Specify how binary files are to be processed. If the word is "binary" (the
 default), pattern matching is performed on binary files, but the only output is
 "Binary file &#60;name&#62; matches" when a match succeeds. If the word is "text",
@@ -250,20 +261,22 @@
 If this option is given without any data, it is equivalent to "--colour=auto".
 If data is required, it must be given in the same shell item, separated by an
 equals sign.
 </P>
 <P>
 <b>--colour=</b><i>value</i>, <b>--color=</b><i>value</i>
 This option specifies under what circumstances the parts of a line that matched
-a pattern should be coloured in the output. By default, the output is not
-coloured. The value (which is optional, see above) may be "never", "always", or
-"auto". In the latter case, colouring happens only if the standard output is
-connected to a terminal. More resources are used when colouring is enabled,
-because <b>pcre2grep</b> has to search for all possible matches in a line, not
-just one, in order to colour them all.
+a pattern should be coloured in the output. It is ignored if
+<b>--file-offsets</b>, <b>--line-offsets</b>, or <b>--output</b> is set. By
+default, output is not coloured. The value for the <b>--colour</b> option (which
+is optional, see above) may be "never", "always", or "auto". In the latter
+case, colouring happens only if the standard output is connected to a terminal.
+More resources are used when colouring is enabled, because <b>pcre2grep</b> has
+to search for all possible matches in a line, not just one, in order to colour
+them all.
 <br>
 <br>
 The colour that is used can be specified by setting one of the environment
 variables PCRE2GREP_COLOUR, PCRE2GREP_COLOR, PCREGREP_COLOUR, or
 PCREGREP_COLOR, which are checked in that order. If none of these are set,
 <b>pcre2grep</b> looks for GREP_COLORS or GREP_COLOR (in that order). The value
 of the variable should be a string of two numbers, separated by a semicolon,
@@ -303,26 +316,20 @@
 <P>
 <b>-e</b> <i>pattern</i>, <b>--regex=</b><i>pattern</i>, <b>--regexp=</b><i>pattern</i>
 Specify a pattern to be matched. This option can be used multiple times in
 order to specify several patterns. It can also be used as a way of specifying a
 single pattern that starts with a hyphen. When <b>-e</b> is used, no argument
 pattern is taken from the command line; all arguments are treated as file
 names. There is no limit to the number of patterns. They are applied to each
-line in the order in which they are defined until one matches.
+line in the order in which they are defined.
 <br>
 <br>
 If <b>-f</b> is used with <b>-e</b>, the command line patterns are matched first,
 followed by the patterns from the file(s), independent of the order in which
-these options are specified. Note that multiple use of <b>-e</b> is not the same
-as a single pattern with alternatives. For example, X|Y finds the first
-character in a line that is X or Y, whereas if the two patterns are given
-separately, with X first, <b>pcre2grep</b> finds X if it is present, even if it
-follows Y in the line. It finds Y only if there is no X in the line. This
-matters only if you are using <b>-o</b> or <b>--colo(u)r</b> to show the part(s)
-of the line that matched.
+these options are specified.
 </P>
 <P>
 <b>--exclude</b>=<i>pattern</i>
 Files (but not directories) whose names match the pattern are skipped without
 being processed. This applies to all files, whether listed on the command line,
 obtained from <b>--file-list</b>, or by scanning a directory. The pattern is a
 PCRE2 regular expression, and is matched against the final component of the
@@ -363,31 +370,28 @@
 strings are found in it (subject to <b>-w</b> or <b>-x</b>, if present). This
 option applies only to the patterns that are matched against the contents of
 files; it does not apply to patterns specified by any of the <b>--include</b> or
 <b>--exclude</b> options.
 </P>
 <P>
 <b>-f</b> <i>filename</i>, <b>--file=</b><i>filename</i>
-Read patterns from the file, one per line, and match them against each line of
-input. As is the case with patterns on the command line, no delimiters should
-be used. What constitutes a newline when reading the file is the operating
-system's default interpretation of \n. The <b>--newline</b> option has no
-effect on this option. Trailing white space is removed from each line, and
-blank lines are ignored. An empty file contains no patterns and therefore
-matches nothing. Patterns read from a file in this way may contain binary
-zeros, which are treated as ordinary data characters. See also the comments
-about multiple patterns versus a single pattern with alternatives in the
-description of <b>-e</b> above.
+Read patterns from the file, one per line. As is the case with patterns on the
+command line, no delimiters should be used. What constitutes a newline when
+reading the file is the operating system's default interpretation of \n. The
+<b>--newline</b> option has no effect on this option. Trailing white space is
+removed from each line, and blank lines are ignored. An empty file contains no
+patterns and therefore matches nothing. Patterns read from a file in this way
+may contain binary zeros, which are treated as ordinary data characters.
 <br>
 <br>
 If this option is given more than once, all the specified files are read. A
 data line is output if any of the patterns match it. A file name can be given
 as "-" to refer to the standard input. When <b>-f</b> is used, patterns
 specified on the command line using <b>-e</b> may also be present; they are
-tested before the file's patterns. However, no other pattern is taken from the
+matched before the file's patterns. However, no pattern is taken from the
 command line; all arguments are treated as the names of paths to be searched.
 </P>
 <P>
 <b>--file-list</b>=<i>filename</i>
 Read a list of files and/or directories that are to be scanned from the given
 file, one per line. What constitutes a newline when reading the file is the
 operating system's default. Trailing white space is removed from each line, and
@@ -399,36 +403,38 @@
 end-of-file indication. If this option is given more than once, all the
 specified files are read.
 </P>
 <P>
 <b>--file-offsets</b>
 Instead of showing lines or parts of lines that match, show each match as an
 offset from the start of the file and a length, separated by a comma. In this
-mode, no context is shown. That is, the <b>-A</b>, <b>-B</b>, and <b>-C</b>
-options are ignored. If there is more than one match in a line, each of them is
-shown separately. This option is mutually exclusive with <b>--output</b>,
-<b>--line-offsets</b>, and <b>--only-matching</b>.
+mode, <b>--colour</b> has no effect, and no context is shown. That is, the
+<b>-A</b>, <b>-B</b>, and <b>-C</b> options are ignored. If there is more than one
+match in a line, each of them is shown separately. This option is mutually
+exclusive with <b>--output</b>, <b>--line-offsets</b>, and <b>--only-matching</b>.
 </P>
 <P>
 <b>-H</b>, <b>--with-filename</b>
 Force the inclusion of the file name at the start of output lines when
-searching a single file. By default, the file name is not shown in this case.
-For matching lines, the file name is followed by a colon; for context lines, a
-hyphen separator is used. If a line number is also being output, it follows the
-file name. When the <b>-M</b> option causes a pattern to match more than one
-line, only the first is preceded by the file name. This option overrides any
-previous <b>-h</b>, <b>-l</b>, or <b>-L</b> options.
+searching a single file. The file name is not normally shown in this case.
+By default, for matching lines, the file name is followed by a colon; for
+context lines, a hyphen separator is used. The <b>-Z</b> option can be used to
+change the terminator to a zero byte. If a line number is also being output,
+it follows the file name. When the <b>-M</b> option causes a pattern to match
+more than one line, only the first is preceded by the file name. This option
+overrides any previous <b>-h</b>, <b>-l</b>, or <b>-L</b> options.
 </P>
 <P>
 <b>-h</b>, <b>--no-filename</b>
-Suppress the output file names when searching multiple files. By default,
-file names are shown when multiple files are searched. For matching lines, the
-file name is followed by a colon; for context lines, a hyphen separator is used.
-If a line number is also being output, it follows the file name. This option
-overrides any previous <b>-H</b>, <b>-L</b>, or <b>-l</b> options.
+Suppress the output file names when searching multiple files. File names are
+normally shown when multiple files are searched. By default, for matching
+lines, the file name is followed by a colon; for context lines, a hyphen
+separator is used. The <b>-Z</b> option can be used to change the terminator to
+a zero byte. If a line number is also being output, it follows the file name.
+This option overrides any previous <b>-H</b>, <b>-L</b>, or <b>-l</b> options.
 </P>
 <P>
 <b>--heap-limit</b>=<i>number</i>
 See <b>--match-limit</b> below.
 </P>
 <P>
 <b>--help</b>
@@ -477,26 +483,28 @@
 given any number of times. If a directory matches both <b>--include-dir</b> and
 <b>--exclude-dir</b>, it is excluded. There is no short form for this option.
 </P>
 <P>
 <b>-L</b>, <b>--files-without-match</b>
 Instead of outputting lines from the files, just output the names of the files
 that do not contain any lines that would have been output. Each file name is
-output once, on a separate line. This option overrides any previous <b>-H</b>,
-<b>-h</b>, or <b>-l</b> options.
+output once, on a separate line by default, but if the <b>-Z</b> option is set,
+they are separated by zero bytes instead of newlines. This option overrides any
+previous <b>-H</b>, <b>-h</b>, or <b>-l</b> options.
 </P>
 <P>
 <b>-l</b>, <b>--files-with-matches</b>
 Instead of outputting lines from the files, just output the names of the files
 containing lines that would have been output. Each file name is output once, on
-a separate line. Searching normally stops as soon as a matching line is found
-in a file. However, if the <b>-c</b> (count) option is also used, matching
-continues in order to obtain the correct count, and those files that have at
-least one match are listed along with their counts. Using this option with
-<b>-c</b> is a way of suppressing the listing of files with no matches that
+a separate line, but if the <b>-Z</b> option is set, they are separated by zero
+bytes instead of newlines. Searching normally stops as soon as a matching line
+is found in a file. However, if the <b>-c</b> (count) option is also used,
+matching continues in order to obtain the correct count, and those files that
+have at least one match are listed along with their counts. Using this option
+with <b>-c</b> is a way of suppressing the listing of files with no matches that
 occurs with <b>-c</b> on its own. This option overrides any previous <b>-H</b>,
 <b>-h</b>, or <b>-L</b> options.
 </P>
 <P>
 <b>--label</b>=<i>name</i>
 This option supplies a name to be used for the standard input when file names
 are being output. If not supplied, "(standard input)" is used. There is no
@@ -516,19 +524,19 @@
 <b>--line-buffered</b> is ignored.
 </P>
 <P>
 <b>--line-offsets</b>
 Instead of showing lines or parts of lines that match, show each match as a
 line number, the offset from the start of the line, and a length. The line
 number is terminated by a colon (as usual; see the <b>-n</b> option), and the
-offset and length are separated by a comma. In this mode, no context is shown.
-That is, the <b>-A</b>, <b>-B</b>, and <b>-C</b> options are ignored. If there is
-more than one match in a line, each of them is shown separately. This option is
-mutually exclusive with <b>--output</b>, <b>--file-offsets</b>, and
-<b>--only-matching</b>.
+offset and length are separated by a comma. In this mode, <b>--colour</b> has no
+effect, and no context is shown. That is, the <b>-A</b>, <b>-B</b>, and <b>-C</b>
+options are ignored. If there is more than one match in a line, each of them is
+shown separately. This option is mutually exclusive with <b>--output</b>,
+<b>--file-offsets</b>, and <b>--only-matching</b>.
 </P>
 <P>
 <b>--locale</b>=<i>locale-name</i>
 This option specifies a locale to be used for pattern matching. It overrides
 the value in the <b>LC_ALL</b> or <b>LC_CTYPE</b> environment variables. If no
 locale is specified, the PCRE2 library's default (usually the "C" locale) is
 used. There is no short form for this option.
@@ -588,18 +596,15 @@
 very large number of possibilities in their search trees. The classic example
 is a pattern that uses nested unlimited repeats. Internally, PCRE2 has a
 counter that is incremented each time around its main processing loop. If the
 value set by <b>--match-limit</b> is reached, an error occurs.
 <br>
 <br>
 The <b>--heap-limit</b> option specifies, as a number of kibibytes (units of
-1024 bytes), the amount of heap memory that may be used for matching. Heap
-memory is needed only if matching the pattern requires a significant number of
-nested backtracking points to be remembered. This parameter can be set to zero
-to forbid the use of heap memory altogether.
+1024 bytes), the maximum amount of heap memory that may be used for matching.
 <br>
 <br>
 The <b>--depth-limit</b> option limits the depth of nested backtracking points,
 which indirectly limits the amount of memory that is used. The amount of memory
 needed for each backtracking point depends on the number of capturing
 parentheses in the pattern, so the amount of memory that is used before this
 limit acts varies from pattern to pattern. This limit is of use only if it is
@@ -663,20 +668,20 @@
 use of JIT at run time. It is provided for testing and working round problems.
 It should never be needed in normal use.
 </P>
 <P>
 <b>-O</b> <i>text</i>, <b>--output</b>=<i>text</i>
 When there is a match, instead of outputting the line that matched, output just
 the text specified in this option, followed by an operating-system standard
-newline. In this mode, no context is shown. That is, the <b>-A</b>, <b>-B</b>,
-and <b>-C</b> options are ignored. The <b>--newline</b> option has no effect on
-this option, which is mutually exclusive with <b>--only-matching</b>,
-<b>--file-offsets</b>, and <b>--line-offsets</b>. However, like
-<b>--only-matching</b>, if there is more than one match in a line, each of them
-causes a line of output.
+newline. In this mode, <b>--colour</b> has no effect, and no context is shown.
+That is, the <b>-A</b>, <b>-B</b>, and <b>-C</b> options are ignored. The
+<b>--newline</b> option has no effect on this option, which is mutually
+exclusive with <b>--only-matching</b>, <b>--file-offsets</b>, and
+<b>--line-offsets</b>. However, like <b>--only-matching</b>, if there is more
+than one match in a line, each of them causes a line of output.
 <br>
 <br>
 Escape sequences starting with a dollar character may be used to insert the
 contents of the matched part of the line and/or captured substrings into the
 text.
 <br>
 <br>
@@ -835,14 +840,21 @@
 Force the patterns to start matching only at the beginnings of lines, and in
 addition, require them to match entire lines. In multiline mode the match may
 be more than one line. This is equivalent to having "^(?:" at the start of each
 pattern and ")$" at the end. This option applies only to the patterns that are
 matched against the contents of files; it does not apply to patterns specified
 by any of the <b>--include</b> or <b>--exclude</b> options.
 </P>
+<P>
+<b>-Z</b>, <b>--null</b>
+Terminate files names in the regular output with a zero byte (the NUL
+character) instead of what would normally appear. This is useful when file
+names contain unusual characters such as colons, hyphens, or even newlines. The
+option does not apply to file names in error messages.
+</P>
 <br><a name="SEC7" href="#TOC1">ENVIRONMENT VARIABLES</a><br>
 <P>
 The environment variables <b>LC_ALL</b> and <b>LC_CTYPE</b> are examined, in that
 order, for a locale. The first one that is set is used. This can be overridden
 by the <b>--locale</b> option. If no locale is set, the PCRE2 library's default
 (usually the "C" locale) is used.
 </P>
@@ -1049,14 +1061,14 @@
 Retired from University Computing Service
 <br>
 Cambridge, England.
 <br>
 </P>
 <br><a name="SEC16" href="#TOC1">REVISION</a><br>
 <P>
-Last updated: 31 August 2021
+Last updated: 21 November 2022
 <br>
-Copyright &copy; 1997-2021 University of Cambridge.
+Copyright &copy; 1997-2022 University of Cambridge.
 <br>
 <p>
 Return to the <a href="index.html">PCRE2 index page</a>.
 </p>
```

#### html2text {}

```diff
@@ -43,21 +43,22 @@
 or both of these options are used to specify patterns, all arguments are
 treated as path names. At least one of -e, -f, or an argument pattern must be
 provided.
 If no files are specified, pcre2grep reads the standard input. The standard
 input can also be referenced by a name consisting of a single hyphen. For
 example:
   pcre2grep some-pattern file1 - file3
-Input files are searched line by line. By default, each line that matches a
+By default, input files are searched line by line. Each line that matches a
 pattern is copied to the standard output, and if there is more than one file,
 the file name is output at the start of each line, followed by a colon.
-However, there are options that can change how pcre2grep behaves. In
-particular, the -M option makes it possible to search for strings that span
-line boundaries. What defines a line boundary is controlled by the -N (--
-newline) option.
+However, there are options that can change how pcre2grep behaves. For example,
+the -M option makes it possible to search for strings that span line
+boundaries. What defines a line boundary is controlled by the -N (--newline)
+option. The -h and -H options control whether or not file names are shown, and
+the -Z option changes the file name terminator to a zero byte.
 The amount of memory used for buffering files that are being scanned is
 controlled by parameters that can be set by the --buffer-size and --max-buffer-
 size options. The first of these sets the size of buffer that is obtained at
 the start of processing. If an input file contains very long lines, a larger
 buffer may be needed; this is handled by automatically extending the buffer, up
 to the limit specified by --max-buffer-size. The default values for these
 parameters can be set when pcre2grep is built; if nothing is specified, the
@@ -69,41 +70,46 @@
 Patterns can be no longer than 8KiB or BUFSIZ bytes, whichever is the greater.
 BUFSIZ is defined in <stdio.h>. When there is more than one pattern (specified
 by the use of -e and/or -f), each pattern is applied to each line in the order
 in which they are defined, except that all the -e patterns are tried before the
 -f patterns.
 By default, as soon as one pattern matches a line, no further patterns are
 considered. However, if --colour (or --color) is used to colour the matching
-substrings, or if --only-matching, --file-offsets, or --line-offsets is used to
-output only the part of the line that matched (either shown literally, or as an
-offset), scanning resumes immediately following the match, so that further
-matches on the same line can be found. If there are multiple patterns, they are
-all tried on the remainder of the line, but patterns that follow the one that
-matched are not tried on the earlier matched part of the line.
-This behaviour means that the order in which multiple patterns are specified
-can affect the output when one of the above options is used. This is no longer
-the same behaviour as GNU grep, which now manages to display earlier matches
-for later patterns (as long as there is no overlap).
+substrings, or if --only-matching, --file-offsets, --line-offsets, or --output
+is used to output only the part of the line that matched (either shown
+literally, or as an offset), the behaviour is different. In this situation, all
+the patterns are applied to the line. If there is more than one match, the one
+that begins nearest to the start of the subject is processed; if there is more
+than one match at that position, the one with the longest matching substring is
+processed; if the matching substrings are equal, the first match found is
+processed.
+Scanning with all the patterns resumes immediately following the match, so that
+later matches on the same line can be found. Note, however, that an overlapping
+match that starts in the middle of another match will not be processed.
+The above behaviour was changed at release 10.41 to be more compatible with GNU
+grep. In earlier releases, pcre2grep did not recognize matches from later
+patterns that were earlier in the subject.
 Patterns that can match an empty string are accepted, but empty string matches
 are never recognized. An example is the pattern "(super)?(man)?", in which all
 components are optional. This pattern finds all occurrences of both "super" and
 "man"; the output differs from matching with "super|man" when only the matching
 substrings are being shown.
 If the LC_ALL or LC_CTYPE environment variable is set, pcre2grep uses the value
 to set a locale when calling the PCRE2 library. The --locale option can be used
 to override this.
 
 SUPPORT_FOR_COMPRESSED_FILES
-It is possible to compile pcre2grep so that it uses libz or libbz2 to read
-compressed files whose names end in .gz or .bz2, respectively. You can find out
-whether your pcre2grep binary has support for one or both of these file types
-by running it with the --help option. If the appropriate support is not
-present, all files are treated as plain text. The standard input is always so
-treated. When input is from a compressed .gz or .bz2 file, the --line-buffered
-option is ignored.
+Compile-time options for pcre2grep can set it up to use libz or libbz2 for
+reading compressed files whose names end in .gz or .bz2, respectively. You can
+find out whether your pcre2grep binary has support for one or both of these
+file types by running it with the --help option. If the appropriate support is
+not present, all files are treated as plain text. The standard input is always
+so treated. If a file with a .gz or .bz2 extension is not in fact compressed,
+it is read as a plain text file. When input is from a compressed .gz or .bz2
+file, the --line-buffered option is ignored.
 
 BINARY_FILES
 By default, a file that contains a binary zero byte within the first 1024 bytes
 is identified as a binary file, and is processed specially. However, if the
 newline type is specified as NUL, that is, the line terminator is a binary
 zero, the test for a binary file is not applied. See the --binary-files option
 for a means of changing the way binary files are handled.
@@ -123,29 +129,31 @@
 -- This terminates the list of options. It is useful if the next item on the
 command line starts with a hyphen but is not an option. This allows for the
 processing of patterns and file names that start with hyphens.
 -A number, --after-context=number Output up to number lines of context after
 each matching line. Fewer lines are output if the next match or the end of the
 file is reached, or if the processing buffer size has been set too small. If
 file names and/or line numbers are being output, a hyphen separator is used
-instead of a colon for the context lines. A line containing "--" is output
+instead of a colon for the context lines (the -Z option can be used to change
+the file name terminator to a zero byte). A line containing "--" is output
 between each group of lines, unless they are in fact contiguous in the input
 file. The value of number is expected to be relatively small. When -c is used,
 -A is ignored.
 -a, --text Treat binary files as text. This is equivalent to --binary-
 files=text.
 --allow-lookaround-bsk PCRE2 now forbids the use of \K in lookarounds by
 default, in line with Perl. This option causes pcre2grep to set the
 PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK option, which enables this somewhat dangerous
 usage.
 -B number, --before-context=number Output up to number lines of context before
 each matching line. Fewer lines are output if the previous match or the start
 of the file is within number lines, or if the processing buffer size has been
 set too small. If file names and/or line numbers are being output, a hyphen
-separator is used instead of a colon for the context lines. A line containing
+separator is used instead of a colon for the context lines (the -Z option can
+be used to change the file name terminator to a zero byte). A line containing
 "--" is output between each group of lines, unless they are in fact contiguous
 in the input file. The value of number is expected to be relatively small. When
 -c is used, -B is ignored.
 --binary-files=word Specify how binary files are to be processed. If the word
 is "binary" (the default), pattern matching is performed on binary files, but
 the only output is "Binary file <name> matches" when a match succeeds. If the
 word is "text", which is equivalent to the -a or --text option, binary files
@@ -173,20 +181,21 @@
 to cause a total to be output at the end. However, if the --files-with-matches
 option is also used, only those files whose counts are greater than zero are
 listed. When -c is used, the -A, -B, and -C options are ignored.
 --colour, --color If this option is given without any data, it is equivalent to
 "--colour=auto". If data is required, it must be given in the same shell item,
 separated by an equals sign.
 --colour=value, --color=value This option specifies under what circumstances
-the parts of a line that matched a pattern should be coloured in the output. By
-default, the output is not coloured. The value (which is optional, see above)
-may be "never", "always", or "auto". In the latter case, colouring happens only
-if the standard output is connected to a terminal. More resources are used when
-colouring is enabled, because pcre2grep has to search for all possible matches
-in a line, not just one, in order to colour them all.
+the parts of a line that matched a pattern should be coloured in the output. It
+is ignored if --file-offsets, --line-offsets, or --output is set. By default,
+output is not coloured. The value for the --colour option (which is optional,
+see above) may be "never", "always", or "auto". In the latter case, colouring
+happens only if the standard output is connected to a terminal. More resources
+are used when colouring is enabled, because pcre2grep has to search for all
+possible matches in a line, not just one, in order to colour them all.
 
 The colour that is used can be specified by setting one of the environment
 variables PCRE2GREP_COLOUR, PCRE2GREP_COLOR, PCREGREP_COLOUR, or
 PCREGREP_COLOR, which are checked in that order. If none of these are set,
 pcre2grep looks for GREP_COLORS or GREP_COLOR (in that order). The value of the
 variable should be a string of two numbers, separated by a semicolon, except in
 the case of GREP_COLORS, which must start with "ms=" or "mt=" followed by two
@@ -213,25 +222,20 @@
 error.
 --depth-limit=number See --match-limit below.
 -e pattern, --regex=pattern, --regexp=pattern Specify a pattern to be matched.
 This option can be used multiple times in order to specify several patterns. It
 can also be used as a way of specifying a single pattern that starts with a
 hyphen. When -e is used, no argument pattern is taken from the command line;
 all arguments are treated as file names. There is no limit to the number of
-patterns. They are applied to each line in the order in which they are defined
-until one matches.
+patterns. They are applied to each line in the order in which they are defined.
+
 
 If -f is used with -e, the command line patterns are matched first, followed by
 the patterns from the file(s), independent of the order in which these options
-are specified. Note that multiple use of -e is not the same as a single pattern
-with alternatives. For example, X|Y finds the first character in a line that is
-X or Y, whereas if the two patterns are given separately, with X first,
-pcre2grep finds X if it is present, even if it follows Y in the line. It finds
-Y only if there is no X in the line. This matters only if you are using -o or -
--colo(u)r to show the part(s) of the line that matched.
+are specified.
 --exclude=pattern Files (but not directories) whose names match the pattern are
 skipped without being processed. This applies to all files, whether listed on
 the command line, obtained from --file-list, or by scanning a directory. The
 pattern is a PCRE2 regular expression, and is matched against the final
 component of the file name, not the entire path. The -F, -w, and -x options do
 not apply to this pattern. The option may be given any number of times in order
 to specify multiple patterns. If a file name matches both an --include and an -
@@ -254,59 +258,59 @@
 strings, separated by newlines, instead of as a regular expression. What
 constitutes a newline for this purpose is controlled by the --newline option.
 The -w (match as a word) and -x (match whole line) options can be used with -F.
 They apply to each of the fixed strings. A line is selected if any of the fixed
 strings are found in it (subject to -w or -x, if present). This option applies
 only to the patterns that are matched against the contents of files; it does
 not apply to patterns specified by any of the --include or --exclude options.
--f filename, --file=filename Read patterns from the file, one per line, and
-match them against each line of input. As is the case with patterns on the
-command line, no delimiters should be used. What constitutes a newline when
-reading the file is the operating system's default interpretation of \n. The --
-newline option has no effect on this option. Trailing white space is removed
-from each line, and blank lines are ignored. An empty file contains no patterns
-and therefore matches nothing. Patterns read from a file in this way may
-contain binary zeros, which are treated as ordinary data characters. See also
-the comments about multiple patterns versus a single pattern with alternatives
-in the description of -e above.
+-f filename, --file=filename Read patterns from the file, one per line. As is
+the case with patterns on the command line, no delimiters should be used. What
+constitutes a newline when reading the file is the operating system's default
+interpretation of \n. The --newline option has no effect on this option.
+Trailing white space is removed from each line, and blank lines are ignored. An
+empty file contains no patterns and therefore matches nothing. Patterns read
+from a file in this way may contain binary zeros, which are treated as ordinary
+data characters.
 
 If this option is given more than once, all the specified files are read. A
 data line is output if any of the patterns match it. A file name can be given
 as "-" to refer to the standard input. When -f is used, patterns specified on
-the command line using -e may also be present; they are tested before the
-file's patterns. However, no other pattern is taken from the command line; all
+the command line using -e may also be present; they are matched before the
+file's patterns. However, no pattern is taken from the command line; all
 arguments are treated as the names of paths to be searched.
 --file-list=filename Read a list of files and/or directories that are to be
 scanned from the given file, one per line. What constitutes a newline when
 reading the file is the operating system's default. Trailing white space is
 removed from each line, and blank lines are ignored. These paths are processed
 before any that are listed on the command line. The file name can be given as
 "-" to refer to the standard input. If --file and --file-list are both
 specified as "-", patterns are read first. This is useful only when the
 standard input is a terminal, from which further lines (the list of files) can
 be read after an end-of-file indication. If this option is given more than
 once, all the specified files are read.
 --file-offsets Instead of showing lines or parts of lines that match, show each
 match as an offset from the start of the file and a length, separated by a
-comma. In this mode, no context is shown. That is, the -A, -B, and -C options
-are ignored. If there is more than one match in a line, each of them is shown
-separately. This option is mutually exclusive with --output, --line-offsets,
-and --only-matching.
+comma. In this mode, --colour has no effect, and no context is shown. That is,
+the -A, -B, and -C options are ignored. If there is more than one match in a
+line, each of them is shown separately. This option is mutually exclusive with
+--output, --line-offsets, and --only-matching.
 -H, --with-filename Force the inclusion of the file name at the start of output
-lines when searching a single file. By default, the file name is not shown in
-this case. For matching lines, the file name is followed by a colon; for
-context lines, a hyphen separator is used. If a line number is also being
-output, it follows the file name. When the -M option causes a pattern to match
-more than one line, only the first is preceded by the file name. This option
-overrides any previous -h, -l, or -L options.
+lines when searching a single file. The file name is not normally shown in this
+case. By default, for matching lines, the file name is followed by a colon; for
+context lines, a hyphen separator is used. The -Z option can be used to change
+the terminator to a zero byte. If a line number is also being output, it
+follows the file name. When the -M option causes a pattern to match more than
+one line, only the first is preceded by the file name. This option overrides
+any previous -h, -l, or -L options.
 -h, --no-filename Suppress the output file names when searching multiple files.
-By default, file names are shown when multiple files are searched. For matching
-lines, the file name is followed by a colon; for context lines, a hyphen
-separator is used. If a line number is also being output, it follows the file
-name. This option overrides any previous -H, -L, or -l options.
+File names are normally shown when multiple files are searched. By default, for
+matching lines, the file name is followed by a colon; for context lines, a
+hyphen separator is used. The -Z option can be used to change the terminator to
+a zero byte. If a line number is also being output, it follows the file name.
+This option overrides any previous -H, -L, or -l options.
 --heap-limit=number See --match-limit below.
 --help Output a help message, giving brief details of the command options and
 file type support, and then exit. Anything else on the command line is ignored.
 -I Ignore binary files. This is equivalent to --binary-files=without-match.
 -i, --ignore-case Ignore upper/lower case distinctions during comparisons.
 --include=pattern If any --include patterns are specified, the only files that
 are processed are those whose names match one of the patterns and do not match
@@ -328,25 +332,27 @@
 parent directory. The pattern is a PCRE2 regular expression, and is matched
 against the final component of the directory name, not the entire path. The -F,
 -w, and -x options do not apply to this pattern. The option may be given any
 number of times. If a directory matches both --include-dir and --exclude-dir,
 it is excluded. There is no short form for this option.
 -L, --files-without-match Instead of outputting lines from the files, just
 output the names of the files that do not contain any lines that would have
-been output. Each file name is output once, on a separate line. This option
-overrides any previous -H, -h, or -l options.
+been output. Each file name is output once, on a separate line by default, but
+if the -Z option is set, they are separated by zero bytes instead of newlines.
+This option overrides any previous -H, -h, or -l options.
 -l, --files-with-matches Instead of outputting lines from the files, just
 output the names of the files containing lines that would have been output.
-Each file name is output once, on a separate line. Searching normally stops as
-soon as a matching line is found in a file. However, if the -c (count) option
-is also used, matching continues in order to obtain the correct count, and
-those files that have at least one match are listed along with their counts.
-Using this option with -c is a way of suppressing the listing of files with no
-matches that occurs with -c on its own. This option overrides any previous -H,
--h, or -L options.
+Each file name is output once, on a separate line, but if the -Z option is set,
+they are separated by zero bytes instead of newlines. Searching normally stops
+as soon as a matching line is found in a file. However, if the -c (count)
+option is also used, matching continues in order to obtain the correct count,
+and those files that have at least one match are listed along with their
+counts. Using this option with -c is a way of suppressing the listing of files
+with no matches that occurs with -c on its own. This option overrides any
+previous -H, -h, or -L options.
 --label=name This option supplies a name to be used for the standard input when
 file names are being output. If not supplied, "(standard input)" is used. There
 is no short form for this option.
 --line-buffered When this option is given, non-compressed input is read and
 processed line by line, and the output is flushed after each write. By default,
 input is read in large chunks, unless pcre2grep can determine that it is
 reading from a terminal, which is currently possible only in Unix-like
@@ -355,18 +361,19 @@
 attached to a pipe and you do not want pcre2grep to buffer up large amounts of
 data. However, its use will affect performance, and the -M (multiline) option
 ceases to work. When input is from a compressed .gz or .bz2 file, --line-
 buffered is ignored.
 --line-offsets Instead of showing lines or parts of lines that match, show each
 match as a line number, the offset from the start of the line, and a length.
 The line number is terminated by a colon (as usual; see the -n option), and the
-offset and length are separated by a comma. In this mode, no context is shown.
-That is, the -A, -B, and -C options are ignored. If there is more than one
-match in a line, each of them is shown separately. This option is mutually
-exclusive with --output, --file-offsets, and --only-matching.
+offset and length are separated by a comma. In this mode, --colour has no
+effect, and no context is shown. That is, the -A, -B, and -C options are
+ignored. If there is more than one match in a line, each of them is shown
+separately. This option is mutually exclusive with --output, --file-offsets,
+and --only-matching.
 --locale=locale-name This option specifies a locale to be used for pattern
 matching. It overrides the value in the LC_ALL or LC_CTYPE environment
 variables. If no locale is specified, the PCRE2 library's default (usually the
 "C" locale) is used. There is no short form for this option.
 -M, --multiline Allow patterns to match more than one line. When this option is
 set, the PCRE2 library is called in "multiline" mode. This allows a matched
 string to extend past the end of a line and continue on one or more subsequent
@@ -409,18 +416,15 @@
 when processing patterns that are not going to match, but which have a very
 large number of possibilities in their search trees. The classic example is a
 pattern that uses nested unlimited repeats. Internally, PCRE2 has a counter
 that is incremented each time around its main processing loop. If the value set
 by --match-limit is reached, an error occurs.
 
 The --heap-limit option specifies, as a number of kibibytes (units of 1024
-bytes), the amount of heap memory that may be used for matching. Heap memory is
-needed only if matching the pattern requires a significant number of nested
-backtracking points to be remembered. This parameter can be set to zero to
-forbid the use of heap memory altogether.
+bytes), the maximum amount of heap memory that may be used for matching.
 
 The --depth-limit option limits the depth of nested backtracking points, which
 indirectly limits the amount of memory that is used. The amount of memory
 needed for each backtracking point depends on the number of capturing
 parentheses in the pattern, so the amount of memory that is used before this
 limit acts varies from pattern to pattern. This limit is of use only if it is
 set smaller than --match-limit.
@@ -462,19 +466,20 @@
 --no-jit If the PCRE2 library is built with support for just-in-time compiling
 (which speeds up matching), pcre2grep automatically makes use of this, unless
 it was explicitly disabled at build time. This option can be used to disable
 the use of JIT at run time. It is provided for testing and working round
 problems. It should never be needed in normal use.
 -O text, --output=text When there is a match, instead of outputting the line
 that matched, output just the text specified in this option, followed by an
-operating-system standard newline. In this mode, no context is shown. That is,
-the -A, -B, and -C options are ignored. The --newline option has no effect on
-this option, which is mutually exclusive with --only-matching, --file-offsets,
-and --line-offsets. However, like --only-matching, if there is more than one
-match in a line, each of them causes a line of output.
+operating-system standard newline. In this mode, --colour has no effect, and no
+context is shown. That is, the -A, -B, and -C options are ignored. The --
+newline option has no effect on this option, which is mutually exclusive with -
+-only-matching, --file-offsets, and --line-offsets. However, like --only-
+matching, if there is more than one match in a line, each of them causes a line
+of output.
 
 Escape sequences starting with a dollar character may be used to insert the
 contents of the matched part of the line and/or captured substrings into the
 text.
 
 $<digits> or ${<digits>} is replaced by the captured substring of the given
 decimal number; zero substitutes the whole match. If the number is greater than
@@ -576,14 +581,18 @@
 -x, --line-regex, --line-regexp Force the patterns to start matching only at
 the beginnings of lines, and in addition, require them to match entire lines.
 In multiline mode the match may be more than one line. This is equivalent to
 having "^(?:" at the start of each pattern and ")$" at the end. This option
 applies only to the patterns that are matched against the contents of files; it
 does not apply to patterns specified by any of the --include or --exclude
 options.
+-Z, --null Terminate files names in the regular output with a zero byte (the
+NUL character) instead of what would normally appear. This is useful when file
+names contain unusual characters such as colons, hyphens, or even newlines. The
+option does not apply to file names in error messages.
 
 ENVIRONMENT_VARIABLES
 The environment variables LC_ALL and LC_CTYPE are examined, in that order, for
 a locale. The first one that is set is used. This can be overridden by the --
 locale option. If no locale is set, the PCRE2 library's default (usually the
 "C" locale) is used.
 
@@ -738,10 +747,10 @@
 
 AUTHOR
 Philip Hazel
 Retired from University Computing Service
 Cambridge, England.
 
 REVISION
-Last updated: 31 August 2021
-Copyright  1997-2021 University of Cambridge.
+Last updated: 21 November 2022
+Copyright  1997-2022 University of Cambridge.
 Return to the PCRE2_index_page.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2jit.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2jit.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2limits.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2limits.html`

 * *Files 5% similar despite different names*

```diff
@@ -67,29 +67,34 @@
 is 255 code units for the 8-bit library and 65535 code units for the 16-bit and
 32-bit libraries.
 </P>
 <P>
 The maximum length of a string argument to a callout is the largest number a
 32-bit unsigned integer can hold.
 </P>
+<P>
+The maximum amount of heap memory used for matching is controlled by the heap
+limit, which can be set in a pattern or in a match context. The default is a
+very large number, effectively unlimited.
+</P>
 <br><b>
 AUTHOR
 </b><br>
 <P>
 Philip Hazel
 <br>
-University Computing Service
+Retired from University Computing Service
 <br>
 Cambridge, England.
 <br>
 </P>
 <br><b>
 REVISION
 </b><br>
 <P>
-Last updated: 02 February 2019
+Last updated: 26 July 2022
 <br>
-Copyright &copy; 1997-2019 University of Cambridge.
+Copyright &copy; 1997-2022 University of Cambridge.
 <br>
 <p>
 Return to the <a href="index.html">PCRE2 index page</a>.
 </p>
```

#### html2text {}

```diff
@@ -36,17 +36,20 @@
 The maximum length of name for a named capture group is 32 code units, and the
 maximum number of such groups is 10000.
 The maximum length of a name in a (*MARK), (*PRUNE), (*SKIP), or (*THEN) verb
 is 255 code units for the 8-bit library and 65535 code units for the 16-bit and
 32-bit libraries.
 The maximum length of a string argument to a callout is the largest number a
 32-bit unsigned integer can hold.
+The maximum amount of heap memory used for matching is controlled by the heap
+limit, which can be set in a pattern or in a match context. The default is a
+very large number, effectively unlimited.
 
 AUTHOR
 Philip Hazel
-University Computing Service
+Retired from University Computing Service
 Cambridge, England.
 
 REVISION
-Last updated: 02 February 2019
-Copyright  1997-2019 University of Cambridge.
+Last updated: 26 July 2022
+Copyright  1997-2022 University of Cambridge.
 Return to the PCRE2_index_page.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2matching.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2matching.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2partial.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2partial.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2pattern.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2pattern.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2perform.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2perform.html`

 * *Files 3% similar despite different names*

```diff
@@ -79,20 +79,39 @@
 </P>
 <br><a name="SEC3" href="#TOC1">STACK AND HEAP USAGE AT RUN TIME</a><br>
 <P>
 From release 10.30, the interpretive (non-JIT) version of <b>pcre2_match()</b>
 uses very little system stack at run time. In earlier releases recursive
 function calls could use a great deal of stack, and this could cause problems,
 but this usage has been eliminated. Backtracking positions are now explicitly
-remembered in memory frames controlled by the code. An initial 20KiB vector of
-frames is allocated on the system stack (enough for about 100 frames for small
-patterns), but if this is insufficient, heap memory is used. The amount of heap
-memory can be limited; if the limit is set to zero, only the initial stack
-vector is used. Rewriting patterns to be time-efficient, as described below,
-may also reduce the memory requirements.
+remembered in memory frames controlled by the code.
+</P>
+<P>
+The size of each frame depends on the size of pointer variables and the number
+of capturing parenthesized groups in the pattern being matched. On a 64-bit
+system the frame size for a pattern with no captures is 128 bytes. For each
+capturing group the size increases by 16 bytes.
+</P>
+<P>
+Until release 10.41, an initial 20KiB frames vector was allocated on the system
+stack, but this still caused some issues for multi-thread applications where
+each thread has a very small stack. From release 10.41 backtracking memory
+frames are always held in heap memory. An initial heap allocation is obtained
+the first time any match data block is passed to <b>pcre2_match()</b>. This is
+remembered with the match data block and re-used if that block is used for
+another match. It is freed when the match data block itself is freed.
+</P>
+<P>
+The size of the initial block is the larger of 20KiB or ten times the pattern's
+frame size, unless the heap limit is less than this, in which case the heap
+limit is used. If the initial block proves to be too small during matching, it
+is replaced by a larger block, subject to the heap limit. The heap limit is
+checked only when a new block is to be allocated. Reducing the heap limit
+between calls to <b>pcre2_match()</b> with the same match data block does not
+affect the saved block.
 </P>
 <P>
 In contrast to <b>pcre2_match()</b>, <b>pcre2_dfa_match()</b> does use recursive
 function calls, but only for processing atomic groups, lookaround assertions,
 and recursion within the pattern. The original version of the code used to
 allocate quite large internal workspace vectors on the stack, which caused some
 problems for some patterns in environments with small stacks. From release
@@ -241,21 +260,21 @@
 applied to a subject line, causes it to find the smallest limits that allow a
 pattern to match. This is done by repeatedly matching with different limits.
 </P>
 <br><a name="SEC5" href="#TOC1">AUTHOR</a><br>
 <P>
 Philip Hazel
 <br>
-University Computing Service
+Retired from University Computing Service
 <br>
 Cambridge, England.
 <br>
 </P>
 <br><a name="SEC6" href="#TOC1">REVISION</a><br>
 <P>
-Last updated: 03 February 2019
+Last updated: 27 July 2022
 <br>
-Copyright &copy; 1997-2019 University of Cambridge.
+Copyright &copy; 1997-2022 University of Cambridge.
 <br>
 <p>
 Return to the <a href="index.html">PCRE2 index page</a>.
 </p>
```

#### html2text {}

```diff
@@ -52,20 +52,33 @@
 were different in earlier releases.)
 
 STACK_AND_HEAP_USAGE_AT_RUN_TIME
 From release 10.30, the interpretive (non-JIT) version of pcre2_match() uses
 very little system stack at run time. In earlier releases recursive function
 calls could use a great deal of stack, and this could cause problems, but this
 usage has been eliminated. Backtracking positions are now explicitly remembered
-in memory frames controlled by the code. An initial 20KiB vector of frames is
-allocated on the system stack (enough for about 100 frames for small patterns),
-but if this is insufficient, heap memory is used. The amount of heap memory can
-be limited; if the limit is set to zero, only the initial stack vector is used.
-Rewriting patterns to be time-efficient, as described below, may also reduce
-the memory requirements.
+in memory frames controlled by the code.
+The size of each frame depends on the size of pointer variables and the number
+of capturing parenthesized groups in the pattern being matched. On a 64-bit
+system the frame size for a pattern with no captures is 128 bytes. For each
+capturing group the size increases by 16 bytes.
+Until release 10.41, an initial 20KiB frames vector was allocated on the system
+stack, but this still caused some issues for multi-thread applications where
+each thread has a very small stack. From release 10.41 backtracking memory
+frames are always held in heap memory. An initial heap allocation is obtained
+the first time any match data block is passed to pcre2_match(). This is
+remembered with the match data block and re-used if that block is used for
+another match. It is freed when the match data block itself is freed.
+The size of the initial block is the larger of 20KiB or ten times the pattern's
+frame size, unless the heap limit is less than this, in which case the heap
+limit is used. If the initial block proves to be too small during matching, it
+is replaced by a larger block, subject to the heap limit. The heap limit is
+checked only when a new block is to be allocated. Reducing the heap limit
+between calls to pcre2_match() with the same match data block does not affect
+the saved block.
 In contrast to pcre2_match(), pcre2_dfa_match() does use recursive function
 calls, but only for processing atomic groups, lookaround assertions, and
 recursion within the pattern. The original version of the code used to allocate
 quite large internal workspace vectors on the stack, which caused some problems
 for some patterns in environments with small stacks. From release 10.32 the
 code for pcre2_dfa_match() has been re-factored to use heap memory when
 necessary for internal workspace when recursing, though recursive function
@@ -166,14 +179,14 @@
 the section entitled "The_match_context" in the pcre2api documentation.
 The pcre2test test program has a modifier called "find_limits" which, if
 applied to a subject line, causes it to find the smallest limits that allow a
 pattern to match. This is done by repeatedly matching with different limits.
 
 AUTHOR
 Philip Hazel
-University Computing Service
+Retired from University Computing Service
 Cambridge, England.
 
 REVISION
-Last updated: 03 February 2019
-Copyright  1997-2019 University of Cambridge.
+Last updated: 27 July 2022
+Copyright  1997-2022 University of Cambridge.
 Return to the PCRE2_index_page.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2posix.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2posix.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2sample.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2sample.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2serialize.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2serialize.html`

 * *Files 1% similar despite different names*

```diff
@@ -90,15 +90,15 @@
 argument is a pointer to a general context, which can be used to specify custom
 memory mangagement functions. If this argument is NULL, <b>malloc()</b> is used
 to obtain memory for the byte stream. The yield of the function is the number
 of serialized patterns, or one of the following negative error codes:
 <pre>
   PCRE2_ERROR_BADDATA      the number of patterns is zero or less
   PCRE2_ERROR_BADMAGIC     mismatch of id bytes in one of the patterns
-  PCRE2_ERROR_MEMORY       memory allocation failed
+  PCRE2_ERROR_NOMEMORY     memory allocation failed
   PCRE2_ERROR_MIXEDTABLES  the patterns do not all use the same tables
   PCRE2_ERROR_NULL         the 1st, 3rd, or 4th argument is NULL
 </pre>
 PCRE2_ERROR_BADMAGIC means either that a pattern's code has been corrupted, or
 that a slot in the vector does not point to a compiled pattern.
 </P>
 <P>
```

#### html2text {}

```diff
@@ -64,15 +64,15 @@
 point to the created byte stream and its length, respectively. The final
 argument is a pointer to a general context, which can be used to specify custom
 memory mangagement functions. If this argument is NULL, malloc() is used to
 obtain memory for the byte stream. The yield of the function is the number of
 serialized patterns, or one of the following negative error codes:
   PCRE2_ERROR_BADDATA      the number of patterns is zero or less
   PCRE2_ERROR_BADMAGIC     mismatch of id bytes in one of the patterns
-  PCRE2_ERROR_MEMORY       memory allocation failed
+  PCRE2_ERROR_NOMEMORY     memory allocation failed
   PCRE2_ERROR_MIXEDTABLES  the patterns do not all use the same tables
   PCRE2_ERROR_NULL         the 1st, 3rd, or 4th argument is NULL
 PCRE2_ERROR_BADMAGIC means either that a pattern's code has been corrupted, or
 that a slot in the vector does not point to a compiled pattern.
 Once a set of patterns has been serialized you can save the data in any
 appropriate manner. Here is sample code that compiles two patterns and writes
 them to a file. It assumes that the variable fd refers to a file that is open
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2syntax.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2syntax.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2test.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2test.html`

 * *Files 2% similar despite different names*

```diff
@@ -259,15 +259,15 @@
 <b>-LP</b>
 List properties: write a list of recognized Unicode properties to the standard
 output, then exit with zero exit code. All other options are ignored. If both
 -C and any -Lx options are present, whichever is first is recognized.
 </P>
 <P>
 <b>-LS</b>
-List scripts: write a list of recogized Unicode script names to the standard
+List scripts: write a list of recognized Unicode script names to the standard
 output, then exit with zero exit code. All other options are ignored. If both
 -C and any -Lx options are present, whichever is first is recognized.
 </P>
 <P>
 <b>-pattern</b> <i>modifier-list</i>
 Behave as if each pattern line contains the given modifiers.
 </P>
@@ -1237,15 +1237,16 @@
       callout_extra              show extra callout information
       callout_fail=&#60;n&#62;[:&#60;m&#62;]     control callout failure
       callout_no_where           do not show position of a callout
       callout_none               do not supply a callout function
       copy=&#60;number or name&#62;      copy captured substring
       depth_limit=&#60;n&#62;            set a depth limit
       dfa                        use <b>pcre2_dfa_match()</b>
-      find_limits                find match and depth limits
+      find_limits                find heap, match and depth limits
+      find_limits_noheap         find match and depth limits
       get=&#60;number or name&#62;       extract captured substring
       getall                     extract all captured substrings
   /g  global                     global matching
       heap_limit=&#60;n&#62;             set a limit on heap memory (Kbytes)
       jitstack=&#60;n&#62;               set size of JIT stack
       mark                       show mark values
       match_limit=&#60;n&#62;            set a match limit
@@ -1363,15 +1364,15 @@
 </b><br>
 <P>
 A callout function is supplied when <b>pcre2test</b> calls the library matching
 functions, unless <b>callout_none</b> is specified. Its behaviour can be
 controlled by various modifiers listed above whose names begin with
 <b>callout_</b>. Details are given in the section entitled "Callouts"
 <a href="#callouts">below.</a>
-Testing callouts from <b>pcre2_substitute()</b> is decribed separately in
+Testing callouts from <b>pcre2_substitute()</b> is described separately in
 "Testing the substitution function"
 <a href="#substitution">below.</a>
 </P>
 <br><b>
 Finding all matches in a string
 </b><br>
 <P>
@@ -1560,26 +1561,30 @@
 </P>
 <br><b>
 Setting heap, match, and depth limits
 </b><br>
 <P>
 The <b>heap_limit</b>, <b>match_limit</b>, and <b>depth_limit</b> modifiers set
 the appropriate limits in the match context. These values are ignored when the
-<b>find_limits</b> modifier is specified.
+<b>find_limits</b> or <b>find_limits_noheap</b> modifier is specified.
 </P>
 <br><b>
 Finding minimum limits
 </b><br>
 <P>
 If the <b>find_limits</b> modifier is present on a subject line, <b>pcre2test</b>
 calls the relevant matching function several times, setting different values in
 the match context via <b>pcre2_set_heap_limit()</b>,
 <b>pcre2_set_match_limit()</b>, or <b>pcre2_set_depth_limit()</b> until it finds
-the minimum values for each parameter that allows the match to complete without
-error. If JIT is being used, only the match limit is relevant.
+the smallest value for each parameter that allows the match to complete without
+a "limit exceeded" error. The match itself may succeed or fail. An alternative
+modifier, <b>find_limits_noheap</b>, omits the heap limit. This is used in the
+standard tests, because the minimum heap limit varies between systems. If JIT
+is being used, only the match limit is relevant, and the other two are
+automatically omitted.
 </P>
 <P>
 When using this modifier, the pattern should not contain any limit settings
 such as (*LIMIT_MATCH=...) within it. If such a setting is present and is
 lower than the minimum matching value, the minimum value cannot be found
 because <b>pcre2_set_match_limit()</b> etc. are only able to reduce the value of
 an in-pattern limit; they cannot increase it.
@@ -1599,17 +1604,15 @@
 very quickly with increasing length of subject string. In the case of DFA
 matching, <i>match_limit</i> controls the total number of calls, both recursive
 and non-recursive, to the internal matching function, thus controlling the
 overall amount of computing resource that is used.
 </P>
 <P>
 For both kinds of matching, the <i>heap_limit</i> number, which is in kibibytes
-(units of 1024 bytes), limits the amount of heap memory used for matching. A
-value of zero disables the use of any heap memory; many simple pattern matches
-can be done without using the heap, so zero is not an unreasonable setting.
+(units of 1024 bytes), limits the amount of heap memory used for matching.
 </P>
 <br><b>
 Showing MARK names
 </b><br>
 <P>
 The <b>mark</b> modifier causes the names from backtracking control verbs that
 are returned from calls to <b>pcre2_match()</b> to be displayed. If a mark is
@@ -1619,20 +1622,18 @@
 </P>
 <br><b>
 Showing memory usage
 </b><br>
 <P>
 The <b>memory</b> modifier causes <b>pcre2test</b> to log the sizes of all heap
 memory allocation and freeing calls that occur during a call to
-<b>pcre2_match()</b> or <b>pcre2_dfa_match()</b>. These occur only when a match
-requires a bigger vector than the default for remembering backtracking points
-(<b>pcre2_match()</b>) or for internal workspace (<b>pcre2_dfa_match()</b>). In
-many cases there will be no heap memory used and therefore no additional
-output. No heap memory is allocated during matching with JIT, so in that case
-the <b>memory</b> modifier never has any effect. For this modifier to work, the
+<b>pcre2_match()</b> or <b>pcre2_dfa_match()</b>. In the latter case, heap memory
+is used only when a match requires more internal workspace that the default
+allocation on the stack, so in many cases there will be no output. No heap
+memory is allocated during matching with JIT. For this modifier to work, the
 <b>null_context</b> modifier must not be set on both the pattern and the
 subject, though it can be set on one or the other.
 </P>
 <br><b>
 Setting a starting offset
 </b><br>
 <P>
@@ -1686,15 +1687,16 @@
 </b><br>
 <P>
 Normally, <b>pcre2test</b> passes a context block to <b>pcre2_match()</b>,
 <b>pcre2_dfa_match()</b>, <b>pcre2_jit_match()</b> or <b>pcre2_substitute()</b>.
 If the <b>null_context</b> modifier is set, however, NULL is passed. This is for
 testing that the matching and substitution functions behave correctly in this
 case (they use default values). This modifier cannot be used with the
-<b>find_limits</b> or <b>substitute_callout</b> modifiers.
+<b>find_limits</b>, <b>find_limits_noheap</b>, or <b>substitute_callout</b>
+modifiers.
 </P>
 <P>
 Similarly, for testing purposes, if the <b>null_subject</b> or
 <b>null_replacement</b> modifier is set, the subject or replacement string
 pointers are passed as NULL, respectively, to the relevant functions.
 </P>
 <br><a name="SEC12" href="#TOC1">THE ALTERNATIVE MATCHING FUNCTION</a><br>
@@ -2116,15 +2118,15 @@
   #pop jit,bincode
   abc
 </pre>
 If <b>jitverify</b> is used with #pop, it does not automatically imply
 <b>jit</b>, which is different behaviour from when it is used on a pattern.
 </P>
 <P>
-The #popcopy command is analagous to the <b>pushcopy</b> modifier in that it
+The #popcopy command is analogous to the <b>pushcopy</b> modifier in that it
 makes current a copy of the topmost stack pattern, leaving the original still
 on the stack.
 </P>
 <br><a name="SEC19" href="#TOC1">SEE ALSO</a><br>
 <P>
 <b>pcre2</b>(3), <b>pcre2api</b>(3), <b>pcre2callout</b>(3),
 <b>pcre2jit</b>, <b>pcre2matching</b>(3), <b>pcre2partial</b>(d),
@@ -2137,14 +2139,14 @@
 Retired from University Computing Service
 <br>
 Cambridge, England.
 <br>
 </P>
 <br><a name="SEC21" href="#TOC1">REVISION</a><br>
 <P>
-Last updated: 12 January 2022
+Last updated: 27 July 2022
 <br>
 Copyright &copy; 1997-2022 University of Cambridge.
 <br>
 <p>
 Return to the <a href="index.html">PCRE2 index page</a>.
 </p>
```

#### html2text {}

```diff
@@ -163,15 +163,15 @@
 -LM List modifiers: write a list of available pattern and subject modifiers to
 the standard output, then exit with zero exit code. All other options are
 ignored. If both -C and any -Lx options are present, whichever is first is
 recognized.
 -LP List properties: write a list of recognized Unicode properties to the
 standard output, then exit with zero exit code. All other options are ignored.
 If both -C and any -Lx options are present, whichever is first is recognized.
--LS List scripts: write a list of recogized Unicode script names to the
+-LS List scripts: write a list of recognized Unicode script names to the
 standard output, then exit with zero exit code. All other options are ignored.
 If both -C and any -Lx options are present, whichever is first is recognized.
 -pattern modifier-list Behave as if each pattern line contains the given
 modifiers.
 -q Do not output the version number of pcre2test at the start of execution.
 -S size On Unix-like systems, set the size of the run-time stack to size
 mebibytes (units of 1024*1024 bytes).
@@ -864,15 +864,16 @@
       callout_extra              show extra callout information
       callout_fail=<n>[:<m>]     control callout failure
       callout_no_where           do not show position of a callout
       callout_none               do not supply a callout function
       copy=<number or name>      copy captured substring
       depth_limit=<n>            set a depth limit
       dfa                        use pcre2_dfa_match()
-      find_limits                find match and depth limits
+      find_limits                find heap, match and depth limits
+      find_limits_noheap         find match and depth limits
       get=<number or name>       extract captured substring
       getall                     extract all captured substrings
   /g  global                     global matching
       heap_limit=<n>             set a limit on heap memory (Kbytes)
       jitstack=<n>               set size of JIT stack
       mark                       show mark values
       match_limit=<n>            set a match limit
@@ -968,15 +969,15 @@
 ovector that is used depends on the number of matches that were found.
 
 Testing pattern callouts
 A callout function is supplied when pcre2test calls the library matching
 functions, unless callout_none is specified. Its behaviour can be controlled by
 various modifiers listed above whose names begin with callout_. Details are
 given in the section entitled "Callouts" below. Testing callouts from
-pcre2_substitute() is decribed separately in "Testing the substitution
+pcre2_substitute() is described separately in "Testing the substitution
 function" below.
 
 Finding all matches in a string
 Searching for all possible matches within a subject can be requested by the
 global or altglobal modifier. After finding a match, the matching function is
 called again to search the remainder of the subject. The difference between
 global and altglobal is that the former uses the start_offset argument to
@@ -1110,24 +1111,27 @@
 Setting zero reverts to the default of 32KiB. Providing a stack that is larger
 than the default is necessary only for very complicated patterns. If jitstack
 is set non-zero on a subject line it overrides any value that was set on the
 pattern.
 
 Setting heap, match, and depth limits
 The heap_limit, match_limit, and depth_limit modifiers set the appropriate
-limits in the match context. These values are ignored when the find_limits
-modifier is specified.
+limits in the match context. These values are ignored when the find_limits or
+find_limits_noheap modifier is specified.
 
 Finding minimum limits
 If the find_limits modifier is present on a subject line, pcre2test calls the
 relevant matching function several times, setting different values in the match
 context via pcre2_set_heap_limit(), pcre2_set_match_limit(), or
-pcre2_set_depth_limit() until it finds the minimum values for each parameter
-that allows the match to complete without error. If JIT is being used, only the
-match limit is relevant.
+pcre2_set_depth_limit() until it finds the smallest value for each parameter
+that allows the match to complete without a "limit exceeded" error. The match
+itself may succeed or fail. An alternative modifier, find_limits_noheap, omits
+the heap limit. This is used in the standard tests, because the minimum heap
+limit varies between systems. If JIT is being used, only the match limit is
+relevant, and the other two are automatically omitted.
 When using this modifier, the pattern should not contain any limit settings
 such as (*LIMIT_MATCH=...) within it. If such a setting is present and is lower
 than the minimum matching value, the minimum value cannot be found because
 pcre2_set_match_limit() etc. are only able to reduce the value of an in-pattern
 limit; they cannot increase it.
 For non-DFA matching, the minimum depth_limit number is a measure of how much
 nested backtracking happens (that is, how deeply the pattern's tree is
@@ -1139,35 +1143,32 @@
 instructive. For most simple matches, the number is quite small, but for
 patterns with very large numbers of matching possibilities, it can become large
 very quickly with increasing length of subject string. In the case of DFA
 matching, match_limit controls the total number of calls, both recursive and
 non-recursive, to the internal matching function, thus controlling the overall
 amount of computing resource that is used.
 For both kinds of matching, the heap_limit number, which is in kibibytes (units
-of 1024 bytes), limits the amount of heap memory used for matching. A value of
-zero disables the use of any heap memory; many simple pattern matches can be
-done without using the heap, so zero is not an unreasonable setting.
+of 1024 bytes), limits the amount of heap memory used for matching.
 
 Showing MARK names
 The mark modifier causes the names from backtracking control verbs that are
 returned from calls to pcre2_match() to be displayed. If a mark is returned for
 a match, non-match, or partial match, pcre2test shows it. For a match, it is on
 a line by itself, tagged with "MK:". Otherwise, it is added to the non-match
 message.
 
 Showing memory usage
 The memory modifier causes pcre2test to log the sizes of all heap memory
 allocation and freeing calls that occur during a call to pcre2_match() or
-pcre2_dfa_match(). These occur only when a match requires a bigger vector than
-the default for remembering backtracking points (pcre2_match()) or for internal
-workspace (pcre2_dfa_match()). In many cases there will be no heap memory used
-and therefore no additional output. No heap memory is allocated during matching
-with JIT, so in that case the memory modifier never has any effect. For this
-modifier to work, the null_context modifier must not be set on both the pattern
-and the subject, though it can be set on one or the other.
+pcre2_dfa_match(). In the latter case, heap memory is used only when a match
+requires more internal workspace that the default allocation on the stack, so
+in many cases there will be no output. No heap memory is allocated during
+matching with JIT. For this modifier to work, the null_context modifier must
+not be set on both the pattern and the subject, though it can be set on one or
+the other.
 
 Setting a starting offset
 The offset modifier sets an offset in the subject string at which matching
 starts. Its value is a number of code units, not characters.
 
 Setting an offset limit
 The offset_limit modifier sets a limit for unanchored matches. If a match
@@ -1198,15 +1199,16 @@
 the replacement string as zero-terminated.
 
 Passing a NULL context, subject, or replacement
 Normally, pcre2test passes a context block to pcre2_match(), pcre2_dfa_match(),
 pcre2_jit_match() or pcre2_substitute(). If the null_context modifier is set,
 however, NULL is passed. This is for testing that the matching and substitution
 functions behave correctly in this case (they use default values). This
-modifier cannot be used with the find_limits or substitute_callout modifiers.
+modifier cannot be used with the find_limits, find_limits_noheap, or
+substitute_callout modifiers.
 Similarly, for testing purposes, if the null_subject or null_replacement
 modifier is set, the subject or replacement string pointers are passed as NULL,
 respectively, to the relevant functions.
 
 THE_ALTERNATIVE_MATCHING_FUNCTION
 By default, pcre2test uses the standard PCRE2 matching function, pcre2_match()
 to match each subject line. PCRE2 also supports an alternative matching
@@ -1522,24 +1524,24 @@
   #pop info
   xyz
 
   #pop jit,bincode
   abc
 If jitverify is used with #pop, it does not automatically imply jit, which is
 different behaviour from when it is used on a pattern.
-The #popcopy command is analagous to the pushcopy modifier in that it makes
+The #popcopy command is analogous to the pushcopy modifier in that it makes
 current a copy of the topmost stack pattern, leaving the original still on the
 stack.
 
 SEE_ALSO
 pcre2(3), pcre2api(3), pcre2callout(3), pcre2jit, pcre2matching(3),
 pcre2partial(d), pcre2pattern(3), pcre2serialize(3).
 
 AUTHOR
 Philip Hazel
 Retired from University Computing Service
 Cambridge, England.
 
 REVISION
-Last updated: 12 January 2022
+Last updated: 27 July 2022
 Copyright  1997-2022 University of Cambridge.
 Return to the PCRE2_index_page.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/html/pcre2unicode.html` & `pcre2-0.2.0/src/libpcre2/doc/html/pcre2unicode.html`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/index.html.src` & `pcre2-0.2.0/src/libpcre2/doc/index.html.src`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2-config.1` & `pcre2-0.2.0/src/libpcre2/doc/pcre2-config.1`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2-config.txt` & `pcre2-0.2.0/src/libpcre2/doc/pcre2-config.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2.txt` & `pcre2-0.2.0/src/libpcre2/doc/pcre2.txt`

 * *Files 0% similar despite different names*

```diff
@@ -1024,38 +1024,34 @@
        also applies to pcre2_dfa_match(), which may use the heap when process-
        ing patterns with a lot of nested pattern recursion or  lookarounds  or
        atomic groups. This limit does not apply to matching with the JIT opti-
        mization, which has  its  own  memory  control  arrangements  (see  the
        pcre2jit  documentation for more details). If the limit is reached, the
        negative error code  PCRE2_ERROR_HEAPLIMIT  is  returned.  The  default
        limit  can be set when PCRE2 is built; if it is not, the default is set
-       very large and is essentially "unlimited".
+       very large and is essentially unlimited.
 
        A value for the heap limit may also be supplied by an item at the start
        of a pattern of the form
 
          (*LIMIT_HEAP=ddd)
 
        where  ddd  is a decimal number. However, such a setting is ignored un-
        less ddd is less than the limit set by the caller of pcre2_match()  or,
        if no such limit is set, less than the default.
 
-       The  pcre2_match() function starts out using a 20KiB vector on the sys-
-       tem stack for recording backtracking points. The more nested backtrack-
-       ing  points  there  are (that is, the deeper the search tree), the more
-       memory is needed.  Heap memory is used only if the  initial  vector  is
-       too small. If the heap limit is set to a value less than 21 (in partic-
-       ular, zero) no heap memory will be used. In this  case,  only  patterns
-       that  do not have a lot of nested backtracking can be successfully pro-
-       cessed.
-
-       Similarly, for pcre2_dfa_match(), a vector on the system stack is  used
-       when  processing pattern recursions, lookarounds, or atomic groups, and
-       only if this is not big enough is heap memory used. In this case,  too,
-       setting a value of zero disables the use of the heap.
+       The  pcre2_match() function always needs some heap memory, so setting a
+       value of zero guarantees a "heap limit exceeded" error. Details of  how
+       pcre2_match()  uses  the  heap are given in the pcre2perform documenta-
+       tion.
+
+       For pcre2_dfa_match(), a vector on the system stack is used  when  pro-
+       cessing  pattern recursions, lookarounds, or atomic groups, and only if
+       this is not big enough is heap memory used. In  this  case,  setting  a
+       value of zero disables the use of the heap.
 
        int pcre2_set_match_limit(pcre2_match_context *mcontext,
          uint32_t value);
 
        The match_limit parameter provides a means of preventing PCRE2 from us-
        ing up too many computing resources when processing patterns  that  are
        not going to match, but which have a very large number of possibilities
@@ -1089,20 +1085,20 @@
        pcre2_dfa_match() or, if no such limit is set, less than the default.
 
        int pcre2_set_depth_limit(pcre2_match_context *mcontext,
          uint32_t value);
 
        This   parameter   limits   the   depth   of   nested  backtracking  in
        pcre2_match().  Each time a nested backtracking point is passed, a  new
-       memory "frame" is used to remember the state of matching at that point.
+       memory  frame  is used to remember the state of matching at that point.
        Thus, this parameter indirectly limits the amount  of  memory  that  is
-       used  in  a match. However, because the size of each memory "frame" de-
-       pends on the number of capturing parentheses, the actual  memory  limit
-       varies  from pattern to pattern. This limit was more useful in versions
-       before 10.30, where function recursion was used for backtracking.
+       used in a match. However, because the size of each memory frame depends
+       on the number of capturing parentheses, the actual memory limit  varies
+       from  pattern to pattern. This limit was more useful in versions before
+       10.30, where function recursion was used for backtracking.
 
        The depth limit is not relevant, and is ignored, when matching is  done
        using JIT compiled code. However, it is supported by pcre2_dfa_match(),
        which uses it to limit the depth of nested internal recursive  function
        calls  that implement atomic groups, lookaround assertions, and pattern
        recursions. This limits, indirectly, the amount of system stack that is
        used.  It  was  more useful in versions before 10.32, when stack memory
@@ -1368,35 +1364,37 @@
        rameters (for example, the newline setting) can be provided in  a  com-
        pile context (as described above).
 
        If errorcode or erroroffset is NULL, pcre2_compile() returns NULL imme-
        diately. Otherwise, the variables to which these point are  set  to  an
        error code and an offset (number of code units) within the pattern, re-
        spectively, when pcre2_compile() returns NULL because a compilation er-
-       ror  has  occurred. The values are not defined when compilation is suc-
-       cessful and pcre2_compile() returns a non-NULL value.
+       ror has occurred.
 
-       There are nearly 100 positive error codes that pcre2_compile() may  re-
-       turn  if it finds an error in the pattern. There are also some negative
-       error codes that are used for invalid UTF strings when validity  check-
-       ing  is  in  force.  These  are  the same as given by pcre2_match() and
+       There  are nearly 100 positive error codes that pcre2_compile() may re-
+       turn if it finds an error in the pattern. There are also some  negative
+       error  codes that are used for invalid UTF strings when validity check-
+       ing is in force. These are the  same  as  given  by  pcre2_match()  and
        pcre2_dfa_match(), and are described in the pcre2unicode documentation.
-       There  is  no  separate documentation for the positive error codes, be-
-       cause the textual error messages  that  are  obtained  by  calling  the
+       There is no separate documentation for the positive  error  codes,  be-
+       cause  the  textual  error  messages  that  are obtained by calling the
        pcre2_get_error_message() function (see "Obtaining a textual error mes-
-       sage" below) should be  self-explanatory.  Macro  names  starting  with
-       PCRE2_ERROR_  are defined for both positive and negative error codes in
-       pcre2.h.
+       sage"  below)  should  be  self-explanatory.  Macro names starting with
+       PCRE2_ERROR_ are defined for both positive and negative error codes  in
+       pcre2.h.  When  compilation  is  successful errorcode is set to a value
+       that returns the message "no error" if passed  to  pcre2_get_error_mes-
+       sage().
 
        The value returned in erroroffset is an indication of where in the pat-
-       tern  the  error  occurred. It is not necessarily the furthest point in
-       the pattern that was read. For example, after the error "lookbehind as-
-       sertion  is  not fixed length", the error offset points to the start of
-       the failing assertion. For an invalid UTF-8 or UTF-16 string, the  off-
-       set is that of the first code unit of the failing character.
+       tern an error occurred. When there is no error,  zero  is  returned.  A
+       non-zero  value  is  not  necessarily the furthest point in the pattern
+       that was read. For example, after the error  "lookbehind  assertion  is
+       not  fixed length", the error offset points to the start of the failing
+       assertion. For an invalid UTF-8 or UTF-16 string, the offset is that of
+       the first code unit of the failing character.
 
        Some  errors are not detected until the whole pattern has been scanned;
        in these cases, the offset passed back is the length  of  the  pattern.
        Note  that  the  offset is in code units, not characters, even in a UTF
        mode. It may sometimes point into the middle of a UTF-8 or UTF-16 char-
        acter.
 
@@ -2492,15 +2490,17 @@
        When using pcre2_dfa_match() there may be multiple  matched  substrings
        of  different  lengths  at  the  same point in the subject. The ovector
        should be made large enough to hold as many as are expected.
 
        A minimum of at least 1 pair is imposed  by  pcre2_match_data_create(),
        so  it  is  always possible to return the overall matched string in the
        case  of  pcre2_match()  or  the  longest  match   in   the   case   of
-       pcre2_dfa_match().
+       pcre2_dfa_match().  The  maximum  number  of pairs is 65535; if the the
+       first argument of pcre2_match_data_create() is greater than this, 65535
+       is used.
 
        The second argument of pcre2_match_data_create() is a pointer to a gen-
        eral context, which can specify custom memory management for  obtaining
        the memory for the match data block. If you are not using custom memory
        management, pass NULL, which causes malloc() to be used.
 
        For pcre2_match_data_create_from_pattern(), the  first  argument  is  a
@@ -3045,20 +3045,20 @@
 
          PCRE2_ERROR_MATCHLIMIT
 
        The backtracking match limit was reached.
 
          PCRE2_ERROR_NOMEMORY
 
-       If  a  pattern contains many nested backtracking points, heap memory is
-       used to remember them. This error is given when the  memory  allocation
-       function  (default  or  custom)  fails.  Note  that  a different error,
-       PCRE2_ERROR_HEAPLIMIT, is given if the amount of memory needed  exceeds
-       the    heap   limit.   PCRE2_ERROR_NOMEMORY   is   also   returned   if
-       PCRE2_COPY_MATCHED_SUBJECT is set and memory allocation fails.
+       Heap  memory  is  used  to  remember backgracking points. This error is
+       given when the memory allocation function (default  or  custom)  fails.
+       Note  that  a  different  error, PCRE2_ERROR_HEAPLIMIT, is given if the
+       amount of memory needed exceeds the heap limit. PCRE2_ERROR_NOMEMORY is
+       also  returned  if PCRE2_COPY_MATCHED_SUBJECT is set and memory alloca-
+       tion fails.
 
          PCRE2_ERROR_NULL
 
        Either the code, subject, or match_data argument was passed as NULL.
 
          PCRE2_ERROR_RECURSELOOP
 
@@ -3854,16 +3854,16 @@
        Philip Hazel
        Retired from University Computing Service
        Cambridge, England.
 
 
 REVISION
 
-       Last updated: 14 December 2021
-       Copyright (c) 1997-2021 University of Cambridge.
+       Last updated: 27 July 2022
+       Copyright (c) 1997-2022 University of Cambridge.
 ------------------------------------------------------------------------------
 
 
 PCRE2BUILD(3)              Library Functions Manual              PCRE2BUILD(3)
 
 
 
@@ -4112,252 +4112,251 @@
 
          --with-match-limit=500000
 
        to   the   configure   command.   This  setting  also  applies  to  the
        pcre2_dfa_match() matching function, and to JIT  matching  (though  the
        counting is done differently).
 
-       The  pcre2_match() function starts out using a 20KiB vector on the sys-
-       tem stack to record backtracking points. The more  nested  backtracking
-       points there are (that is, the deeper the search tree), the more memory
-       is needed. If the initial vector is not large enough,  heap  memory  is
-       used,  up to a certain limit, which is specified in kibibytes (units of
-       1024 bytes). The limit can be changed at run time, as described in  the
-       pcre2api  documentation.  The default limit (in effect unlimited) is 20
-       million. You can change this by a setting such as
+       The  pcre2_match()  function  uses  heap  memory to record backtracking
+       points. The more nested backtracking points there  are  (that  is,  the
+       deeper  the  search tree), the more memory is needed. There is an upper
+       limit, specified in kibibytes (units of 1024 bytes). This limit can  be
+       changed  at  run  time, as described in the pcre2api documentation. The
+       default limit (in effect unlimited) is 20 million. You can change  this
+       by a setting such as
 
          --with-heap-limit=500
 
-       which limits the amount of heap to 500 KiB. This limit applies only  to
+       which  limits the amount of heap to 500 KiB. This limit applies only to
        interpretive matching in pcre2_match() and pcre2_dfa_match(), which may
-       also use the heap for internal workspace  when  processing  complicated
-       patterns.  This limit does not apply when JIT (which has its own memory
+       also  use  the  heap for internal workspace when processing complicated
+       patterns. This limit does not apply when JIT (which has its own  memory
        arrangements) is used.
 
-       You can also explicitly limit the depth of nested backtracking  in  the
+       You  can  also explicitly limit the depth of nested backtracking in the
        pcre2_match() interpreter. This limit defaults to the value that is set
-       for --with-match-limit. You can set a lower default  limit  by  adding,
+       for  --with-match-limit.  You  can set a lower default limit by adding,
        for example,
 
          --with-match-limit-depth=10000
 
-       to  the  configure  command.  This value can be overridden at run time.
-       This depth limit indirectly limits the amount of heap  memory  that  is
-       used,  but because the size of each backtracking "frame" depends on the
-       number of capturing parentheses in a pattern, the amount of  heap  that
-       is  used  before  the  limit is reached varies from pattern to pattern.
+       to the configure command. This value can be  overridden  at  run  time.
+       This  depth  limit  indirectly limits the amount of heap memory that is
+       used, but because the size of each backtracking "frame" depends on  the
+       number  of  capturing parentheses in a pattern, the amount of heap that
+       is used before the limit is reached varies  from  pattern  to  pattern.
        This limit was more useful in versions before 10.30, where function re-
        cursion was used for backtracking.
 
        As well as applying to pcre2_match(), the depth limit also controls the
-       depth of recursive function calls in pcre2_dfa_match(). These are  used
-       for  lookaround  assertions,  atomic  groups, and recursion within pat-
+       depth  of recursive function calls in pcre2_dfa_match(). These are used
+       for lookaround assertions, atomic groups,  and  recursion  within  pat-
        terns.  The limit does not apply to JIT matching.
 
 
 CREATING CHARACTER TABLES AT BUILD TIME
 
        PCRE2 uses fixed tables for processing characters whose code points are
        less than 256. By default, PCRE2 is built with a set of tables that are
-       distributed in the file src/pcre2_chartables.c.dist. These  tables  are
+       distributed  in  the file src/pcre2_chartables.c.dist. These tables are
        for ASCII codes only. If you add
 
          --enable-rebuild-chartables
 
-       to  the  configure  command, the distributed tables are no longer used.
+       to the configure command, the distributed tables are  no  longer  used.
        Instead, a program called pcre2_dftables is compiled and run. This out-
        puts the source for new set of tables, created in the default locale of
-       your C run-time system. This method of replacing the  tables  does  not
+       your  C  run-time  system. This method of replacing the tables does not
        work if you are cross compiling, because pcre2_dftables needs to be run
        on the local host and therefore not compiled with the cross compiler.
 
        If you need to create alternative tables when cross compiling, you will
-       have  to  do so "by hand". There may also be other reasons for creating
-       tables manually.  To cause pcre2_dftables to  be  built  on  the  local
+       have to do so "by hand". There may also be other reasons  for  creating
+       tables  manually.   To  cause  pcre2_dftables  to be built on the local
        host, run a normal compiling command, and then run the program with the
        output file as its argument, for example:
 
          cc src/pcre2_dftables.c -o pcre2_dftables
          ./pcre2_dftables src/pcre2_chartables.c
 
-       This builds the tables in the default locale of the local host. If  you
+       This  builds the tables in the default locale of the local host. If you
        want to specify a locale, you must use the -L option:
 
          LC_ALL=fr_FR ./pcre2_dftables -L src/pcre2_chartables.c
 
        You can also specify -b (with or without -L). This causes the tables to
-       be written in binary instead of as source code. A set of binary  tables
-       can  be  loaded  into memory by an application and passed to pcre2_com-
+       be  written in binary instead of as source code. A set of binary tables
+       can be loaded into memory by an application and  passed  to  pcre2_com-
        pile() in the same way as tables created by calling pcre2_maketables().
-       The  tables are just a string of bytes, independent of hardware charac-
-       teristics such as endianness. This means they can be  bundled  with  an
-       application  that  runs in different environments, to ensure consistent
+       The tables are just a string of bytes, independent of hardware  charac-
+       teristics  such  as  endianness. This means they can be bundled with an
+       application that runs in different environments, to  ensure  consistent
        behaviour.
 
 
 USING EBCDIC CODE
 
-       PCRE2 assumes by default that it will run in an environment  where  the
-       character  code is ASCII or Unicode, which is a superset of ASCII. This
+       PCRE2  assumes  by default that it will run in an environment where the
+       character code is ASCII or Unicode, which is a superset of ASCII.  This
        is the case for most computer operating systems. PCRE2 can, however, be
        compiled to run in an 8-bit EBCDIC environment by adding
 
          --enable-ebcdic --disable-unicode
 
        to the configure command. This setting implies --enable-rebuild-charta-
-       bles. You should only use it if you know that you are in an EBCDIC  en-
+       bles.  You should only use it if you know that you are in an EBCDIC en-
        vironment (for example, an IBM mainframe operating system).
 
-       It  is  not possible to support both EBCDIC and UTF-8 codes in the same
-       version of the library. Consequently,  --enable-unicode  and  --enable-
+       It is not possible to support both EBCDIC and UTF-8 codes in  the  same
+       version  of  the  library. Consequently, --enable-unicode and --enable-
        ebcdic are mutually exclusive.
 
        The EBCDIC character that corresponds to an ASCII LF is assumed to have
-       the value 0x15 by default. However, in some EBCDIC  environments,  0x25
+       the  value  0x15 by default. However, in some EBCDIC environments, 0x25
        is used. In such an environment you should use
 
          --enable-ebcdic-nl25
 
        as well as, or instead of, --enable-ebcdic. The EBCDIC character for CR
-       has the same value as in ASCII, namely, 0x0d.  Whichever  of  0x15  and
+       has  the  same  value  as in ASCII, namely, 0x0d. Whichever of 0x15 and
        0x25 is not chosen as LF is made to correspond to the Unicode NEL char-
        acter (which, in Unicode, is 0x85).
 
        The options that select newline behaviour, such as --enable-newline-is-
        cr, and equivalent run-time options, refer to these character values in
        an EBCDIC environment.
 
 
 PCRE2GREP SUPPORT FOR EXTERNAL SCRIPTS
 
        By default pcre2grep supports the use of callouts with string arguments
-       within  the patterns it is matching. There are two kinds: one that gen-
+       within the patterns it is matching. There are two kinds: one that  gen-
        erates output using local code, and another that calls an external pro-
-       gram  or  script.   If --disable-pcre2grep-callout-fork is added to the
-       configure command, only the first kind  of  callout  is  supported;  if
-       --disable-pcre2grep-callout  is  used,  all callouts are completely ig-
-       nored. For more details of pcre2grep callouts, see the pcre2grep  docu-
+       gram or script.  If --disable-pcre2grep-callout-fork is  added  to  the
+       configure  command,  only  the  first  kind of callout is supported; if
+       --disable-pcre2grep-callout is used, all callouts  are  completely  ig-
+       nored.  For more details of pcre2grep callouts, see the pcre2grep docu-
        mentation.
 
 
 PCRE2GREP OPTIONS FOR COMPRESSED FILE SUPPORT
 
-       By  default,  pcre2grep reads all files as plain text. You can build it
-       so that it recognizes files whose names end in .gz or .bz2,  and  reads
+       By default, pcre2grep reads all files as plain text. You can  build  it
+       so  that  it recognizes files whose names end in .gz or .bz2, and reads
        them with libz or libbz2, respectively, by adding one or both of
 
          --enable-pcre2grep-libz
          --enable-pcre2grep-libbz2
 
        to the configure command. These options naturally require that the rel-
-       evant libraries are installed on your system. Configuration  will  fail
+       evant  libraries  are installed on your system. Configuration will fail
        if they are not.
 
 
 PCRE2GREP BUFFER SIZE
 
-       pcre2grep  uses an internal buffer to hold a "window" on the file it is
+       pcre2grep uses an internal buffer to hold a "window" on the file it  is
        scanning, in order to be able to output "before" and "after" lines when
        it finds a match. The default starting size of the buffer is 20KiB. The
-       buffer itself is three times this size, but because of the  way  it  is
+       buffer  itself  is  three times this size, but because of the way it is
        used for holding "before" lines, the longest line that is guaranteed to
        be processable is the notional buffer size. If a longer line is encoun-
-       tered,  pcre2grep  automatically  expands the buffer, up to a specified
-       maximum size, whose default is 1MiB or the starting size, whichever  is
-       the  larger. You can change the default parameter values by adding, for
+       tered, pcre2grep automatically expands the buffer, up  to  a  specified
+       maximum  size, whose default is 1MiB or the starting size, whichever is
+       the larger. You can change the default parameter values by adding,  for
        example,
 
          --with-pcre2grep-bufsize=51200
          --with-pcre2grep-max-bufsize=2097152
 
-       to the configure command. The caller of pcre2grep  can  override  these
-       values  by  using  --buffer-size  and  --max-buffer-size on the command
+       to  the  configure  command. The caller of pcre2grep can override these
+       values by using --buffer-size  and  --max-buffer-size  on  the  command
        line.
 
 
 PCRE2TEST OPTION FOR LIBREADLINE SUPPORT
 
        If you add one of
 
          --enable-pcre2test-libreadline
          --enable-pcre2test-libedit
 
-       to the configure command, pcre2test is linked with the libreadline  or-
-       libedit  library,  respectively, and when its input is from a terminal,
-       it reads it using the readline() function. This  provides  line-editing
-       and  history  facilities.  Note that libreadline is GPL-licensed, so if
-       you distribute a binary of pcre2test linked in this way, there  may  be
+       to  the configure command, pcre2test is linked with the libreadline or-
+       libedit library, respectively, and when its input is from  a  terminal,
+       it  reads  it using the readline() function. This provides line-editing
+       and history facilities. Note that libreadline is  GPL-licensed,  so  if
+       you  distribute  a binary of pcre2test linked in this way, there may be
        licensing issues. These can be avoided by linking instead with libedit,
        which has a BSD licence.
 
-       Setting --enable-pcre2test-libreadline causes the -lreadline option  to
-       be  added to the pcre2test build. In many operating environments with a
-       sytem-installed readline library this is sufficient. However,  in  some
+       Setting  --enable-pcre2test-libreadline causes the -lreadline option to
+       be added to the pcre2test build. In many operating environments with  a
+       sytem-installed  readline  library this is sufficient. However, in some
        environments (e.g. if an unmodified distribution version of readline is
-       in use), some extra configuration may be necessary.  The  INSTALL  file
+       in  use),  some  extra configuration may be necessary. The INSTALL file
        for libreadline says this:
 
          "Readline uses the termcap functions, but does not link with
          the termcap or curses library itself, allowing applications
          which link with readline the to choose an appropriate library."
 
-       If  your environment has not been set up so that an appropriate library
+       If your environment has not been set up so that an appropriate  library
        is automatically included, you may need to add something like
 
          LIBS="-ncurses"
 
        immediately before the configure command.
 
 
 INCLUDING DEBUGGING CODE
 
        If you add
 
          --enable-debug
 
-       to the configure command, additional debugging code is included in  the
+       to  the configure command, additional debugging code is included in the
        build. This feature is intended for use by the PCRE2 maintainers.
 
 
 DEBUGGING WITH VALGRIND SUPPORT
 
        If you add
 
          --enable-valgrind
 
-       to  the  configure command, PCRE2 will use valgrind annotations to mark
-       certain memory regions as unaddressable. This allows it to  detect  in-
+       to the configure command, PCRE2 will use valgrind annotations  to  mark
+       certain  memory  regions as unaddressable. This allows it to detect in-
        valid memory accesses, and is mostly useful for debugging PCRE2 itself.
 
 
 CODE COVERAGE REPORTING
 
-       If  your  C  compiler is gcc, you can build a version of PCRE2 that can
+       If your C compiler is gcc, you can build a version of  PCRE2  that  can
        generate a code coverage report for its test suite. To enable this, you
        must install lcov version 1.6 or above. Then specify
 
          --enable-coverage
 
        to the configure command and build PCRE2 in the usual way.
 
        Note that using ccache (a caching C compiler) is incompatible with code
-       coverage reporting. If you have configured ccache to run  automatically
+       coverage  reporting. If you have configured ccache to run automatically
        on your system, you must set the environment variable
 
          CCACHE_DISABLE=1
 
        before running make to build PCRE2, so that ccache is not used.
 
-       When  --enable-coverage  is  used,  the  following addition targets are
+       When --enable-coverage is used,  the  following  addition  targets  are
        added to the Makefile:
 
          make coverage
 
-       This creates a fresh coverage report for the PCRE2 test  suite.  It  is
-       equivalent  to running "make coverage-reset", "make coverage-baseline",
+       This  creates  a  fresh coverage report for the PCRE2 test suite. It is
+       equivalent to running "make coverage-reset", "make  coverage-baseline",
        "make check", and then "make coverage-report".
 
          make coverage-reset
 
        This zeroes the coverage counters, but does nothing else.
 
          make coverage-baseline
@@ -4366,100 +4365,100 @@
 
          make coverage-report
 
        This creates the coverage report.
 
          make coverage-clean-report
 
-       This removes the generated coverage report without cleaning the  cover-
+       This  removes the generated coverage report without cleaning the cover-
        age data itself.
 
          make coverage-clean-data
 
-       This  removes  the captured coverage data without removing the coverage
+       This removes the captured coverage data without removing  the  coverage
        files created at compile time (*.gcno).
 
          make coverage-clean
 
-       This cleans all coverage data including the generated coverage  report.
-       For  more  information about code coverage, see the gcov and lcov docu-
+       This  cleans all coverage data including the generated coverage report.
+       For more information about code coverage, see the gcov and  lcov  docu-
        mentation.
 
 
 DISABLING THE Z AND T FORMATTING MODIFIERS
 
-       The C99 standard defines formatting modifiers z and t  for  size_t  and
-       ptrdiff_t  values, respectively. By default, PCRE2 uses these modifiers
+       The  C99  standard  defines formatting modifiers z and t for size_t and
+       ptrdiff_t values, respectively. By default, PCRE2 uses these  modifiers
        in environments other than old versions of Microsoft Visual Studio when
-       __STDC_VERSION__  is  defined  and has a value greater than or equal to
-       199901L (indicating support for C99).  However, there is at  least  one
+       __STDC_VERSION__ is defined and has a value greater than  or  equal  to
+       199901L  (indicating  support for C99).  However, there is at least one
        environment that claims to be C99 but does not support these modifiers.
        If
 
          --disable-percent-zt
 
        is specified, no use is made of the z or t modifiers. Instead of %td or
-       %zu,  a  suitable  format is used depending in the size of long for the
+       %zu, a suitable format is used depending in the size of  long  for  the
        platform.
 
 
 SUPPORT FOR FUZZERS
 
-       There is a special option for use by people who  want  to  run  fuzzing
+       There  is  a  special  option for use by people who want to run fuzzing
        tests on PCRE2:
 
          --enable-fuzz-support
 
        At present this applies only to the 8-bit library. If set, it causes an
-       extra library called libpcre2-fuzzsupport.a to be built,  but  not  in-
-       stalled.  This  contains  a single function called LLVMFuzzerTestOneIn-
-       put() whose arguments are a pointer to a string and the length  of  the
-       string.  When  called,  this  function tries to compile the string as a
-       pattern, and if that succeeds, to match it.  This is done both with  no
-       options  and  with some random options bits that are generated from the
+       extra  library  called  libpcre2-fuzzsupport.a to be built, but not in-
+       stalled. This contains a single  function  called  LLVMFuzzerTestOneIn-
+       put()  whose  arguments are a pointer to a string and the length of the
+       string. When called, this function tries to compile  the  string  as  a
+       pattern,  and if that succeeds, to match it.  This is done both with no
+       options and with some random options bits that are generated  from  the
        string.
 
-       Setting --enable-fuzz-support also causes  a  binary  called  pcre2fuz-
-       zcheck  to be created. This is normally run under valgrind or used when
+       Setting  --enable-fuzz-support  also  causes  a binary called pcre2fuz-
+       zcheck to be created. This is normally run under valgrind or used  when
        PCRE2 is compiled with address sanitizing enabled. It calls the fuzzing
-       function  and  outputs  information  about  what it is doing. The input
-       strings are specified by arguments: if an argument starts with "="  the
-       rest  of it is a literal input string. Otherwise, it is assumed to be a
+       function and outputs information about what  it  is  doing.  The  input
+       strings  are specified by arguments: if an argument starts with "=" the
+       rest of it is a literal input string. Otherwise, it is assumed to be  a
        file name, and the contents of the file are the test string.
 
 
 OBSOLETE OPTION
 
-       In versions of PCRE2 prior to 10.30, there were two  ways  of  handling
-       backtracking  in the pcre2_match() function. The default was to use the
+       In  versions  of  PCRE2 prior to 10.30, there were two ways of handling
+       backtracking in the pcre2_match() function. The default was to use  the
        system stack, but if
 
          --disable-stack-for-recursion
 
-       was set, memory on the heap was used. From release 10.30  onwards  this
-       has  changed  (the  stack  is  no longer used) and this option now does
+       was  set,  memory on the heap was used. From release 10.30 onwards this
+       has changed (the stack is no longer used)  and  this  option  now  does
        nothing except give a warning.
 
 
 SEE ALSO
 
        pcre2api(3), pcre2-config(3).
 
 
 AUTHOR
 
        Philip Hazel
-       University Computing Service
+       Retired from University Computing Service
        Cambridge, England.
 
 
 REVISION
 
-       Last updated: 08 December 2021
-       Copyright (c) 1997-2021 University of Cambridge.
+       Last updated: 27 July 2022
+       Copyright (c) 1997-2022 University of Cambridge.
 ------------------------------------------------------------------------------
 
 
 PCRE2CALLOUT(3)            Library Functions Manual            PCRE2CALLOUT(3)
 
 
 
@@ -5590,26 +5589,30 @@
        The maximum length of a  name  in  a  (*MARK),  (*PRUNE),  (*SKIP),  or
        (*THEN)  verb  is  255  code units for the 8-bit library and 65535 code
        units for the 16-bit and 32-bit libraries.
 
        The maximum length of a string argument to a  callout  is  the  largest
        number a 32-bit unsigned integer can hold.
 
+       The  maximum  amount  of heap memory used for matching is controlled by
+       the heap limit, which can be set in a pattern or in  a  match  context.
+       The default is a very large number, effectively unlimited.
+
 
 AUTHOR
 
        Philip Hazel
-       University Computing Service
+       Retired from University Computing Service
        Cambridge, England.
 
 
 REVISION
 
-       Last updated: 02 February 2019
-       Copyright (c) 1997-2019 University of Cambridge.
+       Last updated: 26 July 2022
+       Copyright (c) 1997-2022 University of Cambridge.
 ------------------------------------------------------------------------------
 
 
 PCRE2MATCHING(3)           Library Functions Manual           PCRE2MATCHING(3)
 
 
 
@@ -9767,175 +9770,192 @@
 STACK AND HEAP USAGE AT RUN TIME
 
        From release 10.30, the interpretive (non-JIT) version of pcre2_match()
        uses  very  little system stack at run time. In earlier releases recur-
        sive function calls could use a great deal of  stack,  and  this  could
        cause  problems, but this usage has been eliminated. Backtracking posi-
        tions are now explicitly remembered in memory frames controlled by  the
-       code.  An  initial  20KiB  vector  of frames is allocated on the system
-       stack (enough for about 100 frames for small patterns), but if this  is
-       insufficient,  heap  memory  is  used. The amount of heap memory can be
-       limited; if the limit is set to zero, only the initial stack vector  is
-       used.  Rewriting patterns to be time-efficient, as described below, may
-       also reduce the memory requirements.
+       code.
+
+       The size of each frame depends on the size of pointer variables and the
+       number of capturing parenthesized groups in the pattern being  matched.
+       On a 64-bit system the frame size for a pattern with no captures is 128
+       bytes. For each capturing group the size increases by 16 bytes.
+
+       Until release 10.41, an initial 20KiB frames vector  was  allocated  on
+       the  system  stack,  but this still caused some issues for multi-thread
+       applications where each thread has a very  small  stack.  From  release
+       10.41  backtracking  memory  frames  are always held in heap memory. An
+       initial heap allocation is obtained the first time any match data block
+       is  passed  to  pcre2_match().  This  is remembered with the match data
+       block and re-used if that block is used for another match. It is  freed
+       when the match data block itself is freed.
+
+       The  size  of the initial block is the larger of 20KiB or ten times the
+       pattern's frame size, unless the heap limit is less than this, in which
+       case  the  heap  limit  is  used. If the initial block proves to be too
+       small during matching, it is replaced by a larger block, subject to the
+       heap  limit.  The  heap limit is checked only when a new block is to be
+       allocated. Reducing the heap limit between calls to pcre2_match()  with
+       the same match data block does not affect the saved block.
 
-       In contrast to  pcre2_match(),  pcre2_dfa_match()  does  use  recursive
-       function  calls,  but only for processing atomic groups, lookaround as-
+       In  contrast  to  pcre2_match(),  pcre2_dfa_match()  does use recursive
+       function calls, but only for processing atomic groups,  lookaround  as-
        sertions, and recursion within the pattern. The original version of the
-       code  used  to  allocate  quite large internal workspace vectors on the
-       stack, which caused some problems for  some  patterns  in  environments
-       with  small  stacks.  From release 10.32 the code for pcre2_dfa_match()
-       has been re-factored to use heap memory  when  necessary  for  internal
-       workspace  when  recursing,  though  recursive function calls are still
+       code used to allocate quite large internal  workspace  vectors  on  the
+       stack,  which  caused  some  problems for some patterns in environments
+       with small stacks. From release 10.32 the  code  for  pcre2_dfa_match()
+       has  been  re-factored  to  use heap memory when necessary for internal
+       workspace when recursing, though recursive  function  calls  are  still
        used.
 
-       The "match depth" parameter can be used to limit the depth of  function
-       recursion,  and  the  "match  heap"  parameter  to limit heap memory in
+       The  "match depth" parameter can be used to limit the depth of function
+       recursion, and the "match heap"  parameter  to  limit  heap  memory  in
        pcre2_dfa_match().
 
 
 PROCESSING TIME
 
-       Certain items in regular expression patterns are processed  more  effi-
+       Certain  items  in regular expression patterns are processed more effi-
        ciently than others. It is more efficient to use a character class like
-       [aeiou]  than  a  set  of   single-character   alternatives   such   as
-       (a|e|i|o|u).  In  general,  the simplest construction that provides the
+       [aeiou]   than   a   set   of  single-character  alternatives  such  as
+       (a|e|i|o|u). In general, the simplest construction  that  provides  the
        required behaviour is usually the most efficient. Jeffrey Friedl's book
-       contains  a  lot  of useful general discussion about optimizing regular
+       contains a lot of useful general discussion  about  optimizing  regular
        expressions for efficient performance. This document contains a few ob-
        servations about PCRE2.
 
-       Using  Unicode  character  properties  (the  \p, \P, and \X escapes) is
-       slow, because PCRE2 has to use a multi-stage table lookup  whenever  it
-       needs  a  character's  property. If you can find an alternative pattern
+       Using Unicode character properties (the \p,  \P,  and  \X  escapes)  is
+       slow,  because  PCRE2 has to use a multi-stage table lookup whenever it
+       needs a character's property. If you can find  an  alternative  pattern
        that does not use character properties, it will probably be faster.
 
-       By default, the escape sequences \b, \d, \s,  and  \w,  and  the  POSIX
-       character  classes  such  as  [:alpha:]  do not use Unicode properties,
+       By  default,  the  escape  sequences  \b, \d, \s, and \w, and the POSIX
+       character classes such as [:alpha:]  do  not  use  Unicode  properties,
        partly for backwards compatibility, and partly for performance reasons.
-       However,  you  can  set  the PCRE2_UCP option or start the pattern with
-       (*UCP) if you want Unicode character properties to be  used.  This  can
-       double  the  matching  time  for  items  such  as \d, when matched with
-       pcre2_match(); the performance loss is less with a DFA  matching  func-
+       However, you can set the PCRE2_UCP option or  start  the  pattern  with
+       (*UCP)  if  you  want Unicode character properties to be used. This can
+       double the matching time for  items  such  as  \d,  when  matched  with
+       pcre2_match();  the  performance loss is less with a DFA matching func-
        tion, and in both cases there is not much difference for \b.
 
-       When  a pattern begins with .* not in atomic parentheses, nor in paren-
-       theses that are the subject of a backreference,  and  the  PCRE2_DOTALL
-       option  is  set,  the pattern is implicitly anchored by PCRE2, since it
-       can match only at the start of a subject string.  If  the  pattern  has
+       When a pattern begins with .* not in atomic parentheses, nor in  paren-
+       theses  that  are  the subject of a backreference, and the PCRE2_DOTALL
+       option is set, the pattern is implicitly anchored by  PCRE2,  since  it
+       can  match  only  at  the start of a subject string. If the pattern has
        multiple top-level branches, they must all be anchorable. The optimiza-
-       tion can be disabled by the PCRE2_NO_DOTSTAR_ANCHOR option, and is  au-
+       tion  can be disabled by the PCRE2_NO_DOTSTAR_ANCHOR option, and is au-
        tomatically disabled if the pattern contains (*PRUNE) or (*SKIP).
 
-       If  PCRE2_DOTALL  is  not set, PCRE2 cannot make this optimization, be-
-       cause the dot metacharacter does not then match a newline, and  if  the
-       subject  string contains newlines, the pattern may match from the char-
+       If PCRE2_DOTALL is not set, PCRE2 cannot make  this  optimization,  be-
+       cause  the  dot metacharacter does not then match a newline, and if the
+       subject string contains newlines, the pattern may match from the  char-
        acter immediately following one of them instead of from the very start.
        For example, the pattern
 
          .*second
 
-       matches  the subject "first\nand second" (where \n stands for a newline
-       character), with the match starting at the seventh character. In  order
-       to  do  this, PCRE2 has to retry the match starting after every newline
+       matches the subject "first\nand second" (where \n stands for a  newline
+       character),  with the match starting at the seventh character. In order
+       to do this, PCRE2 has to retry the match starting after  every  newline
        in the subject.
 
-       If you are using such a pattern with subject strings that do  not  con-
-       tain   newlines,   the   best   performance   is  obtained  by  setting
-       PCRE2_DOTALL, or starting the pattern with ^.* or ^.*? to indicate  ex-
-       plicit  anchoring.  That saves PCRE2 from having to scan along the sub-
+       If  you  are using such a pattern with subject strings that do not con-
+       tain  newlines,  the  best   performance   is   obtained   by   setting
+       PCRE2_DOTALL,  or starting the pattern with ^.* or ^.*? to indicate ex-
+       plicit anchoring. That saves PCRE2 from having to scan along  the  sub-
        ject looking for a newline to restart at.
 
-       Beware of patterns that contain nested indefinite  repeats.  These  can
-       take  a  long time to run when applied to a string that does not match.
+       Beware  of  patterns  that contain nested indefinite repeats. These can
+       take a long time to run when applied to a string that does  not  match.
        Consider the pattern fragment
 
          ^(a+)*
 
-       This can match "aaaa" in 16 different ways, and this  number  increases
-       very  rapidly  as the string gets longer. (The * repeat can match 0, 1,
-       2, 3, or 4 times, and for each of those cases other than 0 or 4, the  +
-       repeats  can  match  different numbers of times.) When the remainder of
-       the pattern is such that the entire match is going to fail,  PCRE2  has
-       in  principle to try every possible variation, and this can take an ex-
+       This  can  match "aaaa" in 16 different ways, and this number increases
+       very rapidly as the string gets longer. (The * repeat can match  0,  1,
+       2,  3, or 4 times, and for each of those cases other than 0 or 4, the +
+       repeats can match different numbers of times.) When  the  remainder  of
+       the  pattern  is such that the entire match is going to fail, PCRE2 has
+       in principle to try every possible variation, and this can take an  ex-
        tremely long time, even for relatively short strings.
 
        An optimization catches some of the more simple cases such as
 
          (a+)*b
 
-       where a literal character follows. Before  embarking  on  the  standard
-       matching  procedure, PCRE2 checks that there is a "b" later in the sub-
-       ject string, and if there is not, it fails the match immediately.  How-
-       ever,  when  there  is no following literal this optimization cannot be
+       where  a  literal  character  follows. Before embarking on the standard
+       matching procedure, PCRE2 checks that there is a "b" later in the  sub-
+       ject  string, and if there is not, it fails the match immediately. How-
+       ever, when there is no following literal this  optimization  cannot  be
        used. You can see the difference by comparing the behaviour of
 
          (a+)*\d
 
-       with the pattern above. The former gives  a  failure  almost  instantly
-       when  applied  to  a  whole  line of "a" characters, whereas the latter
+       with  the  pattern  above.  The former gives a failure almost instantly
+       when applied to a whole line of  "a"  characters,  whereas  the  latter
        takes an appreciable time with strings longer than about 20 characters.
 
        In many cases, the solution to this kind of performance issue is to use
-       an  atomic group or a possessive quantifier. This can often reduce mem-
+       an atomic group or a possessive quantifier. This can often reduce  mem-
        ory requirements as well. As another example, consider this pattern:
 
          ([^<]|<(?!inet))+
 
-       It matches from wherever it starts until it encounters "<inet"  or  the
-       end  of  the  data,  and is the kind of pattern that might be used when
+       It  matches  from wherever it starts until it encounters "<inet" or the
+       end of the data, and is the kind of pattern that  might  be  used  when
        processing an XML file. Each iteration of the outer parentheses matches
-       either  one  character that is not "<" or a "<" that is not followed by
-       "inet". However, each time a parenthesis is processed,  a  backtracking
-       position  is  passed,  so this formulation uses a memory frame for each
+       either one character that is not "<" or a "<" that is not  followed  by
+       "inet".  However,  each time a parenthesis is processed, a backtracking
+       position is passed, so this formulation uses a memory  frame  for  each
        matched character. For a long string, a lot of memory is required. Con-
-       sider  now  this  rewritten  pattern,  which  matches  exactly the same
+       sider now this  rewritten  pattern,  which  matches  exactly  the  same
        strings:
 
          ([^<]++|<(?!inet))+
 
        This runs much faster, because sequences of characters that do not con-
        tain "<" are "swallowed" in one item inside the parentheses, and a pos-
-       sessive quantifier is used to stop any backtracking into  the  runs  of
-       non-"<"  characters.  This  version also uses a lot less memory because
-       entry to a new set of parentheses happens only  when  a  "<"  character
-       that  is  not  followed by "inet" is encountered (and we assume this is
+       sessive  quantifier  is  used to stop any backtracking into the runs of
+       non-"<" characters. This version also uses a lot  less  memory  because
+       entry  to  a  new  set of parentheses happens only when a "<" character
+       that is not followed by "inet" is encountered (and we  assume  this  is
        relatively rare).
 
        This example shows that one way of optimizing performance when matching
-       long  subject strings is to write repeated parenthesized subpatterns to
+       long subject strings is to write repeated parenthesized subpatterns  to
        match more than one character whenever possible.
 
    SETTING RESOURCE LIMITS
 
-       You can set limits on the amount of processing that  takes  place  when
-       matching,  and  on  the amount of heap memory that is used. The default
+       You  can  set  limits on the amount of processing that takes place when
+       matching, and on the amount of heap memory that is  used.  The  default
        values of the limits are very large, and unlikely ever to operate. They
-       can  be  changed  when  PCRE2  is  built, and they can also be set when
-       pcre2_match() or pcre2_dfa_match() is called. For details of these  in-
-       terfaces,  see  the  pcre2build  documentation and the section entitled
+       can be changed when PCRE2 is built, and  they  can  also  be  set  when
+       pcre2_match()  or pcre2_dfa_match() is called. For details of these in-
+       terfaces, see the pcre2build documentation  and  the  section  entitled
        "The match context" in the pcre2api documentation.
 
-       The pcre2test test program has a modifier called  "find_limits"  which,
-       if  applied  to  a  subject line, causes it to find the smallest limits
+       The  pcre2test  test program has a modifier called "find_limits" which,
+       if applied to a subject line, causes it to  find  the  smallest  limits
        that allow a pattern to match. This is done by repeatedly matching with
        different limits.
 
 
 AUTHOR
 
        Philip Hazel
-       University Computing Service
+       Retired from University Computing Service
        Cambridge, England.
 
 
 REVISION
 
-       Last updated: 03 February 2019
-       Copyright (c) 1997-2019 University of Cambridge.
+       Last updated: 27 July 2022
+       Copyright (c) 1997-2022 University of Cambridge.
 ------------------------------------------------------------------------------
 
 
 PCRE2POSIX(3)              Library Functions Manual              PCRE2POSIX(3)
 
 
 
@@ -10430,15 +10450,15 @@
        which can be used to specify custom memory  mangagement  functions.  If
        this  argument  is NULL, malloc() is used to obtain memory for the byte
        stream. The yield of the function is the number of serialized patterns,
        or one of the following negative error codes:
 
          PCRE2_ERROR_BADDATA      the number of patterns is zero or less
          PCRE2_ERROR_BADMAGIC     mismatch of id bytes in one of the patterns
-         PCRE2_ERROR_MEMORY       memory allocation failed
+         PCRE2_ERROR_NOMEMORY     memory allocation failed
          PCRE2_ERROR_MIXEDTABLES  the patterns do not all use the same tables
          PCRE2_ERROR_NULL         the 1st, 3rd, or 4th argument is NULL
 
        PCRE2_ERROR_BADMAGIC  means  either that a pattern's code has been cor-
        rupted, or that a slot in the vector does not point to a compiled  pat-
        tern.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_callout_enumerate.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_callout_enumerate.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_code_copy.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_code_copy.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_code_copy_with_tables.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_code_copy_with_tables.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_code_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_code_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_compile.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_compile.3`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-.TH PCRE2_COMPILE 3 "23 May 2019" "PCRE2 10.34"
+.TH PCRE2_COMPILE 3 "22 April 2022" "PCRE2 10.41"
 .SH NAME
 PCRE2 - Perl-compatible regular expressions (revised API)
 .SH SYNOPSIS
 .rs
 .sp
 .B #include <pcre2.h>
 .PP
@@ -76,16 +76,25 @@
 .P
 Additional options may be set in the compile context via the
 .\" HREF
 \fBpcre2_set_compile_extra_options\fP
 .\"
 function.
 .P
-The yield of this function is a pointer to a private data structure that
-contains the compiled pattern, or NULL if an error was detected.
+If either of \fIerrorcode\fP or \fIerroroffset\fP is NULL, the function returns
+NULL immediately. Otherwise, the yield of this function is a pointer to a
+private data structure that contains the compiled pattern, or NULL if an error
+was detected. In the error case, a text error message can be obtained by
+passing the value returned via the \fIerrorcode\fP argument to the the
+\fBpcre2_get_error_message()\fP function. The offset (in code units) where the
+error was encountered is returned via the \fIerroroffset\fP argument.
+.P
+If there is no error, the value passed via \fIerrorcode\fP returns the message
+"no error" if passed to \fBpcre2_get_error_message()\fP, and the value passed
+via \fIerroroffset\fP is zero.
 .P
 There is a complete description of the PCRE2 native API, with more detail on
 each option, in the
 .\" HREF
 \fBpcre2api\fP
 .\"
 page, and a description of the POSIX API in the
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_compile_context_copy.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_compile_context_copy.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_compile_context_create.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_compile_context_create.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_compile_context_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_compile_context_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_config.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_config.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_convert_context_copy.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_convert_context_copy.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_convert_context_create.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_convert_context_create.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_convert_context_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_convert_context_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_converted_pattern_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_converted_pattern_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_dfa_match.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_dfa_match.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_general_context_copy.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_general_context_copy.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_general_context_create.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_general_context_create.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_general_context_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_general_context_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_get_error_message.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_get_error_message.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_get_mark.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_get_mark.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_get_match_data_size.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_get_match_data_size.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_get_ovector_count.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_get_ovector_count.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_get_ovector_pointer.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_get_ovector_pointer.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_get_startchar.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_get_startchar.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_compile.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_compile.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_free_unused_memory.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_free_unused_memory.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_match.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_match.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_stack_assign.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_stack_assign.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_stack_create.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_stack_create.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_jit_stack_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_jit_stack_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_maketables.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_maketables.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_maketables_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_maketables_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_match.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_match.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_match_context_copy.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_match_context_copy.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_match_context_create.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_match_context_create.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_match_context_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_match_context_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_match_data_create.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_match_data_create.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_match_data_create_from_pattern.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_match_data_create_from_pattern.3`

 * *Files 1% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 This function creates a new match data block for holding the result of a match.
 The first argument points to a compiled pattern. The number of capturing
 parentheses within the pattern is used to compute the number of pairs of
 offsets that are required in the match data block. These form the "output
 vector" (ovector) within the match data block, and are used to identify the
 matched string and any captured substrings when matching with
 \fBpcre2_match()\fP. If you are using \fBpcre2_dfa_match()\fP, which uses the
-outut vector in a different way, you should use \fBpcre2_match_data_create()\fP
+output vector in a different way, you should use \fBpcre2_match_data_create()\fP
 instead of this function.
 .P
 The second argument points to a general context, for custom memory management,
 or is NULL to use the same memory allocator as was used for the compiled
 pattern. The result of the function is NULL if the memory for the block could
 not be obtained.
 .P
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_match_data_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_match_data_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_pattern_convert.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_pattern_convert.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_pattern_info.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_pattern_info.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_serialize_decode.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_serialize_decode.3`

 * *Files 1% similar despite different names*

```diff
@@ -32,15 +32,15 @@
 data than slots in the list, only those compiled patterns that will fit are
 decoded. The yield of the function is the number of decoded patterns, or one of
 the following negative error codes:
 .sp
   PCRE2_ERROR_BADDATA   \fInumber_of_codes\fP is zero or less
   PCRE2_ERROR_BADMAGIC  mismatch of id bytes in \fIbytes\fP
   PCRE2_ERROR_BADMODE   mismatch of variable unit size or PCRE version
-  PCRE2_ERROR_MEMORY    memory allocation failed
+  PCRE2_ERROR_NOMEMORY  memory allocation failed
   PCRE2_ERROR_NULL      \fIcodes\fP or \fIbytes\fP is NULL
 .sp
 PCRE2_ERROR_BADMAGIC may mean that the data is corrupt, or that it was compiled
 on a system with different endianness.
 .P
 There is a complete description of the PCRE2 native API in the
 .\" HREF
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_serialize_encode.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_serialize_encode.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_serialize_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_serialize_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_serialize_get_number_of_codes.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_serialize_get_number_of_codes.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_bsr.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_bsr.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_callout.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_callout.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_character_tables.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_character_tables.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_compile_extra_options.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_compile_extra_options.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_compile_recursion_guard.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_compile_recursion_guard.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_depth_limit.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_depth_limit.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_glob_escape.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_glob_escape.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_glob_separator.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_glob_separator.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_heap_limit.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_heap_limit.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_match_limit.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_match_limit.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_max_pattern_length.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_max_pattern_length.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_newline.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_newline.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_offset_limit.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_offset_limit.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_parens_nest_limit.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_parens_nest_limit.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_recursion_limit.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_recursion_limit.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_recursion_memory_management.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_recursion_memory_management.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_set_substitute_callout.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_set_substitute_callout.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substitute.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substitute.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_copy_byname.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_copy_byname.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_copy_bynumber.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_copy_bynumber.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_get_byname.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_get_byname.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_get_bynumber.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_get_bynumber.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_length_byname.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_length_byname.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_length_bynumber.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_length_bynumber.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_list_free.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_list_free.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_list_get.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_list_get.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_nametable_scan.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_nametable_scan.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2_substring_number_from_name.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2_substring_number_from_name.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2api.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2api.3`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-.TH PCRE2API 3 "14 December 2021" "PCRE2 10.40"
+.TH PCRE2API 3 "27 July 2022" "PCRE2 10.41"
 .SH NAME
 PCRE2 - Perl-compatible regular expressions (revised API)
 .sp
 .B #include <pcre2.h>
 .sp
 PCRE2 is a new API for PCRE, starting at release 10.0. This document contains a
 description of all its native functions. See the
@@ -949,37 +949,37 @@
 has its own memory control arrangements (see the
 .\" HREF
 \fBpcre2jit\fP
 .\"
 documentation for more details). If the limit is reached, the negative error
 code PCRE2_ERROR_HEAPLIMIT is returned. The default limit can be set when PCRE2
 is built; if it is not, the default is set very large and is essentially
-"unlimited".
+unlimited.
 .P
 A value for the heap limit may also be supplied by an item at the start of a
 pattern of the form
 .sp
   (*LIMIT_HEAP=ddd)
 .sp
 where ddd is a decimal number. However, such a setting is ignored unless ddd is
 less than the limit set by the caller of \fBpcre2_match()\fP or, if no such
 limit is set, less than the default.
 .P
-The \fBpcre2_match()\fP function starts out using a 20KiB vector on the system
-stack for recording backtracking points. The more nested backtracking points
-there are (that is, the deeper the search tree), the more memory is needed.
-Heap memory is used only if the initial vector is too small. If the heap limit
-is set to a value less than 21 (in particular, zero) no heap memory will be
-used. In this case, only patterns that do not have a lot of nested backtracking
-can be successfully processed.
-.P
-Similarly, for \fBpcre2_dfa_match()\fP, a vector on the system stack is used
-when processing pattern recursions, lookarounds, or atomic groups, and only if
-this is not big enough is heap memory used. In this case, too, setting a value
-of zero disables the use of the heap.
+The \fBpcre2_match()\fP function always needs some heap memory, so setting a
+value of zero guarantees a "heap limit exceeded" error. Details of how
+\fBpcre2_match()\fP uses the heap are given in the
+.\" HREF
+\fBpcre2perform\fP
+.\"
+documentation.
+.P
+For \fBpcre2_dfa_match()\fP, a vector on the system stack is used when
+processing pattern recursions, lookarounds, or atomic groups, and only if this
+is not big enough is heap memory used. In this case, setting a value of zero
+disables the use of the heap.
 .sp
 .nf
 .B int pcre2_set_match_limit(pcre2_match_context *\fImcontext\fP,
 .B "  uint32_t \fIvalue\fP);"
 .fi
 .sp
 The \fImatch_limit\fP parameter provides a means of preventing PCRE2 from using
@@ -1015,18 +1015,18 @@
 .sp
 .nf
 .B int pcre2_set_depth_limit(pcre2_match_context *\fImcontext\fP,
 .B "  uint32_t \fIvalue\fP);"
 .fi
 .sp
 This parameter limits the depth of nested backtracking in \fBpcre2_match()\fP.
-Each time a nested backtracking point is passed, a new memory "frame" is used
+Each time a nested backtracking point is passed, a new memory frame is used
 to remember the state of matching at that point. Thus, this parameter
 indirectly limits the amount of memory that is used in a match. However,
-because the size of each memory "frame" depends on the number of capturing
+because the size of each memory frame depends on the number of capturing
 parentheses, the actual memory limit varies from pattern to pattern. This limit
 was more useful in versions before 10.30, where function recursion was used for
 backtracking.
 .P
 The depth limit is not relevant, and is ignored, when matching is done using
 JIT compiled code. However, it is supported by \fBpcre2_dfa_match()\fP, which
 uses it to limit the depth of nested internal recursive function calls that
@@ -1319,16 +1319,15 @@
 above).
 .\"
 .P
 If \fIerrorcode\fP or \fIerroroffset\fP is NULL, \fBpcre2_compile()\fP returns
 NULL immediately. Otherwise, the variables to which these point are set to an
 error code and an offset (number of code units) within the pattern,
 respectively, when \fBpcre2_compile()\fP returns NULL because a compilation
-error has occurred. The values are not defined when compilation is successful
-and \fBpcre2_compile()\fP returns a non-NULL value.
+error has occurred.
 .P
 There are nearly 100 positive error codes that \fBpcre2_compile()\fP may return
 if it finds an error in the pattern. There are also some negative error codes
 that are used for invalid UTF strings when validity checking is in force. These
 are the same as given by \fBpcre2_match()\fP and \fBpcre2_dfa_match()\fP, and
 are described in the
 .\" HREF
@@ -1339,22 +1338,25 @@
 \fBpcre2_get_error_message()\fP function (see "Obtaining a textual error
 message"
 .\" HTML <a href="#geterrormessage">
 .\" </a>
 below)
 .\"
 should be self-explanatory. Macro names starting with PCRE2_ERROR_ are defined
-for both positive and negative error codes in \fBpcre2.h\fP.
+for both positive and negative error codes in \fBpcre2.h\fP. When compilation
+is successful \fIerrorcode\fP is set to a value that returns the message "no
+error" if passed to \fBpcre2_get_error_message()\fP.
 .P
 The value returned in \fIerroroffset\fP is an indication of where in the
-pattern the error occurred. It is not necessarily the furthest point in the
-pattern that was read. For example, after the error "lookbehind assertion is
-not fixed length", the error offset points to the start of the failing
-assertion. For an invalid UTF-8 or UTF-16 string, the offset is that of the
-first code unit of the failing character.
+pattern an error occurred. When there is no error, zero is returned. A non-zero
+value is not necessarily the furthest point in the pattern that was read. For
+example, after the error "lookbehind assertion is not fixed length", the error
+offset points to the start of the failing assertion. For an invalid UTF-8 or
+UTF-16 string, the offset is that of the first code unit of the failing
+character.
 .P
 Some errors are not detected until the whole pattern has been scanned; in these
 cases, the offset passed back is the length of the pattern. Note that the
 offset is in code units, not characters, even in a UTF mode. It may sometimes
 point into the middle of a UTF-8 or UTF-16 character.
 .P
 This code fragment shows a typical straightforward call to
@@ -2513,15 +2515,17 @@
 When using \fBpcre2_dfa_match()\fP there may be multiple matched substrings of
 different lengths at the same point in the subject. The ovector should be made
 large enough to hold as many as are expected.
 .P
 A minimum of at least 1 pair is imposed by \fBpcre2_match_data_create()\fP, so
 it is always possible to return the overall matched string in the case of
 \fBpcre2_match()\fP or the longest match in the case of
-\fBpcre2_dfa_match()\fP.
+\fBpcre2_dfa_match()\fP. The maximum number of pairs is 65535; if the the first
+argument of \fBpcre2_match_data_create()\fP is greater than this, 65535 is
+used.
 .P
 The second argument of \fBpcre2_match_data_create()\fP is a pointer to a
 general context, which can specify custom memory management for obtaining the
 memory for the match data block. If you are not using custom memory management,
 pass NULL, which causes \fBmalloc()\fP to be used.
 .P
 For \fBpcre2_match_data_create_from_pattern()\fP, the first argument is a
@@ -3156,19 +3160,19 @@
 .sp
   PCRE2_ERROR_MATCHLIMIT
 .sp
 The backtracking match limit was reached.
 .sp
   PCRE2_ERROR_NOMEMORY
 .sp
-If a pattern contains many nested backtracking points, heap memory is used to
-remember them. This error is given when the memory allocation function (default
-or custom) fails. Note that a different error, PCRE2_ERROR_HEAPLIMIT, is given
-if the amount of memory needed exceeds the heap limit. PCRE2_ERROR_NOMEMORY is
-also returned if PCRE2_COPY_MATCHED_SUBJECT is set and memory allocation fails.
+Heap memory is used to remember backgracking points. This error is given when
+the memory allocation function (default or custom) fails. Note that a different
+error, PCRE2_ERROR_HEAPLIMIT, is given if the amount of memory needed exceeds
+the heap limit. PCRE2_ERROR_NOMEMORY is also returned if
+PCRE2_COPY_MATCHED_SUBJECT is set and memory allocation fails.
 .sp
   PCRE2_ERROR_NULL
 .sp
 Either the \fIcode\fP, \fIsubject\fP, or \fImatch_data\fP argument was passed
 as NULL.
 .sp
   PCRE2_ERROR_RECURSELOOP
@@ -4021,10 +4025,10 @@
 .fi
 .
 .
 .SH REVISION
 .rs
 .sp
 .nf
-Last updated: 14 December 2021
-Copyright (c) 1997-2021 University of Cambridge.
+Last updated: 27 July 2022
+Copyright (c) 1997-2022 University of Cambridge.
 .fi
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2build.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2build.3`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-.TH PCRE2BUILD 3 "08 December 2021" "PCRE2 10.40"
+.TH PCRE2BUILD 3 "27 July 2022" "PCRE2 10.41"
 .SH NAME
 PCRE2 - Perl-compatible regular expressions (revised API)
 .
 .
 .SH "BUILDING PCRE2"
 .rs
 .sp
@@ -274,20 +274,19 @@
 .sp
   --with-match-limit=500000
 .sp
 to the \fBconfigure\fP command. This setting also applies to the
 \fBpcre2_dfa_match()\fP matching function, and to JIT matching (though the
 counting is done differently).
 .P
-The \fBpcre2_match()\fP function starts out using a 20KiB vector on the system
-stack to record backtracking points. The more nested backtracking points there
-are (that is, the deeper the search tree), the more memory is needed. If the
-initial vector is not large enough, heap memory is used, up to a certain limit,
-which is specified in kibibytes (units of 1024 bytes). The limit can be changed
-at run time, as described in the
+The \fBpcre2_match()\fP function uses heap memory to record backtracking
+points. The more nested backtracking points there are (that is, the deeper the
+search tree), the more memory is needed. There is an upper limit, specified in
+kibibytes (units of 1024 bytes). This limit can be changed at run time, as
+described in the
 .\" HREF
 \fBpcre2api\fP
 .\"
 documentation. The default limit (in effect unlimited) is 20 million. You can
 change this by a setting such as
 .sp
   --with-heap-limit=500
@@ -621,19 +620,19 @@
 .
 .
 .SH AUTHOR
 .rs
 .sp
 .nf
 Philip Hazel
-University Computing Service
+Retired from University Computing Service
 Cambridge, England.
 .fi
 .
 .
 .SH REVISION
 .rs
 .sp
 .nf
-Last updated: 08 December 2021
-Copyright (c) 1997-2021 University of Cambridge.
+Last updated: 27 July 2022
+Copyright (c) 1997-2022 University of Cambridge.
 .fi
```

#### html2text {}

```diff
@@ -1,42 +1,42 @@
-.TH PCRE2BUILD 3 "08 December 2021" "PCRE2 10.40" .SH NAME PCRE2 - Perl-
-compatible regular expressions (revised API) . . .SH "BUILDING PCRE2" .rs .sp
-PCRE2 is distributed with a \fBconfigure\fP script that can be used to build
-the library in Unix-like environments using the applications known as
-Autotools. Also in the distribution are files to support building using
-\fBCMake\fP instead of \fBconfigure\fP. The text file .\" HTML .\" \fBREADME\fP
-.\" contains general information about building with Autotools (some of which
-is repeated below), and also has some comments about building on various
-operating systems. There is a lot more information about building PCRE2 without
-using Autotools (including information about using \fBCMake\fP and building "by
-hand") in the text file called .\" HTML .\" \fBNON-AUTOTOOLS-BUILD\fP. .\" You
-should consult this file as well as the .\" HTML .\" \fBREADME\fP .\" file if
-you are building in a non-Unix-like environment. . . .SH "PCRE2 BUILD-TIME
-OPTIONS" .rs .sp The rest of this document describes the optional features of
-PCRE2 that can be selected when the library is compiled. It assumes use of the
-\fBconfigure\fP script, where the optional features are selected or deselected
-by providing options to \fBconfigure\fP before running the \fBmake\fP command.
-However, the same options can be selected in both Unix-like and non-Unix-like
-environments if you are using \fBCMake\fP instead of \fBconfigure\fP to build
-PCRE2. .P If you are not using Autotools or \fBCMake\fP, option selection can
-be done by editing the \fBconfig.h\fP file, or by passing parameter settings to
-the compiler, as described in .\" HTML .\" \fBNON-AUTOTOOLS-BUILD\fP. .\" .P
-The complete list of options for \fBconfigure\fP (which includes the standard
-ones such as the selection of the installation directory) can be obtained by
-running .sp ./configure --help .sp The following sections include descriptions
-of "on/off" options whose names begin with --enable or --disable. Because of
-the way that \fBconfigure\fP works, --enable and --disable always come in
-pairs, so the complementary option always exists as well, but as it specifies
-the default, it is not described. Options that specify values have names that
-start with --with. At the end of a \fBconfigure\fP run, a summary of the
-configuration is output. . . .SH "BUILDING 8-BIT, 16-BIT AND 32-BIT LIBRARIES"
-.rs .sp By default, a library called \fBlibpcre2-8\fP is built, containing
-functions that take string arguments contained in arrays of bytes, interpreted
-either as single-byte characters, or UTF-8 strings. You can also build two
-other libraries, called \fBlibpcre2-16\fP and \fBlibpcre2-32\fP, which process
+.TH PCRE2BUILD 3 "27 July 2022" "PCRE2 10.41" .SH NAME PCRE2 - Perl-compatible
+regular expressions (revised API) . . .SH "BUILDING PCRE2" .rs .sp PCRE2 is
+distributed with a \fBconfigure\fP script that can be used to build the library
+in Unix-like environments using the applications known as Autotools. Also in
+the distribution are files to support building using \fBCMake\fP instead of
+\fBconfigure\fP. The text file .\" HTML .\" \fBREADME\fP .\" contains general
+information about building with Autotools (some of which is repeated below),
+and also has some comments about building on various operating systems. There
+is a lot more information about building PCRE2 without using Autotools
+(including information about using \fBCMake\fP and building "by hand") in the
+text file called .\" HTML .\" \fBNON-AUTOTOOLS-BUILD\fP. .\" You should consult
+this file as well as the .\" HTML .\" \fBREADME\fP .\" file if you are building
+in a non-Unix-like environment. . . .SH "PCRE2 BUILD-TIME OPTIONS" .rs .sp The
+rest of this document describes the optional features of PCRE2 that can be
+selected when the library is compiled. It assumes use of the \fBconfigure\fP
+script, where the optional features are selected or deselected by providing
+options to \fBconfigure\fP before running the \fBmake\fP command. However, the
+same options can be selected in both Unix-like and non-Unix-like environments
+if you are using \fBCMake\fP instead of \fBconfigure\fP to build PCRE2. .P If
+you are not using Autotools or \fBCMake\fP, option selection can be done by
+editing the \fBconfig.h\fP file, or by passing parameter settings to the
+compiler, as described in .\" HTML .\" \fBNON-AUTOTOOLS-BUILD\fP. .\" .P The
+complete list of options for \fBconfigure\fP (which includes the standard ones
+such as the selection of the installation directory) can be obtained by running
+.sp ./configure --help .sp The following sections include descriptions of "on/
+off" options whose names begin with --enable or --disable. Because of the way
+that \fBconfigure\fP works, --enable and --disable always come in pairs, so the
+complementary option always exists as well, but as it specifies the default, it
+is not described. Options that specify values have names that start with --
+with. At the end of a \fBconfigure\fP run, a summary of the configuration is
+output. . . .SH "BUILDING 8-BIT, 16-BIT AND 32-BIT LIBRARIES" .rs .sp By
+default, a library called \fBlibpcre2-8\fP is built, containing functions that
+take string arguments contained in arrays of bytes, interpreted either as
+single-byte characters, or UTF-8 strings. You can also build two other
+libraries, called \fBlibpcre2-16\fP and \fBlibpcre2-32\fP, which process
 strings that are contained in arrays of 16-bit and 32-bit code units,
 respectively. These can be interpreted either as single-unit characters or UTF-
 16/UTF-32 strings. To build these additional libraries, add one or both of the
 following to the \fBconfigure\fP command: .sp --enable-pcre2-16 --enable-pcre2-
 32 .sp If you do not want the 8-bit library, add .sp --disable-pcre2-8 .sp as
 well. At least one of the three libraries must be built. Note that the POSIX
 wrapper is for the 8-bit library only, and that \fBpcre2grep\fP is an 8-bit
@@ -125,107 +125,105 @@
 increments a counter each time it goes round its main loop. Putting a limit on
 this counter controls the amount of computing resource used by a single call to
 \fBpcre2_match()\fP. The limit can be changed at run time, as described in the
 .\" HREF \fBpcre2api\fP .\" documentation. The default is 10 million, but this
 can be changed by adding a setting such as .sp --with-match-limit=500000 .sp to
 the \fBconfigure\fP command. This setting also applies to the
 \fBpcre2_dfa_match()\fP matching function, and to JIT matching (though the
-counting is done differently). .P The \fBpcre2_match()\fP function starts out
-using a 20KiB vector on the system stack to record backtracking points. The
-more nested backtracking points there are (that is, the deeper the search
-tree), the more memory is needed. If the initial vector is not large enough,
-heap memory is used, up to a certain limit, which is specified in kibibytes
-(units of 1024 bytes). The limit can be changed at run time, as described in
-the .\" HREF \fBpcre2api\fP .\" documentation. The default limit (in effect
-unlimited) is 20 million. You can change this by a setting such as .sp --with-
-heap-limit=500 .sp which limits the amount of heap to 500 KiB. This limit
-applies only to interpretive matching in \fBpcre2_match()\fP and
-\fBpcre2_dfa_match()\fP, which may also use the heap for internal workspace
-when processing complicated patterns. This limit does not apply when JIT (which
-has its own memory arrangements) is used. .P You can also explicitly limit the
-depth of nested backtracking in the \fBpcre2_match()\fP interpreter. This limit
-defaults to the value that is set for --with-match-limit. You can set a lower
-default limit by adding, for example, .sp --with-match-limit-depth=10000 .sp to
-the \fBconfigure\fP command. This value can be overridden at run time. This
-depth limit indirectly limits the amount of heap memory that is used, but
-because the size of each backtracking "frame" depends on the number of
-capturing parentheses in a pattern, the amount of heap that is used before the
-limit is reached varies from pattern to pattern. This limit was more useful in
-versions before 10.30, where function recursion was used for backtracking. .P
-As well as applying to \fBpcre2_match()\fP, the depth limit also controls the
-depth of recursive function calls in \fBpcre2_dfa_match()\fP. These are used
-for lookaround assertions, atomic groups, and recursion within patterns. The
-limit does not apply to JIT matching. . . .\" HTML  .SH "CREATING CHARACTER
-TABLES AT BUILD TIME" .rs .sp PCRE2 uses fixed tables for processing characters
-whose code points are less than 256. By default, PCRE2 is built with a set of
-tables that are distributed in the file \fIsrc/pcre2_chartables.c.dist\fP.
-These tables are for ASCII codes only. If you add .sp --enable-rebuild-
-chartables .sp to the \fBconfigure\fP command, the distributed tables are no
-longer used. Instead, a program called \fBpcre2_dftables\fP is compiled and
-run. This outputs the source for new set of tables, created in the default
-locale of your C run-time system. This method of replacing the tables does not
-work if you are cross compiling, because \fBpcre2_dftables\fP needs to be run
-on the local host and therefore not compiled with the cross compiler. .P If you
-need to create alternative tables when cross compiling, you will have to do so
-"by hand". There may also be other reasons for creating tables manually. To
-cause \fBpcre2_dftables\fP to be built on the local host, run a normal
-compiling command, and then run the program with the output file as its
-argument, for example: .sp cc src/pcre2_dftables.c -o pcre2_dftables ./
-pcre2_dftables src/pcre2_chartables.c .sp This builds the tables in the default
-locale of the local host. If you want to specify a locale, you must use the -
-L option: .sp LC_ALL=fr_FR ./pcre2_dftables -L src/pcre2_chartables.c .sp You
-can also specify -b (with or without -L). This causes the tables to be written
-in binary instead of as source code. A set of binary tables can be loaded into
-memory by an application and passed to \fBpcre2_compile()\fP in the same way as
-tables created by calling \fBpcre2_maketables()\fP. The tables are just a
-string of bytes, independent of hardware characteristics such as endianness.
-This means they can be bundled with an application that runs in different
-environments, to ensure consistent behaviour. . . .SH "USING EBCDIC CODE" .rs
-.sp PCRE2 assumes by default that it will run in an environment where the
-character code is ASCII or Unicode, which is a superset of ASCII. This is the
-case for most computer operating systems. PCRE2 can, however, be compiled to
-run in an 8-bit EBCDIC environment by adding .sp --enable-ebcdic --disable-
-unicode .sp to the \fBconfigure\fP command. This setting implies --enable-
-rebuild-chartables. You should only use it if you know that you are in an
-EBCDIC environment (for example, an IBM mainframe operating system). .P It is
-not possible to support both EBCDIC and UTF-8 codes in the same version of the
-library. Consequently, --enable-unicode and --enable-ebcdic are mutually
-exclusive. .P The EBCDIC character that corresponds to an ASCII LF is assumed
-to have the value 0x15 by default. However, in some EBCDIC environments, 0x25
-is used. In such an environment you should use .sp --enable-ebcdic-nl25 .sp as
-well as, or instead of, --enable-ebcdic. The EBCDIC character for CR has the
-same value as in ASCII, namely, 0x0d. Whichever of 0x15 and 0x25 is \fInot\fP
-chosen as LF is made to correspond to the Unicode NEL character (which, in
-Unicode, is 0x85). .P The options that select newline behaviour, such as --
-enable-newline-is-cr, and equivalent run-time options, refer to these character
-values in an EBCDIC environment. . . .SH "PCRE2GREP SUPPORT FOR EXTERNAL
-SCRIPTS" .rs .sp By default \fBpcre2grep\fP supports the use of callouts with
-string arguments within the patterns it is matching. There are two kinds: one
-that generates output using local code, and another that calls an external
-program or script. If --disable-pcre2grep-callout-fork is added to the
-\fBconfigure\fP command, only the first kind of callout is supported; if --
-disable-pcre2grep-callout is used, all callouts are completely ignored. For
-more details of \fBpcre2grep\fP callouts, see the .\" HREF \fBpcre2grep\fP .\"
-documentation. . . .SH "PCRE2GREP OPTIONS FOR COMPRESSED FILE SUPPORT" .rs .sp
-By default, \fBpcre2grep\fP reads all files as plain text. You can build it so
-that it recognizes files whose names end in \fB.gz\fP or \fB.bz2\fP, and reads
-them with \fBlibz\fP or \fBlibbz2\fP, respectively, by adding one or both of
-.sp --enable-pcre2grep-libz --enable-pcre2grep-libbz2 .sp to the
-\fBconfigure\fP command. These options naturally require that the relevant
-libraries are installed on your system. Configuration will fail if they are
-not. . . .SH "PCRE2GREP BUFFER SIZE" .rs .sp \fBpcre2grep\fP uses an internal
-buffer to hold a "window" on the file it is scanning, in order to be able to
-output "before" and "after" lines when it finds a match. The default starting
-size of the buffer is 20KiB. The buffer itself is three times this size, but
-because of the way it is used for holding "before" lines, the longest line that
-is guaranteed to be processable is the notional buffer size. If a longer line
-is encountered, \fBpcre2grep\fP automatically expands the buffer, up to a
-specified maximum size, whose default is 1MiB or the starting size, whichever
-is the larger. You can change the default parameter values by adding, for
-example, .sp --with-pcre2grep-bufsize=51200 --with-pcre2grep-max-
+counting is done differently). .P The \fBpcre2_match()\fP function uses heap
+memory to record backtracking points. The more nested backtracking points there
+are (that is, the deeper the search tree), the more memory is needed. There is
+an upper limit, specified in kibibytes (units of 1024 bytes). This limit can be
+changed at run time, as described in the .\" HREF \fBpcre2api\fP .\"
+documentation. The default limit (in effect unlimited) is 20 million. You can
+change this by a setting such as .sp --with-heap-limit=500 .sp which limits the
+amount of heap to 500 KiB. This limit applies only to interpretive matching in
+\fBpcre2_match()\fP and \fBpcre2_dfa_match()\fP, which may also use the heap
+for internal workspace when processing complicated patterns. This limit does
+not apply when JIT (which has its own memory arrangements) is used. .P You can
+also explicitly limit the depth of nested backtracking in the \fBpcre2_match
+()\fP interpreter. This limit defaults to the value that is set for --with-
+match-limit. You can set a lower default limit by adding, for example, .sp --
+with-match-limit-depth=10000 .sp to the \fBconfigure\fP command. This value can
+be overridden at run time. This depth limit indirectly limits the amount of
+heap memory that is used, but because the size of each backtracking "frame"
+depends on the number of capturing parentheses in a pattern, the amount of heap
+that is used before the limit is reached varies from pattern to pattern. This
+limit was more useful in versions before 10.30, where function recursion was
+used for backtracking. .P As well as applying to \fBpcre2_match()\fP, the depth
+limit also controls the depth of recursive function calls in \fBpcre2_dfa_match
+()\fP. These are used for lookaround assertions, atomic groups, and recursion
+within patterns. The limit does not apply to JIT matching. . . .\" HTML  .SH
+"CREATING CHARACTER TABLES AT BUILD TIME" .rs .sp PCRE2 uses fixed tables for
+processing characters whose code points are less than 256. By default, PCRE2 is
+built with a set of tables that are distributed in the file \fIsrc/
+pcre2_chartables.c.dist\fP. These tables are for ASCII codes only. If you add
+.sp --enable-rebuild-chartables .sp to the \fBconfigure\fP command, the
+distributed tables are no longer used. Instead, a program called
+\fBpcre2_dftables\fP is compiled and run. This outputs the source for new set
+of tables, created in the default locale of your C run-time system. This method
+of replacing the tables does not work if you are cross compiling, because
+\fBpcre2_dftables\fP needs to be run on the local host and therefore not
+compiled with the cross compiler. .P If you need to create alternative tables
+when cross compiling, you will have to do so "by hand". There may also be other
+reasons for creating tables manually. To cause \fBpcre2_dftables\fP to be built
+on the local host, run a normal compiling command, and then run the program
+with the output file as its argument, for example: .sp cc src/pcre2_dftables.c
+-o pcre2_dftables ./pcre2_dftables src/pcre2_chartables.c .sp This builds the
+tables in the default locale of the local host. If you want to specify a
+locale, you must use the -L option: .sp LC_ALL=fr_FR ./pcre2_dftables -L src/
+pcre2_chartables.c .sp You can also specify -b (with or without -L). This
+causes the tables to be written in binary instead of as source code. A set of
+binary tables can be loaded into memory by an application and passed to
+\fBpcre2_compile()\fP in the same way as tables created by calling
+\fBpcre2_maketables()\fP. The tables are just a string of bytes, independent of
+hardware characteristics such as endianness. This means they can be bundled
+with an application that runs in different environments, to ensure consistent
+behaviour. . . .SH "USING EBCDIC CODE" .rs .sp PCRE2 assumes by default that it
+will run in an environment where the character code is ASCII or Unicode, which
+is a superset of ASCII. This is the case for most computer operating systems.
+PCRE2 can, however, be compiled to run in an 8-bit EBCDIC environment by adding
+.sp --enable-ebcdic --disable-unicode .sp to the \fBconfigure\fP command. This
+setting implies --enable-rebuild-chartables. You should only use it if you know
+that you are in an EBCDIC environment (for example, an IBM mainframe operating
+system). .P It is not possible to support both EBCDIC and UTF-8 codes in the
+same version of the library. Consequently, --enable-unicode and --enable-ebcdic
+are mutually exclusive. .P The EBCDIC character that corresponds to an ASCII LF
+is assumed to have the value 0x15 by default. However, in some EBCDIC
+environments, 0x25 is used. In such an environment you should use .sp --enable-
+ebcdic-nl25 .sp as well as, or instead of, --enable-ebcdic. The EBCDIC
+character for CR has the same value as in ASCII, namely, 0x0d. Whichever of
+0x15 and 0x25 is \fInot\fP chosen as LF is made to correspond to the Unicode
+NEL character (which, in Unicode, is 0x85). .P The options that select newline
+behaviour, such as --enable-newline-is-cr, and equivalent run-time options,
+refer to these character values in an EBCDIC environment. . . .SH "PCRE2GREP
+SUPPORT FOR EXTERNAL SCRIPTS" .rs .sp By default \fBpcre2grep\fP supports the
+use of callouts with string arguments within the patterns it is matching. There
+are two kinds: one that generates output using local code, and another that
+calls an external program or script. If --disable-pcre2grep-callout-fork is
+added to the \fBconfigure\fP command, only the first kind of callout is
+supported; if --disable-pcre2grep-callout is used, all callouts are completely
+ignored. For more details of \fBpcre2grep\fP callouts, see the .\" HREF
+\fBpcre2grep\fP .\" documentation. . . .SH "PCRE2GREP OPTIONS FOR COMPRESSED
+FILE SUPPORT" .rs .sp By default, \fBpcre2grep\fP reads all files as plain
+text. You can build it so that it recognizes files whose names end in \fB.gz\fP
+or \fB.bz2\fP, and reads them with \fBlibz\fP or \fBlibbz2\fP, respectively, by
+adding one or both of .sp --enable-pcre2grep-libz --enable-pcre2grep-libbz2 .sp
+to the \fBconfigure\fP command. These options naturally require that the
+relevant libraries are installed on your system. Configuration will fail if
+they are not. . . .SH "PCRE2GREP BUFFER SIZE" .rs .sp \fBpcre2grep\fP uses an
+internal buffer to hold a "window" on the file it is scanning, in order to be
+able to output "before" and "after" lines when it finds a match. The default
+starting size of the buffer is 20KiB. The buffer itself is three times this
+size, but because of the way it is used for holding "before" lines, the longest
+line that is guaranteed to be processable is the notional buffer size. If a
+longer line is encountered, \fBpcre2grep\fP automatically expands the buffer,
+up to a specified maximum size, whose default is 1MiB or the starting size,
+whichever is the larger. You can change the default parameter values by adding,
+for example, .sp --with-pcre2grep-bufsize=51200 --with-pcre2grep-max-
 bufsize=2097152 .sp to the \fBconfigure\fP command. The caller of
 \fBpcre2grep\fP can override these values by using --buffer-size and --max-
 buffer-size on the command line. . . .SH "PCRE2TEST OPTION FOR LIBREADLINE
 SUPPORT" .rs .sp If you add one of .sp --enable-pcre2test-libreadline --enable-
 pcre2test-libedit .sp to the \fBconfigure\fP command, \fBpcre2test\fP is linked
 with the \fBlibreadline\fP or\fBlibedit\fP library, respectively, and when its
 input is from a terminal, it reads it using the \fBreadline()\fP function. This
@@ -297,10 +295,10 @@
 contents of the file are the test string. . . .SH "OBSOLETE OPTION" .rs .sp In
 versions of PCRE2 prior to 10.30, there were two ways of handling backtracking
 in the \fBpcre2_match()\fP function. The default was to use the system stack,
 but if .sp --disable-stack-for-recursion .sp was set, memory on the heap was
 used. From release 10.30 onwards this has changed (the stack is no longer used)
 and this option now does nothing except give a warning. . .SH "SEE ALSO" .rs
 .sp \fBpcre2api\fP(3), \fBpcre2-config\fP(3). . . .SH AUTHOR .rs .sp .nf Philip
-Hazel University Computing Service Cambridge, England. .fi . . .SH REVISION .rs
-.sp .nf Last updated: 08 December 2021 Copyright (c) 1997-2021 University of
-Cambridge. .fi
+Hazel Retired from University Computing Service Cambridge, England. .fi . . .SH
+REVISION .rs .sp .nf Last updated: 27 July 2022 Copyright (c) 1997-2022
+University of Cambridge. .fi
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2callout.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2callout.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2compat.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2compat.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2convert.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2convert.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2demo.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2demo.3`

 * *Files 1% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+.SH NAME
+// - A demonstration C program for PCRE2 - //
+.sp
 .\" Start example.
 .de EX
 .  nr mE \\n(.f
 .  nf
 .  nh
 .  ft CW
 ..
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2grep.1` & `pcre2-0.2.0/src/libpcre2/doc/pcre2grep.1`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-.TH PCRE2GREP 1 "31 August 2021" "PCRE2 10.38"
+.TH PCRE2GREP 1 "21 November 2022" "PCRE2 10.41"
 .SH NAME
 pcre2grep - a grep with Perl-compatible regular expressions.
 .SH SYNOPSIS
 .B pcre2grep [options] [long options] [pattern] [path1 path2 ...]
 .
 .SH DESCRIPTION
 .rs
@@ -39,21 +39,23 @@
 .P
 If no files are specified, \fBpcre2grep\fP reads the standard input. The
 standard input can also be referenced by a name consisting of a single hyphen.
 For example:
 .sp
   pcre2grep some-pattern file1 - file3
 .sp
-Input files are searched line by line. By default, each line that matches a
+By default, input files are searched line by line. Each line that matches a
 pattern is copied to the standard output, and if there is more than one file,
 the file name is output at the start of each line, followed by a colon.
-However, there are options that can change how \fBpcre2grep\fP behaves. In
-particular, the \fB-M\fP option makes it possible to search for strings that
-span line boundaries. What defines a line boundary is controlled by the
-\fB-N\fP (\fB--newline\fP) option.
+However, there are options that can change how \fBpcre2grep\fP behaves. For
+example, the \fB-M\fP option makes it possible to search for strings that span
+line boundaries. What defines a line boundary is controlled by the \fB-N\fP
+(\fB--newline\fP) option. The \fB-h\fP and \fB-H\fP options control whether or
+not file names are shown, and the \fB-Z\fP option changes the file name
+terminator to a zero byte.
 .P
 The amount of memory used for buffering files that are being scanned is
 controlled by parameters that can be set by the \fB--buffer-size\fP and
 \fB--max-buffer-size\fP options. The first of these sets the size of buffer
 that is obtained at the start of processing. If an input file contains very
 long lines, a larger buffer may be needed; this is handled by automatically
 extending the buffer, up to the limit specified by \fB--max-buffer-size\fP. The
@@ -70,26 +72,30 @@
 BUFSIZ is defined in \fB<stdio.h>\fP. When there is more than one pattern
 (specified by the use of \fB-e\fP and/or \fB-f\fP), each pattern is applied to
 each line in the order in which they are defined, except that all the \fB-e\fP
 patterns are tried before the \fB-f\fP patterns.
 .P
 By default, as soon as one pattern matches a line, no further patterns are
 considered. However, if \fB--colour\fP (or \fB--color\fP) is used to colour the
-matching substrings, or if \fB--only-matching\fP, \fB--file-offsets\fP, or
-\fB--line-offsets\fP is used to output only the part of the line that matched
-(either shown literally, or as an offset), scanning resumes immediately
-following the match, so that further matches on the same line can be found. If
-there are multiple patterns, they are all tried on the remainder of the line,
-but patterns that follow the one that matched are not tried on the earlier
-matched part of the line.
-.P
-This behaviour means that the order in which multiple patterns are specified
-can affect the output when one of the above options is used. This is no longer
-the same behaviour as GNU grep, which now manages to display earlier matches
-for later patterns (as long as there is no overlap).
+matching substrings, or if \fB--only-matching\fP, \fB--file-offsets\fP,
+\fB--line-offsets\fP, or \fB--output\fP is used to output only the part of the
+line that matched (either shown literally, or as an offset), the behaviour is
+different. In this situation, all the patterns are applied to the line. If
+there is more than one match, the one that begins nearest to the start of the
+subject is processed; if there is more than one match at that position, the one
+with the longest matching substring is processed; if the matching substrings
+are equal, the first match found is processed.
+.P
+Scanning with all the patterns resumes immediately following the match, so that
+later matches on the same line can be found. Note, however, that an overlapping
+match that starts in the middle of another match will not be processed.
+.P
+The above behaviour was changed at release 10.41 to be more compatible with GNU
+grep. In earlier releases, \fBpcre2grep\fP did not recognize matches from
+later patterns that were earlier in the subject.
 .P
 Patterns that can match an empty string are accepted, but empty string
 matches are never recognized. An example is the pattern "(super)?(man)?", in
 which all components are optional. This pattern finds all occurrences of both
 "super" and "man"; the output differs from matching with "super|man" when only
 the matching substrings are being shown.
 .P
@@ -97,22 +103,23 @@
 \fBpcre2grep\fP uses the value to set a locale when calling the PCRE2 library.
 The \fB--locale\fP option can be used to override this.
 .
 .
 .SH "SUPPORT FOR COMPRESSED FILES"
 .rs
 .sp
-It is possible to compile \fBpcre2grep\fP so that it uses \fBlibz\fP or
-\fBlibbz2\fP to read compressed files whose names end in \fB.gz\fP or
+Compile-time options for \fBpcre2grep\fP can set it up to use \fBlibz\fP or
+\fBlibbz2\fP for reading compressed files whose names end in \fB.gz\fP or
 \fB.bz2\fP, respectively. You can find out whether your \fBpcre2grep\fP binary
 has support for one or both of these file types by running it with the
 \fB--help\fP option. If the appropriate support is not present, all files are
-treated as plain text. The standard input is always so treated. When input is
-from a compressed .gz or .bz2 file, the \fB--line-buffered\fP option is
-ignored.
+treated as plain text. The standard input is always so treated. If a file with
+a \fB.gz\fP or \fB.bz2\fP extension is not in fact compressed, it is read as a
+plain text file. When input is from a compressed .gz or .bz2 file, the
+\fB--line-buffered\fP option is ignored.
 .
 .
 .SH "BINARY FILES"
 .rs
 .sp
 By default, a file that contains a binary zero byte within the first 1024 bytes
 is identified as a binary file, and is processed specially. However, if the
@@ -145,17 +152,19 @@
 processing of patterns and file names that start with hyphens.
 .TP
 \fB-A\fP \fInumber\fP, \fB--after-context=\fP\fInumber\fP
 Output up to \fInumber\fP lines of context after each matching line. Fewer
 lines are output if the next match or the end of the file is reached, or if the
 processing buffer size has been set too small. If file names and/or line
 numbers are being output, a hyphen separator is used instead of a colon for the
-context lines. A line containing "--" is output between each group of lines,
-unless they are in fact contiguous in the input file. The value of \fInumber\fP
-is expected to be relatively small. When \fB-c\fP is used, \fB-A\fP is ignored.
+context lines (the \fB-Z\fP option can be used to change the file name
+terminator to a zero byte). A line containing "--" is output between each group
+of lines, unless they are in fact contiguous in the input file. The value of
+\fInumber\fP is expected to be relatively small. When \fB-c\fP is used,
+\fB-A\fP is ignored.
 .TP
 \fB-a\fP, \fB--text\fP
 Treat binary files as text. This is equivalent to
 \fB--binary-files\fP=\fItext\fP.
 .TP
 \fB--allow-lookaround-bsk\fP
 PCRE2 now forbids the use of \eK in lookarounds by default, in line with Perl.
@@ -163,17 +172,18 @@
 option, which enables this somewhat dangerous usage.
 .TP
 \fB-B\fP \fInumber\fP, \fB--before-context=\fP\fInumber\fP
 Output up to \fInumber\fP lines of context before each matching line. Fewer
 lines are output if the previous match or the start of the file is within
 \fInumber\fP lines, or if the processing buffer size has been set too small. If
 file names and/or line numbers are being output, a hyphen separator is used
-instead of a colon for the context lines. A line containing "--" is output
-between each group of lines, unless they are in fact contiguous in the input
-file. The value of \fInumber\fP is expected to be relatively small. When
+instead of a colon for the context lines (the \fB-Z\fP option can be used to
+change the file name terminator to a zero byte). A line containing "--" is
+output between each group of lines, unless they are in fact contiguous in the
+input file. The value of \fInumber\fP is expected to be relatively small. When
 \fB-c\fP is used, \fB-B\fP is ignored.
 .TP
 \fB--binary-files=\fP\fIword\fP
 Specify how binary files are to be processed. If the word is "binary" (the
 default), pattern matching is performed on binary files, but the only output is
 "Binary file <name> matches" when a match succeeds. If the word is "text",
 which is equivalent to the \fB-a\fP or \fB--text\fP option, binary files are
@@ -211,20 +221,22 @@
 \fB--colour\fP, \fB--color\fP
 If this option is given without any data, it is equivalent to "--colour=auto".
 If data is required, it must be given in the same shell item, separated by an
 equals sign.
 .TP
 \fB--colour=\fP\fIvalue\fP, \fB--color=\fP\fIvalue\fP
 This option specifies under what circumstances the parts of a line that matched
-a pattern should be coloured in the output. By default, the output is not
-coloured. The value (which is optional, see above) may be "never", "always", or
-"auto". In the latter case, colouring happens only if the standard output is
-connected to a terminal. More resources are used when colouring is enabled,
-because \fBpcre2grep\fP has to search for all possible matches in a line, not
-just one, in order to colour them all.
+a pattern should be coloured in the output. It is ignored if
+\fB--file-offsets\fP, \fB--line-offsets\fP, or \fB--output\fP is set. By
+default, output is not coloured. The value for the \fB--colour\fP option (which
+is optional, see above) may be "never", "always", or "auto". In the latter
+case, colouring happens only if the standard output is connected to a terminal.
+More resources are used when colouring is enabled, because \fBpcre2grep\fP has
+to search for all possible matches in a line, not just one, in order to colour
+them all.
 .sp
 The colour that is used can be specified by setting one of the environment
 variables PCRE2GREP_COLOUR, PCRE2GREP_COLOR, PCREGREP_COLOUR, or
 PCREGREP_COLOR, which are checked in that order. If none of these are set,
 \fBpcre2grep\fP looks for GREP_COLORS or GREP_COLOR (in that order). The value
 of the variable should be a string of two numbers, separated by a semicolon,
 except in the case of GREP_COLORS, which must start with "ms=" or "mt="
@@ -258,25 +270,19 @@
 .TP
 \fB-e\fP \fIpattern\fP, \fB--regex=\fP\fIpattern\fP, \fB--regexp=\fP\fIpattern\fP
 Specify a pattern to be matched. This option can be used multiple times in
 order to specify several patterns. It can also be used as a way of specifying a
 single pattern that starts with a hyphen. When \fB-e\fP is used, no argument
 pattern is taken from the command line; all arguments are treated as file
 names. There is no limit to the number of patterns. They are applied to each
-line in the order in which they are defined until one matches.
+line in the order in which they are defined.
 .sp
 If \fB-f\fP is used with \fB-e\fP, the command line patterns are matched first,
 followed by the patterns from the file(s), independent of the order in which
-these options are specified. Note that multiple use of \fB-e\fP is not the same
-as a single pattern with alternatives. For example, X|Y finds the first
-character in a line that is X or Y, whereas if the two patterns are given
-separately, with X first, \fBpcre2grep\fP finds X if it is present, even if it
-follows Y in the line. It finds Y only if there is no X in the line. This
-matters only if you are using \fB-o\fP or \fB--colo(u)r\fP to show the part(s)
-of the line that matched.
+these options are specified.
 .TP
 \fB--exclude\fP=\fIpattern\fP
 Files (but not directories) whose names match the pattern are skipped without
 being processed. This applies to all files, whether listed on the command line,
 obtained from \fB--file-list\fP, or by scanning a directory. The pattern is a
 PCRE2 regular expression, and is matched against the final component of the
 file name, not the entire path. The \fB-F\fP, \fB-w\fP, and \fB-x\fP options do
@@ -312,30 +318,27 @@
 They apply to each of the fixed strings. A line is selected if any of the fixed
 strings are found in it (subject to \fB-w\fP or \fB-x\fP, if present). This
 option applies only to the patterns that are matched against the contents of
 files; it does not apply to patterns specified by any of the \fB--include\fP or
 \fB--exclude\fP options.
 .TP
 \fB-f\fP \fIfilename\fP, \fB--file=\fP\fIfilename\fP
-Read patterns from the file, one per line, and match them against each line of
-input. As is the case with patterns on the command line, no delimiters should
-be used. What constitutes a newline when reading the file is the operating
-system's default interpretation of \en. The \fB--newline\fP option has no
-effect on this option. Trailing white space is removed from each line, and
-blank lines are ignored. An empty file contains no patterns and therefore
-matches nothing. Patterns read from a file in this way may contain binary
-zeros, which are treated as ordinary data characters. See also the comments
-about multiple patterns versus a single pattern with alternatives in the
-description of \fB-e\fP above.
+Read patterns from the file, one per line. As is the case with patterns on the
+command line, no delimiters should be used. What constitutes a newline when
+reading the file is the operating system's default interpretation of \en. The
+\fB--newline\fP option has no effect on this option. Trailing white space is
+removed from each line, and blank lines are ignored. An empty file contains no
+patterns and therefore matches nothing. Patterns read from a file in this way
+may contain binary zeros, which are treated as ordinary data characters.
 .sp
 If this option is given more than once, all the specified files are read. A
 data line is output if any of the patterns match it. A file name can be given
 as "-" to refer to the standard input. When \fB-f\fP is used, patterns
 specified on the command line using \fB-e\fP may also be present; they are
-tested before the file's patterns. However, no other pattern is taken from the
+matched before the file's patterns. However, no pattern is taken from the
 command line; all arguments are treated as the names of paths to be searched.
 .TP
 \fB--file-list\fP=\fIfilename\fP
 Read a list of files and/or directories that are to be scanned from the given
 file, one per line. What constitutes a newline when reading the file is the
 operating system's default. Trailing white space is removed from each line, and
 blank lines are ignored. These paths are processed before any that are listed
@@ -345,34 +348,36 @@
 terminal, from which further lines (the list of files) can be read after an
 end-of-file indication. If this option is given more than once, all the
 specified files are read.
 .TP
 \fB--file-offsets\fP
 Instead of showing lines or parts of lines that match, show each match as an
 offset from the start of the file and a length, separated by a comma. In this
-mode, no context is shown. That is, the \fB-A\fP, \fB-B\fP, and \fB-C\fP
-options are ignored. If there is more than one match in a line, each of them is
-shown separately. This option is mutually exclusive with \fB--output\fP,
-\fB--line-offsets\fP, and \fB--only-matching\fP.
+mode, \fB--colour\fP has no effect, and no context is shown. That is, the
+\fB-A\fP, \fB-B\fP, and \fB-C\fP options are ignored. If there is more than one
+match in a line, each of them is shown separately. This option is mutually
+exclusive with \fB--output\fP, \fB--line-offsets\fP, and \fB--only-matching\fP.
 .TP
 \fB-H\fP, \fB--with-filename\fP
 Force the inclusion of the file name at the start of output lines when
-searching a single file. By default, the file name is not shown in this case.
-For matching lines, the file name is followed by a colon; for context lines, a
-hyphen separator is used. If a line number is also being output, it follows the
-file name. When the \fB-M\fP option causes a pattern to match more than one
-line, only the first is preceded by the file name. This option overrides any
-previous \fB-h\fP, \fB-l\fP, or \fB-L\fP options.
+searching a single file. The file name is not normally shown in this case.
+By default, for matching lines, the file name is followed by a colon; for
+context lines, a hyphen separator is used. The \fB-Z\fP option can be used to
+change the terminator to a zero byte. If a line number is also being output,
+it follows the file name. When the \fB-M\fP option causes a pattern to match
+more than one line, only the first is preceded by the file name. This option
+overrides any previous \fB-h\fP, \fB-l\fP, or \fB-L\fP options.
 .TP
 \fB-h\fP, \fB--no-filename\fP
-Suppress the output file names when searching multiple files. By default,
-file names are shown when multiple files are searched. For matching lines, the
-file name is followed by a colon; for context lines, a hyphen separator is used.
-If a line number is also being output, it follows the file name. This option
-overrides any previous \fB-H\fP, \fB-L\fP, or \fB-l\fP options.
+Suppress the output file names when searching multiple files. File names are
+normally shown when multiple files are searched. By default, for matching
+lines, the file name is followed by a colon; for context lines, a hyphen
+separator is used. The \fB-Z\fP option can be used to change the terminator to
+a zero byte. If a line number is also being output, it follows the file name.
+This option overrides any previous \fB-H\fP, \fB-L\fP, or \fB-l\fP options.
 .TP
 \fB--heap-limit\fP=\fInumber\fP
 See \fB--match-limit\fP below.
 .TP
 \fB--help\fP
 Output a help message, giving brief details of the command options and file
 type support, and then exit. Anything else on the command line is
@@ -413,25 +418,27 @@
 \fB-w\fP, and \fB-x\fP options do not apply to this pattern. The option may be
 given any number of times. If a directory matches both \fB--include-dir\fP and
 \fB--exclude-dir\fP, it is excluded. There is no short form for this option.
 .TP
 \fB-L\fP, \fB--files-without-match\fP
 Instead of outputting lines from the files, just output the names of the files
 that do not contain any lines that would have been output. Each file name is
-output once, on a separate line. This option overrides any previous \fB-H\fP,
-\fB-h\fP, or \fB-l\fP options.
+output once, on a separate line by default, but if the \fB-Z\fP option is set,
+they are separated by zero bytes instead of newlines. This option overrides any
+previous \fB-H\fP, \fB-h\fP, or \fB-l\fP options.
 .TP
 \fB-l\fP, \fB--files-with-matches\fP
 Instead of outputting lines from the files, just output the names of the files
 containing lines that would have been output. Each file name is output once, on
-a separate line. Searching normally stops as soon as a matching line is found
-in a file. However, if the \fB-c\fP (count) option is also used, matching
-continues in order to obtain the correct count, and those files that have at
-least one match are listed along with their counts. Using this option with
-\fB-c\fP is a way of suppressing the listing of files with no matches that
+a separate line, but if the \fB-Z\fP option is set, they are separated by zero
+bytes instead of newlines. Searching normally stops as soon as a matching line
+is found in a file. However, if the \fB-c\fP (count) option is also used,
+matching continues in order to obtain the correct count, and those files that
+have at least one match are listed along with their counts. Using this option
+with \fB-c\fP is a way of suppressing the listing of files with no matches that
 occurs with \fB-c\fP on its own. This option overrides any previous \fB-H\fP,
 \fB-h\fP, or \fB-L\fP options.
 .TP
 \fB--label\fP=\fIname\fP
 This option supplies a name to be used for the standard input when file names
 are being output. If not supplied, "(standard input)" is used. There is no
 short form for this option.
@@ -448,19 +455,19 @@
 ceases to work. When input is from a compressed .gz or .bz2 file,
 \fB--line-buffered\fP is ignored.
 .TP
 \fB--line-offsets\fP
 Instead of showing lines or parts of lines that match, show each match as a
 line number, the offset from the start of the line, and a length. The line
 number is terminated by a colon (as usual; see the \fB-n\fP option), and the
-offset and length are separated by a comma. In this mode, no context is shown.
-That is, the \fB-A\fP, \fB-B\fP, and \fB-C\fP options are ignored. If there is
-more than one match in a line, each of them is shown separately. This option is
-mutually exclusive with \fB--output\fP, \fB--file-offsets\fP, and
-\fB--only-matching\fP.
+offset and length are separated by a comma. In this mode, \fB--colour\fP has no
+effect, and no context is shown. That is, the \fB-A\fP, \fB-B\fP, and \fB-C\fP
+options are ignored. If there is more than one match in a line, each of them is
+shown separately. This option is mutually exclusive with \fB--output\fP,
+\fB--file-offsets\fP, and \fB--only-matching\fP.
 .TP
 \fB--locale\fP=\fIlocale-name\fP
 This option specifies a locale to be used for pattern matching. It overrides
 the value in the \fBLC_ALL\fP or \fBLC_CTYPE\fP environment variables. If no
 locale is specified, the PCRE2 library's default (usually the "C" locale) is
 used. There is no short form for this option.
 .TP
@@ -512,18 +519,15 @@
 usage when processing patterns that are not going to match, but which have a
 very large number of possibilities in their search trees. The classic example
 is a pattern that uses nested unlimited repeats. Internally, PCRE2 has a
 counter that is incremented each time around its main processing loop. If the
 value set by \fB--match-limit\fP is reached, an error occurs.
 .sp
 The \fB--heap-limit\fP option specifies, as a number of kibibytes (units of
-1024 bytes), the amount of heap memory that may be used for matching. Heap
-memory is needed only if matching the pattern requires a significant number of
-nested backtracking points to be remembered. This parameter can be set to zero
-to forbid the use of heap memory altogether.
+1024 bytes), the maximum amount of heap memory that may be used for matching.
 .sp
 The \fB--depth-limit\fP option limits the depth of nested backtracking points,
 which indirectly limits the amount of memory that is used. The amount of memory
 needed for each backtracking point depends on the number of capturing
 parentheses in the pattern, so the amount of memory that is used before this
 limit acts varies from pattern to pattern. This limit is of use only if it is
 set smaller than \fB--match-limit\fP.
@@ -578,20 +582,20 @@
 was explicitly disabled at build time. This option can be used to disable the
 use of JIT at run time. It is provided for testing and working round problems.
 It should never be needed in normal use.
 .TP
 \fB-O\fP \fItext\fP, \fB--output\fP=\fItext\fP
 When there is a match, instead of outputting the line that matched, output just
 the text specified in this option, followed by an operating-system standard
-newline. In this mode, no context is shown. That is, the \fB-A\fP, \fB-B\fP,
-and \fB-C\fP options are ignored. The \fB--newline\fP option has no effect on
-this option, which is mutually exclusive with \fB--only-matching\fP,
-\fB--file-offsets\fP, and \fB--line-offsets\fP. However, like
-\fB--only-matching\fP, if there is more than one match in a line, each of them
-causes a line of output.
+newline. In this mode, \fB--colour\fP has no effect, and no context is shown.
+That is, the \fB-A\fP, \fB-B\fP, and \fB-C\fP options are ignored. The
+\fB--newline\fP option has no effect on this option, which is mutually
+exclusive with \fB--only-matching\fP, \fB--file-offsets\fP, and
+\fB--line-offsets\fP. However, like \fB--only-matching\fP, if there is more
+than one match in a line, each of them causes a line of output.
 .sp
 Escape sequences starting with a dollar character may be used to insert the
 contents of the matched part of the line and/or captured substrings into the
 text.
 .sp
 $<digits> or ${<digits>} is replaced by the captured substring of the given
 decimal number; zero substitutes the whole match. If the number is greater than
@@ -728,14 +732,20 @@
 \fB-x\fP, \fB--line-regex\fP, \fB--line-regexp\fP
 Force the patterns to start matching only at the beginnings of lines, and in
 addition, require them to match entire lines. In multiline mode the match may
 be more than one line. This is equivalent to having "^(?:" at the start of each
 pattern and ")$" at the end. This option applies only to the patterns that are
 matched against the contents of files; it does not apply to patterns specified
 by any of the \fB--include\fP or \fB--exclude\fP options.
+.TP
+\fB-Z\fP, \fB--null\fP
+Terminate files names in the regular output with a zero byte (the NUL
+character) instead of what would normally appear. This is useful when file
+names contain unusual characters such as colons, hyphens, or even newlines. The
+option does not apply to file names in error messages.
 .
 .
 .SH "ENVIRONMENT VARIABLES"
 .rs
 .sp
 The environment variables \fBLC_ALL\fP and \fBLC_CTYPE\fP are examined, in that
 order, for a locale. The first one that is set is used. This can be overridden
@@ -956,10 +966,10 @@
 .fi
 .
 .
 .SH REVISION
 .rs
 .sp
 .nf
-Last updated: 31 August 2021
-Copyright (c) 1997-2021 University of Cambridge.
+Last updated: 21 November 2022
+Copyright (c) 1997-2022 University of Cambridge.
 .fi
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2grep.txt` & `pcre2-0.2.0/src/libpcre2/doc/pcre2grep.txt`

 * *Files 2% similar despite different names*

```diff
@@ -38,21 +38,23 @@
 
        If no files are specified, pcre2grep  reads  the  standard  input.  The
        standard  input can also be referenced by a name consisting of a single
        hyphen.  For example:
 
          pcre2grep some-pattern file1 - file3
 
-       Input files are searched line by  line.  By  default,  each  line  that
+       By default, input files are searched  line  by  line.  Each  line  that
        matches  a  pattern  is  copied to the standard output, and if there is
        more than one file, the file name is output at the start of each  line,
        followed  by  a  colon.  However, there are options that can change how
-       pcre2grep behaves. In particular, the -M option makes  it  possible  to
+       pcre2grep behaves. For example, the -M  option  makes  it  possible  to
        search  for  strings  that  span  line  boundaries. What defines a line
-       boundary is controlled by the -N (--newline) option.
+       boundary is controlled by the -N (--newline) option. The -h and -H  op-
+       tions  control  whether  or not file names are shown, and the -Z option
+       changes the file name terminator to a zero byte.
 
        The amount of memory used for buffering files that are being scanned is
        controlled  by  parameters  that  can  be  set by the --buffer-size and
        --max-buffer-size options. The first of these sets the size  of  buffer
        that  is obtained at the start of processing. If an input file contains
        very long lines, a larger buffer may be needed; this is handled by  au-
        tomatically  extending  the buffer, up to the limit specified by --max-
@@ -70,115 +72,125 @@
        greater.   BUFSIZ  is defined in <stdio.h>. When there is more than one
        pattern (specified by the use of -e and/or -f), each pattern is applied
        to  each  line  in the order in which they are defined, except that all
        the -e patterns are tried before the -f patterns.
 
        By default, as soon as one pattern matches a line, no further  patterns
        are considered. However, if --colour (or --color) is used to colour the
-       matching substrings, or if --only-matching, --file-offsets, or  --line-
-       offsets  is  used to output only the part of the line that matched (ei-
-       ther shown literally, or as an offset),  scanning  resumes  immediately
-       following  the  match,  so that further matches on the same line can be
-       found. If there are multiple patterns, they are all tried  on  the  re-
-       mainder  of the line, but patterns that follow the one that matched are
-       not tried on the earlier matched part of the line.
-
-       This behaviour means that the order  in  which  multiple  patterns  are
-       specified  can affect the output when one of the above options is used.
-       This is no longer the same behaviour as GNU grep, which now manages  to
-       display  earlier  matches  for  later  patterns (as long as there is no
-       overlap).
-
-       Patterns that can match an empty string are accepted, but empty  string
-       matches   are  never  recognized.  An  example  is  the  pattern  "(su-
-       per)?(man)?", in which all components are optional. This pattern  finds
-       all  occurrences  of  both  "super"  and "man"; the output differs from
-       matching with "super|man" when only the matching substrings  are  being
+       matching substrings, or if --only-matching, --file-offsets, --line-off-
+       sets,  or  --output  is  used  to output only the part of the line that
+       matched (either shown literally, or as an  offset),  the  behaviour  is
+       different. In this situation, all the patterns are applied to the line.
+       If there is more than one match, the one that  begins  nearest  to  the
+       start  of  the subject is processed; if there is more than one match at
+       that position, the one with the  longest  matching  substring  is  pro-
+       cessed;  if the matching substrings are equal, the first match found is
+       processed.
+
+       Scanning with all the patterns resumes immediately following the match,
+       so  that  later  matches  on the same line can be found. Note, however,
+       that an overlapping match that starts in the middle  of  another  match
+       will not be processed.
+
+       The  above behaviour was changed at release 10.41 to be more compatible
+       with GNU grep. In earlier releases, pcre2grep did not recognize matches
+       from later patterns that were earlier in the subject.
+
+       Patterns  that can match an empty string are accepted, but empty string
+       matches  are  never  recognized.  An  example  is  the  pattern   "(su-
+       per)?(man)?",  in which all components are optional. This pattern finds
+       all occurrences of both "super" and  "man";  the  output  differs  from
+       matching  with  "super|man" when only the matching substrings are being
        shown.
 
-       If  the  LC_ALL or LC_CTYPE environment variable is set, pcre2grep uses
+       If the LC_ALL or LC_CTYPE environment variable is set,  pcre2grep  uses
        the value to set a locale when calling the PCRE2 library.  The --locale
        option can be used to override this.
 
 
 SUPPORT FOR COMPRESSED FILES
 
-       It  is  possible to compile pcre2grep so that it uses libz or libbz2 to
-       read compressed files whose names end in .gz or .bz2, respectively. You
-       can  find out whether your pcre2grep binary has support for one or both
-       of these file types by running it with the --help option. If the appro-
-       priate support is not present, all files are treated as plain text. The
-       standard input is always so treated. When input is  from  a  compressed
-       .gz or .bz2 file, the --line-buffered option is ignored.
+       Compile-time options for pcre2grep can set it up to use libz or  libbz2
+       for  reading  compressed  files whose names end in .gz or .bz2, respec-
+       tively. You can find out whether your pcre2grep binary has support  for
+       one  or  both of these file types by running it with the --help option.
+       If the appropriate support is not present, all  files  are  treated  as
+       plain  text.  The standard input is always so treated. If a file with a
+       .gz or .bz2 extension is not in fact compressed, it is read as a  plain
+       text  file.  When  input  is  from  a  compressed .gz or .bz2 file, the
+       --line-buffered option is ignored.
 
 
 BINARY FILES
 
-       By  default,  a  file that contains a binary zero byte within the first
-       1024 bytes is identified as a binary file, and is processed  specially.
-       However,  if  the  newline  type is specified as NUL, that is, the line
+       By default, a file that contains a binary zero byte  within  the  first
+       1024  bytes is identified as a binary file, and is processed specially.
+       However, if the newline type is specified as NUL,  that  is,  the  line
        terminator is a binary zero, the test for a binary file is not applied.
-       See  the  --binary-files  option for a means of changing the way binary
+       See the --binary-files option for a means of changing  the  way  binary
        files are handled.
 
 
 BINARY ZEROS IN PATTERNS
 
-       Patterns passed from the command line are strings that  are  terminated
-       by  a  binary zero, so cannot contain internal zeros. However, patterns
+       Patterns  passed  from the command line are strings that are terminated
+       by a binary zero, so cannot contain internal zeros.  However,  patterns
        that are read from a file via the -f option may contain binary zeros.
 
 
 OPTIONS
 
-       The order in which some of the options appear can  affect  the  output.
-       For  example,  both  the  -H and -l options affect the printing of file
-       names. Whichever comes later in the command line will be the  one  that
-       takes  effect.  Similarly,  except  where  noted below, if an option is
-       given twice, the later setting is used. Numerical  values  for  options
-       may  be  followed  by  K  or  M,  to  signify multiplication by 1024 or
+       The  order  in  which some of the options appear can affect the output.
+       For example, both the -H and -l options affect  the  printing  of  file
+       names.  Whichever  comes later in the command line will be the one that
+       takes effect. Similarly, except where noted  below,  if  an  option  is
+       given  twice,  the  later setting is used. Numerical values for options
+       may be followed by K  or  M,  to  signify  multiplication  by  1024  or
        1024*1024 respectively.
 
        --        This terminates the list of options. It is useful if the next
-                 item  on  the command line starts with a hyphen but is not an
-                 option. This allows for the processing of patterns  and  file
+                 item on the command line starts with a hyphen but is  not  an
+                 option.  This  allows for the processing of patterns and file
                  names that start with hyphens.
 
        -A number, --after-context=number
-                 Output  up  to  number  lines  of context after each matching
-                 line. Fewer lines are output if the next match or the end  of
-                 the  file  is  reached,  or if the processing buffer size has
+                 Output up to number lines  of  context  after  each  matching
+                 line.  Fewer lines are output if the next match or the end of
+                 the file is reached, or if the  processing  buffer  size  has
                  been set too small. If file names and/or line numbers are be-
                  ing output, a hyphen separator is used instead of a colon for
-                 the context lines. A line containing "--" is  output  between
-                 each  group  of  lines, unless they are in fact contiguous in
-                 the input file. The value of number is expected to  be  rela-
-                 tively small. When -c is used, -A is ignored.
+                 the  context  lines  (the -Z option can be used to change the
+                 file name terminator to a zero byte). A line containing  "--"
+                 is  output  between  each  group of lines, unless they are in
+                 fact contiguous in the input file. The value of number is ex-
+                 pected  to  be  relatively  small. When -c is used, -A is ig-
+                 nored.
 
        -a, --text
-                 Treat  binary  files as text. This is equivalent to --binary-
+                 Treat binary files as text. This is equivalent  to  --binary-
                  files=text.
 
        --allow-lookaround-bsk
                  PCRE2 now forbids the use of \K in lookarounds by default, in
-                 line  with  Perl.   This  option  causes pcre2grep to set the
-                 PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK option, which  enables  this
+                 line with Perl.  This option  causes  pcre2grep  to  set  the
+                 PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK  option,  which enables this
                  somewhat dangerous usage.
 
        -B number, --before-context=number
-                 Output  up  to  number  lines of context before each matching
-                 line. Fewer lines are output if the  previous  match  or  the
-                 start  of the file is within number lines, or if the process-
-                 ing buffer size has been set too small. If file names  and/or
+                 Output up to number lines of  context  before  each  matching
+                 line.  Fewer  lines  are  output if the previous match or the
+                 start of the file is within number lines, or if the  process-
+                 ing  buffer size has been set too small. If file names and/or
                  line numbers are being output, a hyphen separator is used in-
-                 stead of a colon for the context  lines.  A  line  containing
-                 "--"  is  output between each group of lines, unless they are
-                 in fact contiguous in the input file. The value of number  is
-                 expected  to  be relatively small. When -c is used, -B is ig-
-                 nored.
+                 stead  of a colon for the context lines (the -Z option can be
+                 used to change the file name terminator to a  zero  byte).  A
+                 line  containing  "--" is output between each group of lines,
+                 unless they are in fact contiguous in  the  input  file.  The
+                 value  of  number is expected to be relatively small. When -c
+                 is used, -B is ignored.
 
        --binary-files=word
                  Specify how binary files are to be processed. If the word  is
                  "binary"  (the default), pattern matching is performed on bi-
                  nary files, but  the  only  output  is  "Binary  file  <name>
                  matches"  when a match succeeds. If the word is "text", which
                  is equivalent to the -a or --text option,  binary  files  are
@@ -222,149 +234,139 @@
                  If this option is given without any data, it is equivalent to
                  "--colour=auto".   If  data  is required, it must be given in
                  the same shell item, separated by an equals sign.
 
        --colour=value, --color=value
                  This option specifies under what circumstances the parts of a
                  line that matched a pattern should be coloured in the output.
-                 By default, the output is not coloured. The value  (which  is
-                 optional,  see above) may be "never", "always", or "auto". In
-                 the latter case, colouring happens only if the standard  out-
-                 put  is connected to a terminal. More resources are used when
-                 colouring is enabled, because pcre2grep has to search for all
-                 possible  matches in a line, not just one, in order to colour
-                 them all.
+                 It is ignored if --file-offsets, --line-offsets, or  --output
+                 is set. By default, output is not coloured. The value for the
+                 --colour  option  (which  is  optional,  see  above)  may  be
+                 "never",  "always",  or "auto". In the latter case, colouring
+                 happens only if the standard output is connected to a  termi-
+                 nal.   More resources are used when colouring is enabled, be-
+                 cause pcre2grep has to search for all possible matches  in  a
+                 line, not just one, in order to colour them all.
 
-                 The colour that is used can be specified by  setting  one  of
-                 the  environment variables PCRE2GREP_COLOUR, PCRE2GREP_COLOR,
+                 The  colour  that  is used can be specified by setting one of
+                 the environment variables PCRE2GREP_COLOUR,  PCRE2GREP_COLOR,
                  PCREGREP_COLOUR, or PCREGREP_COLOR, which are checked in that
                  order.  If  none  of  these  are  set,  pcre2grep  looks  for
-                 GREP_COLORS or GREP_COLOR (in that order). The value  of  the
-                 variable  should  be  a string of two numbers, separated by a
-                 semicolon, except in the  case  of  GREP_COLORS,  which  must
+                 GREP_COLORS  or  GREP_COLOR (in that order). The value of the
+                 variable should be a string of two numbers,  separated  by  a
+                 semicolon,  except  in  the  case  of GREP_COLORS, which must
                  start with "ms=" or "mt=" followed by two semicolon-separated
-                 colours, terminated by the end of the string or by  a  colon.
-                 If  GREP_COLORS  does not start with "ms=" or "mt=" it is ig-
+                 colours,  terminated  by the end of the string or by a colon.
+                 If GREP_COLORS does not start with "ms=" or "mt=" it  is  ig-
                  nored, and GREP_COLOR is checked.
 
-                 If the string obtained from one of the above  variables  con-
+                 If  the  string obtained from one of the above variables con-
                  tains any characters other than semicolon or digits, the set-
                  ting is ignored and the default colour is used. The string is
                  copied directly into the control string for setting colour on
-                 a terminal, so it is your responsibility to ensure  that  the
-                 values  make  sense.  If  no relevant environment variable is
+                 a  terminal,  so it is your responsibility to ensure that the
+                 values make sense. If no  relevant  environment  variable  is
                  set, the default is "1;31", which gives red.
 
        -D action, --devices=action
-                 If an input path is not a regular file or a  directory,  "ac-
-                 tion"  specifies  how it is to be processed. Valid values are
+                 If  an  input path is not a regular file or a directory, "ac-
+                 tion" specifies how it is to be processed. Valid  values  are
                  "read" (the default) or "skip" (silently skip the path).
 
        -d action, --directories=action
                  If an input path is a directory, "action" specifies how it is
-                 to  be  processed.   Valid  values are "read" (the default in
-                 non-Windows environments, for compatibility with  GNU  grep),
-                 "recurse"  (equivalent to the -r option), or "skip" (silently
-                 skip the path, the default in Windows environments).  In  the
-                 "read"  case,  directories  are read as if they were ordinary
-                 files. In some operating systems the effect of reading a  di-
-                 rectory  like  this is an immediate end-of-file; in others it
+                 to be processed.  Valid values are  "read"  (the  default  in
+                 non-Windows  environments,  for compatibility with GNU grep),
+                 "recurse" (equivalent to the -r option), or "skip"  (silently
+                 skip  the  path, the default in Windows environments). In the
+                 "read" case, directories are read as if  they  were  ordinary
+                 files.  In some operating systems the effect of reading a di-
+                 rectory like this is an immediate end-of-file; in  others  it
                  may provoke an error.
 
        --depth-limit=number
                  See --match-limit below.
 
        -e pattern, --regex=pattern, --regexp=pattern
                  Specify a pattern to be matched. This option can be used mul-
                  tiple times in order to specify several patterns. It can also
-                 be used as a way of specifying a single pattern  that  starts
-                 with  a hyphen. When -e is used, no argument pattern is taken
-                 from the command line; all  arguments  are  treated  as  file
-                 names.  There is no limit to the number of patterns. They are
-                 applied to each line in the order in which they  are  defined
-                 until one matches.
+                 be  used  as a way of specifying a single pattern that starts
+                 with a hyphen. When -e is used, no argument pattern is  taken
+                 from  the  command  line;  all  arguments are treated as file
+                 names. There is no limit to the number of patterns. They  are
+                 applied to each line in the order in which they are defined.
 
                  If  -f is used with -e, the command line patterns are matched
                  first, followed by the patterns from the file(s), independent
-                 of  the order in which these options are specified. Note that
-                 multiple use of -e is not the same as a single  pattern  with
-                 alternatives. For example, X|Y finds the first character in a
-                 line that is X or Y, whereas if the two  patterns  are  given
-                 separately, with X first, pcre2grep finds X if it is present,
-                 even if it follows Y in the line. It finds Y only if there is
-                 no  X  in  the line. This matters only if you are using -o or
-                 --colo(u)r to show the part(s) of the line that matched.
+                 of the order in which these options are specified.
 
        --exclude=pattern
                  Files (but not directories) whose names match the pattern are
-                 skipped  without  being processed. This applies to all files,
-                 whether listed on the command  line,  obtained  from  --file-
+                 skipped without being processed. This applies to  all  files,
+                 whether  listed  on  the  command line, obtained from --file-
                  list, or by scanning a directory. The pattern is a PCRE2 reg-
-                 ular expression, and is matched against the  final  component
+                 ular  expression,  and is matched against the final component
                  of the file name, not the entire path. The -F, -w, and -x op-
-                 tions do not apply to this pattern. The option may  be  given
+                 tions  do  not apply to this pattern. The option may be given
                  any number of times in order to specify multiple patterns. If
-                 a file name matches both an --include and an  --exclude  pat-
+                 a  file  name matches both an --include and an --exclude pat-
                  tern, it is excluded. There is no short form for this option.
 
        --exclude-from=filename
-                 Treat  each  non-empty  line  of  the file as the data for an
+                 Treat each non-empty line of the file  as  the  data  for  an
                  --exclude option. What constitutes a newline when reading the
-                 file  is the operating system's default. The --newline option
-                 has no effect on this option. This option may be  given  more
+                 file is the operating system's default. The --newline  option
+                 has  no  effect on this option. This option may be given more
                  than once in order to specify a number of files to read.
 
        --exclude-dir=pattern
                  Directories whose names match the pattern are skipped without
-                 being processed, whatever the setting of the --recursive  op-
-                 tion.  This applies to all directories, whether listed on the
-                 command line, obtained from --file-list,  or  by  scanning  a
-                 parent  directory. The pattern is a PCRE2 regular expression,
-                 and is matched against the final component of  the  directory
-                 name,  not the entire path. The -F, -w, and -x options do not
-                 apply to this pattern. The option may be given any number  of
-                 times  in order to specify more than one pattern. If a direc-
-                 tory matches both --include-dir and --exclude-dir, it is  ex-
+                 being  processed, whatever the setting of the --recursive op-
+                 tion. This applies to all directories, whether listed on  the
+                 command  line,  obtained  from  --file-list, or by scanning a
+                 parent directory. The pattern is a PCRE2 regular  expression,
+                 and  is  matched against the final component of the directory
+                 name, not the entire path. The -F, -w, and -x options do  not
+                 apply  to this pattern. The option may be given any number of
+                 times in order to specify more than one pattern. If a  direc-
+                 tory  matches both --include-dir and --exclude-dir, it is ex-
                  cluded. There is no short form for this option.
 
        -F, --fixed-strings
-                 Interpret  each  data-matching  pattern  as  a  list of fixed
-                 strings, separated by newlines, instead of as a  regular  ex-
+                 Interpret each data-matching  pattern  as  a  list  of  fixed
+                 strings,  separated  by newlines, instead of as a regular ex-
                  pression. What constitutes a newline for this purpose is con-
                  trolled by the --newline option. The -w (match as a word) and
-                 -x  (match whole line) options can be used with -F.  They ap-
-                 ply to each of the fixed strings. A line is selected  if  any
+                 -x (match whole line) options can be used with -F.  They  ap-
+                 ply  to  each of the fixed strings. A line is selected if any
                  of the fixed strings are found in it (subject to -w or -x, if
-                 present). This option applies only to the patterns  that  are
-                 matched  against  the contents of files; it does not apply to
-                 patterns specified by any of the --include or  --exclude  op-
+                 present).  This  option applies only to the patterns that are
+                 matched against the contents of files; it does not  apply  to
+                 patterns  specified  by any of the --include or --exclude op-
                  tions.
 
        -f filename, --file=filename
-                 Read  patterns  from  the  file, one per line, and match them
-                 against each line of input. As is the case with  patterns  on
-                 the  command line, no delimiters should be used. What consti-
-                 tutes a newline when reading the file is the  operating  sys-
-                 tem's  default interpretation of \n. The --newline option has
-                 no effect on this option. Trailing  white  space  is  removed
-                 from  each  line,  and blank lines are ignored. An empty file
-                 contains no patterns and therefore matches nothing.  Patterns
-                 read  from a file in this way may contain binary zeros, which
-                 are treated as ordinary data characters. See  also  the  com-
-                 ments  about  multiple  patterns versus a single pattern with
-                 alternatives in the description of -e above.
+                 Read patterns from the file, one per line.  As  is  the  case
+                 with  patterns  on  the command line, no delimiters should be
+                 used. What constitutes a newline when reading the file is the
+                 operating  system's  default interpretation of \n. The --new-
+                 line option has no effect  on  this  option.  Trailing  white
+                 space is removed from each line, and blank lines are ignored.
+                 An empty file contains  no  patterns  and  therefore  matches
+                 nothing.  Patterns  read  from a file in this way may contain
+                 binary zeros, which are treated as ordinary data characters.
 
                  If this option is given more than  once,  all  the  specified
                  files  are read. A data line is output if any of the patterns
                  match it. A file name can be given as "-"  to  refer  to  the
                  standard  input.  When  -f is used, patterns specified on the
-                 command line using -e may also be present;  they  are  tested
-                 before  the  file's  patterns.  However,  no other pattern is
-                 taken from the command line; all arguments are treated as the
-                 names of paths to be searched.
+                 command line using -e may also be present; they  are  matched
+                 before the file's patterns. However, no pattern is taken from
+                 the command line; all arguments are treated as the  names  of
+                 paths to be searched.
 
        --file-list=filename
                  Read  a  list  of  files  and/or  directories  that are to be
                  scanned from the given file, one per line. What constitutes a
                  newline  when  reading the file is the operating system's de-
                  fault. Trailing white space is removed from  each  line,  and
                  blank lines are ignored. These paths are processed before any
@@ -375,38 +377,42 @@
                  minal, from which further lines (the list of  files)  can  be
                  read after an end-of-file indication. If this option is given
                  more than once, all the specified files are read.
 
        --file-offsets
                  Instead of showing lines or parts of lines that  match,  show
                  each  match  as  an  offset  from the start of the file and a
-                 length, separated by a comma. In this  mode,  no  context  is
-                 shown.  That  is,  the -A, -B, and -C options are ignored. If
-                 there is more than one match in a line, each of them is shown
-                 separately.  This option is mutually exclusive with --output,
-                 --line-offsets, and --only-matching.
+                 length, separated by a comma. In this mode, --colour  has  no
+                 effect,  and no context is shown. That is, the -A, -B, and -C
+                 options are ignored. If there is more than  one  match  in  a
+                 line,  each of them is shown separately. This option is mutu-
+                 ally exclusive with  --output,  --line-offsets,  and  --only-
+                 matching.
 
        -H, --with-filename
-                 Force the inclusion of the file name at the start  of  output
-                 lines when searching a single file. By default, the file name
-                 is not shown in this case.  For matching lines, the file name
-                 is followed by a colon; for context lines, a hyphen separator
-                 is used. If a line number is also being  output,  it  follows
-                 the  file  name. When the -M option causes a pattern to match
-                 more than one line, only the first is preceded  by  the  file
-                 name.  This  option  overrides any previous -h, -l, or -L op-
-                 tions.
+                 Force  the  inclusion of the file name at the start of output
+                 lines when searching a single file. The file name is not nor-
+                 mally  shown  in  this case.  By default, for matching lines,
+                 the file name is followed by a colon; for  context  lines,  a
+                 hyphen separator is used. The -Z option can be used to change
+                 the terminator to a zero byte. If a line number is also being
+                 output, it follows the file name. When the -M option causes a
+                 pattern to match more than one line, only the first  is  pre-
+                 ceded  by  the  file name. This option overrides any previous
+                 -h, -l, or -L options.
 
        -h, --no-filename
                  Suppress the output file names when searching multiple files.
-                 By  default,  file  names  are  shown when multiple files are
-                 searched. For matching lines, the file name is followed by  a
-                 colon;  for  context lines, a hyphen separator is used.  If a
-                 line number is also being output, it follows the  file  name.
-                 This option overrides any previous -H, -L, or -l options.
+                 File  names  are  normally  shown  when  multiple  files  are
+                 searched. By default, for matching lines, the  file  name  is
+                 followed by a colon; for context lines, a hyphen separator is
+                 used. The -Z option can be used to change the terminator to a
+                 zero  byte. If a line number is also being output, it follows
+                 the file name.  This option overrides any previous -H, -L, or
+                 -l options.
 
        --heap-limit=number
                  See --match-limit below.
 
        --help    Output  a  help  message, giving brief details of the command
                  options and file type support, and then exit.  Anything  else
                  on the command line is ignored.
@@ -451,29 +457,31 @@
                  If a directory matches both --include-dir and  --exclude-dir,
                  it is excluded. There is no short form for this option.
 
        -L, --files-without-match
                  Instead  of  outputting lines from the files, just output the
                  names of the files that do not contain any lines  that  would
                  have  been  output. Each file name is output once, on a sepa-
-                 rate line. This option overrides any previous -H, -h,  or  -l
-                 options.
+                 rate line by default, but if the -Z option is set,  they  are
+                 separated  by  zero  bytes  instead  of newlines. This option
+                 overrides any previous -H, -h, or -l options.
 
        -l, --files-with-matches
-                 Instead  of  outputting lines from the files, just output the
+                 Instead of outputting lines from the files, just  output  the
                  names of the files containing lines that would have been out-
-                 put.  Each  file  name  is  output  once, on a separate line.
-                 Searching normally stops as soon as a matching line is  found
-                 in  a  file.  However, if the -c (count) option is also used,
-                 matching continues in order to obtain the correct count,  and
-                 those  files  that  have  at least one match are listed along
-                 with their counts. Using this option with -c is a way of sup-
-                 pressing  the  listing  of  files with no matches that occurs
-                 with -c on its own. This option overrides  any  previous  -H,
-                 -h, or -L options.
+                 put. Each file name is output once, on a separate  line,  but
+                 if the -Z option is set, they are separated by zero bytes in-
+                 stead of newlines. Searching normally  stops  as  soon  as  a
+                 matching  line is found in a file. However, if the -c (count)
+                 option is also used, matching continues in  order  to  obtain
+                 the  correct  count,  and  those files that have at least one
+                 match are listed along with their counts. Using  this  option
+                 with  -c is a way of suppressing the listing of files with no
+                 matches that occurs with -c on its own. This option overrides
+                 any previous -H, -h, or -L options.
 
        --label=name
                  This option supplies a name to be used for the standard input
                  when file names are being output. If not supplied, "(standard
                  input)" is used. There is no short form for this option.
 
        --line-buffered
@@ -491,19 +499,19 @@
                  file, --line-buffered is ignored.
 
        --line-offsets
                  Instead of showing lines or parts of lines that  match,  show
                  each match as a line number, the offset from the start of the
                  line, and a length. The line number is terminated by a  colon
                  (as  usual; see the -n option), and the offset and length are
-                 separated by a comma. In this  mode,  no  context  is  shown.
-                 That  is, the -A, -B, and -C options are ignored. If there is
-                 more than one match in a line, each of them  is  shown  sepa-
-                 rately.  This  option  is  mutually  exclusive with --output,
-                 --file-offsets, and --only-matching.
+                 separated by a comma. In this mode, --colour has  no  effect,
+                 and  no context is shown. That is, the -A, -B, and -C options
+                 are ignored. If there is more than one match in a line,  each
+                 of  them  is shown separately. This option is mutually exclu-
+                 sive with --output, --file-offsets, and --only-matching.
 
        --locale=locale-name
                  This option specifies a locale to be used for pattern  match-
                  ing.  It  overrides the value in the LC_ALL or LC_CTYPE envi-
                  ronment variables. If no locale is specified, the  PCRE2  li-
                  brary's default (usually the "C" locale) is used. There is no
                  short form for this option.
@@ -567,448 +575,452 @@
                  ities in their search trees. The classic example is a pattern
                  that uses nested unlimited repeats. Internally, PCRE2  has  a
                  counter  that  is  incremented each time around its main pro-
                  cessing loop. If the value set by --match-limit  is  reached,
                  an error occurs.
 
                  The  --heap-limit  option specifies, as a number of kibibytes
-                 (units of 1024 bytes), the amount of heap memory that may  be
-                 used for matching. Heap memory is needed only if matching the
-                 pattern requires a significant number of nested  backtracking
-                 points to be remembered. This parameter can be set to zero to
-                 forbid the use of heap memory altogether.
+                 (units of 1024 bytes), the maximum amount of heap memory that
+                 may be used for matching.
 
-                 The --depth-limit option limits the  depth  of  nested  back-
+                 The  --depth-limit  option  limits  the depth of nested back-
                  tracking points, which indirectly limits the amount of memory
                  that is used. The amount of memory needed for each backtrack-
-                 ing  point  depends on the number of capturing parentheses in
+                 ing point depends on the number of capturing  parentheses  in
                  the pattern, so the amount of memory that is used before this
-                 limit  acts  varies from pattern to pattern. This limit is of
+                 limit acts varies from pattern to pattern. This limit  is  of
                  use only if it is set smaller than --match-limit.
 
-                 There are no short forms for these options. The default  lim-
-                 its  can  be  set when the PCRE2 library is compiled; if they
-                 are not specified, the defaults are very large and so  effec-
+                 There  are no short forms for these options. The default lim-
+                 its can be set when the PCRE2 library is  compiled;  if  they
+                 are  not specified, the defaults are very large and so effec-
                  tively unlimited.
 
        --max-buffer-size=number
-                 This  limits  the  expansion  of the processing buffer, whose
-                 initial size can be set by --buffer-size. The maximum  buffer
-                 size  is  silently  forced to be no smaller than the starting
+                 This limits the expansion of  the  processing  buffer,  whose
+                 initial  size can be set by --buffer-size. The maximum buffer
+                 size is silently forced to be no smaller  than  the  starting
                  buffer size.
 
        -N newline-type, --newline=newline-type
                  Six different conventions for indicating the ends of lines in
                  scanned files are supported. For example:
 
                    pcre2grep -N CRLF 'some pattern' <file>
 
-                 The  newline  type may be specified in upper, lower, or mixed
-                 case. If the newline type is NUL, lines are separated by  bi-
-                 nary  zero characters. The other types are the single-charac-
-                 ter sequences CR (carriage return)  and  LF  (linefeed),  the
-                 two-character  sequence CRLF, an "anycrlf" type, which recog-
-                 nizes any of the preceding three types, and  an  "any"  type,
-                 for  which any Unicode line ending sequence is assumed to end
-                 a line. The Unicode sequences are the three  just  mentioned,
-                 plus  VT  (vertical tab, U+000B), FF (form feed, U+000C), NEL
-                 (next line, U+0085), LS  (line  separator,  U+2028),  and  PS
+                 The newline type may be specified in upper, lower,  or  mixed
+                 case.  If the newline type is NUL, lines are separated by bi-
+                 nary zero characters. The other types are the  single-charac-
+                 ter  sequences  CR  (carriage  return) and LF (linefeed), the
+                 two-character sequence CRLF, an "anycrlf" type, which  recog-
+                 nizes  any  of  the preceding three types, and an "any" type,
+                 for which any Unicode line ending sequence is assumed to  end
+                 a  line.  The Unicode sequences are the three just mentioned,
+                 plus VT (vertical tab, U+000B), FF (form feed,  U+000C),  NEL
+                 (next  line,  U+0085),  LS  (line  separator, U+2028), and PS
                  (paragraph separator, U+2029).
 
-                 When  the  PCRE2  library is built, a default line-ending se-
-                 quence is specified.  This is normally the standard  sequence
-                 for  the operating system. Unless otherwise specified by this
+                 When the PCRE2 library is built, a  default  line-ending  se-
+                 quence  is specified.  This is normally the standard sequence
+                 for the operating system. Unless otherwise specified by  this
                  option, pcre2grep uses the library's default.
 
-                 This option makes it possible to use pcre2grep to scan  files
+                 This  option makes it possible to use pcre2grep to scan files
                  that have come from other environments without having to mod-
-                 ify their line endings. If the data  that  is  being  scanned
-                 does  not  agree  with  the  convention  set  by this option,
-                 pcre2grep may behave in strange ways. Note that  this  option
-                 does  not apply to files specified by the -f, --exclude-from,
-                 or --include-from options, which are expected to use the  op-
+                 ify  their  line  endings.  If the data that is being scanned
+                 does not agree  with  the  convention  set  by  this  option,
+                 pcre2grep  may  behave in strange ways. Note that this option
+                 does not apply to files specified by the -f,  --exclude-from,
+                 or  --include-from options, which are expected to use the op-
                  erating system's standard newline sequence.
 
        -n, --line-number
                  Precede each output line by its line number in the file, fol-
-                 lowed by a colon for matching lines or a hyphen  for  context
+                 lowed  by  a colon for matching lines or a hyphen for context
                  lines. If the file name is also being output, it precedes the
-                 line number. When the -M option causes  a  pattern  to  match
-                 more  than  one  line, only the first is preceded by its line
+                 line  number.  When  the  -M option causes a pattern to match
+                 more than one line, only the first is preceded  by  its  line
                  number. This option is forced if --line-offsets is used.
 
-       --no-jit  If the PCRE2 library is built with support  for  just-in-time
+       --no-jit  If  the  PCRE2 library is built with support for just-in-time
                  compiling (which speeds up matching), pcre2grep automatically
                  makes use of this, unless it was explicitly disabled at build
-                 time.  This  option  can be used to disable the use of JIT at
-                 run time. It is provided for testing and working round  prob-
+                 time. This option can be used to disable the use  of  JIT  at
+                 run  time. It is provided for testing and working round prob-
                  lems.  It should never be needed in normal use.
 
        -O text, --output=text
-                 When  there  is  a match, instead of outputting the line that
-                 matched, output just the text specified in this option,  fol-
-                 lowed  by an operating-system standard newline. In this mode,
-                 no context is shown. That is, the -A, -B, and -C options  are
-                 ignored.  The  --newline option has no effect on this option,
-                 which is mutually exclusive with --only-matching, --file-off-
-                 sets,  and  --line-offsets. However, like --only-matching, if
-                 there is more than one match in a line, each of them causes a
-                 line of output.
+                 When there is a match, instead of outputting  the  line  that
+                 matched,  output just the text specified in this option, fol-
+                 lowed by an operating-system standard newline. In this  mode,
+                 --colour  has  no  effect, and no context is shown.  That is,
+                 the -A, -B, and -C options are ignored. The --newline  option
+                 has  no  effect  on  this option, which is mutually exclusive
+                 with  --only-matching,  --file-offsets,  and  --line-offsets.
+                 However,  like  --only-matching,  if  there  is more than one
+                 match in a line, each of them causes a line of output.
 
                  Escape sequences starting with a dollar character may be used
                  to insert the contents of the matched part of the line and/or
                  captured substrings into the text.
 
-                 $<digits>  or  ${<digits>}  is  replaced by the captured sub-
-                 string of the given  decimal  number;  zero  substitutes  the
+                 $<digits> or ${<digits>} is replaced  by  the  captured  sub-
+                 string  of  the  given  decimal  number; zero substitutes the
                  whole match. If the number is greater than the number of cap-
-                 turing substrings, or if the capture is unset,  the  replace-
+                 turing  substrings,  or if the capture is unset, the replace-
                  ment is empty.
 
-                 $a  is replaced by bell; $b by backspace; $e by escape; $f by
-                 form feed; $n by newline; $r by carriage return; $t  by  tab;
+                 $a is replaced by bell; $b by backspace; $e by escape; $f  by
+                 form  feed;  $n by newline; $r by carriage return; $t by tab;
                  $v by vertical tab.
 
                  $o<digits> or $o{<digits>} is replaced by the character whose
-                 code point is the given octal number. In the first  form,  up
-                 to  three  octal  digits are processed.  When more digits are
-                 needed in Unicode mode to specify a wide character, the  sec-
+                 code  point  is the given octal number. In the first form, up
+                 to three octal digits are processed.  When  more  digits  are
+                 needed  in Unicode mode to specify a wide character, the sec-
                  ond form must be used.
 
-                 $x<digits>  or $x{<digits>} is replaced by the character rep-
-                 resented by the given hexadecimal number. In the first  form,
-                 up  to two hexadecimal digits are processed. When more digits
-                 are needed in Unicode mode to specify a wide  character,  the
+                 $x<digits> or $x{<digits>} is replaced by the character  rep-
+                 resented  by the given hexadecimal number. In the first form,
+                 up to two hexadecimal digits are processed. When more  digits
+                 are  needed  in Unicode mode to specify a wide character, the
                  second form must be used.
 
-                 Any  other character is substituted by itself. In particular,
+                 Any other character is substituted by itself. In  particular,
                  $$ is replaced by a single dollar.
 
        -o, --only-matching
                  Show only the part of the line that matched a pattern instead
-                 of  the  whole  line. In this mode, no context is shown. That
-                 is, the -A, -B, and -C options are ignored. If there is  more
-                 than  one  match in a line, each of them is shown separately,
-                 on a separate line of output. If -o is combined with -v  (in-
-                 vert  the  sense of the match to find non-matching lines), no
-                 output is generated, but the return  code  is  set  appropri-
-                 ately.  If  the matched portion of the line is empty, nothing
-                 is output unless the file  name  or  line  number  are  being
-                 printed,  in  which case they are shown on an otherwise empty
+                 of the whole line. In this mode, no context  is  shown.  That
+                 is,  the -A, -B, and -C options are ignored. If there is more
+                 than one match in a line, each of them is  shown  separately,
+                 on  a separate line of output. If -o is combined with -v (in-
+                 vert the sense of the match to find non-matching  lines),  no
+                 output  is  generated,  but  the return code is set appropri-
+                 ately. If the matched portion of the line is  empty,  nothing
+                 is  output  unless  the  file  name  or line number are being
+                 printed, in which case they are shown on an  otherwise  empty
                  line.  This  option  is  mutually  exclusive  with  --output,
                  --file-offsets and --line-offsets.
 
        -onumber, --only-matching=number
-                 Show  only  the  part  of the line that matched the capturing
+                 Show only the part of the line  that  matched  the  capturing
                  parentheses of the given number. Up to 50 capturing parenthe-
-                 ses  are  supported by default. This limit can be changed via
-                 the --om-capture option. A pattern may contain any number  of
-                 capturing  parentheses, but only those whose number is within
-                 the limit can be accessed by -o. An error occurs if the  num-
+                 ses are supported by default. This limit can be  changed  via
+                 the  --om-capture option. A pattern may contain any number of
+                 capturing parentheses, but only those whose number is  within
+                 the  limit can be accessed by -o. An error occurs if the num-
                  ber specified by -o is greater than the limit.
 
                  -o0 is the same as -o without a number. Because these options
-                 can be given without an argument (see above), if an  argument
-                 is  present, it must be given in the same shell item, for ex-
-                 ample, -o3 or --only-matching=2. The comments given  for  the
-                 non-argument  case  above  also  apply to this option. If the
-                 specified capturing parentheses do not exist in the  pattern,
-                 or  were  not  set in the match, nothing is output unless the
+                 can  be given without an argument (see above), if an argument
+                 is present, it must be given in the same shell item, for  ex-
+                 ample,  -o3  or --only-matching=2. The comments given for the
+                 non-argument case above also apply to  this  option.  If  the
+                 specified  capturing parentheses do not exist in the pattern,
+                 or were not set in the match, nothing is  output  unless  the
                  file name or line number are being output.
 
-                 If this option is given multiple times,  multiple  substrings
-                 are  output  for  each  match,  in  the order the options are
-                 given, and all on one line. For example, -o3 -o1  -o3  causes
-                 the  substrings  matched by capturing parentheses 3 and 1 and
-                 then 3 again to be output. By default, there is no  separator
+                 If  this  option is given multiple times, multiple substrings
+                 are output for each match,  in  the  order  the  options  are
+                 given,  and  all on one line. For example, -o3 -o1 -o3 causes
+                 the substrings matched by capturing parentheses 3 and  1  and
+                 then  3 again to be output. By default, there is no separator
                  (but see the next but one option).
 
        --om-capture=number
-                 Set  the number of capturing parentheses that can be accessed
+                 Set the number of capturing parentheses that can be  accessed
                  by -o. The default is 50.
 
        --om-separator=text
-                 Specify a separating string for multiple occurrences  of  -o.
-                 The  default is an empty string. Separating strings are never
+                 Specify  a  separating string for multiple occurrences of -o.
+                 The default is an empty string. Separating strings are  never
                  coloured.
 
        -q, --quiet
                  Work quietly, that is, display nothing except error messages.
-                 The  exit  status  indicates  whether or not any matches were
+                 The exit status indicates whether or  not  any  matches  were
                  found.
 
        -r, --recursive
-                 If any given path is a directory, recursively scan the  files
-                 it  contains, taking note of any --include and --exclude set-
-                 tings. By default, a directory is read as a normal  file;  in
-                 some  operating  systems this gives an immediate end-of-file.
-                 This option is a shorthand for setting the -d option to  "re-
+                 If  any given path is a directory, recursively scan the files
+                 it contains, taking note of any --include and --exclude  set-
+                 tings.  By  default, a directory is read as a normal file; in
+                 some operating systems this gives an  immediate  end-of-file.
+                 This  option is a shorthand for setting the -d option to "re-
                  curse".
 
        --recursion-limit=number
-                 This  is  an obsolete synonym for --depth-limit. See --match-
+                 This is an obsolete synonym for --depth-limit.  See  --match-
                  limit above for details.
 
        -s, --no-messages
-                 Suppress error  messages  about  non-existent  or  unreadable
-                 files.  Such  files  are quietly skipped. However, the return
+                 Suppress  error  messages  about  non-existent  or unreadable
+                 files. Such files are quietly skipped.  However,  the  return
                  code is still 2, even if matches were found in other files.
 
        -t, --total-count
-                 This option is useful when scanning more than  one  file.  If
-                 used  on its own, -t suppresses all output except for a grand
-                 total number of matching lines (or non-matching lines  if  -v
+                 This  option  is  useful when scanning more than one file. If
+                 used on its own, -t suppresses all output except for a  grand
+                 total  number  of matching lines (or non-matching lines if -v
                  is used) in all the files. If -t is used with -c, a grand to-
-                 tal is output except when the previous  output  is  just  one
-                 line.  In  other words, it is not output when just one file's
-                 count is listed. If file names are being  output,  the  grand
-                 total  is preceded by "TOTAL:". Otherwise, it appears as just
-                 another number. The -t option is ignored when  used  with  -L
-                 (list  files  without matches), because the grand total would
+                 tal  is  output  except  when the previous output is just one
+                 line. In other words, it is not output when just  one  file's
+                 count  is  listed.  If file names are being output, the grand
+                 total is preceded by "TOTAL:". Otherwise, it appears as  just
+                 another  number.  The  -t option is ignored when used with -L
+                 (list files without matches), because the grand  total  would
                  always be zero.
 
        -u, --utf Operate in UTF-8 mode. This option is available only if PCRE2
                  has been compiled with UTF-8 support. All patterns (including
-                 those for any --exclude and --include options) and all  lines
-                 that  are  scanned must be valid strings of UTF-8 characters.
+                 those  for any --exclude and --include options) and all lines
+                 that are scanned must be valid strings of  UTF-8  characters.
                  If an invalid UTF-8 string is encountered, an error occurs.
 
        -U, --utf-allow-invalid
-                 As --utf, but in addition subject lines may  contain  invalid
-                 UTF-8  code  unit sequences. These can never form part of any
-                 pattern match. Patterns themselves, however,  must  still  be
+                 As  --utf,  but in addition subject lines may contain invalid
+                 UTF-8 code unit sequences. These can never form part  of  any
+                 pattern  match.  Patterns  themselves, however, must still be
                  valid UTF-8 strings. This facility allows valid UTF-8 strings
                  to be sought within arbitrary byte sequences in executable or
-                 other  binary  files. For more details about matching in non-
+                 other binary files. For more details about matching  in  non-
                  valid UTF-8 strings, see the pcre2unicode(3) documentation.
 
        -V, --version
-                 Write the version numbers of pcre2grep and the PCRE2  library
-                 to  the  standard  output and then exit. Anything else on the
+                 Write  the version numbers of pcre2grep and the PCRE2 library
+                 to the standard output and then exit. Anything  else  on  the
                  command line is ignored.
 
        -v, --invert-match
-                 Invert the sense of the match, so that  lines  which  do  not
-                 match  any  of the patterns are the ones that are found. When
-                 this option is  set,  options  such  as  --only-matching  and
-                 --output,  which specify parts of a match that are to be out-
+                 Invert  the  sense  of  the match, so that lines which do not
+                 match any of the patterns are the ones that are  found.  When
+                 this  option  is  set,  options  such  as --only-matching and
+                 --output, which specify parts of a match that are to be  out-
                  put, are ignored.
 
        -w, --word-regex, --word-regexp
                  Force the patterns only to match "words". That is, there must
-                 be  a  word  boundary  at  the  start and end of each matched
-                 string. This is equivalent to having "\b(?:" at the start  of
-                 each  pattern, and ")\b" at the end. This option applies only
-                 to the patterns that are  matched  against  the  contents  of
-                 files;  it does not apply to patterns specified by any of the
+                 be a word boundary at the  start  and  end  of  each  matched
+                 string.  This is equivalent to having "\b(?:" at the start of
+                 each pattern, and ")\b" at the end. This option applies  only
+                 to  the  patterns  that  are  matched against the contents of
+                 files; it does not apply to patterns specified by any of  the
                  --include or --exclude options.
 
        -x, --line-regex, --line-regexp
-                 Force the patterns to start matching only at  the  beginnings
-                 of  lines,  and  in  addition,  require  them to match entire
+                 Force  the  patterns to start matching only at the beginnings
+                 of lines, and in  addition,  require  them  to  match  entire
                  lines. In multiline mode the match may be more than one line.
                  This is equivalent to having "^(?:" at the start of each pat-
-                 tern and ")$" at the end. This option  applies  only  to  the
-                 patterns  that  are matched against the contents of files; it
-                 does not apply to patterns specified by any of the  --include
+                 tern  and  ")$"  at  the end. This option applies only to the
+                 patterns that are matched against the contents of  files;  it
+                 does  not apply to patterns specified by any of the --include
                  or --exclude options.
 
+       -Z, --null
+                 Terminate files names in the regular output with a zero  byte
+                 (the  NUL  character)  instead of what would normally appear.
+                 This is useful when file  names  contain  unusual  characters
+                 such  as  colons,  hyphens, or even newlines. The option does
+                 not apply to file names in error messages.
+
 
 ENVIRONMENT VARIABLES
 
        The environment variables LC_ALL and LC_CTYPE are examined, in that or-
        der, for a locale. The first one that is set is used. This can be over-
        ridden by the --locale option. If no locale is set, the PCRE2 library's
        default (usually the "C" locale) is used.
 
 
 NEWLINES
 
-       The -N (--newline) option allows pcre2grep to scan files  with  newline
-       conventions  that differ from the default. This option affects only the
-       way scanned files are processed. It does not affect the  interpretation
-       of  files  specified  by  the -f, --file-list, --exclude-from, or --in-
+       The  -N  (--newline) option allows pcre2grep to scan files with newline
+       conventions that differ from the default. This option affects only  the
+       way  scanned files are processed. It does not affect the interpretation
+       of files specified by the -f,  --file-list,  --exclude-from,  or  --in-
        clude-from options.
 
-       Any parts of the scanned input files that are written to  the  standard
-       output  are copied with whatever newline sequences they have in the in-
-       put. However, if the final line of a file is output, and  it  does  not
-       end  with  a newline sequence, a newline sequence is added. If the new-
-       line setting is CR, LF, CRLF or NUL, that line ending  is  output;  for
+       Any  parts  of the scanned input files that are written to the standard
+       output are copied with whatever newline sequences they have in the  in-
+       put.  However,  if  the final line of a file is output, and it does not
+       end with a newline sequence, a newline sequence is added. If  the  new-
+       line  setting  is  CR, LF, CRLF or NUL, that line ending is output; for
        the other settings (ANYCRLF or ANY) a single NL is used.
 
-       The  newline  setting does not affect the way in which pcre2grep writes
-       newlines in informational messages to the  standard  output  and  error
-       streams.   Under  Windows,  the standard output is set to be binary, so
-       that "\r\n" at the ends of output lines that are copied from the  input
-       is  not converted to "\r\r\n" by the C I/O library. This means that any
-       messages written to the standard output must end with "\r\n".  For  all
-       other  operating  systems,  and  for all messages to the standard error
+       The newline setting does not affect the way in which  pcre2grep  writes
+       newlines  in  informational  messages  to the standard output and error
+       streams.  Under Windows, the standard output is set to  be  binary,  so
+       that  "\r\n" at the ends of output lines that are copied from the input
+       is not converted to "\r\r\n" by the C I/O library. This means that  any
+       messages  written  to the standard output must end with "\r\n". For all
+       other operating systems, and for all messages  to  the  standard  error
        stream, "\n" is used.
 
 
 OPTIONS COMPATIBILITY
 
        Many of the short and long forms of pcre2grep's options are the same as
-       in  the GNU grep program. Any long option of the form --xxx-regexp (GNU
+       in the GNU grep program. Any long option of the form --xxx-regexp  (GNU
        terminology) is also available as --xxx-regex (PCRE2 terminology). How-
-       ever,  the  --depth-limit,  --file-list,  --file-offsets, --heap-limit,
-       --include-dir, --line-offsets, --locale,  --match-limit,  -M,  --multi-
-       line,  -N,  --newline,  --om-separator,  --output,  -u,  --utf, -U, and
+       ever, the  --depth-limit,  --file-list,  --file-offsets,  --heap-limit,
+       --include-dir,  --line-offsets,  --locale,  --match-limit, -M, --multi-
+       line, -N, --newline,  --om-separator,  --output,  -u,  --utf,  -U,  and
        --utf-allow-invalid options are specific to pcre2grep, as is the use of
        the --only-matching option with a capturing parentheses number.
 
-       Although  most  of the common options work the same way, a few are dif-
-       ferent in pcre2grep. For example, the --include option's argument is  a
-       glob  for GNU grep, but a regular expression for pcre2grep. If both the
-       -c and -l options are given, GNU grep lists only  file  names,  without
+       Although most of the common options work the same way, a few  are  dif-
+       ferent  in pcre2grep. For example, the --include option's argument is a
+       glob for GNU grep, but a regular expression for pcre2grep. If both  the
+       -c  and  -l  options are given, GNU grep lists only file names, without
        counts, but pcre2grep gives the counts as well.
 
 
 OPTIONS WITH DATA
 
        There are four different ways in which an option with data can be spec-
-       ified.  If a short form option is used, the  data  may  follow  immedi-
+       ified.   If  a  short  form option is used, the data may follow immedi-
        ately, or (with one exception) in the next command line item. For exam-
        ple:
 
          -f/some/file
          -f /some/file
 
-       The exception is the -o option, which may appear with or without  data.
-       Because  of this, if data is present, it must follow immediately in the
+       The  exception is the -o option, which may appear with or without data.
+       Because of this, if data is present, it must follow immediately in  the
        same item, for example -o3.
 
-       If a long form option is used, the data may appear in the same  command
-       line  item,  separated by an equals character, or (with two exceptions)
+       If  a long form option is used, the data may appear in the same command
+       line item, separated by an equals character, or (with  two  exceptions)
        it may appear in the next command line item. For example:
 
          --file=/some/file
          --file /some/file
 
-       Note, however, that if you want to supply a file name beginning with  ~
-       as  data  in a shell command, and have the shell expand ~ to a home di-
-       rectory, you must separate the file name from the option,  because  the
+       Note,  however, that if you want to supply a file name beginning with ~
+       as data in a shell command, and have the shell expand ~ to a  home  di-
+       rectory,  you  must separate the file name from the option, because the
        shell does not treat ~ specially unless it is at the start of an item.
 
-       The  exceptions  to the above are the --colour (or --color) and --only-
-       matching options, for which the data is optional. If one of  these  op-
-       tions  does  have  data,  it  must be given in the first form, using an
+       The exceptions to the above are the --colour (or --color)  and  --only-
+       matching  options,  for which the data is optional. If one of these op-
+       tions does have data, it must be given in  the  first  form,  using  an
        equals character. Otherwise pcre2grep will assume that it has no data.
 
 
 USING PCRE2'S CALLOUT FACILITY
 
-       pcre2grep has, by default, support for  calling  external  programs  or
-       scripts  or  echoing  specific strings during matching by making use of
-       PCRE2's callout facility. However, this support can  be  completely  or
-       partially  disabled  when  pcre2grep is built. You can find out whether
-       your binary has support for callouts by running it with the --help  op-
-       tion.  If  callout support is completely disabled, all callouts in pat-
+       pcre2grep  has,  by  default,  support for calling external programs or
+       scripts or echoing specific strings during matching by  making  use  of
+       PCRE2's  callout  facility.  However, this support can be completely or
+       partially disabled when pcre2grep is built. You can  find  out  whether
+       your  binary has support for callouts by running it with the --help op-
+       tion. If callout support is completely disabled, all callouts  in  pat-
        terns are ignored by pcre2grep.  If the facility is partially disabled,
-       calling  external  programs is not supported, and callouts that request
+       calling external programs is not supported, and callouts  that  request
        it are ignored.
 
-       A callout in a PCRE2 pattern is of the form (?C<arg>) where  the  argu-
-       ment  is either a number or a quoted string (see the pcre2callout docu-
-       mentation for details). Numbered callouts  are  ignored  by  pcre2grep;
+       A  callout  in a PCRE2 pattern is of the form (?C<arg>) where the argu-
+       ment is either a number or a quoted string (see the pcre2callout  docu-
+       mentation  for  details).  Numbered  callouts are ignored by pcre2grep;
        only callouts with string arguments are useful.
 
    Echoing a specific string
 
-       Starting  the  callout  string with a pipe character invokes an echoing
+       Starting the callout string with a pipe character  invokes  an  echoing
        facility that avoids calling an external program or script. This facil-
-       ity  is  always  available,  provided that callouts were not completely
-       disabled when pcre2grep was built. The rest of the  callout  string  is
-       processed  as  a zero-terminated string, which means it should not con-
-       tain any internal binary zeros. It is written  to  the  output,  having
-       first  been  passed through the same escape processing as text from the
-       --output (-O) option (see above). However, $0 cannot be used to  insert
-       a  matched  substring  because the match is still in progress. Instead,
-       the single character '0' is inserted. Any syntax errors in  the  string
-       (for  example,  a  dollar not followed by another character) causes the
-       callout to be ignored. No terminator is added to the output string,  so
-       if  you want a newline, you must include it explicitly using the escape
+       ity is always available, provided that  callouts  were  not  completely
+       disabled  when  pcre2grep  was built. The rest of the callout string is
+       processed as a zero-terminated string, which means it should  not  con-
+       tain  any  internal  binary  zeros. It is written to the output, having
+       first been passed through the same escape processing as text  from  the
+       --output  (-O) option (see above). However, $0 cannot be used to insert
+       a matched substring because the match is still  in  progress.  Instead,
+       the  single  character '0' is inserted. Any syntax errors in the string
+       (for example, a dollar not followed by another  character)  causes  the
+       callout  to be ignored. No terminator is added to the output string, so
+       if you want a newline, you must include it explicitly using the  escape
        $n. For example:
 
          pcre2grep '(.)(..(.))(?C"|[$1] [$2] [$3]$n")' <some file>
 
-       Matching continues normally after the string is output. If you want  to
-       see  only  the  callout output but not any output from an actual match,
+       Matching  continues normally after the string is output. If you want to
+       see only the callout output but not any output from  an  actual  match,
        you should end the pattern with (*FAIL).
 
    Calling external programs or scripts
 
        This facility can be independently disabled when pcre2grep is built. It
-       is  supported for Windows, where a call to _spawnvp() is used, for VMS,
-       where lib$spawn() is used, and  for  any  Unix-like  environment  where
+       is supported for Windows, where a call to _spawnvp() is used, for  VMS,
+       where  lib$spawn()  is  used,  and  for any Unix-like environment where
        fork() and execv() are available.
 
        If the callout string does not start with a pipe (vertical bar) charac-
-       ter, it is parsed into a list of substrings separated by  pipe  charac-
-       ters.  The first substring must be an executable name, with the follow-
+       ter,  it  is parsed into a list of substrings separated by pipe charac-
+       ters. The first substring must be an executable name, with the  follow-
        ing substrings specifying arguments:
 
          executable_name|arg1|arg2|...
 
-       Any substring (including the executable name) may  contain  escape  se-
-       quences  started  by  a dollar character. These are the same as for the
+       Any  substring  (including  the executable name) may contain escape se-
+       quences started by a dollar character. These are the same  as  for  the
        --output (-O) option documented above, except that $0 cannot insert the
-       matched  string  because  the  match is still in progress. Instead, the
+       matched string because the match is still  in  progress.  Instead,  the
        character '0' is inserted. If you need a literal dollar or pipe charac-
        ter in any substring, use $$ or $| respectively. Here is an example:
 
          echo -e "abcde\n12345" | pcre2grep \
            '(?x)(.)(..(.))
            (?C"/bin/echo|Arg1: [$1] [$2] [$3]|Arg2: $|${1}$| ($4)")()' -
 
          Output:
 
            Arg1: [a] [bcd] [d] Arg2: |a| ()
            abcde
            Arg1: [1] [234] [4] Arg2: |1| ()
            12345
 
-       The  parameters  for the system call that is used to run the program or
+       The parameters for the system call that is used to run the  program  or
        script are zero-terminated strings. This means that binary zero charac-
-       ters  in the callout argument will cause premature termination of their
-       substrings, and therefore should not be present. Any syntax  errors  in
-       the  string  (for  example, a dollar not followed by another character)
+       ters in the callout argument will cause premature termination of  their
+       substrings,  and  therefore should not be present. Any syntax errors in
+       the string (for example, a dollar not followed  by  another  character)
        causes the callout to be ignored.  If running the program fails for any
-       reason  (including the non-existence of the executable), a local match-
+       reason (including the non-existence of the executable), a local  match-
        ing failure occurs and the matcher backtracks in the normal way.
 
 
 MATCHING ERRORS
 
-       It is possible to supply a regular expression that takes  a  very  long
-       time  to  fail  to  match certain lines. Such patterns normally involve
-       nested indefinite repeats, for example: (a+)*\d when matched against  a
-       line  of a's with no final digit. The PCRE2 matching function has a re-
-       source limit that causes it to abort in these  circumstances.  If  this
-       happens,  pcre2grep  outputs  an error message and the line that caused
-       the problem to the standard error stream. If there  are  more  than  20
+       It  is  possible  to supply a regular expression that takes a very long
+       time to fail to match certain lines.  Such  patterns  normally  involve
+       nested  indefinite repeats, for example: (a+)*\d when matched against a
+       line of a's with no final digit. The PCRE2 matching function has a  re-
+       source  limit  that  causes it to abort in these circumstances. If this
+       happens, pcre2grep outputs an error message and the  line  that  caused
+       the  problem  to  the  standard error stream. If there are more than 20
        such errors, pcre2grep gives up.
 
-       The  --match-limit  option  of pcre2grep can be used to set the overall
-       resource limit. There are also other limits that affect the  amount  of
-       memory  used  during  matching;  see the discussion of --heap-limit and
+       The --match-limit option of pcre2grep can be used to  set  the  overall
+       resource  limit.  There are also other limits that affect the amount of
+       memory used during matching; see the  discussion  of  --heap-limit  and
        --depth-limit above.
 
 
 DIAGNOSTICS
 
        Exit status is 0 if any matches were found, 1 if no matches were found,
-       and  2  for syntax errors, overlong lines, non-existent or inaccessible
-       files (even if matches were found in other files) or too many  matching
+       and 2 for syntax errors, overlong lines, non-existent  or  inaccessible
+       files  (even if matches were found in other files) or too many matching
        errors. Using the -s option to suppress error messages about inaccessi-
        ble files does not affect the return code.
 
-       When  run  under  VMS,  the  return  code  is  placed  in  the   symbol
-       PCRE2GREP_RC  because  VMS  does  not  distinguish  between exit(0) and
+       When   run  under  VMS,  the  return  code  is  placed  in  the  symbol
+       PCRE2GREP_RC because VMS  does  not  distinguish  between  exit(0)  and
        exit(1).
 
 
 SEE ALSO
 
        pcre2pattern(3), pcre2syntax(3), pcre2callout(3), pcre2unicode(3).
 
@@ -1018,9 +1030,9 @@
        Philip Hazel
        Retired from University Computing Service
        Cambridge, England.
 
 
 REVISION
 
-       Last updated: 31 August 2021
-       Copyright (c) 1997-2021 University of Cambridge.
+       Last updated: 21 November 2022
+       Copyright (c) 1997-2022 University of Cambridge.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2jit.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2jit.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2limits.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2limits.3`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-.TH PCRE2LIMITS 3 "03 February 2019" "PCRE2 10.33"
+.TH PCRE2LIMITS 3 "26 July 2022" "PCRE2 10.41"
 .SH NAME
 PCRE2 - Perl-compatible regular expressions (revised API)
 .SH "SIZE AND OTHER LIMITATIONS"
 .rs
 .sp
 There are some size limitations in PCRE2 but it is hoped that they will never
 in practice be relevant.
@@ -47,26 +47,30 @@
 .P
 The maximum length of a name in a (*MARK), (*PRUNE), (*SKIP), or (*THEN) verb
 is 255 code units for the 8-bit library and 65535 code units for the 16-bit and
 32-bit libraries.
 .P
 The maximum length of a string argument to a callout is the largest number a
 32-bit unsigned integer can hold.
+.P
+The maximum amount of heap memory used for matching is controlled by the heap
+limit, which can be set in a pattern or in a match context. The default is a
+very large number, effectively unlimited.
 .
 .
 .SH AUTHOR
 .rs
 .sp
 .nf
 Philip Hazel
-University Computing Service
+Retired from University Computing Service
 Cambridge, England.
 .fi
 .
 .
 .SH REVISION
 .rs
 .sp
 .nf
-Last updated: 02 February 2019
-Copyright (c) 1997-2019 University of Cambridge.
+Last updated: 26 July 2022
+Copyright (c) 1997-2022 University of Cambridge.
 .fi
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2matching.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2matching.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2partial.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2partial.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2pattern.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2pattern.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2perform.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2perform.3`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-.TH PCRE2PERFORM 3 "03 February 2019" "PCRE2 10.33"
+.TH PCRE2PERFORM 3 "27 July 2022" "PCRE2 10.41"
 .SH NAME
 PCRE2 - Perl-compatible regular expressions (revised API)
 .SH "PCRE2 PERFORMANCE"
 .rs
 .sp
 Two aspects of performance are discussed below: memory usage and processing
 time. The way you express your pattern as a regular expression can affect both
@@ -65,20 +65,36 @@
 .SH "STACK AND HEAP USAGE AT RUN TIME"
 .rs
 .sp
 From release 10.30, the interpretive (non-JIT) version of \fBpcre2_match()\fP
 uses very little system stack at run time. In earlier releases recursive
 function calls could use a great deal of stack, and this could cause problems,
 but this usage has been eliminated. Backtracking positions are now explicitly
-remembered in memory frames controlled by the code. An initial 20KiB vector of
-frames is allocated on the system stack (enough for about 100 frames for small
-patterns), but if this is insufficient, heap memory is used. The amount of heap
-memory can be limited; if the limit is set to zero, only the initial stack
-vector is used. Rewriting patterns to be time-efficient, as described below,
-may also reduce the memory requirements.
+remembered in memory frames controlled by the code.
+.P
+The size of each frame depends on the size of pointer variables and the number
+of capturing parenthesized groups in the pattern being matched. On a 64-bit
+system the frame size for a pattern with no captures is 128 bytes. For each
+capturing group the size increases by 16 bytes.
+.P
+Until release 10.41, an initial 20KiB frames vector was allocated on the system
+stack, but this still caused some issues for multi-thread applications where
+each thread has a very small stack. From release 10.41 backtracking memory
+frames are always held in heap memory. An initial heap allocation is obtained
+the first time any match data block is passed to \fBpcre2_match()\fP. This is
+remembered with the match data block and re-used if that block is used for
+another match. It is freed when the match data block itself is freed.
+.P
+The size of the initial block is the larger of 20KiB or ten times the pattern's
+frame size, unless the heap limit is less than this, in which case the heap
+limit is used. If the initial block proves to be too small during matching, it
+is replaced by a larger block, subject to the heap limit. The heap limit is
+checked only when a new block is to be allocated. Reducing the heap limit
+between calls to \fBpcre2_match()\fP with the same match data block does not
+affect the saved block.
 .P
 In contrast to \fBpcre2_match()\fP, \fBpcre2_dfa_match()\fP does use recursive
 function calls, but only for processing atomic groups, lookaround assertions,
 and recursion within the pattern. The original version of the code used to
 allocate quite large internal workspace vectors on the stack, which caused some
 problems for some patterns in environments with small stacks. From release
 10.32 the code for \fBpcre2_dfa_match()\fP has been re-factored to use heap
@@ -226,19 +242,19 @@
 .
 .
 .SH AUTHOR
 .rs
 .sp
 .nf
 Philip Hazel
-University Computing Service
+Retired from University Computing Service
 Cambridge, England.
 .fi
 .
 .
 .SH REVISION
 .rs
 .sp
 .nf
-Last updated: 03 February 2019
-Copyright (c) 1997-2019 University of Cambridge.
+Last updated: 27 July 2022
+Copyright (c) 1997-2022 University of Cambridge.
 .fi
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-.TH PCRE2PERFORM 3 "03 February 2019" "PCRE2 10.33" .SH NAME PCRE2 - Perl-
+.TH PCRE2PERFORM 3 "27 July 2022" "PCRE2 10.41" .SH NAME PCRE2 - Perl-
 compatible regular expressions (revised API) .SH "PCRE2 PERFORMANCE" .rs .sp
 Two aspects of performance are discussed below: memory usage and processing
 time. The way you express your pattern as a regular expression can affect both
 of them. . .SH "COMPILED PATTERN MEMORY USAGE" .rs .sp Patterns are compiled by
 PCRE2 into a reasonably efficient interpretive code, so that most simple
 patterns do not use much memory for storing the compiled version. However,
 there is one case where the memory usage of a compiled pattern can be
@@ -33,33 +33,45 @@
 of the pattern are roughly the same. (This applies from release 10.30 - things
 were different in earlier releases.) . . .SH "STACK AND HEAP USAGE AT RUN TIME"
 .rs .sp From release 10.30, the interpretive (non-JIT) version of
 \fBpcre2_match()\fP uses very little system stack at run time. In earlier
 releases recursive function calls could use a great deal of stack, and this
 could cause problems, but this usage has been eliminated. Backtracking
 positions are now explicitly remembered in memory frames controlled by the
-code. An initial 20KiB vector of frames is allocated on the system stack
-(enough for about 100 frames for small patterns), but if this is insufficient,
-heap memory is used. The amount of heap memory can be limited; if the limit is
-set to zero, only the initial stack vector is used. Rewriting patterns to be
-time-efficient, as described below, may also reduce the memory requirements. .P
-In contrast to \fBpcre2_match()\fP, \fBpcre2_dfa_match()\fP does use recursive
-function calls, but only for processing atomic groups, lookaround assertions,
-and recursion within the pattern. The original version of the code used to
-allocate quite large internal workspace vectors on the stack, which caused some
-problems for some patterns in environments with small stacks. From release
-10.32 the code for \fBpcre2_dfa_match()\fP has been re-factored to use heap
-memory when necessary for internal workspace when recursing, though recursive
-function calls are still used. .P The "match depth" parameter can be used to
-limit the depth of function recursion, and the "match heap" parameter to limit
-heap memory in \fBpcre2_dfa_match()\fP. . . .SH "PROCESSING TIME" .rs .sp
-Certain items in regular expression patterns are processed more efficiently
-than others. It is more efficient to use a character class like [aeiou] than a
-set of single-character alternatives such as (a|e|i|o|u). In general, the
-simplest construction that provides the required behaviour is usually the most
+code. .P The size of each frame depends on the size of pointer variables and
+the number of capturing parenthesized groups in the pattern being matched. On a
+64-bit system the frame size for a pattern with no captures is 128 bytes. For
+each capturing group the size increases by 16 bytes. .P Until release 10.41, an
+initial 20KiB frames vector was allocated on the system stack, but this still
+caused some issues for multi-thread applications where each thread has a very
+small stack. From release 10.41 backtracking memory frames are always held in
+heap memory. An initial heap allocation is obtained the first time any match
+data block is passed to \fBpcre2_match()\fP. This is remembered with the match
+data block and re-used if that block is used for another match. It is freed
+when the match data block itself is freed. .P The size of the initial block is
+the larger of 20KiB or ten times the pattern's frame size, unless the heap
+limit is less than this, in which case the heap limit is used. If the initial
+block proves to be too small during matching, it is replaced by a larger block,
+subject to the heap limit. The heap limit is checked only when a new block is
+to be allocated. Reducing the heap limit between calls to \fBpcre2_match()\fP
+with the same match data block does not affect the saved block. .P In contrast
+to \fBpcre2_match()\fP, \fBpcre2_dfa_match()\fP does use recursive function
+calls, but only for processing atomic groups, lookaround assertions, and
+recursion within the pattern. The original version of the code used to allocate
+quite large internal workspace vectors on the stack, which caused some problems
+for some patterns in environments with small stacks. From release 10.32 the
+code for \fBpcre2_dfa_match()\fP has been re-factored to use heap memory when
+necessary for internal workspace when recursing, though recursive function
+calls are still used. .P The "match depth" parameter can be used to limit the
+depth of function recursion, and the "match heap" parameter to limit heap
+memory in \fBpcre2_dfa_match()\fP. . . .SH "PROCESSING TIME" .rs .sp Certain
+items in regular expression patterns are processed more efficiently than
+others. It is more efficient to use a character class like [aeiou] than a set
+of single-character alternatives such as (a|e|i|o|u). In general, the simplest
+construction that provides the required behaviour is usually the most
 efficient. Jeffrey Friedl's book contains a lot of useful general discussion
 about optimizing regular expressions for efficient performance. This document
 contains a few observations about PCRE2. .P Using Unicode character properties
 (the \ep, \eP, and \eX escapes) is slow, because PCRE2 has to use a multi-stage
 table lookup whenever it needs a character's property. If you can find an
 alternative pattern that does not use character properties, it will probably be
 faster. .P By default, the escape sequences \eb, \ed, \es, and \ew, and the
@@ -130,10 +142,10 @@
 set when \fBpcre2_match()\fP or \fBpcre2_dfa_match()\fP is called. For details
 of these interfaces, see the .\" HREF \fBpcre2build\fP .\" documentation and
 the section entitled .\" HTML .\" "The match context" .\" in the .\" HREF
 \fBpcre2api\fP .\" documentation. .P The \fBpcre2test\fP test program has a
 modifier called "find_limits" which, if applied to a subject line, causes it to
 find the smallest limits that allow a pattern to match. This is done by
 repeatedly matching with different limits. . . .SH AUTHOR .rs .sp .nf Philip
-Hazel University Computing Service Cambridge, England. .fi . . .SH REVISION .rs
-.sp .nf Last updated: 03 February 2019 Copyright (c) 1997-2019 University of
-Cambridge. .fi
+Hazel Retired from University Computing Service Cambridge, England. .fi . . .SH
+REVISION .rs .sp .nf Last updated: 27 July 2022 Copyright (c) 1997-2022
+University of Cambridge. .fi
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2posix.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2posix.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2sample.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2sample.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2serialize.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2serialize.3`

 * *Files 0% similar despite different names*

```diff
@@ -77,15 +77,15 @@
 argument is a pointer to a general context, which can be used to specify custom
 memory mangagement functions. If this argument is NULL, \fBmalloc()\fP is used
 to obtain memory for the byte stream. The yield of the function is the number
 of serialized patterns, or one of the following negative error codes:
 .sp
   PCRE2_ERROR_BADDATA      the number of patterns is zero or less
   PCRE2_ERROR_BADMAGIC     mismatch of id bytes in one of the patterns
-  PCRE2_ERROR_MEMORY       memory allocation failed
+  PCRE2_ERROR_NOMEMORY     memory allocation failed
   PCRE2_ERROR_MIXEDTABLES  the patterns do not all use the same tables
   PCRE2_ERROR_NULL         the 1st, 3rd, or 4th argument is NULL
 .sp
 PCRE2_ERROR_BADMAGIC means either that a pattern's code has been corrupted, or
 that a slot in the vector does not point to a compiled pattern.
 .P
 Once a set of patterns has been serialized you can save the data in any
```

#### html2text {}

```diff
@@ -45,15 +45,15 @@
 variables which are set to point to the created byte stream and its length,
 respectively. The final argument is a pointer to a general context, which can
 be used to specify custom memory mangagement functions. If this argument is
 NULL, \fBmalloc()\fP is used to obtain memory for the byte stream. The yield of
 the function is the number of serialized patterns, or one of the following
 negative error codes: .sp PCRE2_ERROR_BADDATA the number of patterns is zero or
 less PCRE2_ERROR_BADMAGIC mismatch of id bytes in one of the patterns
-PCRE2_ERROR_MEMORY memory allocation failed PCRE2_ERROR_MIXEDTABLES the
+PCRE2_ERROR_NOMEMORY memory allocation failed PCRE2_ERROR_MIXEDTABLES the
 patterns do not all use the same tables PCRE2_ERROR_NULL the 1st, 3rd, or 4th
 argument is NULL .sp PCRE2_ERROR_BADMAGIC means either that a pattern's code
 has been corrupted, or that a slot in the vector does not point to a compiled
 pattern. .P Once a set of patterns has been serialized you can save the data in
 any appropriate manner. Here is sample code that compiles two patterns and
 writes them to a file. It assumes that the variable \fIfd\fP refers to a file
 that is open for output. The error checking that should be present in a real
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2syntax.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2syntax.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2test.1` & `pcre2-0.2.0/src/libpcre2/doc/pcre2test.1`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-.TH PCRE2TEST 1 "12 January 2022" "PCRE 10.40"
+.TH PCRE2TEST 1 "27 July 2022" "PCRE 10.41"
 .SH NAME
 pcre2test - a program for testing Perl-compatible regular expressions.
 .SH SYNOPSIS
 .rs
 .sp
 .B pcre2test "[options] [input file [output file]]"
 .sp
@@ -215,15 +215,15 @@
 .TP 10
 \fB-LP\fP
 List properties: write a list of recognized Unicode properties to the standard
 output, then exit with zero exit code. All other options are ignored. If both
 -C and any -Lx options are present, whichever is first is recognized.
 .TP 10
 \fB-LS\fP
-List scripts: write a list of recogized Unicode script names to the standard
+List scripts: write a list of recognized Unicode script names to the standard
 output, then exit with zero exit code. All other options are ignored. If both
 -C and any -Lx options are present, whichever is first is recognized.
 .TP 10
 \fB-pattern\fP \fImodifier-list\fP
 Behave as if each pattern line contains the given modifiers.
 .TP 10
 \fB-q\fP
@@ -1202,15 +1202,16 @@
       callout_extra              show extra callout information
       callout_fail=<n>[:<m>]     control callout failure
       callout_no_where           do not show position of a callout
       callout_none               do not supply a callout function
       copy=<number or name>      copy captured substring
       depth_limit=<n>            set a depth limit
       dfa                        use \fBpcre2_dfa_match()\fP
-      find_limits                find match and depth limits
+      find_limits                find heap, match and depth limits
+      find_limits_noheap         find match and depth limits
       get=<number or name>       extract captured substring
       getall                     extract all captured substrings
   /g  global                     global matching
       heap_limit=<n>             set a limit on heap memory (Kbytes)
       jitstack=<n>               set size of JIT stack
       mark                       show mark values
       match_limit=<n>            set a match limit
@@ -1329,15 +1330,15 @@
 functions, unless \fBcallout_none\fP is specified. Its behaviour can be
 controlled by various modifiers listed above whose names begin with
 \fBcallout_\fP. Details are given in the section entitled "Callouts"
 .\" HTML <a href="#callouts">
 .\" </a>
 below.
 .\"
-Testing callouts from \fBpcre2_substitute()\fP is decribed separately in
+Testing callouts from \fBpcre2_substitute()\fP is described separately in
 "Testing the substitution function"
 .\" HTML <a href="#substitution">
 .\" </a>
 below.
 .\"
 .
 .
@@ -1524,26 +1525,30 @@
 .
 .
 .SS "Setting heap, match, and depth limits"
 .rs
 .sp
 The \fBheap_limit\fP, \fBmatch_limit\fP, and \fBdepth_limit\fP modifiers set
 the appropriate limits in the match context. These values are ignored when the
-\fBfind_limits\fP modifier is specified.
+\fBfind_limits\fP or \fBfind_limits_noheap\fP modifier is specified.
 .
 .
 .SS "Finding minimum limits"
 .rs
 .sp
 If the \fBfind_limits\fP modifier is present on a subject line, \fBpcre2test\fP
 calls the relevant matching function several times, setting different values in
 the match context via \fBpcre2_set_heap_limit()\fP,
 \fBpcre2_set_match_limit()\fP, or \fBpcre2_set_depth_limit()\fP until it finds
-the minimum values for each parameter that allows the match to complete without
-error. If JIT is being used, only the match limit is relevant.
+the smallest value for each parameter that allows the match to complete without
+a "limit exceeded" error. The match itself may succeed or fail. An alternative
+modifier, \fBfind_limits_noheap\fP, omits the heap limit. This is used in the
+standard tests, because the minimum heap limit varies between systems. If JIT
+is being used, only the match limit is relevant, and the other two are
+automatically omitted.
 .P
 When using this modifier, the pattern should not contain any limit settings
 such as (*LIMIT_MATCH=...) within it. If such a setting is present and is
 lower than the minimum matching value, the minimum value cannot be found
 because \fBpcre2_set_match_limit()\fP etc. are only able to reduce the value of
 an in-pattern limit; they cannot increase it.
 .P
@@ -1559,17 +1564,15 @@
 patterns with very large numbers of matching possibilities, it can become large
 very quickly with increasing length of subject string. In the case of DFA
 matching, \fImatch_limit\fP controls the total number of calls, both recursive
 and non-recursive, to the internal matching function, thus controlling the
 overall amount of computing resource that is used.
 .P
 For both kinds of matching, the \fIheap_limit\fP number, which is in kibibytes
-(units of 1024 bytes), limits the amount of heap memory used for matching. A
-value of zero disables the use of any heap memory; many simple pattern matches
-can be done without using the heap, so zero is not an unreasonable setting.
+(units of 1024 bytes), limits the amount of heap memory used for matching.
 .
 .
 .SS "Showing MARK names"
 .rs
 .sp
 .P
 The \fBmark\fP modifier causes the names from backtracking control verbs that
@@ -1580,20 +1583,18 @@
 .
 .
 .SS "Showing memory usage"
 .rs
 .sp
 The \fBmemory\fP modifier causes \fBpcre2test\fP to log the sizes of all heap
 memory allocation and freeing calls that occur during a call to
-\fBpcre2_match()\fP or \fBpcre2_dfa_match()\fP. These occur only when a match
-requires a bigger vector than the default for remembering backtracking points
-(\fBpcre2_match()\fP) or for internal workspace (\fBpcre2_dfa_match()\fP). In
-many cases there will be no heap memory used and therefore no additional
-output. No heap memory is allocated during matching with JIT, so in that case
-the \fBmemory\fP modifier never has any effect. For this modifier to work, the
+\fBpcre2_match()\fP or \fBpcre2_dfa_match()\fP. In the latter case, heap memory
+is used only when a match requires more internal workspace that the default
+allocation on the stack, so in many cases there will be no output. No heap
+memory is allocated during matching with JIT. For this modifier to work, the
 \fBnull_context\fP modifier must not be set on both the pattern and the
 subject, though it can be set on one or the other.
 .
 .
 .SS "Setting a starting offset"
 .rs
 .sp
@@ -1645,15 +1646,16 @@
 .rs
 .sp
 Normally, \fBpcre2test\fP passes a context block to \fBpcre2_match()\fP,
 \fBpcre2_dfa_match()\fP, \fBpcre2_jit_match()\fP or \fBpcre2_substitute()\fP.
 If the \fBnull_context\fP modifier is set, however, NULL is passed. This is for
 testing that the matching and substitution functions behave correctly in this
 case (they use default values). This modifier cannot be used with the
-\fBfind_limits\fP or \fBsubstitute_callout\fP modifiers.
+\fBfind_limits\fP, \fBfind_limits_noheap\fP, or \fBsubstitute_callout\fP
+modifiers.
 .P
 Similarly, for testing purposes, if the \fBnull_subject\fP or
 \fBnull_replacement\fP modifier is set, the subject or replacement string
 pointers are passed as NULL, respectively, to the relevant functions.
 .
 .
 .SH "THE ALTERNATIVE MATCHING FUNCTION"
@@ -2087,15 +2089,15 @@
 .sp
   #pop jit,bincode
   abc
 .sp
 If \fBjitverify\fP is used with #pop, it does not automatically imply
 \fBjit\fP, which is different behaviour from when it is used on a pattern.
 .P
-The #popcopy command is analagous to the \fBpushcopy\fP modifier in that it
+The #popcopy command is analogous to the \fBpushcopy\fP modifier in that it
 makes current a copy of the topmost stack pattern, leaving the original still
 on the stack.
 .
 .
 .
 .SH "SEE ALSO"
 .rs
@@ -2115,10 +2117,10 @@
 .fi
 .
 .
 .SH REVISION
 .rs
 .sp
 .nf
-Last updated: 12 January 2022
+Last updated: 27 July 2022
 Copyright (c) 1997-2022 University of Cambridge.
 .fi
```

#### html2text {}

```diff
@@ -1,11 +1,11 @@
-.TH PCRE2TEST 1 "12 January 2022" "PCRE 10.40" .SH NAME pcre2test - a program
-for testing Perl-compatible regular expressions. .SH SYNOPSIS .rs .sp .B
-pcre2test "[options] [input file [output file]]" .sp \fBpcre2test\fP is a test
-program for the PCRE2 regular expression libraries, but it can also be used for
+.TH PCRE2TEST 1 "27 July 2022" "PCRE 10.41" .SH NAME pcre2test - a program for
+testing Perl-compatible regular expressions. .SH SYNOPSIS .rs .sp .B pcre2test
+"[options] [input file [output file]]" .sp \fBpcre2test\fP is a test program
+for the PCRE2 regular expression libraries, but it can also be used for
 experimenting with regular expressions. This document describes the features of
 the test program; for details of the regular expressions themselves, see the
 .\" HREF \fBpcre2pattern\fP .\" documentation. For details of the PCRE2 library
 function calls and their options, see the .\" HREF \fBpcre2api\fP .\"
 documentation. .P The input for \fBpcre2test\fP is a sequence of regular
 expression patterns and subject strings to be matched. There are also command
 lines for setting defaults and controlling some special actions. The output
@@ -115,15 +115,15 @@
 and the use of JIT for matching is verified. .TP 10 \fB-LM\fP List modifiers:
 write a list of available pattern and subject modifiers to the standard output,
 then exit with zero exit code. All other options are ignored. If both -C and
 any -Lx options are present, whichever is first is recognized. .TP 10 \fB-LP\fP
 List properties: write a list of recognized Unicode properties to the standard
 output, then exit with zero exit code. All other options are ignored. If both -
 C and any -Lx options are present, whichever is first is recognized. .TP 10
-\fB-LS\fP List scripts: write a list of recogized Unicode script names to the
+\fB-LS\fP List scripts: write a list of recognized Unicode script names to the
 standard output, then exit with zero exit code. All other options are ignored.
 If both -C and any -Lx options are present, whichever is first is recognized.
 .TP 10 \fB-pattern\fP \fImodifier-list\fP Behave as if each pattern line
 contains the given modifiers. .TP 10 \fB-q\fP Do not output the version number
 of \fBpcre2test\fP at the start of execution. .TP 10 \fB-S\fP \fIsize\fP On
 Unix-like systems, set the size of the run-time stack to \fIsize\fP mebibytes
 (units of 1024*1024 bytes). .TP 10 \fB-subject\fP \fImodifier-list\fP Behave as
@@ -642,53 +642,53 @@
 entire ovector allusedtext show all consulted text (non-JIT only) altglobal
 alternative global matching callout_capture show captures at callout time
 callout_data= set a value to pass via callouts callout_error=[:] control
 callout error callout_extra show extra callout information callout_fail=[:
 ] control callout failure callout_no_where do not show position of a callout
 callout_none do not supply a callout function copy= copy captured substring
 depth_limit= set a depth limit dfa use \fBpcre2_dfa_match()\fP find_limits find
-match and depth limits get= extract captured substring getall extract all
-captured substrings /g global global matching heap_limit= set a limit on heap
-memory (Kbytes) jitstack= set size of JIT stack mark show mark values
-match_limit= set a match limit memory show heap memory usage null_context match
-with a NULL context null_replacement substitute with NULL replacement
-null_subject match with NULL subject offset= set starting offset offset_limit=
-set offset limit ovector= set size of output vector recursion_limit= obsolete
-synonym for depth_limit replace= specify a replacement string startchar show
-startchar when relevant startoffset= same as offset= substitute_callout use
-substitution callouts substitute_extedded use PCRE2_SUBSTITUTE_EXTENDED
-substitute_literal use PCRE2_SUBSTITUTE_LITERAL substitute_matched use
-PCRE2_SUBSTITUTE_MATCHED substitute_overflow_length use
-PCRE2_SUBSTITUTE_OVERFLOW_LENGTH substitute_replacement_only use
-PCRE2_SUBSTITUTE_REPLACEMENT_ONLY substitute_skip= skip substitution number n
-substitute_stop= skip substitution number n and greater
-substitute_unknown_unset use PCRE2_SUBSTITUTE_UNKNOWN_UNSET
-substitute_unset_empty use PCRE2_SUBSTITUTE_UNSET_EMPTY zero_terminate pass the
-subject as zero-terminated .sp The effects of these modifiers are described in
-the following sections. When matching via the POSIX wrapper API, the
-\fBaftertext\fP, \fBallaftertext\fP, and \fBovector\fP subject modifiers work
-as described below. All other modifiers are either ignored, with a warning
-message, or cause an error. . . .SS "Showing more text" .rs .sp The
-\fBaftertext\fP modifier requests that as well as outputting the part of the
-subject string that matched the entire pattern, \fBpcre2test\fP should in
-addition output the remainder of the subject string. This is useful for tests
-where the subject contains multiple copies of the same substring. The
-\fBallaftertext\fP modifier requests the same action for captured substrings as
-well as the main matched substring. In each case the remainder is output on the
-following line with a plus character following the capture number. .P The
-\fBallusedtext\fP modifier requests that all the text that was consulted during
-a successful pattern match by the interpreter should be shown, for both full
-and partial matches. This feature is not supported for JIT matching, and if
-requested with JIT it is ignored (with a warning message). Setting this
-modifier affects the output if there is a lookbehind at the start of a match,
-or, for a complete match, a lookahead at the end, or if \eK is used in the
-pattern. Characters that precede or follow the start and end of the actual
-match are indicated in the output by '<' or '>' characters underneath them.
-Here is an example: .sp re> /(?<=pqr)abc(?=xyz)/ data>
-123pqrabcxyz456\e=allusedtext 0: pqrabcxyz <<< >>> data>
+heap, match and depth limits find_limits_noheap find match and depth limits
+get= extract captured substring getall extract all captured substrings /
+g global global matching heap_limit= set a limit on heap memory (Kbytes)
+jitstack= set size of JIT stack mark show mark values match_limit= set a match
+limit memory show heap memory usage null_context match with a NULL context
+null_replacement substitute with NULL replacement null_subject match with NULL
+subject offset= set starting offset offset_limit= set offset limit ovector= set
+size of output vector recursion_limit= obsolete synonym for depth_limit
+replace= specify a replacement string startchar show startchar when relevant
+startoffset= same as offset= substitute_callout use substitution callouts
+substitute_extedded use PCRE2_SUBSTITUTE_EXTENDED substitute_literal use
+PCRE2_SUBSTITUTE_LITERAL substitute_matched use PCRE2_SUBSTITUTE_MATCHED
+substitute_overflow_length use PCRE2_SUBSTITUTE_OVERFLOW_LENGTH
+substitute_replacement_only use PCRE2_SUBSTITUTE_REPLACEMENT_ONLY
+substitute_skip= skip substitution number n substitute_stop= skip substitution
+number n and greater substitute_unknown_unset use
+PCRE2_SUBSTITUTE_UNKNOWN_UNSET substitute_unset_empty use
+PCRE2_SUBSTITUTE_UNSET_EMPTY zero_terminate pass the subject as zero-terminated
+.sp The effects of these modifiers are described in the following sections.
+When matching via the POSIX wrapper API, the \fBaftertext\fP,
+\fBallaftertext\fP, and \fBovector\fP subject modifiers work as described
+below. All other modifiers are either ignored, with a warning message, or cause
+an error. . . .SS "Showing more text" .rs .sp The \fBaftertext\fP modifier
+requests that as well as outputting the part of the subject string that matched
+the entire pattern, \fBpcre2test\fP should in addition output the remainder of
+the subject string. This is useful for tests where the subject contains
+multiple copies of the same substring. The \fBallaftertext\fP modifier requests
+the same action for captured substrings as well as the main matched substring.
+In each case the remainder is output on the following line with a plus
+character following the capture number. .P The \fBallusedtext\fP modifier
+requests that all the text that was consulted during a successful pattern match
+by the interpreter should be shown, for both full and partial matches. This
+feature is not supported for JIT matching, and if requested with JIT it is
+ignored (with a warning message). Setting this modifier affects the output if
+there is a lookbehind at the start of a match, or, for a complete match, a
+lookahead at the end, or if \eK is used in the pattern. Characters that precede
+or follow the start and end of the actual match are indicated in the output by
+'<' or '>' characters underneath them. Here is an example: .sp re> /(?<=pqr)abc
+(?=xyz)/ data> 123pqrabcxyz456\e=allusedtext 0: pqrabcxyz <<< >>> data>
 123pqrabcxy\e=ph,allusedtext Partial match: pqrabcxy <<< .sp The first,
 complete match shows that the matched string is "abc", with the preceding and
 following strings "pqr" and "xyz" having been consulted during the match (when
 processing the assertions). The partial match can indicate only the preceding
 string. .P The \fBstartchar\fP modifier requests that the starting character
 for the match be indicated, if it is different to the start of the matched
 string. The only time when this occurs is when \eK has been processed as part
@@ -718,15 +718,15 @@
 match, the first two elements are the only ones that should be set. After a DFA
 match, the amount of ovector that is used depends on the number of matches that
 were found. . . .SS "Testing pattern callouts" .rs .sp A callout function is
 supplied when \fBpcre2test\fP calls the library matching functions, unless
 \fBcallout_none\fP is specified. Its behaviour can be controlled by various
 modifiers listed above whose names begin with \fBcallout_\fP. Details are given
 in the section entitled "Callouts" .\" HTML .\" below. .\" Testing callouts
-from \fBpcre2_substitute()\fP is decribed separately in "Testing the
+from \fBpcre2_substitute()\fP is described separately in "Testing the
 substitution function" .\" HTML .\" below. .\" . . .SS "Finding all matches in
 a string" .rs .sp Searching for all possible matches within a subject can be
 requested by the \fBglobal\fP or \fBaltglobal\fP modifier. After finding a
 match, the matching function is called again to search the remainder of the
 subject. The difference between \fBglobal\fP and \fBaltglobal\fP is that the
 former uses the \fIstart_offset\fP argument to \fBpcre2_match()\fP or
 \fBpcre2_dfa_match()\fP to start searching at a new point within the entire
@@ -830,89 +830,89 @@
 optimization is not being used. The value is a number of kibibytes (units of
 1024 bytes). Setting zero reverts to the default of 32KiB. Providing a stack
 that is larger than the default is necessary only for very complicated
 patterns. If \fBjitstack\fP is set non-zero on a subject line it overrides any
 value that was set on the pattern. . . .SS "Setting heap, match, and depth
 limits" .rs .sp The \fBheap_limit\fP, \fBmatch_limit\fP, and \fBdepth_limit\fP
 modifiers set the appropriate limits in the match context. These values are
-ignored when the \fBfind_limits\fP modifier is specified. . . .SS "Finding
-minimum limits" .rs .sp If the \fBfind_limits\fP modifier is present on a
-subject line, \fBpcre2test\fP calls the relevant matching function several
-times, setting different values in the match context via
-\fBpcre2_set_heap_limit()\fP, \fBpcre2_set_match_limit()\fP, or
-\fBpcre2_set_depth_limit()\fP until it finds the minimum values for each
-parameter that allows the match to complete without error. If JIT is being
-used, only the match limit is relevant. .P When using this modifier, the
-pattern should not contain any limit settings such as (*LIMIT_MATCH=...) within
-it. If such a setting is present and is lower than the minimum matching value,
-the minimum value cannot be found because \fBpcre2_set_match_limit()\fP etc.
-are only able to reduce the value of an in-pattern limit; they cannot increase
-it. .P For non-DFA matching, the minimum \fIdepth_limit\fP number is a measure
-of how much nested backtracking happens (that is, how deeply the pattern's tree
-is searched). In the case of DFA matching, \fIdepth_limit\fP controls the depth
-of recursive calls of the internal function that is used for handling pattern
-recursion, lookaround assertions, and atomic groups. .P For non-DFA matching,
-the \fImatch_limit\fP number is a measure of the amount of backtracking that
-takes place, and learning the minimum value can be instructive. For most simple
-matches, the number is quite small, but for patterns with very large numbers of
-matching possibilities, it can become large very quickly with increasing length
-of subject string. In the case of DFA matching, \fImatch_limit\fP controls the
+ignored when the \fBfind_limits\fP or \fBfind_limits_noheap\fP modifier is
+specified. . . .SS "Finding minimum limits" .rs .sp If the \fBfind_limits\fP
+modifier is present on a subject line, \fBpcre2test\fP calls the relevant
+matching function several times, setting different values in the match context
+via \fBpcre2_set_heap_limit()\fP, \fBpcre2_set_match_limit()\fP, or
+\fBpcre2_set_depth_limit()\fP until it finds the smallest value for each
+parameter that allows the match to complete without a "limit exceeded" error.
+The match itself may succeed or fail. An alternative modifier,
+\fBfind_limits_noheap\fP, omits the heap limit. This is used in the standard
+tests, because the minimum heap limit varies between systems. If JIT is being
+used, only the match limit is relevant, and the other two are automatically
+omitted. .P When using this modifier, the pattern should not contain any limit
+settings such as (*LIMIT_MATCH=...) within it. If such a setting is present and
+is lower than the minimum matching value, the minimum value cannot be found
+because \fBpcre2_set_match_limit()\fP etc. are only able to reduce the value of
+an in-pattern limit; they cannot increase it. .P For non-DFA matching, the
+minimum \fIdepth_limit\fP number is a measure of how much nested backtracking
+happens (that is, how deeply the pattern's tree is searched). In the case of
+DFA matching, \fIdepth_limit\fP controls the depth of recursive calls of the
+internal function that is used for handling pattern recursion, lookaround
+assertions, and atomic groups. .P For non-DFA matching, the \fImatch_limit\fP
+number is a measure of the amount of backtracking that takes place, and
+learning the minimum value can be instructive. For most simple matches, the
+number is quite small, but for patterns with very large numbers of matching
+possibilities, it can become large very quickly with increasing length of
+subject string. In the case of DFA matching, \fImatch_limit\fP controls the
 total number of calls, both recursive and non-recursive, to the internal
 matching function, thus controlling the overall amount of computing resource
 that is used. .P For both kinds of matching, the \fIheap_limit\fP number, which
 is in kibibytes (units of 1024 bytes), limits the amount of heap memory used
-for matching. A value of zero disables the use of any heap memory; many simple
-pattern matches can be done without using the heap, so zero is not an
-unreasonable setting. . . .SS "Showing MARK names" .rs .sp .P The \fBmark\fP
-modifier causes the names from backtracking control verbs that are returned
-from calls to \fBpcre2_match()\fP to be displayed. If a mark is returned for a
-match, non-match, or partial match, \fBpcre2test\fP shows it. For a match, it
-is on a line by itself, tagged with "MK:". Otherwise, it is added to the non-
-match message. . . .SS "Showing memory usage" .rs .sp The \fBmemory\fP modifier
-causes \fBpcre2test\fP to log the sizes of all heap memory allocation and
-freeing calls that occur during a call to \fBpcre2_match()\fP or
-\fBpcre2_dfa_match()\fP. These occur only when a match requires a bigger vector
-than the default for remembering backtracking points (\fBpcre2_match()\fP) or
-for internal workspace (\fBpcre2_dfa_match()\fP). In many cases there will be
-no heap memory used and therefore no additional output. No heap memory is
-allocated during matching with JIT, so in that case the \fBmemory\fP modifier
-never has any effect. For this modifier to work, the \fBnull_context\fP
-modifier must not be set on both the pattern and the subject, though it can be
-set on one or the other. . . .SS "Setting a starting offset" .rs .sp The
-\fBoffset\fP modifier sets an offset in the subject string at which matching
-starts. Its value is a number of code units, not characters. . . .SS "Setting
-an offset limit" .rs .sp The \fBoffset_limit\fP modifier sets a limit for
-unanchored matches. If a match cannot be found starting at or before this
-offset in the subject, a "no match" return is given. The data value is a number
-of code units, not characters. When this modifier is used, the
-\fBuse_offset_limit\fP modifier must have been set for the pattern; if not, an
-error is generated. . . .SS "Setting the size of the output vector" .rs .sp The
-\fBovector\fP modifier applies only to the subject line in which it appears,
-though of course it can also be used to set a default in a \fB#subject\fP
-command. It specifies the number of pairs of offsets that are available for
-storing matching information. The default is 15. .P A value of zero is useful
-when testing the POSIX API because it causes \fBregexec()\fP to be called with
-a NULL capture vector. When not testing the POSIX API, a value of zero is used
-to cause \fBpcre2_match_data_create_from_pattern()\fP to be called, in order to
-create a match block of exactly the right size for the pattern. (It is not
-possible to create a match block with a zero-length ovector; there is always at
-least one pair of offsets.) . . .SS "Passing the subject as zero-terminated"
-.rs .sp By default, the subject string is passed to a native API matching
-function with its correct length. In order to test the facility for passing a
-zero-terminated string, the \fBzero_terminate\fP modifier is provided. It
-causes the length to be passed as PCRE2_ZERO_TERMINATED. When matching via the
-POSIX interface, this modifier is ignored, with a warning. .P When testing
-\fBpcre2_substitute()\fP, this modifier also has the effect of passing the
-replacement string as zero-terminated. . . .SS "Passing a NULL context,
-subject, or replacement" .rs .sp Normally, \fBpcre2test\fP passes a context
-block to \fBpcre2_match()\fP, \fBpcre2_dfa_match()\fP, \fBpcre2_jit_match()\fP
-or \fBpcre2_substitute()\fP. If the \fBnull_context\fP modifier is set,
-however, NULL is passed. This is for testing that the matching and substitution
-functions behave correctly in this case (they use default values). This
-modifier cannot be used with the \fBfind_limits\fP or \fBsubstitute_callout\fP
+for matching. . . .SS "Showing MARK names" .rs .sp .P The \fBmark\fP modifier
+causes the names from backtracking control verbs that are returned from calls
+to \fBpcre2_match()\fP to be displayed. If a mark is returned for a match, non-
+match, or partial match, \fBpcre2test\fP shows it. For a match, it is on a line
+by itself, tagged with "MK:". Otherwise, it is added to the non-match message.
+. . .SS "Showing memory usage" .rs .sp The \fBmemory\fP modifier causes
+\fBpcre2test\fP to log the sizes of all heap memory allocation and freeing
+calls that occur during a call to \fBpcre2_match()\fP or \fBpcre2_dfa_match
+()\fP. In the latter case, heap memory is used only when a match requires more
+internal workspace that the default allocation on the stack, so in many cases
+there will be no output. No heap memory is allocated during matching with JIT.
+For this modifier to work, the \fBnull_context\fP modifier must not be set on
+both the pattern and the subject, though it can be set on one or the other. . .
+.SS "Setting a starting offset" .rs .sp The \fBoffset\fP modifier sets an
+offset in the subject string at which matching starts. Its value is a number of
+code units, not characters. . . .SS "Setting an offset limit" .rs .sp The
+\fBoffset_limit\fP modifier sets a limit for unanchored matches. If a match
+cannot be found starting at or before this offset in the subject, a "no match"
+return is given. The data value is a number of code units, not characters. When
+this modifier is used, the \fBuse_offset_limit\fP modifier must have been set
+for the pattern; if not, an error is generated. . . .SS "Setting the size of
+the output vector" .rs .sp The \fBovector\fP modifier applies only to the
+subject line in which it appears, though of course it can also be used to set a
+default in a \fB#subject\fP command. It specifies the number of pairs of
+offsets that are available for storing matching information. The default is 15.
+.P A value of zero is useful when testing the POSIX API because it causes
+\fBregexec()\fP to be called with a NULL capture vector. When not testing the
+POSIX API, a value of zero is used to cause
+\fBpcre2_match_data_create_from_pattern()\fP to be called, in order to create a
+match block of exactly the right size for the pattern. (It is not possible to
+create a match block with a zero-length ovector; there is always at least one
+pair of offsets.) . . .SS "Passing the subject as zero-terminated" .rs .sp By
+default, the subject string is passed to a native API matching function with
+its correct length. In order to test the facility for passing a zero-terminated
+string, the \fBzero_terminate\fP modifier is provided. It causes the length to
+be passed as PCRE2_ZERO_TERMINATED. When matching via the POSIX interface, this
+modifier is ignored, with a warning. .P When testing \fBpcre2_substitute()\fP,
+this modifier also has the effect of passing the replacement string as zero-
+terminated. . . .SS "Passing a NULL context, subject, or replacement" .rs .sp
+Normally, \fBpcre2test\fP passes a context block to \fBpcre2_match()\fP,
+\fBpcre2_dfa_match()\fP, \fBpcre2_jit_match()\fP or \fBpcre2_substitute()\fP.
+If the \fBnull_context\fP modifier is set, however, NULL is passed. This is for
+testing that the matching and substitution functions behave correctly in this
+case (they use default values). This modifier cannot be used with the
+\fBfind_limits\fP, \fBfind_limits_noheap\fP, or \fBsubstitute_callout\fP
 modifiers. .P Similarly, for testing purposes, if the \fBnull_subject\fP or
 \fBnull_replacement\fP modifier is set, the subject or replacement string
 pointers are passed as NULL, respectively, to the relevant functions. . . .SH
 "THE ALTERNATIVE MATCHING FUNCTION" .rs .sp By default, \fBpcre2test\fP uses
 the standard PCRE2 matching function, \fBpcre2_match()\fP to match each subject
 line. PCRE2 also supports an alternative matching function, \fBpcre2_dfa_match
 ()\fP, which operates in a different way, and has some restrictions. The
@@ -1102,15 +1102,15 @@
 particular, \fBhex\fP, \fBposix\fP, \fBposix_nosub\fP, \fBpush\fP, and
 \fBpushcopy\fP are not allowed, nor are any .\" HTML .\" option-setting
 modifiers. .\" The JIT modifiers are, however permitted. Here is an example
 that saves and reloads two patterns. .sp /abc/push /xyz/push #save tempfile
 #load tempfile #pop info xyz .sp #pop jit,bincode abc .sp If \fBjitverify\fP is
 used with #pop, it does not automatically imply \fBjit\fP, which is different
 behaviour from when it is used on a pattern. .P The #popcopy command is
-analagous to the \fBpushcopy\fP modifier in that it makes current a copy of the
+analogous to the \fBpushcopy\fP modifier in that it makes current a copy of the
 topmost stack pattern, leaving the original still on the stack. . . . .SH "SEE
 ALSO" .rs .sp \fBpcre2\fP(3), \fBpcre2api\fP(3), \fBpcre2callout\fP(3),
 \fBpcre2jit\fP, \fBpcre2matching\fP(3), \fBpcre2partial\fP(d),
 \fBpcre2pattern\fP(3), \fBpcre2serialize\fP(3). . . .SH AUTHOR .rs .sp .nf
 Philip Hazel Retired from University Computing Service Cambridge, England. .fi
-. . .SH REVISION .rs .sp .nf Last updated: 12 January 2022 Copyright (c) 1997-
-2022 University of Cambridge. .fi
+. . .SH REVISION .rs .sp .nf Last updated: 27 July 2022 Copyright (c) 1997-2022
+University of Cambridge. .fi
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2test.txt` & `pcre2-0.2.0/src/libpcre2/doc/pcre2test.txt`

 * *Files 1% similar despite different names*

```diff
@@ -201,15 +201,15 @@
                  options are present, whichever is first is recognized.
 
        -LP       List properties: write a list of recognized  Unicode  proper-
                  ties  to  the standard output, then exit with zero exit code.
                  All other options are ignored. If both -C and any -Lx options
                  are present, whichever is first is recognized.
 
-       -LS       List  scripts: write a list of recogized Unicode script names
+       -LS       List scripts: write a list of recognized Unicode script names
                  to the standard output, then exit with zero  exit  code.  All
                  other options are ignored. If both -C and any -Lx options are
                  present, whichever is first is recognized.
 
        -pattern modifier-list
                  Behave as if each pattern line contains the given modifiers.
 
@@ -1107,15 +1107,16 @@
              callout_extra              show extra callout information
              callout_fail=<n>[:<m>]     control callout failure
              callout_no_where           do not show position of a callout
              callout_none               do not supply a callout function
              copy=<number or name>      copy captured substring
              depth_limit=<n>            set a depth limit
              dfa                        use pcre2_dfa_match()
-             find_limits                find match and depth limits
+             find_limits                find heap, match and depth limits
+             find_limits_noheap         find match and depth limits
              get=<number or name>       extract captured substring
              getall                     extract all captured substrings
          /g  global                     global matching
              heap_limit=<n>             set a limit on heap memory (Kbytes)
              jitstack=<n>               set size of JIT stack
              mark                       show mark values
              match_limit=<n>            set a match limit
@@ -1226,15 +1227,15 @@
 
    Testing pattern callouts
 
        A  callout function is supplied when pcre2test calls the library match-
        ing functions, unless callout_none is specified. Its behaviour  can  be
        controlled  by  various  modifiers  listed above whose names begin with
        callout_. Details are given in the section entitled  "Callouts"  below.
-       Testing  callouts  from  pcre2_substitute()  is  decribed separately in
+       Testing  callouts  from  pcre2_substitute()  is described separately in
        "Testing the substitution function" below.
 
    Finding all matches in a string
 
        Searching for all possible matches within a subject can be requested by
        the  global  or altglobal modifier. After finding a match, the matching
        function is called again to search the remainder of  the  subject.  The
@@ -1407,24 +1408,28 @@
        very  complicated  patterns.  If  jitstack is set non-zero on a subject
        line it overrides any value that was set on the pattern.
 
    Setting heap, match, and depth limits
 
        The heap_limit, match_limit, and depth_limit modifiers set  the  appro-
        priate  limits  in the match context. These values are ignored when the
-       find_limits modifier is specified.
+       find_limits or find_limits_noheap modifier is specified.
 
    Finding minimum limits
 
        If the find_limits modifier is present on  a  subject  line,  pcre2test
        calls  the  relevant matching function several times, setting different
        values   in   the    match    context    via    pcre2_set_heap_limit(),
        pcre2_set_match_limit(),  or pcre2_set_depth_limit() until it finds the
-       minimum values for each parameter that allows  the  match  to  complete
-       without error. If JIT is being used, only the match limit is relevant.
+       smallest value for each parameter that allows  the  match  to  complete
+       without a "limit exceeded" error. The match itself may succeed or fail.
+       An alternative modifier, find_limits_noheap, omits the heap limit. This
+       is  used  in  the standard tests, because the minimum heap limit varies
+       between systems. If JIT is being used, only the match  limit  is  rele-
+       vant, and the other two are automatically omitted.
 
        When using this modifier, the pattern should not contain any limit set-
        tings such as (*LIMIT_MATCH=...)  within  it.  If  such  a  setting  is
        present and is lower than the minimum matching value, the minimum value
        cannot be found because pcre2_set_match_limit() etc. are only  able  to
        reduce the value of an in-pattern limit; they cannot increase it.
 
@@ -1442,38 +1447,34 @@
        the case of DFA matching, match_limit  controls  the  total  number  of
        calls, both recursive and non-recursive, to the internal matching func-
        tion, thus controlling the overall amount of computing resource that is
        used.
 
        For  both  kinds  of  matching,  the  heap_limit  number,  which  is in
        kibibytes (units of 1024 bytes), limits the amount of heap memory  used
-       for matching. A value of zero disables the use of any heap memory; many
-       simple pattern matches can be done without using the heap, so  zero  is
-       not an unreasonable setting.
+       for matching.
 
    Showing MARK names
 
 
        The mark modifier causes the names from backtracking control verbs that
        are returned from calls to pcre2_match() to be displayed. If a mark  is
        returned  for a match, non-match, or partial match, pcre2test shows it.
        For a match, it is on a line by itself, tagged with  "MK:".  Otherwise,
        it is added to the non-match message.
 
    Showing memory usage
 
        The  memory modifier causes pcre2test to log the sizes of all heap mem-
        ory  allocation  and  freeing  calls  that  occur  during  a  call   to
-       pcre2_match()  or  pcre2_dfa_match(). These occur only when a match re-
-       quires a bigger vector than the default  for  remembering  backtracking
-       points  (pcre2_match())  or for internal workspace (pcre2_dfa_match()).
-       In many cases there will be no heap memory used and therefore no  addi-
-       tional output. No heap memory is allocated during matching with JIT, so
-       in that case the memory modifier never has any effect. For  this  modi-
-       fier  to  work,  the  null_context modifier must not be set on both the
+       pcre2_match()  or pcre2_dfa_match(). In the latter case, heap memory is
+       used only when a match requires more internal workspace  that  the  de-
+       fault  allocation  on the stack, so in many cases there will be no out-
+       put. No heap memory is allocated during matching  with  JIT.  For  this
+       modifier to work, the null_context modifier must not be set on both the
        pattern and the subject, though it can be set on one or the other.
 
    Setting a starting offset
 
        The offset modifier sets an offset  in  the  subject  string  at  which
        matching starts. Its value is a number of code units, not characters.
 
@@ -1514,53 +1515,54 @@
    Passing a NULL context, subject, or replacement
 
        Normally,   pcre2test   passes   a   context  block  to  pcre2_match(),
        pcre2_dfa_match(), pcre2_jit_match()  or  pcre2_substitute().   If  the
        null_context  modifier  is  set,  however,  NULL is passed. This is for
        testing that the matching and substitution functions  behave  correctly
        in  this  case  (they use default values). This modifier cannot be used
-       with the find_limits or substitute_callout modifiers.
+       with the find_limits, find_limits_noheap, or  substitute_callout  modi-
+       fiers.
 
-       Similarly, for testing purposes, if the null_subject  or  null_replace-
-       ment  modifier  is  set, the subject or replacement string pointers are
+       Similarly,  for  testing purposes, if the null_subject or null_replace-
+       ment modifier is set, the subject or replacement  string  pointers  are
        passed as NULL, respectively, to the relevant functions.
 
 
 THE ALTERNATIVE MATCHING FUNCTION
 
-       By default,  pcre2test  uses  the  standard  PCRE2  matching  function,
+       By  default,  pcre2test  uses  the  standard  PCRE2  matching function,
        pcre2_match() to match each subject line. PCRE2 also supports an alter-
-       native matching function, pcre2_dfa_match(), which operates in  a  dif-
-       ferent  way, and has some restrictions. The differences between the two
+       native  matching  function, pcre2_dfa_match(), which operates in a dif-
+       ferent way, and has some restrictions. The differences between the  two
        functions are described in the pcre2matching documentation.
 
-       If the dfa modifier is set, the alternative matching function is  used.
-       This  function  finds all possible matches at a given point in the sub-
-       ject. If, however, the dfa_shortest modifier is set,  processing  stops
-       after  the  first  match is found. This is always the shortest possible
+       If  the dfa modifier is set, the alternative matching function is used.
+       This function finds all possible matches at a given point in  the  sub-
+       ject.  If,  however, the dfa_shortest modifier is set, processing stops
+       after the first match is found. This is always  the  shortest  possible
        match.
 
 
 DEFAULT OUTPUT FROM pcre2test
 
-       This section describes the output when the  normal  matching  function,
+       This  section  describes  the output when the normal matching function,
        pcre2_match(), is being used.
 
-       When  a  match  succeeds,  pcre2test  outputs the list of captured sub-
-       strings, starting with number 0 for the string that matched  the  whole
+       When a match succeeds, pcre2test outputs  the  list  of  captured  sub-
+       strings,  starting  with number 0 for the string that matched the whole
        pattern.  Otherwise, it outputs "No match" when the return is PCRE2_ER-
-       ROR_NOMATCH, or "Partial match:" followed  by  the  partially  matching
-       substring  when  the  return is PCRE2_ERROR_PARTIAL. (Note that this is
-       the entire substring that was inspected during the  partial  match;  it
-       may  include  characters  before the actual match start if a lookbehind
+       ROR_NOMATCH,  or  "Partial  match:"  followed by the partially matching
+       substring when the return is PCRE2_ERROR_PARTIAL. (Note  that  this  is
+       the  entire  substring  that was inspected during the partial match; it
+       may include characters before the actual match start  if  a  lookbehind
        assertion, \K, \b, or \B was involved.)
 
        For any other return, pcre2test outputs the PCRE2 negative error number
-       and  a  short  descriptive  phrase. If the error is a failed UTF string
-       check, the code unit offset of the start of the  failing  character  is
+       and a short descriptive phrase. If the error is  a  failed  UTF  string
+       check,  the  code  unit offset of the start of the failing character is
        also output. Here is an example of an interactive pcre2test run.
 
          $ pcre2test
          PCRE2 version 10.22 2016-07-29
 
            re> /^abc(\d+)/
          data> abc123
@@ -1568,32 +1570,32 @@
           1: 123
          data> xyz
          No match
 
        Unset capturing substrings that are not followed by one that is set are
        not shown by pcre2test unless the allcaptures modifier is specified. In
        the following example, there are two capturing substrings, but when the
-       first data line is matched, the second, unset substring is  not  shown.
-       An  "internal" unset substring is shown as "<unset>", as for the second
+       first  data  line is matched, the second, unset substring is not shown.
+       An "internal" unset substring is shown as "<unset>", as for the  second
        data line.
 
            re> /(a)|(b)/
          data> a
           0: a
           1: a
          data> b
           0: b
           1: <unset>
           2: b
 
-       If the strings contain any non-printing characters, they are output  as
-       \xhh  escapes  if  the  value is less than 256 and UTF mode is not set.
+       If  the strings contain any non-printing characters, they are output as
+       \xhh escapes if the value is less than 256 and UTF  mode  is  not  set.
        Otherwise they are output as \x{hh...} escapes. See below for the defi-
-       nition  of  non-printing  characters. If the aftertext modifier is set,
-       the output for substring 0 is followed by the the rest of  the  subject
+       nition of non-printing characters. If the aftertext  modifier  is  set,
+       the  output  for substring 0 is followed by the the rest of the subject
        string, identified by "0+" like this:
 
            re> /cat/aftertext
          data> cataract
           0: cat
           0+ aract
 
@@ -1605,45 +1607,45 @@
           0: iss
           1: ss
           0: iss
           1: ss
           0: ipp
           1: pp
 
-       "No match" is output only if the first match attempt fails. Here is  an
-       example  of  a  failure  message (the offset 4 that is specified by the
+       "No  match" is output only if the first match attempt fails. Here is an
+       example of a failure message (the offset 4 that  is  specified  by  the
        offset modifier is past the end of the subject string):
 
            re> /xyz/
          data> xyz\=offset=4
          Error -24 (bad offset value)
 
        Note that whereas patterns can be continued over several lines (a plain
-       ">"  prompt  is used for continuations), subject lines may not. However
+       ">" prompt is used for continuations), subject lines may  not.  However
        newlines can be included in a subject by means of the \n escape (or \r,
        \r\n, etc., depending on the newline sequence setting).
 
 
 OUTPUT FROM THE ALTERNATIVE MATCHING FUNCTION
 
        When the alternative matching function, pcre2_dfa_match(), is used, the
-       output consists of a list of all the matches that start  at  the  first
+       output  consists  of  a list of all the matches that start at the first
        point in the subject where there is at least one match. For example:
 
            re> /(tang|tangerine|tan)/
          data> yellow tangerine\=dfa
           0: tangerine
           1: tang
           2: tan
 
-       Using  the normal matching function on this data finds only "tang". The
-       longest matching string is always given first (and numbered zero).  Af-
-       ter  a PCRE2_ERROR_PARTIAL return, the output is "Partial match:", fol-
+       Using the normal matching function on this data finds only "tang".  The
+       longest  matching string is always given first (and numbered zero). Af-
+       ter a PCRE2_ERROR_PARTIAL return, the output is "Partial match:",  fol-
        lowed by the partially matching substring. Note that this is the entire
-       substring  that  was inspected during the partial match; it may include
+       substring that was inspected during the partial match; it  may  include
        characters before the actual match start if a lookbehind assertion, \b,
        or \B was involved. (\K is not supported for DFA matching.)
 
        If global matching is requested, the search for further matches resumes
        at the end of the longest match. For example:
 
            re> /(tang|tangerine|tan)/g
@@ -1651,63 +1653,63 @@
           0: tangerine
           1: tang
           2: tan
           0: tang
           1: tan
           0: tan
 
-       The alternative matching function does not support  substring  capture,
-       so  the  modifiers  that are concerned with captured substrings are not
+       The  alternative  matching function does not support substring capture,
+       so the modifiers that are concerned with captured  substrings  are  not
        relevant.
 
 
 RESTARTING AFTER A PARTIAL MATCH
 
-       When the alternative matching function has given  the  PCRE2_ERROR_PAR-
+       When  the  alternative matching function has given the PCRE2_ERROR_PAR-
        TIAL return, indicating that the subject partially matched the pattern,
-       you can restart the match with additional subject data by means of  the
+       you  can restart the match with additional subject data by means of the
        dfa_restart modifier. For example:
 
            re> /^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$/
          data> 23ja\=ps,dfa
          Partial match: 23ja
          data> n05\=dfa,dfa_restart
           0: n05
 
-       For  further  information  about partial matching, see the pcre2partial
+       For further information about partial matching,  see  the  pcre2partial
        documentation.
 
 
 CALLOUTS
 
        If the pattern contains any callout requests, pcre2test's callout func-
-       tion  is  called during matching unless callout_none is specified. This
+       tion is called during matching unless callout_none is  specified.  This
        works with both matching functions, and with JIT, though there are some
-       differences  in behaviour. The output for callouts with numerical argu-
+       differences in behaviour. The output for callouts with numerical  argu-
        ments and those with string arguments is slightly different.
 
    Callouts with numerical arguments
 
        By default, the callout function displays the callout number, the start
-       and  current positions in the subject text at the callout time, and the
+       and current positions in the subject text at the callout time, and  the
        next pattern item to be tested. For example:
 
          --->pqrabcdef
            0    ^  ^     \d
 
-       This output indicates that callout number 0 occurred for  a  match  at-
-       tempt  starting at the fourth character of the subject string, when the
-       pointer was at the seventh character, and when the  next  pattern  item
-       was  \d.  Just  one circumflex is output if the start and current posi-
+       This  output  indicates  that callout number 0 occurred for a match at-
+       tempt starting at the fourth character of the subject string, when  the
+       pointer  was  at  the seventh character, and when the next pattern item
+       was \d. Just one circumflex is output if the start  and  current  posi-
        tions are the same, or if the current position precedes the start posi-
        tion, which can happen if the callout is in a lookbehind assertion.
 
        Callouts numbered 255 are assumed to be automatic callouts, inserted as
        a result of the auto_callout pattern modifier. In this case, instead of
-       showing  the  callout  number, the offset in the pattern, preceded by a
+       showing the callout number, the offset in the pattern,  preceded  by  a
        plus, is output. For example:
 
            re> /\d?[A-E]\*/auto_callout
          data> E*
          --->E*
           +0 ^      \d?
           +3 ^      [A-E]
@@ -1726,25 +1728,25 @@
           +1 ^^      (*MARK:X)
          +10 ^^      b
          Latest Mark: X
          +11 ^ ^     c
          +12 ^  ^
           0: abc
 
-       The mark changes between matching "a" and "b", but stays the  same  for
-       the  rest  of  the match, so nothing more is output. If, as a result of
-       backtracking, the mark reverts to being unset, the  text  "<unset>"  is
+       The  mark  changes between matching "a" and "b", but stays the same for
+       the rest of the match, so nothing more is output. If, as  a  result  of
+       backtracking,  the  mark  reverts to being unset, the text "<unset>" is
        output.
 
    Callouts with string arguments
 
        The output for a callout with a string argument is similar, except that
-       instead of outputting a callout number before the position  indicators,
-       the  callout string and its offset in the pattern string are output be-
-       fore the reflection of the subject string, and the  subject  string  is
+       instead  of outputting a callout number before the position indicators,
+       the callout string and its offset in the pattern string are output  be-
+       fore  the  reflection  of the subject string, and the subject string is
        reflected for each callout. For example:
 
            re> /^ab(?C'first')cd(?C"second")ef/
          data> abcdefg
          Callout (7): 'first'
          --->abcdefg
              ^ ^         c
@@ -1752,34 +1754,34 @@
          --->abcdefg
              ^   ^       e
           0: abcdef
 
 
    Callout modifiers
 
-       The  callout  function in pcre2test returns zero (carry on matching) by
-       default, but you can use a callout_fail modifier in a subject  line  to
+       The callout function in pcre2test returns zero (carry on  matching)  by
+       default,  but  you can use a callout_fail modifier in a subject line to
        change this and other parameters of the callout (see below).
 
        If the callout_capture modifier is set, the current captured groups are
        output when a callout occurs. This is useful only for non-DFA matching,
-       as  pcre2_dfa_match()  does  not  support capturing, so no captures are
+       as pcre2_dfa_match() does not support capturing,  so  no  captures  are
        ever shown.
 
        The normal callout output, showing the callout number or pattern offset
-       (as  described above) is suppressed if the callout_no_where modifier is
+       (as described above) is suppressed if the callout_no_where modifier  is
        set.
 
-       When using the interpretive  matching  function  pcre2_match()  without
-       JIT,  setting  the callout_extra modifier causes additional output from
-       pcre2test's callout function to be generated. For the first callout  in
-       a  match  attempt at a new starting position in the subject, "New match
-       attempt" is output. If there has been a backtrack since the last  call-
+       When  using  the  interpretive  matching function pcre2_match() without
+       JIT, setting the callout_extra modifier causes additional  output  from
+       pcre2test's  callout function to be generated. For the first callout in
+       a match attempt at a new starting position in the subject,  "New  match
+       attempt"  is output. If there has been a backtrack since the last call-
        out (or start of matching if this is the first callout), "Backtrack" is
-       output, followed by "No other matching paths" if  the  backtrack  ended
+       output,  followed  by  "No other matching paths" if the backtrack ended
        the previous match attempt. For example:
 
           re> /(a+)b/auto_callout,no_start_optimize,no_auto_possess
          data> aac\=callout_extra
          New match attempt
          --->aac
           +0 ^       (
@@ -1808,132 +1810,132 @@
          No other matching paths
          New match attempt
          --->aac
           +0    ^    (
           +1    ^    a+
          No match
 
-       Notice  that  various  optimizations must be turned off if you want all
-       possible matching paths to be  scanned.  If  no_start_optimize  is  not
-       used,  there  is an immediate "no match", without any callouts, because
-       the starting optimization fails to find "b" in the  subject,  which  it
-       knows  must  be  present for any match. If no_auto_possess is not used,
-       the "a+" item is turned into "a++", which reduces the number  of  back-
+       Notice that various optimizations must be turned off if  you  want  all
+       possible  matching  paths  to  be  scanned. If no_start_optimize is not
+       used, there is an immediate "no match", without any  callouts,  because
+       the  starting  optimization  fails to find "b" in the subject, which it
+       knows must be present for any match. If no_auto_possess  is  not  used,
+       the  "a+"  item is turned into "a++", which reduces the number of back-
        tracks.
 
-       The  callout_extra modifier has no effect if used with the DFA matching
+       The callout_extra modifier has no effect if used with the DFA  matching
        function, or with JIT.
 
    Return values from callouts
 
-       The default return from the callout  function  is  zero,  which  allows
+       The  default  return  from  the  callout function is zero, which allows
        matching to continue. The callout_fail modifier can be given one or two
        numbers. If there is only one number, 1 is returned instead of 0 (caus-
        ing matching to backtrack) when a callout of that number is reached. If
-       two numbers (<n>:<m>) are given, 1 is  returned  when  callout  <n>  is
-       reached  and  there  have been at least <m> callouts. The callout_error
+       two  numbers  (<n>:<m>)  are  given,  1 is returned when callout <n> is
+       reached and there have been at least <m>  callouts.  The  callout_error
        modifier is similar, except that PCRE2_ERROR_CALLOUT is returned, caus-
-       ing  the entire matching process to be aborted. If both these modifiers
-       are set for the same callout number,  callout_error  takes  precedence.
-       Note  that  callouts  with string arguments are always given the number
+       ing the entire matching process to be aborted. If both these  modifiers
+       are  set  for  the same callout number, callout_error takes precedence.
+       Note that callouts with string arguments are always  given  the  number
        zero.
 
-       The callout_data modifier can be given an unsigned or a  negative  num-
-       ber.   This  is  set  as the "user data" that is passed to the matching
-       function, and passed back when the callout  function  is  invoked.  Any
-       value  other  than  zero  is  used as a return from pcre2test's callout
+       The  callout_data  modifier can be given an unsigned or a negative num-
+       ber.  This is set as the "user data" that is  passed  to  the  matching
+       function,  and  passed  back  when the callout function is invoked. Any
+       value other than zero is used as  a  return  from  pcre2test's  callout
        function.
 
        Inserting callouts can be helpful when using pcre2test to check compli-
-       cated  regular expressions. For further information about callouts, see
+       cated regular expressions. For further information about callouts,  see
        the pcre2callout documentation.
 
 
 NON-PRINTING CHARACTERS
 
        When pcre2test is outputting text in the compiled version of a pattern,
-       bytes  other  than 32-126 are always treated as non-printing characters
+       bytes other than 32-126 are always treated as  non-printing  characters
        and are therefore shown as hex escapes.
 
-       When pcre2test is outputting text that is a matched part of  a  subject
-       string,  it behaves in the same way, unless a different locale has been
-       set for the pattern (using the locale modifier). In this case, the  is-
+       When  pcre2test  is outputting text that is a matched part of a subject
+       string, it behaves in the same way, unless a different locale has  been
+       set  for the pattern (using the locale modifier). In this case, the is-
        print() function is used to distinguish printing and non-printing char-
        acters.
 
 
 SAVING AND RESTORING COMPILED PATTERNS
 
-       It is possible to save compiled patterns  on  disc  or  elsewhere,  and
+       It  is  possible  to  save  compiled patterns on disc or elsewhere, and
        reload them later, subject to a number of restrictions. JIT data cannot
-       be saved. The host on which the patterns are reloaded must  be  running
+       be  saved.  The host on which the patterns are reloaded must be running
        the same version of PCRE2, with the same code unit width, and must also
-       have the same endianness, pointer width  and  PCRE2_SIZE  type.  Before
-       compiled  patterns  can be saved they must be serialized, that is, con-
-       verted to a stream of bytes. A single byte stream may contain any  num-
-       ber  of compiled patterns, but they must all use the same character ta-
-       bles. A single copy of the tables is included in the byte  stream  (its
+       have  the  same  endianness,  pointer width and PCRE2_SIZE type. Before
+       compiled patterns can be saved they must be serialized, that  is,  con-
+       verted  to a stream of bytes. A single byte stream may contain any num-
+       ber of compiled patterns, but they must all use the same character  ta-
+       bles.  A  single copy of the tables is included in the byte stream (its
        size is 1088 bytes).
 
-       The  functions whose names begin with pcre2_serialize_ are used for se-
-       rializing and de-serializing. They are described in the  pcre2serialize
-       documentation.  In  this  section we describe the features of pcre2test
+       The functions whose names begin with pcre2_serialize_ are used for  se-
+       rializing  and de-serializing. They are described in the pcre2serialize
+       documentation. In this section we describe the  features  of  pcre2test
        that can be used to test these functions.
 
-       Note that "serialization" in PCRE2 does not convert  compiled  patterns
-       to  an  abstract  format  like Java or .NET. It just makes a reloadable
+       Note  that  "serialization" in PCRE2 does not convert compiled patterns
+       to an abstract format like Java or .NET. It  just  makes  a  reloadable
        byte code stream.  Hence the restrictions on reloading mentioned above.
 
-       In pcre2test, when a pattern with push modifier  is  successfully  com-
-       piled,  it  is  pushed onto a stack of compiled patterns, and pcre2test
-       expects the next line to contain a new pattern (or command) instead  of
+       In  pcre2test,  when  a pattern with push modifier is successfully com-
+       piled, it is pushed onto a stack of compiled  patterns,  and  pcre2test
+       expects  the next line to contain a new pattern (or command) instead of
        a subject line. By contrast, the pushcopy modifier causes a copy of the
-       compiled pattern to be stacked, leaving the original available for  im-
-       mediate  matching.  By using push and/or pushcopy, a number of patterns
-       can be compiled and retained. These  modifiers  are  incompatible  with
+       compiled  pattern to be stacked, leaving the original available for im-
+       mediate matching. By using push and/or pushcopy, a number  of  patterns
+       can  be  compiled  and  retained. These modifiers are incompatible with
        posix, and control modifiers that act at match time are ignored (with a
-       message) for the stacked patterns. The jitverify modifier applies  only
+       message)  for the stacked patterns. The jitverify modifier applies only
        at compile time.
 
        The command
 
          #save <filename>
 
        causes all the stacked patterns to be serialized and the result written
-       to the named file. Afterwards, all the stacked patterns are freed.  The
+       to  the named file. Afterwards, all the stacked patterns are freed. The
        command
 
          #load <filename>
 
-       reads  the  data in the file, and then arranges for it to be de-serial-
-       ized, with the resulting compiled patterns added to the pattern  stack.
-       The  pattern  on the top of the stack can be retrieved by the #pop com-
-       mand, which must be followed by  lines  of  subjects  that  are  to  be
-       matched  with  the pattern, terminated as usual by an empty line or end
-       of file. This command may be followed by  a  modifier  list  containing
-       only  control  modifiers that act after a pattern has been compiled. In
-       particular, hex, posix, posix_nosub, push, and  pushcopy  are  not  al-
-       lowed,  nor  are  any option-setting modifiers.  The JIT modifiers are,
-       however permitted. Here is an example that saves and reloads  two  pat-
+       reads the data in the file, and then arranges for it to  be  de-serial-
+       ized,  with the resulting compiled patterns added to the pattern stack.
+       The pattern on the top of the stack can be retrieved by the  #pop  com-
+       mand,  which  must  be  followed  by  lines  of subjects that are to be
+       matched with the pattern, terminated as usual by an empty line  or  end
+       of  file.  This  command  may be followed by a modifier list containing
+       only control modifiers that act after a pattern has been  compiled.  In
+       particular,  hex,  posix,  posix_nosub,  push, and pushcopy are not al-
+       lowed, nor are any option-setting modifiers.  The  JIT  modifiers  are,
+       however  permitted.  Here is an example that saves and reloads two pat-
        terns.
 
          /abc/push
          /xyz/push
          #save tempfile
          #load tempfile
          #pop info
          xyz
 
          #pop jit,bincode
          abc
 
-       If  jitverify  is  used with #pop, it does not automatically imply jit,
+       If jitverify is used with #pop, it does not  automatically  imply  jit,
        which is different behaviour from when it is used on a pattern.
 
-       The #popcopy command is analagous to the pushcopy modifier in  that  it
+       The  #popcopy  command is analogous to the pushcopy modifier in that it
        makes current a copy of the topmost stack pattern, leaving the original
        still on the stack.
 
 
 SEE ALSO
 
        pcre2(3),  pcre2api(3),  pcre2callout(3),  pcre2jit,  pcre2matching(3),
@@ -1945,9 +1947,9 @@
        Philip Hazel
        Retired from University Computing Service
        Cambridge, England.
 
 
 REVISION
 
-       Last updated: 12 January 2022
+       Last updated: 27 July 2022
        Copyright (c) 1997-2022 University of Cambridge.
```

### Comparing `pcre2-0.1.0/src/libpcre2/doc/pcre2unicode.3` & `pcre2-0.2.0/src/libpcre2/doc/pcre2unicode.3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/index.md` & `pcre2-0.2.0/src/libpcre2/index.md`

 * *Files 11% similar despite different names*

```diff
@@ -10,37 +10,37 @@
 PCRE2 was first released in 2015 to replace the API in the original PCRE 
 library, which is now obsolete and no longer maintained. As well as a more
 flexible API, the code of PCRE2 has been much improved since the fork.
  
 ## Download
 
 As well as downloading from the 
-[GitHub site](https://github.com/PhilipHazel/pcre2), you can download PCRE2 
+[GitHub site](https://github.com/PCRE2Project/pcre2), you can download PCRE2 
 or the older, unmaintained PCRE1 library from an 
 [*unofficial* mirror](https://sourceforge.net/projects/pcre/files/) at SourceForge.
 
 You can check out the PCRE2 source code via Git or Subversion:
 
-    git clone https://github.com/PhilipHazel/pcre2.git
-    svn co    https://github.com/PhilipHazel/pcre2.git
+    git clone https://github.com/PCRE2Project/pcre2.git
+    svn co    https://github.com/PCRE2Project/pcre2.git
 
 ## Contributed Ports
 
 If you just need the command-line PCRE2 tools on Windows, precompiled binary
 versions are available at this 
 [Rexegg page](http://www.rexegg.com/pcregrep-pcretest.html).
 
 A PCRE2 port for z/OS, a mainframe operating system which uses EBCDIC as its
 default character encoding, can be found at 
 [http://www.cbttape.org](http://www.cbttape.org/) (File 939).
 
 ## Documentation
 
 You can read the PCRE2 documentation 
-[here](https://philiphazel.github.io/pcre2/doc/html/index.html).
+[here](https://PCRE2Project.github.io/pcre2/doc/html/index.html).
 
 Comparisons to Perl's regular expression semantics can be found in the
 community authored Wikipedia entry for PCRE.
 
 There is a curated summary of changes for each PCRE release, copies of
 documentation from older releases, and other useful information from the third
 party authored
```

### Comparing `pcre2-0.1.0/src/libpcre2/m4/ax_pthread.m4` & `pcre2-0.2.0/src/libpcre2/m4/ax_pthread.m4`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/m4/pcre2_visibility.m4` & `pcre2-0.2.0/src/libpcre2/m4/pcre2_visibility.m4`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/GenerateCommon.py` & `pcre2-0.2.0/src/libpcre2/maint/GenerateCommon.py`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/GenerateTest26.py` & `pcre2-0.2.0/src/libpcre2/maint/GenerateTest26.py`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/GenerateUcd.py` & `pcre2-0.2.0/src/libpcre2/maint/GenerateUcd.py`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/GenerateUcpHeader.py` & `pcre2-0.2.0/src/libpcre2/maint/GenerateUcpHeader.py`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/GenerateUcpTables.py` & `pcre2-0.2.0/src/libpcre2/maint/GenerateUcpTables.py`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/ManyConfigTests` & `pcre2-0.2.0/src/libpcre2/maint/ManyConfigTests`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/README` & `pcre2-0.2.0/src/libpcre2/maint/README`

 * *Files 3% similar despite different names*

```diff
@@ -74,32 +74,33 @@
   A directory containing four files, testinput{1,2} and testoutput{1,2}, for
   use in conjunction with the ucptest program.
 
 utf8.c
   A short, freestanding C program for converting a Unicode code point into a
   sequence of bytes in the UTF-8 encoding, and vice versa. If its argument is a
   hex number such as 0x1234, it outputs a list of the equivalent UTF-8 bytes.
-  If its argument is a sequence of concatenated UTF-8 bytes (e.g. e188b4) it
-  treats them as a UTF-8 character and outputs the equivalent code point in
-  hex. See comments at its head for details.
+  If its argument is a sequence of concatenated UTF-8 bytes (e.g. 12e188b4) it
+  treats them as a UTF-8 string and outputs the equivalent code points in hex.
+  See comments at its head for details.
 
 
 Updating to a new Unicode release
 =================================
 
 When there is a new release of Unicode, the files in Unicode.tables must be
 refreshed from the web site. Once that is done, the four Python scripts that 
 generate files from the Unicode data can be run from within the "maint" 
 directory.
 
 Note: Previously, it was necessary to update lists of scripts and their 
 abbreviations by hand before running the Python scripts. This is no longer
 necessary because the scripts have been upgraded to extract this information
-themselves. Also, there used to be explicit lists of script in two of the man
-pages. This is no longer the case.
+themselves. Also, there used to be explicit lists of scripts in two of the man
+pages. This is no longer the case; the pcre2test program can now output a list 
+of supported scripts.
 
 You can give an output file name as an argument to the following scripts, but
 by default:
 
 GenerateUcd.py        creates pcre2_ucd.c        )
 GenerateUcpHeader.py  creates pcre2_ucp.h        ) in the current directory
 GenerateUcpTables.py  creates pcre2_ucptables.c  )
@@ -125,50 +126,50 @@
 can give an alternative directory name as an argument to the script. These
 files should eventually be installed in the main testdata directory.
 
 
 Preparing for a PCRE2 release
 =============================
 
-This section contains a checklist of things that I consult before building a
-distribution for a new release.
+This section contains a checklist of things that I do before building a new
+release.
 
 . Ensure that the version number and version date are correct in configure.ac.
 
 . Update the library version numbers in configure.ac according to the rules
   given below.
 
 . If new build options or new source files have been added, ensure that they
   are added to the CMake files as well as to the autoconf files. The relevant
-  files are CMakeLists.txt and config-cmake.h.in. After making a release
-  tarball, test it out with CMake if there have been changes here.
+  files are CMakeLists.txt and config-cmake.h.in. After making a release, test
+  it out with CMake if there have been changes here.
 
 . Run ./autogen.sh to ensure everything is up-to-date.
 
 . Compile and test with many different config options, and combinations of
   options. Also, test with valgrind by running "RunTest valgrind" and
-  "RunGrepTest valgrind" (which takes quite a long time). The script
-  maint/ManyConfigTests now encapsulates this testing. It runs tests with
-  different configurations, and it also runs some of them with valgrind, all of
-  which can take quite some time.
+  "RunGrepTest valgrind". The script maint/ManyConfigTests now encapsulates
+  this testing. It runs tests with different configurations, and it also runs
+  some of them with valgrind, all of which can take quite some time.
 
 . Run tests in both 32-bit and 64-bit environments if possible. I can no longer
   run 32-bit tests.
 
 . Run tests with two or more different compilers (e.g. clang and gcc), and
   make use of -fsanitize=address and friends where possible. For gcc,
   -fsanitize=undefined -std=gnu99 picks up undefined behaviour at runtime, but
   needs -fno-sanitize=shift to get rid of warnings for shifts of negative
   numbers in the JIT compiler. For clang, -fsanitize=address,undefined,integer
   can be used but -fno-sanitize=alignment,shift,unsigned-integer-overflow must
   be added when compiling with JIT. Another useful clang option is
   -fsanitize=signed-integer-overflow
 
 . Do a test build using CMake. Remove src/config.h first, lest it override the
-  version that CMake creates. Do NOT use parallel make.
+  version that CMake creates. Also do a CMake unity build to check that it 
+  still works: [c]cmake -DCMAKE_UNITY_BUILD=ON sets up a unity build.
 
 . Run perltest.sh on the test data for tests 1 and 4. The output should match
   the PCRE2 test output, apart from the version identification at the start of
   each test. Sometimes there are other differences in test 4 if PCRE2 and Perl
   are using different Unicode releases. The other tests are not Perl-compatible
   (they use various PCRE2-specific features or options).
 
@@ -179,19 +180,20 @@
   NEWS (check version and date), NON-AUTOTOOLS-BUILD, and README. Many of these
   won't need changing, but over the long term things do change.
 
 . I used to test new releases myself on a number of different operating
   systems. For example, on Solaris it is helpful to test using Sun's cc
   compiler as a change from gcc. Adding -xarch=v9 to the cc options does a
   64-bit test, but it also needs -S 64 for pcre2test to increase the stack size
-  for test 2. Since I retired I can no longer do much of this, but instead I
-  rely on putting out release candidates for testing by the community.
+  for test 2. Since I retired I can no longer do much of this. There are 
+  automated tests under Ubuntu, Alpine, and Windows that are now set up as 
+  GitHub actions. Check that they are running clean.
 
 . The buildbots at http://buildfarm.opencsw.org/ do some automated testing
-  of PCRE2 and should be checked before putting out a release.
+  of PCRE2 and should also be checked before putting out a release.
 
 
 Updating version info for libtool
 =================================
 
 This set of rules for updating library version information came from a web page
 whose URL I have forgotten. The version information consists of three parts:
@@ -239,18 +241,19 @@
 
 Run PrepareRelease and commit the files that it changes. The first thing this
 script does is to run CheckMan on the man pages; if it finds any markup errors,
 it reports them and then aborts. Otherwise it removes trailing spaces from
 sources and refreshes the HTML documentation. Update the GitHub repository with
 "git push".
 
-Once PrepareRelease has run clean, run "make distcheck" to create the tarball
+Once PrepareRelease has run clean, run "make distcheck" to create the tarballs
 and the zipball. I then sign these files. Double-check with "git status" that
-the repository is fully up-to-date, then create a new tag on GitHub. Upload the
-tarball, zipball, and the signatures as "assets" of the GitHub release.
+the repository is fully up-to-date, then create a new tag and a release on
+GitHub. Upload the tarballs, zipball, and the signatures as "assets" of the
+GitHub release.
 
 When the new release is out, don't forget to tell webmaster@pcre.org and the
 mailing list.
 
 
 Future ideas (wish list)
 ========================
@@ -361,16 +364,14 @@
 
     \b{gcb} or \b{g}    grapheme cluster boundary
     \b{sb}              sentence boundary
     \b{wb}              word boundary
 
   See Unicode TR 29. The last two are very much aimed at natural language.
 
-. (?[...]) extended classes: big project.
-
 . Allow a callout to specify a number of characters to skip. This can be done
   compatibly via an extra callout field.
 
 . Allow callouts to return *PRUNE, *COMMIT, *THEN, *SKIP, with and without
   continuing (that is, with and without an implied *FAIL). A new option,
   PCRE2_CALLOUT_EXTENDED say, would be needed. This is unlikely ever to be
   implemented by JIT, so this could be an option for pcre2_match().
@@ -432,21 +433,16 @@
 . Redesign handling of class/nclass/xclass because the compile code logic is
   currently very contorted and obscure. Also there was a request for a way of
   re-defining \w (and therefore \W, \b, and \B). An in-pattern sequence such as
   (?w=[...]) was suggested. Easiest way would be simply to inline the class,
   with lookarounds for \b and \B. Ideally the setting should last till the end
   of the group, which means remembering all previous settings; maybe a fixed
   amount of stack would do - how deep would anyone want to nest these things?
-  See GitHub issue #13 for a compendium of character class issues.
-
-. Recognize the short script names. They are already listed in maint/
-  Multistage2.py because they are needed for scanning the script extensions
-  file.
-
-. Use script extensions for \p?
+  See GitHub issue #13 for a compendium of character class issues, including
+  (?[...]) extended classes.
 
 . A user suggested something like --with-build-info to set a build information
   string that could be retrieved by pcre2_config(). However, there's no
   facility for a length limit in pcre2_config(), and what would be the
   encoding?
 
 . Quantified groups with a fixed count currently operate by replicating the
@@ -457,8 +453,8 @@
 . There are regular requests for variable-length lookbehinds.
 
 . See also any suggestions in the GitHub issues.
 
 Philip Hazel
 Email local part: Philip.Hazel
 Email domain: gmail.com
-Last updated: 10 January 2022
+Last updated: 25 April 2022
```

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/BidiMirroring.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/BidiMirroring.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/CaseFolding.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/CaseFolding.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/DerivedBidiClass.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/DerivedBidiClass.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/DerivedCoreProperties.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/DerivedCoreProperties.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/DerivedGeneralCategory.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/DerivedGeneralCategory.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/GraphemeBreakProperty.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/GraphemeBreakProperty.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/PropList.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/PropList.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/PropertyAliases.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/PropertyAliases.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/PropertyValueAliases.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/PropertyValueAliases.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/ScriptExtensions.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/ScriptExtensions.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/Scripts.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/Scripts.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/UnicodeData.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/UnicodeData.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/Unicode.tables/emoji-data.txt` & `pcre2-0.2.0/src/libpcre2/maint/Unicode.tables/emoji-data.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/pcre2_chartables.c.non-standard` & `pcre2-0.2.0/src/libpcre2/maint/pcre2_chartables.c.non-standard`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/ucptest.c` & `pcre2-0.2.0/src/libpcre2/maint/ucptest.c`

 * *Files 1% similar despite different names*

```diff
@@ -542,33 +542,30 @@
 int bprop_list[128];
 unsigned int bprop_count = 0;
 uint32_t i, c;
 int script = -1;
 int type = -1;
 int gbreak = -1;
 int bidiclass = -1;
-BOOL bidicontrol = FALSE;
 BOOL script_not = FALSE;
 BOOL type_not = FALSE;
 BOOL gbreak_not = FALSE;
 BOOL bidiclass_not = FALSE;
 BOOL hadrange = FALSE;
 const ucd_record *ucd, *next_ucd;
 const char *pad = "        ";
 
 while (*s != 0)
   {
   unsigned int offset = 0;
   BOOL scriptx_not = FALSE;
-  char *value_start;
 
   for (t = name; *s != 0 && !isspace(*s); s++) *t++ = *s;
   *t = 0;
   while (isspace(*s)) s++;
-  value_start = s;
 
   for (t = value; *s != 0 && !isspace(*s); s++) 
     {
     if (*s != '_' && *s != '-') *t++ = *s;
     } 
   *t = 0;
   while (isspace(*s)) s++;
```

### Comparing `pcre2-0.1.0/src/libpcre2/maint/ucptestdata/testinput1` & `pcre2-0.2.0/src/libpcre2/maint/ucptestdata/testinput1`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/maint/ucptestdata/testoutput1` & `pcre2-0.2.0/src/libpcre2/maint/ucptestdata/testoutput1`

 * *Files 25% similar despite different names*

```diff
@@ -1,151 +1,151 @@
 findprop 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 
-U+0000 BN  Control: Control, common, Control, [ascii]
-U+0001 BN  Control: Control, common, Control, [ascii]
-U+0002 BN  Control: Control, common, Control, [ascii]
-U+0003 BN  Control: Control, common, Control, [ascii]
-U+0004 BN  Control: Control, common, Control, [ascii]
-U+0005 BN  Control: Control, common, Control, [ascii]
-U+0006 BN  Control: Control, common, Control, [ascii]
-U+0007 BN  Control: Control, common, Control, [ascii]
-U+0008 BN  Control: Control, common, Control, [ascii]
-U+0009 S   Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
-U+000A B   Control: Control, common, LF, [ascii, patternwhitespace, whitespace]
-U+000B S   Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
-U+000C WS  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
-U+000D B   Control: Control, common, CR, [ascii, patternwhitespace, whitespace]
-U+000E BN  Control: Control, common, Control, [ascii]
-U+000F BN  Control: Control, common, Control, [ascii]
+U+0000 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0001 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0002 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0003 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0004 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0005 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0006 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0007 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0008 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0009 S   Control: Control, common, Control, [ascii, graphemebase, patternsyntax, sentenceterminal, terminalpunctuation]
+U+000A B   Control: Control, common, LF, [ascii, graphemebase, patternsyntax, sentenceterminal, terminalpunctuation]
+U+000B S   Control: Control, common, Control, [ascii, graphemebase, patternsyntax, sentenceterminal, terminalpunctuation]
+U+000C WS  Control: Control, common, Control, [ascii, graphemebase, patternsyntax, sentenceterminal, terminalpunctuation]
+U+000D B   Control: Control, common, CR, [ascii, graphemebase, patternsyntax, sentenceterminal, terminalpunctuation]
+U+000E BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+000F BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
 findprop 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 
-U+0010 BN  Control: Control, common, Control, [ascii]
-U+0011 BN  Control: Control, common, Control, [ascii]
-U+0012 BN  Control: Control, common, Control, [ascii]
-U+0013 BN  Control: Control, common, Control, [ascii]
-U+0014 BN  Control: Control, common, Control, [ascii]
-U+0015 BN  Control: Control, common, Control, [ascii]
-U+0016 BN  Control: Control, common, Control, [ascii]
-U+0017 BN  Control: Control, common, Control, [ascii]
-U+0018 BN  Control: Control, common, Control, [ascii]
-U+0019 BN  Control: Control, common, Control, [ascii]
-U+001A BN  Control: Control, common, Control, [ascii]
-U+001B BN  Control: Control, common, Control, [ascii]
-U+001C B   Control: Control, common, Control, [ascii]
-U+001D B   Control: Control, common, Control, [ascii]
-U+001E B   Control: Control, common, Control, [ascii]
-U+001F S   Control: Control, common, Control, [ascii]
+U+0010 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0011 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0012 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0013 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0014 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0015 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0016 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0017 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0018 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0019 BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+001A BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+001B BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+001C B   Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+001D B   Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+001E B   Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+001F S   Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
 findprop 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 
-U+0020 WS  Separator: Space separator, common, Other, [ascii, graphemebase, patternwhitespace, whitespace]
-U+0021 ON  Punctuation: Other punctuation, common, Other, [ascii, graphemebase, patternsyntax, sentenceterminal, terminalpunctuation]
-U+0022 ON  Punctuation: Other punctuation, common, Other, [ascii, graphemebase, patternsyntax, quotationmark]
-U+0023 ET  Punctuation: Other punctuation, common, Other, [ascii, emoji, emojicomponent, graphemebase, patternsyntax]
-U+0024 ET  Symbol: Currency symbol, common, Other, [ascii, graphemebase, patternsyntax]
-U+0025 ET  Punctuation: Other punctuation, common, Other, [ascii, graphemebase, patternsyntax]
-U+0026 ON  Punctuation: Other punctuation, common, Other, [ascii, graphemebase, patternsyntax]
-U+0027 ON  Punctuation: Other punctuation, common, Other, [ascii, caseignorable, graphemebase, patternsyntax, quotationmark]
-U+0028 ON  Punctuation: Open punctuation, common, Other, [ascii, bidimirrored, graphemebase, patternsyntax]
-U+0029 ON  Punctuation: Close punctuation, common, Other, [ascii, bidimirrored, graphemebase, patternsyntax]
-U+002A ON  Punctuation: Other punctuation, common, Other, [ascii, emoji, emojicomponent, graphemebase, patternsyntax]
-U+002B ES  Symbol: Mathematical symbol, common, Other, [ascii, graphemebase, math, patternsyntax]
-U+002C CS  Punctuation: Other punctuation, common, Other, [ascii, graphemebase, patternsyntax, terminalpunctuation]
-U+002D ES  Punctuation: Dash punctuation, common, Other, [ascii, dash, graphemebase, patternsyntax]
-U+002E CS  Punctuation: Other punctuation, common, Other, [ascii, caseignorable, graphemebase, patternsyntax, sentenceterminal, terminalpunctuation]
-U+002F CS  Punctuation: Other punctuation, common, Other, [ascii, graphemebase, patternsyntax]
+U+0020 WS  Separator: Space separator, common, Other, [ascii, emoji, emojicomponent, graphemebase, patternsyntax]
+U+0021 ON  Punctuation: Other punctuation, common, Other, [ascii, caseignorable, graphemebase, patternsyntax, quotationmark]
+U+0022 ON  Punctuation: Other punctuation, common, Other, [ascii, graphemebase, math, patternsyntax]
+U+0023 ET  Punctuation: Other punctuation, common, Other, [ascii, dash, graphemebase, patternsyntax]
+U+0024 ET  Symbol: Currency symbol, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
+U+0025 ET  Punctuation: Other punctuation, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
+U+0026 ON  Punctuation: Other punctuation, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
+U+0027 ON  Punctuation: Other punctuation, common, Other, [ascii, bidimirrored, graphemebase, math, patternsyntax]
+U+0028 ON  Punctuation: Open punctuation, common, Other, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
+U+0029 ON  Punctuation: Close punctuation, common, Other, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
+U+002A ON  Punctuation: Other punctuation, common, Other, [ascii, dash, graphemebase, patternsyntax]
+U+002B ES  Symbol: Mathematical symbol, common, Other, [ascii, graphemebase, idcontinue, xidcontinue]
+U+002C CS  Punctuation: Other punctuation, common, Other, [ascii, asciihexdigit, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, hexdigit, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+002D ES  Punctuation: Dash punctuation, common, Other, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, softdotted, xidcontinue, xidstart]
+U+002E CS  Punctuation: Other punctuation, common, Other, [graphemebase, whitespace]
+U+002F CS  Punctuation: Other punctuation, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
 findprop 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f 
-U+0030 EN  Number: Decimal number, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
-U+0031 EN  Number: Decimal number, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
-U+0032 EN  Number: Decimal number, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
-U+0033 EN  Number: Decimal number, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
-U+0034 EN  Number: Decimal number, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
-U+0035 EN  Number: Decimal number, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
-U+0036 EN  Number: Decimal number, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
-U+0037 EN  Number: Decimal number, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
-U+0038 EN  Number: Decimal number, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
-U+0039 EN  Number: Decimal number, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
-U+003A CS  Punctuation: Other punctuation, common, Other, [ascii, caseignorable, graphemebase, patternsyntax, terminalpunctuation]
-U+003B ON  Punctuation: Other punctuation, common, Other, [ascii, graphemebase, patternsyntax, terminalpunctuation]
-U+003C ON  Symbol: Mathematical symbol, common, Other, [ascii, bidimirrored, graphemebase, math, patternsyntax]
-U+003D ON  Symbol: Mathematical symbol, common, Other, [ascii, graphemebase, math, patternsyntax]
-U+003E ON  Symbol: Mathematical symbol, common, Other, [ascii, bidimirrored, graphemebase, math, patternsyntax]
-U+003F ON  Punctuation: Other punctuation, common, Other, [ascii, graphemebase, patternsyntax, sentenceterminal, terminalpunctuation]
+U+0030 EN  Number: Decimal number, common, Other, [caseignorable, diacritic, graphemebase]
+U+0031 EN  Number: Decimal number, common, Other, [caseignorable, diacritic, graphemebase]
+U+0032 EN  Number: Decimal number, common, Other, [caseignorable, diacritic, graphemebase]
+U+0033 EN  Number: Decimal number, common, Other, [caseignorable, diacritic, graphemebase]
+U+0034 EN  Number: Decimal number, common, Other, [caseignorable, diacritic, graphemebase]
+U+0035 EN  Number: Decimal number, common, Other, [caseignorable, diacritic, graphemebase]
+U+0036 EN  Number: Decimal number, common, Other, [caseignorable, diacritic, graphemebase]
+U+0037 EN  Number: Decimal number, common, Other, [caseignorable, diacritic, graphemebase]
+U+0038 EN  Number: Decimal number, common, Other, [caseignorable, diacritic, graphemebase]
+U+0039 EN  Number: Decimal number, common, Other, [caseignorable, diacritic, graphemebase]
+U+003A CS  Punctuation: Other punctuation, common, Other, [alphabetic, cased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+003B ON  Punctuation: Other punctuation, common, Other, [ascii, asciihexdigit, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, hexdigit, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+003C ON  Symbol: Mathematical symbol, common, Other, [graphemebase, math, patternsyntax]
+U+003D ON  Symbol: Mathematical symbol, common, Other, [ascii, graphemebase, idcontinue, xidcontinue]
+U+003E ON  Symbol: Mathematical symbol, common, Other, [graphemebase, math, patternsyntax]
+U+003F ON  Punctuation: Other punctuation, common, Other, [ascii, caseignorable, graphemebase, patternsyntax, quotationmark]
 findprop 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 
-U+0040 ON  Punctuation: Other punctuation, common, Other, [ascii, graphemebase, patternsyntax]
-U+0041 L   Letter: Upper case letter, latin, Other, U+0061, [ascii, asciihexdigit, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, hexdigit, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0042 L   Letter: Upper case letter, latin, Other, U+0062, [ascii, asciihexdigit, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, hexdigit, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0043 L   Letter: Upper case letter, latin, Other, U+0063, [ascii, asciihexdigit, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, hexdigit, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0044 L   Letter: Upper case letter, latin, Other, U+0064, [ascii, asciihexdigit, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, hexdigit, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0045 L   Letter: Upper case letter, latin, Other, U+0065, [ascii, asciihexdigit, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, hexdigit, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0046 L   Letter: Upper case letter, latin, Other, U+0066, [ascii, asciihexdigit, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, hexdigit, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0047 L   Letter: Upper case letter, latin, Other, U+0067, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0048 L   Letter: Upper case letter, latin, Other, U+0068, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0049 L   Letter: Upper case letter, latin, Other, U+0069, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+004A L   Letter: Upper case letter, latin, Other, U+006A, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+004B L   Letter: Upper case letter, latin, Other, U+006B, U+212A, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+004C L   Letter: Upper case letter, latin, Other, U+006C, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+004D L   Letter: Upper case letter, latin, Other, U+006D, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+004E L   Letter: Upper case letter, latin, Other, U+006E, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+004F L   Letter: Upper case letter, latin, Other, U+006F, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
+U+0040 ON  Punctuation: Other punctuation, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
+U+0041 L   Letter: Upper case letter, latin, Other, U+0061, [graphemebase]
+U+0042 L   Letter: Upper case letter, latin, Other, U+0062, [graphemebase]
+U+0043 L   Letter: Upper case letter, latin, Other, U+0063, [graphemebase]
+U+0044 L   Letter: Upper case letter, latin, Other, U+0064, [graphemebase]
+U+0045 L   Letter: Upper case letter, latin, Other, U+0065, [graphemebase]
+U+0046 L   Letter: Upper case letter, latin, Other, U+0066, [graphemebase]
+U+0047 L   Letter: Upper case letter, latin, Other, U+0067, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+0048 L   Letter: Upper case letter, latin, Other, U+0068, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+0049 L   Letter: Upper case letter, latin, Other, U+0069, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+004A L   Letter: Upper case letter, latin, Other, U+006A, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+004B L   Letter: Upper case letter, latin, Other, U+006B, U+212A, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+004C L   Letter: Upper case letter, latin, Other, U+006C, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+004D L   Letter: Upper case letter, latin, Other, U+006D, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+004E L   Letter: Upper case letter, latin, Other, U+006E, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+004F L   Letter: Upper case letter, latin, Other, U+006F, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
 findprop 50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f 
-U+0050 L   Letter: Upper case letter, latin, Other, U+0070, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0051 L   Letter: Upper case letter, latin, Other, U+0071, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0052 L   Letter: Upper case letter, latin, Other, U+0072, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0053 L   Letter: Upper case letter, latin, Other, U+0073, U+017F, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0054 L   Letter: Upper case letter, latin, Other, U+0074, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0055 L   Letter: Upper case letter, latin, Other, U+0075, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0056 L   Letter: Upper case letter, latin, Other, U+0076, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0057 L   Letter: Upper case letter, latin, Other, U+0077, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0058 L   Letter: Upper case letter, latin, Other, U+0078, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0059 L   Letter: Upper case letter, latin, Other, U+0079, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+005A L   Letter: Upper case letter, latin, Other, U+007A, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+005B ON  Punctuation: Open punctuation, common, Other, [ascii, bidimirrored, graphemebase, patternsyntax]
-U+005C ON  Punctuation: Other punctuation, common, Other, [ascii, graphemebase, patternsyntax]
-U+005D ON  Punctuation: Close punctuation, common, Other, [ascii, bidimirrored, graphemebase, patternsyntax]
-U+005E ON  Symbol: Modifier symbol, common, Other, [ascii, caseignorable, diacritic, graphemebase, math, patternsyntax]
-U+005F ON  Punctuation: Connector punctuation, common, Other, [ascii, graphemebase, idcontinue, xidcontinue]
+U+0050 L   Letter: Upper case letter, latin, Other, U+0070, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+0051 L   Letter: Upper case letter, latin, Other, U+0071, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+0052 L   Letter: Upper case letter, latin, Other, U+0072, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+0053 L   Letter: Upper case letter, latin, Other, U+0073, U+017F, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+0054 L   Letter: Upper case letter, latin, Other, U+0074, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+0055 L   Letter: Upper case letter, latin, Other, U+0075, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+0056 L   Letter: Upper case letter, latin, Other, U+0076, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+0057 L   Letter: Upper case letter, latin, Other, U+0077, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+0058 L   Letter: Upper case letter, latin, Other, U+0078, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+0059 L   Letter: Upper case letter, latin, Other, U+0079, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+005A L   Letter: Upper case letter, latin, Other, U+007A, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
+U+005B ON  Punctuation: Open punctuation, common, Other, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
+U+005C ON  Punctuation: Other punctuation, common, Other, [ascii, asciihexdigit, emoji, emojicomponent, graphemebase, hexdigit, idcontinue, xidcontinue]
+U+005D ON  Punctuation: Close punctuation, common, Other, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
+U+005E ON  Symbol: Modifier symbol, common, Other, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+005F ON  Punctuation: Connector punctuation, common, Other, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, deprecated, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
 findprop 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 
-U+0060 ON  Symbol: Modifier symbol, common, Other, [ascii, caseignorable, diacritic, graphemebase, patternsyntax]
-U+0061 L   Letter: Lower case letter, latin, Other, U+0041, [ascii, asciihexdigit, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, hexdigit, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0062 L   Letter: Lower case letter, latin, Other, U+0042, [ascii, asciihexdigit, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, hexdigit, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0063 L   Letter: Lower case letter, latin, Other, U+0043, [ascii, asciihexdigit, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, hexdigit, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0064 L   Letter: Lower case letter, latin, Other, U+0044, [ascii, asciihexdigit, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, hexdigit, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0065 L   Letter: Lower case letter, latin, Other, U+0045, [ascii, asciihexdigit, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, hexdigit, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0066 L   Letter: Lower case letter, latin, Other, U+0046, [ascii, asciihexdigit, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, hexdigit, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0067 L   Letter: Lower case letter, latin, Other, U+0047, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0068 L   Letter: Lower case letter, latin, Other, U+0048, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0069 L   Letter: Lower case letter, latin, Other, U+0049, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, softdotted, xidcontinue, xidstart]
-U+006A L   Letter: Lower case letter, latin, Other, U+004A, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, softdotted, xidcontinue, xidstart]
-U+006B L   Letter: Lower case letter, latin, Other, U+004B, U+212A, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+006C L   Letter: Lower case letter, latin, Other, U+004C, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+006D L   Letter: Lower case letter, latin, Other, U+004D, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+006E L   Letter: Lower case letter, latin, Other, U+004E, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+006F L   Letter: Lower case letter, latin, Other, U+004F, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+0060 ON  Symbol: Modifier symbol, common, Other, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, changeswhentitlecased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
+U+0061 L   Letter: Lower case letter, latin, Other, U+0041, [alphabetic, caseignorable, cased, diacritic, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+0062 L   Letter: Lower case letter, latin, Other, U+0042, [alphabetic, caseignorable, cased, diacritic, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+0063 L   Letter: Lower case letter, latin, Other, U+0043, [alphabetic, caseignorable, cased, diacritic, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+0064 L   Letter: Lower case letter, latin, Other, U+0044, [alphabetic, caseignorable, cased, diacritic, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+0065 L   Letter: Lower case letter, latin, Other, U+0045, [alphabetic, caseignorable, cased, diacritic, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+0066 L   Letter: Lower case letter, latin, Other, U+0046, [alphabetic, caseignorable, cased, diacritic, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+0067 L   Letter: Lower case letter, latin, Other, U+0047, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+0068 L   Letter: Lower case letter, latin, Other, U+0048, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+0069 L   Letter: Lower case letter, latin, Other, U+0049, [caseignorable, diacritic, graphemeextend, idcontinue, xidcontinue]
+U+006A L   Letter: Lower case letter, latin, Other, U+004A, [caseignorable, diacritic, graphemeextend, idcontinue, xidcontinue]
+U+006B L   Letter: Lower case letter, latin, Other, U+004B, U+212A, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+006C L   Letter: Lower case letter, latin, Other, U+004C, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+006D L   Letter: Lower case letter, latin, Other, U+004D, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+006E L   Letter: Lower case letter, latin, Other, U+004E, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+006F L   Letter: Lower case letter, latin, Other, U+004F, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
 findprop 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f 
-U+0070 L   Letter: Lower case letter, latin, Other, U+0050, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0071 L   Letter: Lower case letter, latin, Other, U+0051, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0072 L   Letter: Lower case letter, latin, Other, U+0052, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0073 L   Letter: Lower case letter, latin, Other, U+0053, U+017F, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0074 L   Letter: Lower case letter, latin, Other, U+0054, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0075 L   Letter: Lower case letter, latin, Other, U+0055, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0076 L   Letter: Lower case letter, latin, Other, U+0056, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0077 L   Letter: Lower case letter, latin, Other, U+0057, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0078 L   Letter: Lower case letter, latin, Other, U+0058, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0079 L   Letter: Lower case letter, latin, Other, U+0059, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+007A L   Letter: Lower case letter, latin, Other, U+005A, [ascii, alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+007B ON  Punctuation: Open punctuation, common, Other, [ascii, bidimirrored, graphemebase, patternsyntax]
-U+007C ON  Symbol: Mathematical symbol, common, Other, [ascii, graphemebase, math, patternsyntax]
-U+007D ON  Punctuation: Close punctuation, common, Other, [ascii, bidimirrored, graphemebase, patternsyntax]
-U+007E ON  Symbol: Mathematical symbol, common, Other, [ascii, graphemebase, math, patternsyntax]
-U+007F BN  Control: Control, common, Control, [ascii]
+U+0070 L   Letter: Lower case letter, latin, Other, U+0050, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+0071 L   Letter: Lower case letter, latin, Other, U+0051, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+0072 L   Letter: Lower case letter, latin, Other, U+0052, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+0073 L   Letter: Lower case letter, latin, Other, U+0053, U+017F, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+0074 L   Letter: Lower case letter, latin, Other, U+0054, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+0075 L   Letter: Lower case letter, latin, Other, U+0055, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+0076 L   Letter: Lower case letter, latin, Other, U+0056, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+0077 L   Letter: Lower case letter, latin, Other, U+0057, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+0078 L   Letter: Lower case letter, latin, Other, U+0058, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+0079 L   Letter: Lower case letter, latin, Other, U+0059, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+007A L   Letter: Lower case letter, latin, Other, U+005A, [alphabetic, caseignorable, diacritic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+007B ON  Punctuation: Open punctuation, common, Other, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
+U+007C ON  Symbol: Mathematical symbol, common, Other, [ascii, graphemebase, idcontinue, xidcontinue]
+U+007D ON  Punctuation: Close punctuation, common, Other, [ascii, alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
+U+007E ON  Symbol: Mathematical symbol, common, Other, [ascii, graphemebase, idcontinue, xidcontinue]
+U+007F BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
 
 findprop 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 
 U+0080 BN  Control: Control, common, Control
 U+0081 BN  Control: Control, common, Control
 U+0082 BN  Control: Control, common, Control
 U+0083 BN  Control: Control, common, Control
 U+0084 BN  Control: Control, common, Control
-U+0085 B   Control: Control, common, Control, [patternwhitespace, whitespace]
+U+0085 B   Control: Control, common, Control, [caseignorable, defaultignorablecodepoint, graphemeextend, idcontinue, xidcontinue]
 U+0086 BN  Control: Control, common, Control
 U+0087 BN  Control: Control, common, Control
 U+0088 BN  Control: Control, common, Control
 U+0089 BN  Control: Control, common, Control
 U+008A BN  Control: Control, common, Control
 U+008B BN  Control: Control, common, Control
 U+008C BN  Control: Control, common, Control
@@ -166,244 +166,244 @@
 U+009A BN  Control: Control, common, Control
 U+009B BN  Control: Control, common, Control
 U+009C BN  Control: Control, common, Control
 U+009D BN  Control: Control, common, Control
 U+009E BN  Control: Control, common, Control
 U+009F BN  Control: Control, common, Control
 findprop a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af 
-U+00A0 CS  Separator: Space separator, common, Other, [graphemebase, whitespace]
-U+00A1 ON  Punctuation: Other punctuation, common, Other, [graphemebase, patternsyntax]
-U+00A2 ET  Symbol: Currency symbol, common, Other, [graphemebase, patternsyntax]
-U+00A3 ET  Symbol: Currency symbol, common, Other, [graphemebase, patternsyntax]
-U+00A4 ET  Symbol: Currency symbol, common, Other, [graphemebase, patternsyntax]
-U+00A5 ET  Symbol: Currency symbol, common, Other, [graphemebase, patternsyntax]
-U+00A6 ON  Symbol: Other symbol, common, Other, [graphemebase, patternsyntax]
-U+00A7 ON  Punctuation: Other punctuation, common, Other, [graphemebase, patternsyntax]
-U+00A8 ON  Symbol: Modifier symbol, common, Other, [caseignorable, diacritic, graphemebase]
-U+00A9 ON  Symbol: Other symbol, common, Extended Pictographic, [emoji, extendedpictographic, graphemebase, patternsyntax]
-U+00AA L   Letter: Other letter, latin, Other, [alphabetic, cased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00AB ON  Punctuation: Initial punctuation, common, Other, [bidimirrored, graphemebase, patternsyntax, quotationmark]
-U+00AC ON  Symbol: Mathematical symbol, common, Other, [graphemebase, math, patternsyntax]
-U+00AD BN  Control: Format, common, Control, [caseignorable, defaultignorablecodepoint]
-U+00AE ON  Symbol: Other symbol, common, Extended Pictographic, [emoji, extendedpictographic, graphemebase, patternsyntax]
-U+00AF ON  Symbol: Modifier symbol, common, Other, [caseignorable, diacritic, graphemebase]
+U+00A0 CS  Separator: Space separator, common, Other, [alphabetic, caseignorable, cased, diacritic, graphemebase, idcontinue, idstart, lowercase]
+U+00A1 ON  Punctuation: Other punctuation, common, Other, [caseignorable, graphemebase, idcontinue, terminalpunctuation, xidcontinue]
+U+00A2 ET  Symbol: Currency symbol, common, Other, [caseignorable, graphemebase, idcontinue, terminalpunctuation, xidcontinue]
+U+00A3 ET  Symbol: Currency symbol, common, Other, [caseignorable, graphemebase, idcontinue, terminalpunctuation, xidcontinue]
+U+00A4 ET  Symbol: Currency symbol, common, Other, [caseignorable, graphemebase, idcontinue, terminalpunctuation, xidcontinue]
+U+00A5 ET  Symbol: Currency symbol, common, Other, [caseignorable, graphemebase, idcontinue, terminalpunctuation, xidcontinue]
+U+00A6 ON  Symbol: Other symbol, common, Other, [caseignorable, graphemebase, idcontinue, terminalpunctuation, xidcontinue]
+U+00A7 ON  Punctuation: Other punctuation, common, Other, [caseignorable, graphemebase, idcontinue, terminalpunctuation, xidcontinue]
+U+00A8 ON  Symbol: Modifier symbol, common, Other, [alphabetic, cased, graphemebase, idcontinue, idstart, math, uppercase, xidcontinue, xidstart]
+U+00A9 ON  Symbol: Other symbol, common, Extended Pictographic, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, math, uppercase, xidcontinue, xidstart]
+U+00AA L   Letter: Other letter, latin, Other, [caseignorable, graphemeextend]
+U+00AB ON  Punctuation: Initial punctuation, common, Other, [graphemebase, sentenceterminal, terminalpunctuation]
+U+00AC ON  Symbol: Mathematical symbol, common, Other, [alphabetic, caseignorable, diacritic, graphemeextend, idcontinue, xidcontinue]
+U+00AD BN  Control: Format, common, Control, [caseignorable, prependedconcatenationmark]
+U+00AE ON  Symbol: Other symbol, common, Extended Pictographic, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, math, uppercase, xidcontinue, xidstart]
+U+00AF ON  Symbol: Modifier symbol, common, Other, [alphabetic, cased, graphemebase, idcontinue, idstart, math, uppercase, xidcontinue, xidstart]
 findprop b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf 
-U+00B0 ET  Symbol: Other symbol, common, Other, [graphemebase, patternsyntax]
-U+00B1 ET  Symbol: Mathematical symbol, common, Other, [graphemebase, math, patternsyntax]
-U+00B2 EN  Number: Other number, common, Other, [graphemebase]
-U+00B3 EN  Number: Other number, common, Other, [graphemebase]
-U+00B4 ON  Symbol: Modifier symbol, common, Other, [caseignorable, diacritic, graphemebase]
-U+00B5 L   Letter: Lower case letter, common, Other, U+03BC, U+039C, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00B6 ON  Punctuation: Other punctuation, common, Other, [graphemebase, patternsyntax]
-U+00B7 ON  Punctuation: Other punctuation, common, Other, [caseignorable, diacritic, extender, graphemebase, idcontinue, xidcontinue]
-U+00B8 ON  Symbol: Modifier symbol, common, Other, [caseignorable, diacritic, graphemebase]
-U+00B9 EN  Number: Other number, common, Other, [graphemebase]
-U+00BA L   Letter: Other letter, latin, Other, [alphabetic, cased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00BB ON  Punctuation: Final punctuation, common, Other, [bidimirrored, graphemebase, patternsyntax, quotationmark]
-U+00BC ON  Number: Other number, common, Other, [graphemebase]
-U+00BD ON  Number: Other number, common, Other, [graphemebase]
-U+00BE ON  Number: Other number, common, Other, [graphemebase]
-U+00BF ON  Punctuation: Other punctuation, common, Other, [graphemebase, patternsyntax]
+U+00B0 ET  Symbol: Other symbol, common, Other, [caseignorable, graphemebase, idcontinue, terminalpunctuation, xidcontinue]
+U+00B1 ET  Symbol: Mathematical symbol, common, Other, [alphabetic, caseignorable, diacritic, graphemeextend, idcontinue, xidcontinue]
+U+00B2 EN  Number: Other number, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+00B3 EN  Number: Other number, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+00B4 ON  Symbol: Modifier symbol, common, Other, [alphabetic, cased, graphemebase, idcontinue, idstart, math, uppercase, xidcontinue, xidstart]
+U+00B5 L   Letter: Lower case letter, common, Other, U+03BC, U+039C, [alphabetic, deprecated, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+00B6 ON  Punctuation: Other punctuation, common, Other, [caseignorable, graphemebase, idcontinue, terminalpunctuation, xidcontinue]
+U+00B7 ON  Punctuation: Other punctuation, common, Other, [alphabetic, graphemebase, idcontinue, xidcontinue]
+U+00B8 ON  Symbol: Modifier symbol, common, Other, [alphabetic, cased, graphemebase, idcontinue, idstart, math, uppercase, xidcontinue, xidstart]
+U+00B9 EN  Number: Other number, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+00BA L   Letter: Other letter, latin, Other, [caseignorable, graphemeextend]
+U+00BB ON  Punctuation: Final punctuation, common, Other, [graphemebase, sentenceterminal, terminalpunctuation]
+U+00BC ON  Number: Other number, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+00BD ON  Number: Other number, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+00BE ON  Number: Other number, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+00BF ON  Punctuation: Other punctuation, common, Other, [caseignorable, graphemebase, idcontinue, terminalpunctuation, xidcontinue]
 findprop c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce cf 
-U+00C0 L   Letter: Upper case letter, latin, Other, U+00E0, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00C1 L   Letter: Upper case letter, latin, Other, U+00E1, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00C2 L   Letter: Upper case letter, latin, Other, U+00E2, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00C3 L   Letter: Upper case letter, latin, Other, U+00E3, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00C4 L   Letter: Upper case letter, latin, Other, U+00E4, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00C5 L   Letter: Upper case letter, latin, Other, U+00E5, U+212B, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00C6 L   Letter: Upper case letter, latin, Other, U+00E6, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00C7 L   Letter: Upper case letter, latin, Other, U+00E7, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00C8 L   Letter: Upper case letter, latin, Other, U+00E8, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00C9 L   Letter: Upper case letter, latin, Other, U+00E9, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00CA L   Letter: Upper case letter, latin, Other, U+00EA, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00CB L   Letter: Upper case letter, latin, Other, U+00EB, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00CC L   Letter: Upper case letter, latin, Other, U+00EC, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00CD L   Letter: Upper case letter, latin, Other, U+00ED, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00CE L   Letter: Upper case letter, latin, Other, U+00EE, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00CF L   Letter: Upper case letter, latin, Other, U+00EF, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
+U+00C0 L   Letter: Upper case letter, latin, Other, U+00E0, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00C1 L   Letter: Upper case letter, latin, Other, U+00E1, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00C2 L   Letter: Upper case letter, latin, Other, U+00E2, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00C3 L   Letter: Upper case letter, latin, Other, U+00E3, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00C4 L   Letter: Upper case letter, latin, Other, U+00E4, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00C5 L   Letter: Upper case letter, latin, Other, U+00E5, U+212B, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00C6 L   Letter: Upper case letter, latin, Other, U+00E6, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00C7 L   Letter: Upper case letter, latin, Other, U+00E7, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00C8 L   Letter: Upper case letter, latin, Other, U+00E8, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00C9 L   Letter: Upper case letter, latin, Other, U+00E9, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00CA L   Letter: Upper case letter, latin, Other, U+00EA, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00CB L   Letter: Upper case letter, latin, Other, U+00EB, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00CC L   Letter: Upper case letter, latin, Other, U+00EC, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00CD L   Letter: Upper case letter, latin, Other, U+00ED, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00CE L   Letter: Upper case letter, latin, Other, U+00EE, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00CF L   Letter: Upper case letter, latin, Other, U+00EF, [alphabetic, graphemeextend, idcontinue, xidcontinue]
 findprop d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df 
-U+00D0 L   Letter: Upper case letter, latin, Other, U+00F0, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00D1 L   Letter: Upper case letter, latin, Other, U+00F1, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00D2 L   Letter: Upper case letter, latin, Other, U+00F2, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00D3 L   Letter: Upper case letter, latin, Other, U+00F3, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00D4 L   Letter: Upper case letter, latin, Other, U+00F4, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00D5 L   Letter: Upper case letter, latin, Other, U+00F5, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00D6 L   Letter: Upper case letter, latin, Other, U+00F6, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00D7 ON  Symbol: Mathematical symbol, common, Other, [graphemebase, math, patternsyntax]
-U+00D8 L   Letter: Upper case letter, latin, Other, U+00F8, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00D9 L   Letter: Upper case letter, latin, Other, U+00F9, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00DA L   Letter: Upper case letter, latin, Other, U+00FA, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00DB L   Letter: Upper case letter, latin, Other, U+00FB, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00DC L   Letter: Upper case letter, latin, Other, U+00FC, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00DD L   Letter: Upper case letter, latin, Other, U+00FD, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00DE L   Letter: Upper case letter, latin, Other, U+00FE, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+00DF L   Letter: Lower case letter, latin, Other, U+1E9E, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+00D0 L   Letter: Upper case letter, latin, Other, U+00F0, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00D1 L   Letter: Upper case letter, latin, Other, U+00F1, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00D2 L   Letter: Upper case letter, latin, Other, U+00F2, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00D3 L   Letter: Upper case letter, latin, Other, U+00F3, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00D4 L   Letter: Upper case letter, latin, Other, U+00F4, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00D5 L   Letter: Upper case letter, latin, Other, U+00F5, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00D6 L   Letter: Upper case letter, latin, Other, U+00F6, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00D7 ON  Symbol: Mathematical symbol, common, Other, [alphabetic, caseignorable, diacritic, graphemeextend, idcontinue, xidcontinue]
+U+00D8 L   Letter: Upper case letter, latin, Other, U+00F8, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00D9 L   Letter: Upper case letter, latin, Other, U+00F9, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00DA L   Letter: Upper case letter, latin, Other, U+00FA, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00DB L   Letter: Upper case letter, latin, Other, U+00FB, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00DC L   Letter: Upper case letter, latin, Other, U+00FC, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00DD L   Letter: Upper case letter, latin, Other, U+00FD, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00DE L   Letter: Upper case letter, latin, Other, U+00FE, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+00DF L   Letter: Lower case letter, latin, Other, U+1E9E, [alphabetic, deprecated, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
 findprop e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef 
-U+00E0 L   Letter: Lower case letter, latin, Other, U+00C0, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00E1 L   Letter: Lower case letter, latin, Other, U+00C1, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00E2 L   Letter: Lower case letter, latin, Other, U+00C2, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00E3 L   Letter: Lower case letter, latin, Other, U+00C3, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00E4 L   Letter: Lower case letter, latin, Other, U+00C4, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00E5 L   Letter: Lower case letter, latin, Other, U+00C5, U+212B, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00E6 L   Letter: Lower case letter, latin, Other, U+00C6, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00E7 L   Letter: Lower case letter, latin, Other, U+00C7, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00E8 L   Letter: Lower case letter, latin, Other, U+00C8, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00E9 L   Letter: Lower case letter, latin, Other, U+00C9, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00EA L   Letter: Lower case letter, latin, Other, U+00CA, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00EB L   Letter: Lower case letter, latin, Other, U+00CB, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00EC L   Letter: Lower case letter, latin, Other, U+00CC, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00ED L   Letter: Lower case letter, latin, Other, U+00CD, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00EE L   Letter: Lower case letter, latin, Other, U+00CE, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00EF L   Letter: Lower case letter, latin, Other, U+00CF, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+00E0 L   Letter: Lower case letter, latin, Other, U+00C0, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00E1 L   Letter: Lower case letter, latin, Other, U+00C1, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00E2 L   Letter: Lower case letter, latin, Other, U+00C2, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00E3 L   Letter: Lower case letter, latin, Other, U+00C3, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00E4 L   Letter: Lower case letter, latin, Other, U+00C4, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00E5 L   Letter: Lower case letter, latin, Other, U+00C5, U+212B, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00E6 L   Letter: Lower case letter, latin, Other, U+00C6, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00E7 L   Letter: Lower case letter, latin, Other, U+00C7, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00E8 L   Letter: Lower case letter, latin, Other, U+00C8, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00E9 L   Letter: Lower case letter, latin, Other, U+00C9, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00EA L   Letter: Lower case letter, latin, Other, U+00CA, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00EB L   Letter: Lower case letter, latin, Other, U+00CB, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00EC L   Letter: Lower case letter, latin, Other, U+00CC, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00ED L   Letter: Lower case letter, latin, Other, U+00CD, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00EE L   Letter: Lower case letter, latin, Other, U+00CE, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00EF L   Letter: Lower case letter, latin, Other, U+00CF, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
 findprop f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff 
-U+00F0 L   Letter: Lower case letter, latin, Other, U+00D0, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00F1 L   Letter: Lower case letter, latin, Other, U+00D1, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00F2 L   Letter: Lower case letter, latin, Other, U+00D2, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00F3 L   Letter: Lower case letter, latin, Other, U+00D3, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00F4 L   Letter: Lower case letter, latin, Other, U+00D4, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00F5 L   Letter: Lower case letter, latin, Other, U+00D5, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00F6 L   Letter: Lower case letter, latin, Other, U+00D6, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00F7 ON  Symbol: Mathematical symbol, common, Other, [graphemebase, math, patternsyntax]
-U+00F8 L   Letter: Lower case letter, latin, Other, U+00D8, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00F9 L   Letter: Lower case letter, latin, Other, U+00D9, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00FA L   Letter: Lower case letter, latin, Other, U+00DA, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00FB L   Letter: Lower case letter, latin, Other, U+00DB, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00FC L   Letter: Lower case letter, latin, Other, U+00DC, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00FD L   Letter: Lower case letter, latin, Other, U+00DD, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00FE L   Letter: Lower case letter, latin, Other, U+00DE, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+00FF L   Letter: Lower case letter, latin, Other, U+0178, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
+U+00F0 L   Letter: Lower case letter, latin, Other, U+00D0, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00F1 L   Letter: Lower case letter, latin, Other, U+00D1, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00F2 L   Letter: Lower case letter, latin, Other, U+00D2, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00F3 L   Letter: Lower case letter, latin, Other, U+00D3, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00F4 L   Letter: Lower case letter, latin, Other, U+00D4, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00F5 L   Letter: Lower case letter, latin, Other, U+00D5, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00F6 L   Letter: Lower case letter, latin, Other, U+00D6, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00F7 ON  Symbol: Mathematical symbol, common, Other, [alphabetic, caseignorable, diacritic, graphemeextend, idcontinue, xidcontinue]
+U+00F8 L   Letter: Lower case letter, latin, Other, U+00D8, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00F9 L   Letter: Lower case letter, latin, Other, U+00D9, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00FA L   Letter: Lower case letter, latin, Other, U+00DA, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00FB L   Letter: Lower case letter, latin, Other, U+00DB, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00FC L   Letter: Lower case letter, latin, Other, U+00DC, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00FD L   Letter: Lower case letter, latin, Other, U+00DD, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00FE L   Letter: Lower case letter, latin, Other, U+00DE, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+00FF L   Letter: Lower case letter, latin, Other, U+0178, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
 
 findprop 0100 0101 0102 0103 0104 0105 0106
-U+0100 L   Letter: Upper case letter, latin, Other, U+0101, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0101 L   Letter: Lower case letter, latin, Other, U+0100, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0102 L   Letter: Upper case letter, latin, Other, U+0103, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0103 L   Letter: Lower case letter, latin, Other, U+0102, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0104 L   Letter: Upper case letter, latin, Other, U+0105, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+0105 L   Letter: Lower case letter, latin, Other, U+0104, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+0106 L   Letter: Upper case letter, latin, Other, U+0107, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
+U+0100 L   Letter: Upper case letter, latin, Other, U+0101, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+0101 L   Letter: Lower case letter, latin, Other, U+0100, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+0102 L   Letter: Upper case letter, latin, Other, U+0103, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+0103 L   Letter: Lower case letter, latin, Other, U+0102, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+0104 L   Letter: Upper case letter, latin, Other, U+0105, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+0105 L   Letter: Lower case letter, latin, Other, U+0104, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+0106 L   Letter: Upper case letter, latin, Other, U+0107, [alphabetic, graphemeextend, idcontinue, xidcontinue]
 
 findprop ffe0 ffe1 ffe2 ffe3 ffe4 ffe5 ffe6 ffe7 
-U+FFE0 ET  Symbol: Currency symbol, common, Other, [graphemebase]
-U+FFE1 ET  Symbol: Currency symbol, common, Other, [graphemebase]
-U+FFE2 ON  Symbol: Mathematical symbol, common, Other, [graphemebase, math]
-U+FFE3 ON  Symbol: Modifier symbol, common, Other, [caseignorable, diacritic, graphemebase]
-U+FFE4 ON  Symbol: Other symbol, common, Other, [graphemebase]
-U+FFE5 ET  Symbol: Currency symbol, common, Other, [graphemebase]
-U+FFE6 ET  Symbol: Currency symbol, common, Other, [graphemebase]
+U+FFE0 ET  Symbol: Currency symbol, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+FFE1 ET  Symbol: Currency symbol, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+FFE2 ON  Symbol: Mathematical symbol, common, Other, [emoji, extendedpictographic, graphemebase]
+U+FFE3 ON  Symbol: Modifier symbol, common, Other, [alphabetic, cased, graphemebase, idcontinue, idstart, math, uppercase, xidcontinue, xidstart]
+U+FFE4 ON  Symbol: Other symbol, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+FFE5 ET  Symbol: Currency symbol, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+FFE6 ET  Symbol: Currency symbol, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
 U+FFE7 L   Control: Unassigned, unknown, Other
 findprop ffe8 ffe9 ffea ffeb ffec ffed ffee ffef
-U+FFE8 ON  Symbol: Other symbol, common, Other, [graphemebase]
-U+FFE9 ON  Symbol: Mathematical symbol, common, Other, [graphemebase, math]
-U+FFEA ON  Symbol: Mathematical symbol, common, Other, [graphemebase, math]
-U+FFEB ON  Symbol: Mathematical symbol, common, Other, [graphemebase, math]
-U+FFEC ON  Symbol: Mathematical symbol, common, Other, [graphemebase, math]
-U+FFED ON  Symbol: Other symbol, common, Other, [graphemebase]
-U+FFEE ON  Symbol: Other symbol, common, Other, [graphemebase]
+U+FFE8 ON  Symbol: Other symbol, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+FFE9 ON  Symbol: Mathematical symbol, common, Other, [emoji, extendedpictographic, graphemebase]
+U+FFEA ON  Symbol: Mathematical symbol, common, Other, [emoji, extendedpictographic, graphemebase]
+U+FFEB ON  Symbol: Mathematical symbol, common, Other, [emoji, extendedpictographic, graphemebase]
+U+FFEC ON  Symbol: Mathematical symbol, common, Other, [emoji, extendedpictographic, graphemebase]
+U+FFED ON  Symbol: Other symbol, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+FFEE ON  Symbol: Other symbol, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
 U+FFEF L   Control: Unassigned, unknown, Other
 findprop fff8 fff9 fffa fffb fffc fffd fffe ffff
-U+FFF8 BN  Control: Unassigned, unknown, Control, [defaultignorablecodepoint]
-U+FFF9 ON  Control: Format, common, Control, [caseignorable]
-U+FFFA ON  Control: Format, common, Control, [caseignorable]
-U+FFFB ON  Control: Format, common, Control, [caseignorable]
-U+FFFC ON  Symbol: Other symbol, common, Other, [graphemebase]
-U+FFFD ON  Symbol: Other symbol, common, Other, [graphemebase]
-U+FFFE BN  Control: Unassigned, unknown, Other, [noncharactercodepoint]
-U+FFFF BN  Control: Unassigned, unknown, Other, [noncharactercodepoint]
+U+FFF8 BN  Control: Unassigned, unknown, Control, [dash, defaultignorablecodepoint, deprecated, extendedpictographic, joincontrol, lowercase, patternwhitespace, quotationmark, sentenceterminal, softdotted, xidcontinue, xidstart]
+U+FFF9 ON  Control: Format, common, Control, [changeswhenuppercased, deprecated, emojimodifier, emojipresentation, extender, sentenceterminal, xidcontinue, xidstart]
+U+FFFA ON  Control: Format, common, Control, [changeswhenuppercased, deprecated, emojimodifier, emojipresentation, extender, sentenceterminal, xidcontinue, xidstart]
+U+FFFB ON  Control: Format, common, Control, [changeswhenuppercased, deprecated, emojimodifier, emojipresentation, extender, sentenceterminal, xidcontinue, xidstart]
+U+FFFC ON  Symbol: Other symbol, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+FFFD ON  Symbol: Other symbol, common, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+FFFE BN  Control: Unassigned, unknown, Other, [changeswhenuppercased, deprecated, emojicomponent, emojimodifierbase, extender, quotationmark, sentenceterminal, xidcontinue, xidstart]
+U+FFFF BN  Control: Unassigned, unknown, Other, [changeswhenuppercased, deprecated, emojicomponent, emojimodifierbase, extender, quotationmark, sentenceterminal, xidcontinue, xidstart]
 findprop 10000 10001 e01ef f0000 100000
-U+10000 L   Letter: Other letter, linearb, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+10001 L   Letter: Other letter, linearb, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+E01EF NSM Mark: Non-spacing mark, inherited, Extend, [caseignorable, defaultignorablecodepoint, graphemeextend, idcontinue, variationselector, xidcontinue]
+U+10000 L   Letter: Other letter, linearb, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+10001 L   Letter: Other letter, linearb, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+E01EF NSM Mark: Non-spacing mark, inherited, Extend, []
 U+F0000 L   Control: Private use, unknown, Other
 U+100000 L   Control: Private use, unknown, Other
 
 findprop 1b00 12000 7c0 a840 10900
-U+1B00 NSM Mark: Non-spacing mark, balinese, Extend, [alphabetic, caseignorable, graphemeextend, idcontinue, xidcontinue]
-U+12000 L   Letter: Other letter, cuneiform, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+07C0 R   Number: Decimal number, nko, Other, [graphemebase, idcontinue, xidcontinue]
-U+A840 L   Letter: Other letter, phagspa, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+10900 R   Letter: Other letter, phoenician, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+1B00 NSM Mark: Non-spacing mark, balinese, Extend, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, uppercase]
+U+12000 L   Letter: Other letter, cuneiform, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+07C0 R   Number: Decimal number, nko, Other, [graphemebase, patternsyntax, terminalpunctuation]
+U+A840 L   Letter: Other letter, phagspa, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+10900 R   Letter: Other letter, phoenician, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
 findprop 1d79 a77d
-U+1D79 L   Letter: Lower case letter, latin, Other, U+A77D, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, idcontinue, idstart, lowercase, xidcontinue, xidstart]
-U+A77D L   Letter: Upper case letter, latin, Other, U+1D79, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
+U+1D79 L   Letter: Lower case letter, latin, Other, U+A77D, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue]
+U+A77D L   Letter: Upper case letter, latin, Other, U+1D79, [alphabetic, graphemeextend, idcontinue, xidcontinue]
 
 findprop  0800  083e  a4d0  a4f7  aa80  aadf
-U+0800 R   Letter: Other letter, samaritan, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+083E R   Punctuation: Other punctuation, samaritan, Other, [graphemebase, sentenceterminal, terminalpunctuation]
-U+A4D0 L   Letter: Other letter, lisu, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+A4F7 L   Letter: Other letter, lisu, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+AA80 L   Letter: Other letter, taiviet, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+AADF L   Punctuation: Other punctuation, taiviet, Other, [graphemebase, terminalpunctuation]
+U+0800 R   Letter: Other letter, samaritan, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+083E R   Punctuation: Other punctuation, samaritan, Other, [bidimirrored, graphemebase, math, patternsyntax]
+U+A4D0 L   Letter: Other letter, lisu, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+A4F7 L   Letter: Other letter, lisu, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+AA80 L   Letter: Other letter, taiviet, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+AADF L   Punctuation: Other punctuation, taiviet, Other, [graphemebase, patternsyntax, sentenceterminal, terminalpunctuation]
 findprop 10b00 10b35 13000 1342e 10840 10855
-U+10B00 R   Letter: Other letter, avestan, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+10B35 R   Letter: Other letter, avestan, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+13000 L   Letter: Other letter, egyptianhieroglyphs, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+1342E L   Letter: Other letter, egyptianhieroglyphs, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+10840 R   Letter: Other letter, imperialaramaic, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+10855 R   Letter: Other letter, imperialaramaic, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+10B00 R   Letter: Other letter, avestan, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+10B35 R   Letter: Other letter, avestan, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+13000 L   Letter: Other letter, egyptianhieroglyphs, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+1342E L   Letter: Other letter, egyptianhieroglyphs, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+10840 R   Letter: Other letter, imperialaramaic, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+10855 R   Letter: Other letter, imperialaramaic, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
 
 findprop 11100 1113c 11680 116c0
-U+11100 NSM Mark: Non-spacing mark, chakma, Extend, [alphabetic, caseignorable, graphemeextend, idcontinue, xidcontinue]
-U+1113C L   Number: Decimal number, chakma, Other, [graphemebase, idcontinue, xidcontinue]
-U+11680 L   Letter: Other letter, takri, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+116C0 L   Number: Decimal number, takri, Other, [graphemebase, idcontinue, xidcontinue]
+U+11100 NSM Mark: Non-spacing mark, chakma, Extend, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, uppercase]
+U+1113C L   Number: Decimal number, chakma, Other, [graphemebase, patternsyntax, terminalpunctuation]
+U+11680 L   Letter: Other letter, takri, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+116C0 L   Number: Decimal number, takri, Other, [graphemebase, patternsyntax, terminalpunctuation]
 
 findprop 0d 0a 0e 0711 1b04 1111 1169 11fe ae4c ad89
-U+000D B   Control: Control, common, CR, [ascii, patternwhitespace, whitespace]
-U+000A B   Control: Control, common, LF, [ascii, patternwhitespace, whitespace]
-U+000E BN  Control: Control, common, Control, [ascii]
-U+0711 NSM Mark: Non-spacing mark, syriac, Extend, [alphabetic, caseignorable, graphemeextend, idcontinue, xidcontinue]
-U+1B04 L   Mark: Spacing mark, balinese, SpacingMark, [alphabetic, graphemebase, idcontinue, xidcontinue]
-U+1111 L   Letter: Other letter, hangul, Hangul syllable type L, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+1169 L   Letter: Other letter, hangul, Hangul syllable type V, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+11FE L   Letter: Other letter, hangul, Hangul syllable type T, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+AE4C L   Letter: Other letter, hangul, Hangul syllable type LV, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+AD89 L   Letter: Other letter, hangul, Hangul syllable type LVT, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+000D B   Control: Control, common, CR, [ascii, graphemebase, patternsyntax, sentenceterminal, terminalpunctuation]
+U+000A B   Control: Control, common, LF, [ascii, graphemebase, patternsyntax, sentenceterminal, terminalpunctuation]
+U+000E BN  Control: Control, common, Control, [ascii, patternwhitespace, whitespace]
+U+0711 NSM Mark: Non-spacing mark, syriac, Extend, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, uppercase]
+U+1B04 L   Mark: Spacing mark, balinese, SpacingMark, [dash, emoji, extendedpictographic, graphemebase, patternsyntax]
+U+1111 L   Letter: Other letter, hangul, Hangul syllable type L, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+1169 L   Letter: Other letter, hangul, Hangul syllable type V, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+11FE L   Letter: Other letter, hangul, Hangul syllable type T, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+AE4C L   Letter: Other letter, hangul, Hangul syllable type LV, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+AD89 L   Letter: Other letter, hangul, Hangul syllable type LVT, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
 
 findprop 118a0 11ac7 16ad0
-U+118A0 L   Letter: Upper case letter, warangciti, Other, U+118C0, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+11AC7 L   Letter: Other letter, paucinhau, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+16AD0 L   Letter: Other letter, bassavah, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+118A0 L   Letter: Upper case letter, warangciti, Other, U+118C0, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+11AC7 L   Letter: Other letter, paucinhau, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+16AD0 L   Letter: Other letter, bassavah, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
 
 findprop 11700 14400 108e0 11280 1d800
-U+11700 L   Letter: Other letter, ahom, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+14400 L   Letter: Other letter, anatolianhieroglyphs, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+108E0 R   Letter: Other letter, hatran, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+11280 L   Letter: Other letter, multani, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+1D800 L   Symbol: Other symbol, signwriting, Other, [graphemebase]
+U+11700 L   Letter: Other letter, ahom, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+14400 L   Letter: Other letter, anatolianhieroglyphs, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+108E0 R   Letter: Other letter, hatran, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+11280 L   Letter: Other letter, multani, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+1D800 L   Symbol: Other symbol, signwriting, Other, [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
 
 findprop 11800 1e903 11da9 10d27 11ee0 16e48 10f27 10f30
-U+11800 L   Letter: Other letter, dogra, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+1E903 R   Letter: Upper case letter, adlam, Other, U+1E925, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+11DA9 L   Number: Decimal number, gunjalagondi, Other, [graphemebase, idcontinue, xidcontinue]
-U+10D27 NSM Mark: Non-spacing mark, hanifirohingya, Extend, [alphabetic, caseignorable, diacritic, graphemeextend, idcontinue, xidcontinue]
-U+11EE0 L   Letter: Other letter, makasar, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+16E48 L   Letter: Upper case letter, medefaidrin, Other, U+16E68, [alphabetic, cased, changeswhencasefolded, changeswhencasemapped, changeswhenlowercased, graphemebase, idcontinue, idstart, uppercase, xidcontinue, xidstart]
-U+10F27 R   Letter: Other letter, oldsogdian, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
-U+10F30 AL  Letter: Other letter, sogdian, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+11800 L   Letter: Other letter, dogra, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+1E903 R   Letter: Upper case letter, adlam, Other, U+1E925, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+11DA9 L   Number: Decimal number, gunjalagondi, Other, [graphemebase, patternsyntax, terminalpunctuation]
+U+10D27 NSM Mark: Non-spacing mark, hanifirohingya, Extend, [extendedpictographic, graphemebase, patternsyntax]
+U+11EE0 L   Letter: Other letter, makasar, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+16E48 L   Letter: Upper case letter, medefaidrin, Other, U+16E68, [alphabetic, graphemeextend, idcontinue, xidcontinue]
+U+10F27 R   Letter: Other letter, oldsogdian, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
+U+10F30 AL  Letter: Other letter, sogdian, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
 
 findprop  a836  a833  1cf4  20f0  1cd0
-U+A836 L   Symbol: Other symbol, common, Other, [devanagari, gurmukhi, gujarati, kaithi, takri, khojki, mahajani, modi, khudawadi, tirhuta, dogra], [graphemebase]
-U+A833 L   Number: Other number, common, Other, [devanagari, gurmukhi, gujarati, kannada, kaithi, takri, khojki, mahajani, modi, khudawadi, tirhuta, dogra, nandinagari], [graphemebase]
-U+1CF4 NSM Mark: Non-spacing mark, inherited, Extend, [devanagari, kannada, grantha], [caseignorable, diacritic, graphemeextend, idcontinue, xidcontinue]
-U+20F0 NSM Mark: Non-spacing mark, inherited, Extend, [latin, devanagari, grantha], [caseignorable, graphemeextend, idcontinue, xidcontinue]
-U+1CD0 NSM Mark: Non-spacing mark, inherited, Extend, [devanagari, bengali, kannada, grantha], [caseignorable, diacritic, graphemeextend, idcontinue, xidcontinue]
+U+A836 L   Symbol: Other symbol, common, Other, [devanagari, gurmukhi, gujarati, kaithi, takri, khojki, mahajani, modi, khudawadi, tirhuta, dogra], [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+A833 L   Number: Other number, common, Other, [devanagari, gurmukhi, gujarati, kannada, kaithi, takri, khojki, mahajani, modi, khudawadi, tirhuta, dogra, nandinagari], [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+1CF4 NSM Mark: Non-spacing mark, inherited, Extend, [devanagari, kannada, grantha], [alphabetic, cased, graphemebase, idcontinue, idstart, lowercase, softdotted, xidcontinue, xidstart]
+U+20F0 NSM Mark: Non-spacing mark, inherited, Extend, [latin, devanagari, grantha], [caseignorable, graphemebase, patternsyntax, quotationmark]
+U+1CD0 NSM Mark: Non-spacing mark, inherited, Extend, [devanagari, bengali, kannada, grantha], [alphabetic, cased, graphemebase, idcontinue, idstart, lowercase, softdotted, xidcontinue, xidstart]
 
 findprop 32ff
-U+32FF L   Symbol: Other symbol, common, Other, [han], [graphemebase]
+U+32FF L   Symbol: Other symbol, common, Other, [han], [alphabetic, caseignorable, extender, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
 
 findprop 1f16d
-U+1F16D ON  Symbol: Other symbol, common, Extended Pictographic, [extendedpictographic, graphemebase]
+U+1F16D ON  Symbol: Other symbol, common, Extended Pictographic, [ascii, sentenceterminal, unifiedideograph, whitespace, xidcontinue]
 
 findprop U+10e93 U+10eaa
-U+10E93 R   Letter: Other letter, yezidi, Other, [alphabetic, graphemebase, idcontinue, idstart, xidcontinue, xidstart]
+U+10E93 R   Letter: Other letter, yezidi, Other, [alphabetic, diacritic, graphemebase, idcontinue, xidcontinue]
 U+10EAA R   Control: Unassigned, unknown, Other
 
 findprop 0602 202a 202b 202c 2068 2069 202d 202e 2067
-U+0602 AN  Control: Format, arabic, Prepend, [caseignorable, prependedconcatenationmark]
-U+202A LRE Control: Format, common, Control, [bidicontrol, caseignorable, defaultignorablecodepoint]
-U+202B RLE Control: Format, common, Control, [bidicontrol, caseignorable, defaultignorablecodepoint]
-U+202C PDF Control: Format, common, Control, [bidicontrol, caseignorable, defaultignorablecodepoint]
-U+2068 FSI Control: Format, common, Control, [bidicontrol, caseignorable, defaultignorablecodepoint]
-U+2069 PDI Control: Format, common, Control, [bidicontrol, caseignorable, defaultignorablecodepoint]
-U+202D LRO Control: Format, common, Control, [bidicontrol, caseignorable, defaultignorablecodepoint]
-U+202E RLO Control: Format, common, Control, [bidicontrol, caseignorable, defaultignorablecodepoint]
-U+2067 RLI Control: Format, common, Control, [bidicontrol, caseignorable, defaultignorablecodepoint]
+U+0602 AN  Control: Format, arabic, Prepend, [alphabetic, cased, changeswhencasemapped, changeswhentitlecased, changeswhenuppercased, graphemebase, lowercase]
+U+202A LRE Control: Format, common, Control, [extendedpictographic, graphemebase, math, patternsyntax]
+U+202B RLE Control: Format, common, Control, [extendedpictographic, graphemebase, math, patternsyntax]
+U+202C PDF Control: Format, common, Control, [extendedpictographic, graphemebase, math, patternsyntax]
+U+2068 FSI Control: Format, common, Control, [extendedpictographic, graphemebase, math, patternsyntax]
+U+2069 PDI Control: Format, common, Control, [extendedpictographic, graphemebase, math, patternsyntax]
+U+202D LRO Control: Format, common, Control, [extendedpictographic, graphemebase, math, patternsyntax]
+U+202E RLO Control: Format, common, Control, [extendedpictographic, graphemebase, math, patternsyntax]
+U+2067 RLI Control: Format, common, Control, [extendedpictographic, graphemebase, math, patternsyntax]
```

### Comparing `pcre2-0.1.0/src/libpcre2/maint/utf8.c` & `pcre2-0.2.0/src/libpcre2/maint/utf8.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/pcre2-config.in` & `pcre2-0.2.0/src/libpcre2/pcre2-config.in`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/perltest.sh` & `pcre2-0.2.0/src/libpcre2/perltest.sh`

 * *Files 1% similar despite different names*

```diff
@@ -214,15 +214,15 @@
   $mod = "$3,$extra_modifiers";
   $mod =~ s/^,\s*//;
 
   # The private "aftertext" modifier means "print $' afterwards".
 
   $showrest = ($mod =~ s/aftertext,?//);
 
-  # The "subject_literal" modifer disables escapes in subjects.
+  # The "subject_literal" modifier disables escapes in subjects.
 
   $subject_literal = ($mod =~ s/subject_literal,?//);
 
   # "allaftertext" is used by pcre2test to print remainders after captures
 
   $mod =~ s/allaftertext,?//;
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/config.h.generic` & `pcre2-0.2.0/src/libpcre2/src/config.h.generic`

 * *Files 2% similar despite different names*

```diff
@@ -232,24 +232,24 @@
 /* Define to the address where bug reports for this package should be sent. */
 #define PACKAGE_BUGREPORT ""
 
 /* Define to the full name of this package. */
 #define PACKAGE_NAME "PCRE2"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "PCRE2 10.40"
+#define PACKAGE_STRING "PCRE2 10.42"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "pcre2"
 
 /* Define to the home page for this package. */
 #define PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "10.40"
+#define PACKAGE_VERSION "10.42"
 
 /* The value of PARENS_NEST_LIMIT specifies the maximum depth of nested
    parentheses (of any kind) in a pattern. This limits the amount of system
    stack that is used while compiling a pattern. */
 #ifndef PARENS_NEST_LIMIT
 #define PARENS_NEST_LIMIT 250
 #endif
@@ -434,15 +434,21 @@
 /* Enable X/Open extensions.  Define to 500 only if necessary
    to make mbstate_t available.  */
 #ifndef _XOPEN_SOURCE
 /* # undef _XOPEN_SOURCE */
 #endif
 
 /* Version number of package */
-#define VERSION "10.40"
+#define VERSION "10.42"
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
 
 /* Define to empty if `const' does not conform to ANSI C. */
 /* #undef const */
 
 /* Define to the type of a signed integer type of width exactly 64 bits if
    such a type exists and the standard includes do not define it. */
 /* #undef int64_t */
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/config.h.in` & `pcre2-0.2.0/src/libpcre2/src/config.h.in`

 * *Files 2% similar despite different names*

```diff
@@ -424,14 +424,20 @@
 # undef _XOPEN_SOURCE
 #endif
 
 
 /* Version number of package */
 #undef VERSION
 
+/* Number of bits in a file offset, on hosts where this is settable. */
+#undef _FILE_OFFSET_BITS
+
+/* Define for large files, on AIX-style hosts. */
+#undef _LARGE_FILES
+
 /* Define to empty if `const' does not conform to ANSI C. */
 #undef const
 
 /* Define to the type of a signed integer type of width exactly 64 bits if
    such a type exists and the standard includes do not define it. */
 #undef int64_t
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2.h.generic` & `pcre2-0.2.0/src/libpcre2/src/pcre2.h.generic`

 * *Files 0% similar despite different names*

```diff
@@ -38,17 +38,17 @@
 
 #ifndef PCRE2_H_IDEMPOTENT_GUARD
 #define PCRE2_H_IDEMPOTENT_GUARD
 
 /* The current PCRE version information. */
 
 #define PCRE2_MAJOR           10
-#define PCRE2_MINOR           40
+#define PCRE2_MINOR           42
 #define PCRE2_PRERELEASE      
-#define PCRE2_DATE            2022-04-14
+#define PCRE2_DATE            2022-12-11
 
 /* When an application links to a PCRE DLL in Windows, the symbols that are
 imported have to be identified as such. When building PCRE2, the appropriate
 export setting is defined in pcre2_internal.h, which includes this file. So we
 don't change existing definitions of PCRE2_EXP_DECL. */
 
 #if defined(_WIN32) && !defined(PCRE2_STATIC)
@@ -568,27 +568,27 @@
 #define PCRE2_GENERAL_INFO_FUNCTIONS \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION pcre2_config(uint32_t, void *);
 
 
 /* Functions for manipulating contexts. */
 
 #define PCRE2_GENERAL_CONTEXT_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_general_context PCRE2_CALL_CONVENTION \
-  *pcre2_general_context_copy(pcre2_general_context *); \
-PCRE2_EXP_DECL pcre2_general_context PCRE2_CALL_CONVENTION \
-  *pcre2_general_context_create(void *(*)(PCRE2_SIZE, void *), \
+PCRE2_EXP_DECL pcre2_general_context *PCRE2_CALL_CONVENTION \
+  pcre2_general_context_copy(pcre2_general_context *); \
+PCRE2_EXP_DECL pcre2_general_context *PCRE2_CALL_CONVENTION \
+  pcre2_general_context_create(void *(*)(PCRE2_SIZE, void *), \
     void (*)(void *, void *), void *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_general_context_free(pcre2_general_context *);
 
 #define PCRE2_COMPILE_CONTEXT_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_compile_context PCRE2_CALL_CONVENTION \
-  *pcre2_compile_context_copy(pcre2_compile_context *); \
-PCRE2_EXP_DECL pcre2_compile_context PCRE2_CALL_CONVENTION \
-  *pcre2_compile_context_create(pcre2_general_context *);\
+PCRE2_EXP_DECL pcre2_compile_context *PCRE2_CALL_CONVENTION \
+  pcre2_compile_context_copy(pcre2_compile_context *); \
+PCRE2_EXP_DECL pcre2_compile_context *PCRE2_CALL_CONVENTION \
+  pcre2_compile_context_create(pcre2_general_context *);\
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_compile_context_free(pcre2_compile_context *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_bsr(pcre2_compile_context *, uint32_t); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_character_tables(pcre2_compile_context *, const uint8_t *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
@@ -600,18 +600,18 @@
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_parens_nest_limit(pcre2_compile_context *, uint32_t); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_compile_recursion_guard(pcre2_compile_context *, \
     int (*)(uint32_t, void *), void *);
 
 #define PCRE2_MATCH_CONTEXT_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_match_context PCRE2_CALL_CONVENTION \
-  *pcre2_match_context_copy(pcre2_match_context *); \
-PCRE2_EXP_DECL pcre2_match_context PCRE2_CALL_CONVENTION \
-  *pcre2_match_context_create(pcre2_general_context *); \
+PCRE2_EXP_DECL pcre2_match_context *PCRE2_CALL_CONVENTION \
+  pcre2_match_context_copy(pcre2_match_context *); \
+PCRE2_EXP_DECL pcre2_match_context *PCRE2_CALL_CONVENTION \
+  pcre2_match_context_create(pcre2_general_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_match_context_free(pcre2_match_context *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_callout(pcre2_match_context *, \
     int (*)(pcre2_callout_block *, void *), void *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_substitute_callout(pcre2_match_context *, \
@@ -627,38 +627,38 @@
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_recursion_limit(pcre2_match_context *, uint32_t); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_recursion_memory_management(pcre2_match_context *, \
     void *(*)(PCRE2_SIZE, void *), void (*)(void *, void *), void *);
 
 #define PCRE2_CONVERT_CONTEXT_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_convert_context PCRE2_CALL_CONVENTION \
-  *pcre2_convert_context_copy(pcre2_convert_context *); \
-PCRE2_EXP_DECL pcre2_convert_context PCRE2_CALL_CONVENTION \
-  *pcre2_convert_context_create(pcre2_general_context *); \
+PCRE2_EXP_DECL pcre2_convert_context *PCRE2_CALL_CONVENTION \
+  pcre2_convert_context_copy(pcre2_convert_context *); \
+PCRE2_EXP_DECL pcre2_convert_context *PCRE2_CALL_CONVENTION \
+  pcre2_convert_context_create(pcre2_general_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_convert_context_free(pcre2_convert_context *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_glob_escape(pcre2_convert_context *, uint32_t); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_glob_separator(pcre2_convert_context *, uint32_t);
 
 
 /* Functions concerned with compiling a pattern to PCRE internal code. */
 
 #define PCRE2_COMPILE_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_code PCRE2_CALL_CONVENTION \
-  *pcre2_compile(PCRE2_SPTR, PCRE2_SIZE, uint32_t, int *, PCRE2_SIZE *, \
+PCRE2_EXP_DECL pcre2_code *PCRE2_CALL_CONVENTION \
+  pcre2_compile(PCRE2_SPTR, PCRE2_SIZE, uint32_t, int *, PCRE2_SIZE *, \
     pcre2_compile_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_code_free(pcre2_code *); \
-PCRE2_EXP_DECL pcre2_code PCRE2_CALL_CONVENTION \
-  *pcre2_code_copy(const pcre2_code *); \
-PCRE2_EXP_DECL pcre2_code PCRE2_CALL_CONVENTION \
-  *pcre2_code_copy_with_tables(const pcre2_code *);
+PCRE2_EXP_DECL pcre2_code *PCRE2_CALL_CONVENTION \
+  pcre2_code_copy(const pcre2_code *); \
+PCRE2_EXP_DECL pcre2_code *PCRE2_CALL_CONVENTION \
+  pcre2_code_copy_with_tables(const pcre2_code *);
 
 
 /* Functions that give information about a compiled pattern. */
 
 #define PCRE2_PATTERN_INFO_FUNCTIONS \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_pattern_info(const pcre2_code *, uint32_t, void *); \
@@ -666,18 +666,18 @@
   pcre2_callout_enumerate(const pcre2_code *, \
     int (*)(pcre2_callout_enumerate_block *, void *), void *);
 
 
 /* Functions for running a match and inspecting the result. */
 
 #define PCRE2_MATCH_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_match_data PCRE2_CALL_CONVENTION \
-  *pcre2_match_data_create(uint32_t, pcre2_general_context *); \
-PCRE2_EXP_DECL pcre2_match_data PCRE2_CALL_CONVENTION \
-  *pcre2_match_data_create_from_pattern(const pcre2_code *, \
+PCRE2_EXP_DECL pcre2_match_data *PCRE2_CALL_CONVENTION \
+  pcre2_match_data_create(uint32_t, pcre2_general_context *); \
+PCRE2_EXP_DECL pcre2_match_data *PCRE2_CALL_CONVENTION \
+  pcre2_match_data_create_from_pattern(const pcre2_code *, \
     pcre2_general_context *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_dfa_match(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE, \
     uint32_t, pcre2_match_data *, pcre2_match_context *, int *, PCRE2_SIZE); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_match(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE, \
     uint32_t, pcre2_match_data *, pcre2_match_context *); \
@@ -685,16 +685,16 @@
   pcre2_match_data_free(pcre2_match_data *); \
 PCRE2_EXP_DECL PCRE2_SPTR PCRE2_CALL_CONVENTION \
   pcre2_get_mark(pcre2_match_data *); \
 PCRE2_EXP_DECL PCRE2_SIZE PCRE2_CALL_CONVENTION \
   pcre2_get_match_data_size(pcre2_match_data *); \
 PCRE2_EXP_DECL uint32_t PCRE2_CALL_CONVENTION \
   pcre2_get_ovector_count(pcre2_match_data *); \
-PCRE2_EXP_DECL PCRE2_SIZE PCRE2_CALL_CONVENTION \
-  *pcre2_get_ovector_pointer(pcre2_match_data *); \
+PCRE2_EXP_DECL PCRE2_SIZE *PCRE2_CALL_CONVENTION \
+  pcre2_get_ovector_pointer(pcre2_match_data *); \
 PCRE2_EXP_DECL PCRE2_SIZE PCRE2_CALL_CONVENTION \
   pcre2_get_startchar(pcre2_match_data *);
 
 
 /* Convenience functions for handling matched substrings. */
 
 #define PCRE2_SUBSTRING_FUNCTIONS \
@@ -766,29 +766,29 @@
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_jit_compile(pcre2_code *, uint32_t); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_jit_match(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE, \
     uint32_t, pcre2_match_data *, pcre2_match_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_jit_free_unused_memory(pcre2_general_context *); \
-PCRE2_EXP_DECL pcre2_jit_stack PCRE2_CALL_CONVENTION \
-  *pcre2_jit_stack_create(PCRE2_SIZE, PCRE2_SIZE, pcre2_general_context *); \
+PCRE2_EXP_DECL pcre2_jit_stack *PCRE2_CALL_CONVENTION \
+  pcre2_jit_stack_create(PCRE2_SIZE, PCRE2_SIZE, pcre2_general_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_jit_stack_assign(pcre2_match_context *, pcre2_jit_callback, void *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_jit_stack_free(pcre2_jit_stack *);
 
 
 /* Other miscellaneous functions. */
 
 #define PCRE2_OTHER_FUNCTIONS \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_get_error_message(int, PCRE2_UCHAR *, PCRE2_SIZE); \
-PCRE2_EXP_DECL const uint8_t PCRE2_CALL_CONVENTION \
-  *pcre2_maketables(pcre2_general_context *); \
+PCRE2_EXP_DECL const uint8_t *PCRE2_CALL_CONVENTION \
+  pcre2_maketables(pcre2_general_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_maketables_free(pcre2_general_context *, const uint8_t *);
 
 /* Define macros that generate width-specific names from generic versions. The
 three-level macro scheme is necessary to get the macros expanded when we want
 them to be. First we get the width from PCRE2_LOCAL_WIDTH, which is used for
 generating three versions of everything below. After that, PCRE2_SUFFIX will be
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2.h.in` & `pcre2-0.2.0/src/libpcre2/src/pcre2.h.in`

 * *Files 0% similar despite different names*

```diff
@@ -568,27 +568,27 @@
 #define PCRE2_GENERAL_INFO_FUNCTIONS \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION pcre2_config(uint32_t, void *);
 
 
 /* Functions for manipulating contexts. */
 
 #define PCRE2_GENERAL_CONTEXT_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_general_context PCRE2_CALL_CONVENTION \
-  *pcre2_general_context_copy(pcre2_general_context *); \
-PCRE2_EXP_DECL pcre2_general_context PCRE2_CALL_CONVENTION \
-  *pcre2_general_context_create(void *(*)(PCRE2_SIZE, void *), \
+PCRE2_EXP_DECL pcre2_general_context *PCRE2_CALL_CONVENTION \
+  pcre2_general_context_copy(pcre2_general_context *); \
+PCRE2_EXP_DECL pcre2_general_context *PCRE2_CALL_CONVENTION \
+  pcre2_general_context_create(void *(*)(PCRE2_SIZE, void *), \
     void (*)(void *, void *), void *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_general_context_free(pcre2_general_context *);
 
 #define PCRE2_COMPILE_CONTEXT_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_compile_context PCRE2_CALL_CONVENTION \
-  *pcre2_compile_context_copy(pcre2_compile_context *); \
-PCRE2_EXP_DECL pcre2_compile_context PCRE2_CALL_CONVENTION \
-  *pcre2_compile_context_create(pcre2_general_context *);\
+PCRE2_EXP_DECL pcre2_compile_context *PCRE2_CALL_CONVENTION \
+  pcre2_compile_context_copy(pcre2_compile_context *); \
+PCRE2_EXP_DECL pcre2_compile_context *PCRE2_CALL_CONVENTION \
+  pcre2_compile_context_create(pcre2_general_context *);\
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_compile_context_free(pcre2_compile_context *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_bsr(pcre2_compile_context *, uint32_t); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_character_tables(pcre2_compile_context *, const uint8_t *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
@@ -600,18 +600,18 @@
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_parens_nest_limit(pcre2_compile_context *, uint32_t); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_compile_recursion_guard(pcre2_compile_context *, \
     int (*)(uint32_t, void *), void *);
 
 #define PCRE2_MATCH_CONTEXT_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_match_context PCRE2_CALL_CONVENTION \
-  *pcre2_match_context_copy(pcre2_match_context *); \
-PCRE2_EXP_DECL pcre2_match_context PCRE2_CALL_CONVENTION \
-  *pcre2_match_context_create(pcre2_general_context *); \
+PCRE2_EXP_DECL pcre2_match_context *PCRE2_CALL_CONVENTION \
+  pcre2_match_context_copy(pcre2_match_context *); \
+PCRE2_EXP_DECL pcre2_match_context *PCRE2_CALL_CONVENTION \
+  pcre2_match_context_create(pcre2_general_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_match_context_free(pcre2_match_context *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_callout(pcre2_match_context *, \
     int (*)(pcre2_callout_block *, void *), void *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_substitute_callout(pcre2_match_context *, \
@@ -627,38 +627,38 @@
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_recursion_limit(pcre2_match_context *, uint32_t); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_recursion_memory_management(pcre2_match_context *, \
     void *(*)(PCRE2_SIZE, void *), void (*)(void *, void *), void *);
 
 #define PCRE2_CONVERT_CONTEXT_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_convert_context PCRE2_CALL_CONVENTION \
-  *pcre2_convert_context_copy(pcre2_convert_context *); \
-PCRE2_EXP_DECL pcre2_convert_context PCRE2_CALL_CONVENTION \
-  *pcre2_convert_context_create(pcre2_general_context *); \
+PCRE2_EXP_DECL pcre2_convert_context *PCRE2_CALL_CONVENTION \
+  pcre2_convert_context_copy(pcre2_convert_context *); \
+PCRE2_EXP_DECL pcre2_convert_context *PCRE2_CALL_CONVENTION \
+  pcre2_convert_context_create(pcre2_general_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_convert_context_free(pcre2_convert_context *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_glob_escape(pcre2_convert_context *, uint32_t); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_set_glob_separator(pcre2_convert_context *, uint32_t);
 
 
 /* Functions concerned with compiling a pattern to PCRE internal code. */
 
 #define PCRE2_COMPILE_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_code PCRE2_CALL_CONVENTION \
-  *pcre2_compile(PCRE2_SPTR, PCRE2_SIZE, uint32_t, int *, PCRE2_SIZE *, \
+PCRE2_EXP_DECL pcre2_code *PCRE2_CALL_CONVENTION \
+  pcre2_compile(PCRE2_SPTR, PCRE2_SIZE, uint32_t, int *, PCRE2_SIZE *, \
     pcre2_compile_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_code_free(pcre2_code *); \
-PCRE2_EXP_DECL pcre2_code PCRE2_CALL_CONVENTION \
-  *pcre2_code_copy(const pcre2_code *); \
-PCRE2_EXP_DECL pcre2_code PCRE2_CALL_CONVENTION \
-  *pcre2_code_copy_with_tables(const pcre2_code *);
+PCRE2_EXP_DECL pcre2_code *PCRE2_CALL_CONVENTION \
+  pcre2_code_copy(const pcre2_code *); \
+PCRE2_EXP_DECL pcre2_code *PCRE2_CALL_CONVENTION \
+  pcre2_code_copy_with_tables(const pcre2_code *);
 
 
 /* Functions that give information about a compiled pattern. */
 
 #define PCRE2_PATTERN_INFO_FUNCTIONS \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_pattern_info(const pcre2_code *, uint32_t, void *); \
@@ -666,18 +666,18 @@
   pcre2_callout_enumerate(const pcre2_code *, \
     int (*)(pcre2_callout_enumerate_block *, void *), void *);
 
 
 /* Functions for running a match and inspecting the result. */
 
 #define PCRE2_MATCH_FUNCTIONS \
-PCRE2_EXP_DECL pcre2_match_data PCRE2_CALL_CONVENTION \
-  *pcre2_match_data_create(uint32_t, pcre2_general_context *); \
-PCRE2_EXP_DECL pcre2_match_data PCRE2_CALL_CONVENTION \
-  *pcre2_match_data_create_from_pattern(const pcre2_code *, \
+PCRE2_EXP_DECL pcre2_match_data *PCRE2_CALL_CONVENTION \
+  pcre2_match_data_create(uint32_t, pcre2_general_context *); \
+PCRE2_EXP_DECL pcre2_match_data *PCRE2_CALL_CONVENTION \
+  pcre2_match_data_create_from_pattern(const pcre2_code *, \
     pcre2_general_context *); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_dfa_match(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE, \
     uint32_t, pcre2_match_data *, pcre2_match_context *, int *, PCRE2_SIZE); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_match(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE, \
     uint32_t, pcre2_match_data *, pcre2_match_context *); \
@@ -685,16 +685,16 @@
   pcre2_match_data_free(pcre2_match_data *); \
 PCRE2_EXP_DECL PCRE2_SPTR PCRE2_CALL_CONVENTION \
   pcre2_get_mark(pcre2_match_data *); \
 PCRE2_EXP_DECL PCRE2_SIZE PCRE2_CALL_CONVENTION \
   pcre2_get_match_data_size(pcre2_match_data *); \
 PCRE2_EXP_DECL uint32_t PCRE2_CALL_CONVENTION \
   pcre2_get_ovector_count(pcre2_match_data *); \
-PCRE2_EXP_DECL PCRE2_SIZE PCRE2_CALL_CONVENTION \
-  *pcre2_get_ovector_pointer(pcre2_match_data *); \
+PCRE2_EXP_DECL PCRE2_SIZE *PCRE2_CALL_CONVENTION \
+  pcre2_get_ovector_pointer(pcre2_match_data *); \
 PCRE2_EXP_DECL PCRE2_SIZE PCRE2_CALL_CONVENTION \
   pcre2_get_startchar(pcre2_match_data *);
 
 
 /* Convenience functions for handling matched substrings. */
 
 #define PCRE2_SUBSTRING_FUNCTIONS \
@@ -766,29 +766,29 @@
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_jit_compile(pcre2_code *, uint32_t); \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_jit_match(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE, \
     uint32_t, pcre2_match_data *, pcre2_match_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_jit_free_unused_memory(pcre2_general_context *); \
-PCRE2_EXP_DECL pcre2_jit_stack PCRE2_CALL_CONVENTION \
-  *pcre2_jit_stack_create(PCRE2_SIZE, PCRE2_SIZE, pcre2_general_context *); \
+PCRE2_EXP_DECL pcre2_jit_stack *PCRE2_CALL_CONVENTION \
+  pcre2_jit_stack_create(PCRE2_SIZE, PCRE2_SIZE, pcre2_general_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_jit_stack_assign(pcre2_match_context *, pcre2_jit_callback, void *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_jit_stack_free(pcre2_jit_stack *);
 
 
 /* Other miscellaneous functions. */
 
 #define PCRE2_OTHER_FUNCTIONS \
 PCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \
   pcre2_get_error_message(int, PCRE2_UCHAR *, PCRE2_SIZE); \
-PCRE2_EXP_DECL const uint8_t PCRE2_CALL_CONVENTION \
-  *pcre2_maketables(pcre2_general_context *); \
+PCRE2_EXP_DECL const uint8_t *PCRE2_CALL_CONVENTION \
+  pcre2_maketables(pcre2_general_context *); \
 PCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \
   pcre2_maketables_free(pcre2_general_context *, const uint8_t *);
 
 /* Define macros that generate width-specific names from generic versions. The
 three-level macro scheme is necessary to get the macros expanded when we want
 them to be. First we get the width from PCRE2_LOCAL_WIDTH, which is used for
 generating three versions of everything below. After that, PCRE2_SUFFIX will be
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_auto_possess.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_auto_possess.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_chartables.c.dist` & `pcre2-0.2.0/src/libpcre2/src/pcre2_chartables.c.dist`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_compile.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_compile.c`

 * *Files 0% similar despite different names*

```diff
@@ -1262,16 +1262,18 @@
 PCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION
 pcre2_code_free(pcre2_code *code)
 {
 PCRE2_SIZE* ref_count;
 
 if (code != NULL)
   {
+#ifdef SUPPORT_JIT
   if (code->executable_jit != NULL)
     PRIV(jit_free)(code->executable_jit, &code->memctl);
+#endif
 
   if ((code->flags & PCRE2_DEREF_TABLES) != 0)
     {
     /* Decoded tables belong to the codes after deserialization, and they must
     be freed when there are no more references to them. The *ref_count should
     always be > 0. */
 
@@ -2683,15 +2685,15 @@
 if ((options & PCRE2_EXTENDED_MORE) != 0) options |= PCRE2_EXTENDED;
 
 /* Now scan the pattern */
 
 while (ptr < ptrend)
   {
   int prev_expect_cond_assert;
-  uint32_t min_repeat, max_repeat;
+  uint32_t min_repeat = 0, max_repeat = 0;
   uint32_t set, unset, *optset;
   uint32_t terminator;
   uint32_t prev_meta_quantifier;
   BOOL prev_okquantifier;
   PCRE2_SPTR tempptr;
   PCRE2_SIZE offset;
 
@@ -8548,15 +8550,15 @@
 
    /* Capturing brackets */
 
    else if (op == OP_CBRA  || op == OP_CBRAPOS ||
             op == OP_SCBRA || op == OP_SCBRAPOS)
      {
      int n = GET2(scode, 1+LINK_SIZE);
-     int new_map = bracket_map | ((n < 32)? (1u << n) : 1);
+     unsigned int new_map = bracket_map | ((n < 32)? (1u << n) : 1);
      if (!is_startline(scode, new_map, cb, atomcount, inassert)) return FALSE;
      }
 
    /* Positive forward assertions */
 
    else if (op == OP_ASSERT || op == OP_ASSERT_NA)
      {
@@ -10616,8 +10618,14 @@
 HAD_ERROR:
 *errorptr = errorcode;
 pcre2_code_free(re);
 re = NULL;
 goto EXIT;
 }
 
+/* These #undefs are here to enable unity builds with CMake. */
+
+#undef NLBLOCK /* Block containing newline information */
+#undef PSSTART /* Field containing processed string start */
+#undef PSEND   /* Field containing processed string end */
+
 /* End of pcre2_compile.c */
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_config.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_config.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_context.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_context.c`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 *************************************************/
 
 /* PCRE is a library of functions to support regular expressions whose syntax
 and semantics are as close as possible to those of the Perl 5 language.
 
                        Written by Philip Hazel
      Original API code Copyright (c) 1997-2012 University of Cambridge
-          New API code Copyright (c) 2016-2018 University of Cambridge
+          New API code Copyright (c) 2016-2022 University of Cambridge
 
 -----------------------------------------------------------------------------
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 
     * Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
@@ -439,16 +439,19 @@
 PCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION
 pcre2_set_offset_limit(pcre2_match_context *mcontext, PCRE2_SIZE limit)
 {
 mcontext->offset_limit = limit;
 return 0;
 }
 
-/* This function became obsolete at release 10.30. It is kept as a synonym for
-backwards compatibility. */
+/* These functions became obsolete at release 10.30. The first is kept as a
+synonym for backwards compatibility. The second now does nothing. Exclude both
+from coverage reports. */
+
+/* LCOV_EXCL_START */
 
 PCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION
 pcre2_set_recursion_limit(pcre2_match_context *mcontext, uint32_t limit)
 {
 return pcre2_set_depth_limit(mcontext, limit);
 }
 
@@ -460,14 +463,17 @@
 (void)mcontext;
 (void)mymalloc;
 (void)myfree;
 (void)mydata;
 return 0;
 }
 
+/* LCOV_EXCL_STOP */
+
+
 /* ------------ Convert context ------------ */
 
 PCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION
 pcre2_set_glob_separator(pcre2_convert_context *ccontext, uint32_t separator)
 {
 if (separator != CHAR_SLASH && separator != CHAR_BACKSLASH &&
     separator != CHAR_DOT) return PCRE2_ERROR_BADDATA;
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_convert.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_convert.c`

 * *Files 2% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 *************************************************/
 
 /* PCRE is a library of functions to support regular expressions whose syntax
 and semantics are as close as possible to those of the Perl 5 language.
 
                        Written by Philip Hazel
      Original API code Copyright (c) 1997-2012 University of Cambridge
-          New API code Copyright (c) 2016-2018 University of Cambridge
+          New API code Copyright (c) 2016-2022 University of Cambridge
 
 -----------------------------------------------------------------------------
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 
     * Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
@@ -61,17 +61,16 @@
 #define STR_BACKSLASH_z STR_BACKSLASH STR_z
 #define STR_COLON_RIGHT_SQUARE_BRACKET STR_COLON STR_RIGHT_SQUARE_BRACKET
 #define STR_DOT_STAR_LOOKBEHIND STR_DOT STR_ASTERISK STR_LEFT_PARENTHESIS STR_QUESTION_MARK STR_LESS_THAN_SIGN STR_EQUALS_SIGN
 #define STR_LOOKAHEAD_NOT_DOT STR_LEFT_PARENTHESIS STR_QUESTION_MARK STR_EXCLAMATION_MARK STR_BACKSLASH STR_DOT STR_RIGHT_PARENTHESIS
 #define STR_QUERY_s STR_LEFT_PARENTHESIS STR_QUESTION_MARK STR_s STR_RIGHT_PARENTHESIS
 #define STR_STAR_NUL STR_LEFT_PARENTHESIS STR_ASTERISK STR_N STR_U STR_L STR_RIGHT_PARENTHESIS
 
-/* States for range and POSIX processing */
+/* States for POSIX processing */
 
-enum { RANGE_NOT_STARTED, RANGE_STARTING, RANGE_STARTED };
 enum { POSIX_START_REGEX, POSIX_ANCHORED, POSIX_NOT_BRACKET,
        POSIX_CLASS_NOT_STARTED, POSIX_CLASS_STARTING, POSIX_CLASS_STARTED };
 
 /* Macro to add a character string to the output buffer, checking for overflow. */
 
 #define PUTCHARS(string) \
   { \
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_dfa_match.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_dfa_match.c`

 * *Files 0% similar despite different names*

```diff
@@ -346,15 +346,15 @@
   extracode         extra code offset when called from condition
   lengthptr         where to return the callout length
 
 Returns:            the return from the callout
 */
 
 static int
-do_callout(PCRE2_SPTR code, PCRE2_SIZE *offsets, PCRE2_SPTR current_subject,
+do_callout_dfa(PCRE2_SPTR code, PCRE2_SIZE *offsets, PCRE2_SPTR current_subject,
   PCRE2_SPTR ptr, dfa_match_block *mb, PCRE2_SIZE extracode,
   PCRE2_SIZE *lengthptr)
 {
 pcre2_callout_block *cb = mb->cb;
 
 *lengthptr = (code[extracode] == OP_CALLOUT)?
   (PCRE2_SIZE)PRIV(OP_lengths)[OP_CALLOUT] :
@@ -2795,15 +2795,15 @@
         is inserted between OP_COND and an assertion condition. This does not
         happen for the other conditions. */
 
         if (code[LINK_SIZE + 1] == OP_CALLOUT
             || code[LINK_SIZE + 1] == OP_CALLOUT_STR)
           {
           PCRE2_SIZE callout_length;
-          rrc = do_callout(code, offsets, current_subject, ptr, mb,
+          rrc = do_callout_dfa(code, offsets, current_subject, ptr, mb,
             1 + LINK_SIZE, &callout_length);
           if (rrc < 0) return rrc;                 /* Abandon */
           if (rrc > 0) break;                      /* Fail this thread */
           code += callout_length;                  /* Skip callout data */
           }
 
         condcode = code[LINK_SIZE+1];
@@ -3192,15 +3192,15 @@
 /* ========================================================================== */
       /* Handle callouts */
 
       case OP_CALLOUT:
       case OP_CALLOUT_STR:
         {
         PCRE2_SIZE callout_length;
-        rrc = do_callout(code, offsets, current_subject, ptr, mb, 0,
+        rrc = do_callout_dfa(code, offsets, current_subject, ptr, mb, 0,
           &callout_length);
         if (rrc < 0) return rrc;   /* Abandon */
         if (rrc == 0)
           { ADD_ACTIVE(state_offset + (int)callout_length, 0); }
         }
       break;
 
@@ -4053,8 +4053,14 @@
   rws->next = next->next;
   mb->memctl.free(next, mb->memctl.memory_data);
   }
 
 return rc;
 }
 
+/* These #undefs are here to enable unity builds with CMake. */
+
+#undef NLBLOCK /* Block containing newline information */
+#undef PSSTART /* Field containing processed string start */
+#undef PSEND   /* Field containing processed string end */
+
 /* End of pcre2_dfa_match.c */
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_dftables.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_dftables.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_error.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_error.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_extuni.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_extuni.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_find_bracket.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_find_bracket.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_fuzzsupport.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_fuzzsupport.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_internal.h` & `pcre2-0.2.0/src/libpcre2/src/pcre2_internal.h`

 * *Files 1% similar despite different names*

```diff
@@ -216,26 +216,25 @@
 unlikely to change, this is not a pressing issue. The original reason for
 having a base other than 0 was to keep the absolute values of compile-time and
 run-time error numbers numerically different, but in the event the code does
 not rely on this. */
 
 #define COMPILE_ERROR_BASE 100
 
-/* The initial frames vector for remembering backtracking points in
-pcre2_match() is allocated on the system stack, of this size (bytes). The size
-must be a multiple of sizeof(PCRE2_SPTR) in all environments, so making it a
-multiple of 8 is best. Typical frame sizes are a few hundred bytes (it depends
-on the number of capturing parentheses) so 20KiB handles quite a few frames. A
-larger vector on the heap is obtained for patterns that need more frames. The
-maximum size of this can be limited. */
+/* The initial frames vector for remembering pcre2_match() backtracking points
+is allocated on the heap, of this size (bytes) or ten times the frame size if
+larger, unless the heap limit is smaller. Typical frame sizes are a few hundred
+bytes (it depends on the number of capturing parentheses) so 20KiB handles
+quite a few frames. A larger vector on the heap is obtained for matches that
+need more frames, subject to the heap limit. */
 
 #define START_FRAMES_SIZE 20480
 
-/* Similarly, for DFA matching, an initial internal workspace vector is
-allocated on the stack. */
+/* For DFA matching, an initial internal workspace vector is allocated on the
+stack. The heap is used only if this turns out to be too small. */
 
 #define DFA_START_RWS_SIZE 30720
 
 /* Define the default BSR convention. */
 
 #ifdef BSR_ANYCRLF
 #define BSR_DEFAULT PCRE2_BSR_ANYCRLF
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_intmodedep.h` & `pcre2-0.2.0/src/libpcre2/src/pcre2_intmodedep.h`

 * *Files 0% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 *************************************************/
 
 /* PCRE is a library of functions to support regular expressions whose syntax
 and semantics are as close as possible to those of the Perl 5 language.
 
                        Written by Philip Hazel
      Original API code Copyright (c) 1997-2012 University of Cambridge
-          New API code Copyright (c) 2016-2018 University of Cambridge
+          New API code Copyright (c) 2016-2022 University of Cambridge
 
 -----------------------------------------------------------------------------
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 
     * Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
@@ -645,27 +645,31 @@
 actually be so that array bound checkers don't grumble. Memory for this
 structure is obtained by calling pcre2_match_data_create(), which sets the size
 as the offset of ovector plus a pair of elements for each capturable string, so
 the size varies from call to call. As the maximum number of capturing
 subpatterns is 65535 we must allow for 65536 strings to include the overall
 match. (See also the heapframe structure below.) */
 
+struct heapframe;  /* Forward reference */
+
 typedef struct pcre2_real_match_data {
-  pcre2_memctl     memctl;
-  const pcre2_real_code *code;    /* The pattern used for the match */
-  PCRE2_SPTR       subject;       /* The subject that was matched */
-  PCRE2_SPTR       mark;          /* Pointer to last mark */
-  PCRE2_SIZE       leftchar;      /* Offset to leftmost code unit */
-  PCRE2_SIZE       rightchar;     /* Offset to rightmost code unit */
-  PCRE2_SIZE       startchar;     /* Offset to starting code unit */
-  uint8_t          matchedby;     /* Type of match (normal, JIT, DFA) */
-  uint8_t          flags;         /* Various flags */
-  uint16_t         oveccount;     /* Number of pairs */
-  int              rc;            /* The return code from the match */
-  PCRE2_SIZE       ovector[131072]; /* Must be last in the structure */
+  pcre2_memctl     memctl;           /* Memory control fields */
+  const pcre2_real_code *code;       /* The pattern used for the match */
+  PCRE2_SPTR       subject;          /* The subject that was matched */
+  PCRE2_SPTR       mark;             /* Pointer to last mark */
+  struct heapframe *heapframes;      /* Backtracking frames heap memory */
+  PCRE2_SIZE       heapframes_size;  /* Malloc-ed size */
+  PCRE2_SIZE       leftchar;         /* Offset to leftmost code unit */
+  PCRE2_SIZE       rightchar;        /* Offset to rightmost code unit */
+  PCRE2_SIZE       startchar;        /* Offset to starting code unit */
+  uint8_t          matchedby;        /* Type of match (normal, JIT, DFA) */
+  uint8_t          flags;            /* Various flags */
+  uint16_t         oveccount;        /* Number of pairs */
+  int              rc;               /* The return code from the match */
+  PCRE2_SIZE       ovector[131072];  /* Must be last in the structure */
 } pcre2_real_match_data;
 
 
 /* ----------------------- PRIVATE STRUCTURES ----------------------------- */
 
 /* These structures are not needed for pcre2test. */
 
@@ -850,18 +854,14 @@
 #define HEAPFRAME_ALIGNMENT offsetof(heapframe_align, frame)
 
 /* Structure for passing "static" information around between the functions
 doing traditional NFA matching (pcre2_match() and friends). */
 
 typedef struct match_block {
   pcre2_memctl memctl;            /* For general use */
-  PCRE2_SIZE frame_vector_size;   /* Size of a backtracking frame */
-  heapframe *match_frames;        /* Points to vector of frames */
-  heapframe *match_frames_top;    /* Points after the end of the vector */
-  heapframe *stack_frames;        /* The original vector on the stack */
   PCRE2_SIZE heap_limit;          /* As it says */
   uint32_t match_limit;           /* As it says */
   uint32_t match_limit_depth;     /* As it says */
   uint32_t match_call_count;      /* Number of times a new frame is created */
   BOOL hitend;                    /* Hit the end of the subject at some point */
   BOOL hasthen;                   /* Pattern contains (*THEN) */
   BOOL allowemptypartial;         /* Allow empty hard partial */
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_jit_compile.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_jit_compile.c`

 * *Files 1% similar despite different names*

```diff
@@ -538,15 +538,15 @@
 #endif
 } compare_context;
 
 /* Undefine sljit macros. */
 #undef CMP
 
 /* Used for accessing the elements of the stack. */
-#define STACK(i)      ((i) * (int)sizeof(sljit_sw))
+#define STACK(i)      ((i) * SSIZE_OF(sw))
 
 #ifdef SLJIT_PREF_SHIFT_REG
 #if SLJIT_PREF_SHIFT_REG == SLJIT_R2
 /* Nothing. */
 #elif SLJIT_PREF_SHIFT_REG == SLJIT_R3
 #define SHIFT_REG_IS_R3
 #else
@@ -586,16 +586,16 @@
 /* Max limit of recursions. */
 #define LIMIT_MATCH      (4 * sizeof(sljit_sw))
 /* The output vector is stored on the stack, and contains pointers
 to characters. The vector data is divided into two groups: the first
 group contains the start / end character pointers, and the second is
 the start pointers when the end of the capturing group has not yet reached. */
 #define OVECTOR_START    (common->ovector_start)
-#define OVECTOR(i)       (OVECTOR_START + (i) * (sljit_sw)sizeof(sljit_sw))
-#define OVECTOR_PRIV(i)  (common->cbra_ptr + (i) * (sljit_sw)sizeof(sljit_sw))
+#define OVECTOR(i)       (OVECTOR_START + (i) * SSIZE_OF(sw))
+#define OVECTOR_PRIV(i)  (common->cbra_ptr + (i) * SSIZE_OF(sw))
 #define PRIVATE_DATA(cc) (common->private_data_ptrs[(cc) - common->start])
 
 #if PCRE2_CODE_UNIT_WIDTH == 8
 #define MOV_UCHAR  SLJIT_MOV_U8
 #define IN_UCHARS(x) (x)
 #elif PCRE2_CODE_UNIT_WIDTH == 16
 #define MOV_UCHAR  SLJIT_MOV_U16
@@ -2147,92 +2147,92 @@
     {
     case OP_SET_SOM:
     SLJIT_ASSERT(common->has_set_som);
     if (!setsom_found)
       {
       OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       setsom_found = TRUE;
       }
     cc += 1;
     break;
 
     case OP_MARK:
     case OP_COMMIT_ARG:
     case OP_PRUNE_ARG:
     case OP_THEN_ARG:
     SLJIT_ASSERT(common->mark_ptr != 0);
     if (!setmark_found)
       {
       OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       setmark_found = TRUE;
       }
     cc += 1 + 2 + cc[1];
     break;
 
     case OP_RECURSE:
     if (common->has_set_som && !setsom_found)
       {
       OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       setsom_found = TRUE;
       }
     if (common->mark_ptr != 0 && !setmark_found)
       {
       OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       setmark_found = TRUE;
       }
     if (common->capture_last_ptr != 0 && !capture_last_found)
       {
       OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       capture_last_found = TRUE;
       }
     cc += 1 + LINK_SIZE;
     break;
 
     case OP_CBRA:
     case OP_CBRAPOS:
     case OP_SCBRA:
     case OP_SCBRAPOS:
     if (common->capture_last_ptr != 0 && !capture_last_found)
       {
       OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);
-      stackpos -= (int)sizeof(sljit_sw);
+      stackpos -= SSIZE_OF(sw);
       capture_last_found = TRUE;
       }
     offset = (GET2(cc, 1 + LINK_SIZE)) << 1;
     OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, OVECTOR(offset));
-    stackpos -= (int)sizeof(sljit_sw);
+    stackpos -= SSIZE_OF(sw);
     OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));
     OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));
     OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);
-    stackpos -= (int)sizeof(sljit_sw);
+    stackpos -= SSIZE_OF(sw);
     OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP2, 0);
-    stackpos -= (int)sizeof(sljit_sw);
+    stackpos -= SSIZE_OF(sw);
 
     cc += 1 + LINK_SIZE + IMM2_SIZE;
     break;
 
     default:
     cc = next_opcode(common, cc);
     SLJIT_ASSERT(cc != NULL);
@@ -3140,15 +3140,15 @@
 
 static SLJIT_INLINE void allocate_stack(compiler_common *common, int size)
 {
 /* May destroy all locals and registers except TMP2. */
 DEFINE_COMPILER;
 
 SLJIT_ASSERT(size > 0);
-OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));
+OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * SSIZE_OF(sw));
 #ifdef DESTROY_REGISTERS
 OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 12345);
 OP1(SLJIT_MOV, TMP3, 0, TMP1, 0);
 OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);
 OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP1, 0);
 OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, TMP1, 0);
 #endif
@@ -3156,15 +3156,15 @@
 }
 
 static SLJIT_INLINE void free_stack(compiler_common *common, int size)
 {
 DEFINE_COMPILER;
 
 SLJIT_ASSERT(size > 0);
-OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));
+OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * SSIZE_OF(sw));
 }
 
 static sljit_uw * allocate_read_only_data(compiler_common *common, sljit_uw size)
 {
 DEFINE_COMPILER;
 sljit_uw *result;
 
@@ -3196,20 +3196,20 @@
 if (length < 8)
   {
   for (i = 1; i < length; i++)
     OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), SLJIT_R0, 0);
   }
 else
   {
-  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw)) == SLJIT_SUCCESS)
+  if (sljit_emit_mem_update(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw)) == SLJIT_SUCCESS)
     {
     GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START);
     OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);
     loop = LABEL();
-    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw));
+    sljit_emit_mem_update(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw));
     OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, 1);
     JUMPTO(SLJIT_NOT_ZERO, loop);
     }
   else
     {
     GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START + sizeof(sljit_sw));
     OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);
@@ -3257,16 +3257,16 @@
 uncleared_size = ((size / sizeof(sljit_sw)) % 3) * sizeof(sljit_sw);
 
 OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, size - uncleared_size);
 
 loop = LABEL();
 OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);
 OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));
-OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -2 * (sljit_sw)sizeof(sljit_sw), src, 0);
-OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -1 * (sljit_sw)sizeof(sljit_sw), src, 0);
+OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -2 * SSIZE_OF(sw), src, 0);
+OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -1 * SSIZE_OF(sw), src, 0);
 CMPTO(SLJIT_LESS, TMP1, 0, TMP2, 0, loop);
 
 if (uncleared_size >= sizeof(sljit_sw))
   OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);
 
 if (uncleared_size >= 2 * sizeof(sljit_sw))
   OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), sizeof(sljit_sw), src, 0);
@@ -3285,20 +3285,20 @@
 if (length < 8)
   {
   for (i = 2; i < length; i++)
     OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), TMP1, 0);
   }
 else
   {
-  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw)) == SLJIT_SUCCESS)
+  if (sljit_emit_mem_update(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw)) == SLJIT_SUCCESS)
     {
     GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + sizeof(sljit_sw));
     OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);
     loop = LABEL();
-    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw));
+    sljit_emit_mem_update(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw));
     OP2(SLJIT_SUB | SLJIT_SET_Z, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 1);
     JUMPTO(SLJIT_NOT_ZERO, loop);
     }
   else
     {
     GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + 2 * sizeof(sljit_sw));
     OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);
@@ -3382,23 +3382,23 @@
   OP1(SLJIT_MOV_U32, SLJIT_R1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, oveccount));
   OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_S0, 0);
   if (common->mark_ptr != 0)
     OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), SLJIT_R0, 0);
   OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, SLJIT_OFFSETOF(pcre2_match_data, ovector) - sizeof(PCRE2_SIZE));
   }
 
-has_pre = sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw)) == SLJIT_SUCCESS;
+has_pre = sljit_emit_mem_update(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw)) == SLJIT_SUCCESS;
 
 GET_LOCAL_BASE(SLJIT_S0, 0, OVECTOR_START - (has_pre ? sizeof(sljit_sw) : 0));
 OP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? SLJIT_R0 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));
 
 loop = LABEL();
 
 if (has_pre)
-  sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw));
+  sljit_emit_mem_update(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw));
 else
   {
   OP1(SLJIT_MOV, SLJIT_S1, 0, SLJIT_MEM1(SLJIT_S0), 0);
   OP2(SLJIT_ADD, SLJIT_S0, 0, SLJIT_S0, 0, SLJIT_IMM, sizeof(sljit_sw));
   }
 
 OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, sizeof(PCRE2_SIZE));
@@ -3413,35 +3413,35 @@
 
 OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);
 JUMPTO(SLJIT_NOT_ZERO, loop);
 
 /* Calculate the return value, which is the maximum ovector value. */
 if (topbracket > 1)
   {
-  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw))) == SLJIT_SUCCESS)
+  if (sljit_emit_mem_update(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * SSIZE_OF(sw))) == SLJIT_SUCCESS)
     {
     GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + topbracket * 2 * sizeof(sljit_sw));
     OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);
 
     /* OVECTOR(0) is never equal to SLJIT_S2. */
     loop = LABEL();
-    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw)));
+    sljit_emit_mem_update(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * SSIZE_OF(sw)));
     OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);
     CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);
     OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);
     }
   else
     {
     GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + (topbracket - 1) * 2 * sizeof(sljit_sw));
     OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);
 
     /* OVECTOR(0) is never equal to SLJIT_S2. */
     loop = LABEL();
     OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_R0), 0);
-    OP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_R0, 0, SLJIT_IMM, 2 * (sljit_sw)sizeof(sljit_sw));
+    OP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_R0, 0, SLJIT_IMM, 2 * SSIZE_OF(sw));
     OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);
     CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);
     OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);
     }
   }
 else
   OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, 1);
@@ -4648,16 +4648,16 @@
 if (common->nltype != NLTYPE_ANY)
   {
   SLJIT_ASSERT(common->nltype != NLTYPE_FIXED || common->newline < 128);
 
   /* All newlines are ascii, just skip intermediate octets. */
   jump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);
   loop = LABEL();
-  if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1)) == SLJIT_SUCCESS)
-    sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));
+  if (sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1)) == SLJIT_SUCCESS)
+    sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));
   else
     {
     OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));
     OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
     }
 
   OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);
@@ -5882,15 +5882,15 @@
       j = i - max_fast_forward_char_pair_offset();
       if (j < 0)
         j = 0;
 
       while (j < i)
         {
         b_pri = chars[j].last_count;
-        if (b_pri > 2 && a_pri + b_pri >= max_pri)
+        if (b_pri > 2 && (sljit_u32)a_pri + (sljit_u32)b_pri >= max_pri)
           {
           b1 = chars[j].chars[0];
           b2 = chars[j].chars[1];
 
           if (a1 != b1 && a1 != b2 && a2 != b1 && a2 != b2)
             {
             max_pri = a_pri + b_pri;
@@ -6568,29 +6568,29 @@
 struct sljit_label *mainloop;
 
 sljit_emit_fast_enter(compiler, RETURN_ADDR, 0);
 GET_LOCAL_BASE(TMP1, 0, 0);
 
 /* Drop frames until we reach STACK_TOP. */
 mainloop = LABEL();
-OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), -sizeof(sljit_sw));
+OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), -SSIZE_OF(sw));
 jump = CMP(SLJIT_SIG_LESS_EQUAL, TMP2, 0, SLJIT_IMM, 0);
 
 OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);
 if (HAS_VIRTUAL_REGISTERS)
   {
-  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));
-  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));
-  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));
+  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * SSIZE_OF(sw)));
+  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), SLJIT_MEM1(STACK_TOP), -(3 * SSIZE_OF(sw)));
+  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * SSIZE_OF(sw));
   }
 else
   {
-  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));
-  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));
-  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));
+  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), -(2 * SSIZE_OF(sw)));
+  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(3 * SSIZE_OF(sw)));
+  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * SSIZE_OF(sw));
   OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP1, 0);
   GET_LOCAL_BASE(TMP1, 0, 0);
   OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), TMP3, 0);
   }
 JUMPTO(SLJIT_JUMP, mainloop);
 
 JUMPHERE(jump);
@@ -6599,21 +6599,21 @@
 OP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);
 
 JUMPHERE(jump);
 OP2(SLJIT_SUB, TMP2, 0, SLJIT_IMM, 0, TMP2, 0);
 OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);
 if (HAS_VIRTUAL_REGISTERS)
   {
-  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));
-  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));
+  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * SSIZE_OF(sw)));
+  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * SSIZE_OF(sw));
   }
 else
   {
-  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));
-  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));
+  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(2 * SSIZE_OF(sw)));
+  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * SSIZE_OF(sw));
   OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP3, 0);
   }
 JUMPTO(SLJIT_JUMP, mainloop);
 }
 
 static void check_wordboundary(compiler_common *common)
 {
@@ -7155,34 +7155,34 @@
 
 if (char1_reg == STR_END)
   {
   OP1(SLJIT_MOV, TMP3, 0, char1_reg, 0);
   OP1(SLJIT_MOV, RETURN_ADDR, 0, char2_reg, 0);
   }
 
-if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)
+if (sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)
   {
   label = LABEL();
-  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));
-  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));
+  sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));
+  sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));
   jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);
   OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));
   JUMPTO(SLJIT_NOT_ZERO, label);
 
   JUMPHERE(jump);
   OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);
   }
-else if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)
+else if (sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)
   {
   OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));
   OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
 
   label = LABEL();
-  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));
-  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));
+  sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));
+  sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));
   jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);
   OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));
   JUMPTO(SLJIT_NOT_ZERO, label);
 
   JUMPHERE(jump);
   OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);
   OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
@@ -7228,17 +7228,17 @@
   }
 else
   {
   char2_reg = RETURN_ADDR;
   lcc_table = TMP3;
   }
 
-if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)
+if (sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)
   opt_type = 1;
-else if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)
+else if (sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)
   opt_type = 2;
 
 sljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);
 OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);
 
 OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, char1_reg, 0);
 
@@ -7249,25 +7249,25 @@
   }
 
 OP1(SLJIT_MOV, lcc_table, 0, SLJIT_IMM, common->lcc);
 
 if (opt_type == 1)
   {
   label = LABEL();
-  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));
-  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));
+  sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));
+  sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));
   }
 else if (opt_type == 2)
   {
   OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));
   OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
 
   label = LABEL();
-  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));
-  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));
+  sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));
+  sljit_emit_mem_update(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));
   }
 else
   {
   label = LABEL();
   OP1(MOV_UCHAR, char1_reg, 0, SLJIT_MEM1(TMP1), 0);
   OP1(MOV_UCHAR, char2_reg, 0, SLJIT_MEM1(STR_PTR), 0);
   OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));
@@ -9685,15 +9685,15 @@
   JUMPTO(SLJIT_FAST_CALL, entry->entry_label);
 /* Leave if the match is failed. */
 add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));
 BACKTRACK_AS(recurse_backtrack)->matchingpath = LABEL();
 return cc + 1 + LINK_SIZE;
 }
 
-static sljit_s32 SLJIT_FUNC do_callout(struct jit_arguments *arguments, pcre2_callout_block *callout_block, PCRE2_SPTR *jit_ovector)
+static sljit_s32 SLJIT_FUNC do_callout_jit(struct jit_arguments *arguments, pcre2_callout_block *callout_block, PCRE2_SPTR *jit_ovector)
 {
 PCRE2_SPTR begin;
 PCRE2_SIZE *ovector;
 sljit_u32 oveccount, capture_top;
 
 if (arguments->callout == NULL)
   return 0;
@@ -9752,15 +9752,15 @@
 backtrack_common *backtrack;
 sljit_s32 mov_opcode;
 unsigned int callout_length = (*cc == OP_CALLOUT)
     ? PRIV(OP_lengths)[OP_CALLOUT] : GET(cc, 1 + 2 * LINK_SIZE);
 sljit_sw value1;
 sljit_sw value2;
 sljit_sw value3;
-sljit_uw callout_arg_size = (common->re->top_bracket + 1) * 2 * sizeof(sljit_sw);
+sljit_uw callout_arg_size = (common->re->top_bracket + 1) * 2 * SSIZE_OF(sw);
 
 PUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);
 
 callout_arg_size = (sizeof(pcre2_callout_block) + callout_arg_size + sizeof(sljit_sw) - 1) / sizeof(sljit_sw);
 
 allocate_stack(common, callout_arg_size);
 
@@ -9802,15 +9802,15 @@
 SLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);
 
 /* Needed to save important temporary registers. */
 OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, STR_PTR, 0);
 /* SLJIT_R0 = arguments */
 OP1(SLJIT_MOV, SLJIT_R1, 0, STACK_TOP, 0);
 GET_LOCAL_BASE(SLJIT_R2, 0, OVECTOR_START);
-sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS3(32, W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_callout));
+sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS3(32, W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_callout_jit));
 OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);
 free_stack(common, callout_arg_size);
 
 /* Check return value. */
 OP2U(SLJIT_SUB32 | SLJIT_SET_Z | SLJIT_SET_SIG_GREATER, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);
 add_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_SIG_GREATER));
 if (common->abort_label == NULL)
@@ -11447,15 +11447,15 @@
 jump_list *no_match = NULL;
 jump_list *no_char1_match = NULL;
 struct sljit_jump *jump = NULL;
 struct sljit_label *label;
 int private_data_ptr = PRIVATE_DATA(cc);
 int base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);
 int offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;
-int offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);
+int offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + SSIZE_OF(sw);
 int tmp_base, tmp_offset;
 #if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32
 BOOL use_tmp;
 #endif
 
 PUSH_BACKTRACK(sizeof(char_iterator_backtrack), cc, NULL);
 
@@ -11513,27 +11513,27 @@
     label = LABEL();
     compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);
     OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);
     JUMPTO(SLJIT_NOT_ZERO, label);
     }
   }
 else if (exact == 1)
-  {
   compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);
 
-  if (early_fail_type == type_fail_range)
-    {
-    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr);
-    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw));
-    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, TMP2, 0);
-    OP2(SLJIT_SUB, TMP2, 0, STR_PTR, 0, TMP2, 0);
-    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, TMP2, 0, TMP1, 0));
+if (early_fail_type == type_fail_range)
+  {
+  /* Range end first, followed by range start. */
+  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr);
+  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + SSIZE_OF(sw));
+  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, TMP2, 0);
+  OP2(SLJIT_SUB, TMP2, 0, STR_PTR, 0, TMP2, 0);
+  add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, TMP2, 0, TMP1, 0));
 
-    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw), STR_PTR, 0);
-    }
+  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);
+  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + SSIZE_OF(sw), STR_PTR, 0);
   }
 
 switch(opcode)
   {
   case OP_STAR:
   case OP_UPTO:
   SLJIT_ASSERT(early_fail_ptr == 0 || opcode == OP_STAR);
@@ -12424,15 +12424,15 @@
 struct sljit_label *label = NULL;
 struct sljit_jump *jump = NULL;
 jump_list *jumplist = NULL;
 PCRE2_SPTR end;
 int private_data_ptr = PRIVATE_DATA(cc);
 int base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);
 int offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;
-int offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);
+int offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + SSIZE_OF(sw);
 
 cc = get_iterator_parameters(common, cc, &opcode, &type, &max, &exact, &end);
 
 switch(opcode)
   {
   case OP_STAR:
   case OP_UPTO:
@@ -14144,15 +14144,15 @@
 common->early_fail_end_ptr = 0;
 common->currententry = common->entries;
 common->local_quit_available = TRUE;
 quit_label = common->quit_label;
 if (common->currententry != NULL)
   {
   /* A free bit for each private data. */
-  common->recurse_bitset_size = ((private_data_size / (int)sizeof(sljit_sw)) + 7) >> 3;
+  common->recurse_bitset_size = ((private_data_size / SSIZE_OF(sw)) + 7) >> 3;
   SLJIT_ASSERT(common->recurse_bitset_size > 0);
   common->recurse_bitset = (sljit_u8*)SLJIT_MALLOC(common->recurse_bitset_size, allocator_data);;
 
   if (common->recurse_bitset != NULL)
     {
     do
       {
@@ -14380,15 +14380,15 @@
 
 PCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION
 pcre2_jit_compile(pcre2_code *code, uint32_t options)
 {
 pcre2_real_code *re = (pcre2_real_code *)code;
 #ifdef SUPPORT_JIT
 executable_functions *functions;
-static int executable_allocator_is_working = 0;
+static int executable_allocator_is_working = -1;
 #endif
 
 if (code == NULL)
   return PCRE2_ERROR_NULL;
 
 if ((options & ~PUBLIC_JIT_COMPILE_OPTIONS) != 0)
   return PCRE2_ERROR_JIT_BADOPTION;
@@ -14443,31 +14443,29 @@
 return PCRE2_ERROR_JIT_BADOPTION;
 #else  /* SUPPORT_JIT */
 
 /* There is JIT support. Do the necessary. */
 
 if ((re->flags & PCRE2_NOJIT) != 0) return 0;
 
-if (executable_allocator_is_working == 0)
+if (executable_allocator_is_working == -1)
   {
   /* Checks whether the executable allocator is working. This check
      might run multiple times in multi-threaded environments, but the
      result should not be affected by it. */
   void *ptr = SLJIT_MALLOC_EXEC(32, NULL);
-
-  executable_allocator_is_working = -1;
-
   if (ptr != NULL)
     {
     SLJIT_FREE_EXEC(((sljit_u8*)(ptr)) + SLJIT_EXEC_OFFSET(ptr), NULL);
     executable_allocator_is_working = 1;
     }
+  else executable_allocator_is_working = 0;
   }
 
-if (executable_allocator_is_working < 0)
+if (!executable_allocator_is_working)
   return PCRE2_ERROR_NOMEMORY;
 
 if ((re->overall_options & PCRE2_MATCH_INVALID_UTF) != 0)
   options |= PCRE2_JIT_INVALID_UTF;
 
 if ((options & PCRE2_JIT_COMPLETE) != 0 && (functions == NULL
     || functions->executable_funcs[0] == NULL)) {
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_jit_match.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_jit_match.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_jit_misc.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_jit_misc.c`

 * *Files 2% similar despite different names*

```diff
@@ -106,16 +106,18 @@
 PCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION
 pcre2_jit_free_unused_memory(pcre2_general_context *gcontext)
 {
 #ifndef SUPPORT_JIT
 (void)gcontext;     /* Suppress warning */
 #else  /* SUPPORT_JIT */
 SLJIT_UNUSED_ARG(gcontext);
+#if (defined SLJIT_EXECUTABLE_ALLOCATOR && SLJIT_EXECUTABLE_ALLOCATOR)
 sljit_free_unused_memory_exec();
-#endif  /* SUPPORT_JIT */
+#endif /* SLJIT_EXECUTABLE_ALLOCATOR */
+#endif /* SUPPORT_JIT */
 }
 
 
 
 /*************************************************
 *            Allocate a JIT stack                *
 *************************************************/
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_jit_neon_inc.h` & `pcre2-0.2.0/src/libpcre2/src/pcre2_jit_neon_inc.h`

 * *Files 2% similar despite different names*

```diff
@@ -179,14 +179,16 @@
 #endif
 
 #if defined(FF_UTF)
 restart:;
 #endif
 
 #if defined(FFCPS)
+if (str_ptr >= str_end)
+  return NULL;
 sljit_u8 *p1 = str_ptr - diff;
 #endif
 sljit_s32 align_offset = ((uint64_t)str_ptr & 0xf);
 str_ptr = (sljit_u8 *) ((uint64_t)str_ptr & ~0xf);
 vect_t data = VLD1Q(str_ptr);
 #if PCRE2_CODE_UNIT_WIDTH != 8
 data = VANDQ(data, char_mask);
@@ -323,15 +325,15 @@
 
 match:;
   if (str_ptr >= str_end)
     /* Failed match. */
     return NULL;
 
 #if defined(FF_UTF)
-  if (utf_continue(str_ptr + IN_UCHARS(-offs1)))
+  if (utf_continue((PCRE2_SPTR)str_ptr - offs1))
     {
     /* Not a match. */
     str_ptr += IN_UCHARS(1);
     goto restart;
     }
 #endif
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_jit_simd_inc.h` & `pcre2-0.2.0/src/libpcre2/src/pcre2_jit_simd_inc.h`

 * *Files 1% similar despite different names*

```diff
@@ -772,15 +772,15 @@
 
 typedef union {
   unsigned int x;
   struct { unsigned char c1, c2, c3, c4; } c;
 } int_char;
 
 #if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32
-static SLJIT_INLINE int utf_continue(sljit_u8 *s)
+static SLJIT_INLINE int utf_continue(PCRE2_SPTR s)
 {
 #if PCRE2_CODE_UNIT_WIDTH == 8
 return (*s & 0xc0) == 0x80;
 #elif PCRE2_CODE_UNIT_WIDTH == 16
 return (*s & 0xfc00) == 0xdc00;
 #else
 #error "Unknown code width"
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_jit_test.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_jit_test.c`

 * *Files 0% similar despite different names*

```diff
@@ -350,14 +350,15 @@
 	{ MU, A, 0, 0, "a(?R)|([a-z]++)#", ".abcd.mbcd#."},
 	{ MU, A, 0, 0, ".[ab]*.", "xx" },
 	{ MU, A, 0, 0, ".[ab]*a", "xxa" },
 	{ MU, A, 0, 0, ".[ab]?.", "xx" },
 	{ MU, A, 0, 0, "_[ab]+_*a", "_aa" },
 	{ MU, A, 0, 0, "#(A+)#\\d+", "#A#A#0" },
 	{ MU, A, 0, 0, "(?P<size>\\d+)m|M", "4M" },
+	{ M, PCRE2_NEWLINE_CRLF, 0, 0, "\\n?.+#", "\n,\n,#" },
 
 	/* Bracket repeats with limit. */
 	{ MU, A, 0, 0, "(?:(ab){2}){5}M", "abababababababababababM" },
 	{ MU, A, 0, 0, "(?:ab|abab){1,5}M", "abababababababababababM" },
 	{ MU, A, 0, 0, "(?>ab|abab){1,5}M", "abababababababababababM" },
 	{ MU, A, 0, 0, "(?:ab|abab){1,5}?M", "abababababababababababM" },
 	{ MU, A, 0, 0, "(?>ab|abab){1,5}?M", "abababababababababababM" },
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_maketables.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_maketables.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_match.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_match.c`

 * *Files 2% similar despite different names*

```diff
@@ -200,37 +200,38 @@
 
 Arguments:
   f           the file to write to
   F           the current top frame
   P           a previous frame of interest
   frame_size  the frame size
   mb          points to the match block
+  match_data  points to the match data block
   s           identification text
 
 Returns:    nothing
 */
 
 static void
 display_frames(FILE *f, heapframe *F, heapframe *P, PCRE2_SIZE frame_size,
-  match_block *mb, const char *s, ...)
+  match_block *mb, pcre2_match_data *match_data, const char *s, ...)
 {
 uint32_t i;
 heapframe *Q;
 va_list ap;
 va_start(ap, s);
 
 fprintf(f, "FRAMES ");
 vfprintf(f, s, ap);
 va_end(ap);
 
 if (P != NULL) fprintf(f, " P=%lu",
-  ((char *)P - (char *)(mb->match_frames))/frame_size);
+  ((char *)P - (char *)(match_data->heapframes))/frame_size);
 fprintf(f, "\n");
 
-for (i = 0, Q = mb->match_frames;
+for (i = 0, Q = match_data->heapframes;
      Q <= F;
      i++, Q = (heapframe *)((char *)Q + frame_size))
   {
   fprintf(f, "Frame %d type=%x subj=%lu code=%d back=%lu id=%d",
     i, Q->group_frame_type, Q->eptr - mb->start_subject, *(Q->ecode),
     Q->back_frame, Q->return_id);
 
@@ -486,18 +487,24 @@
 patterns, various kludges were invented to reduce the amount of stack used,
 making the code hard to understand in places.
 
 A version did exist that used individual frames on the heap instead of calling
 match() recursively, but this ran substantially slower. The current version is
 a refactoring that uses a vector of frames to remember backtracking points.
 This runs no slower, and possibly even a bit faster than the original recursive
-implementation. An initial vector of size START_FRAMES_SIZE (enough for maybe
-50 frames) is allocated on the system stack. If this is not big enough, the
-heap is used for a larger vector.
+implementation.
 
+At first, an initial vector of size START_FRAMES_SIZE (enough for maybe 50
+frames) was allocated on the system stack. If this was not big enough, the heap
+was used for a larger vector. However, it turns out that there are environments
+where taking as little as 20KiB from the system stack is an embarrassment.
+After another refactoring, the heap is used exclusively, but a pointer the
+frames vector and its size are cached in the match_data block, so that there is
+no new memory allocation if the same match_data block is used for multiple
+matches (unless the frames vector has to be extended).
 *******************************************************************************
 ******************************************************************************/
 
 
 
 
 /*************************************************
@@ -562,39 +569,40 @@
 mb structure (e.g. end_subject) into individual variables to improve
 performance. Tests using gcc on a SPARC disproved this; in the first case, it
 made performance worse.
 
 Arguments:
    start_eptr   starting character in subject
    start_ecode  starting position in compiled code
-   ovector      pointer to the final output vector
-   oveccount    number of pairs in ovector
    top_bracket  number of capturing parentheses in the pattern
    frame_size   size of each backtracking frame
+   match_data   pointer to the match_data block
    mb           pointer to "static" variables block
 
 Returns:        MATCH_MATCH if matched            )  these values are >= 0
                 MATCH_NOMATCH if failed to match  )
                 negative MATCH_xxx value for PRUNE, SKIP, etc
                 negative PCRE2_ERROR_xxx value if aborted by an error condition
                 (e.g. stopped by repeated call or depth limit)
 */
 
 static int
-match(PCRE2_SPTR start_eptr, PCRE2_SPTR start_ecode, PCRE2_SIZE *ovector,
-  uint16_t oveccount, uint16_t top_bracket, PCRE2_SIZE frame_size,
-  match_block *mb)
+match(PCRE2_SPTR start_eptr, PCRE2_SPTR start_ecode, uint16_t top_bracket,
+  PCRE2_SIZE frame_size, pcre2_match_data *match_data, match_block *mb)
 {
 /* Frame-handling variables */
 
 heapframe *F;           /* Current frame pointer */
 heapframe *N = NULL;    /* Temporary frame pointers */
 heapframe *P = NULL;
+
+heapframe *frames_top;  /* End of frames vector */
 heapframe *assert_accept_frame = NULL;  /* For passing back a frame with captures */
-PCRE2_SIZE frame_copy_size;     /* Amount to copy when creating a new frame */
+PCRE2_SIZE heapframes_size;   /* Usable size of frames vector */
+PCRE2_SIZE frame_copy_size;   /* Amount to copy when creating a new frame */
 
 /* Local variables that do not need to be preserved over calls to RRMATCH(). */
 
 PCRE2_SPTR bracode;     /* Temp pointer to start of group */
 PCRE2_SIZE offset;      /* Used for group offsets */
 PCRE2_SIZE length;      /* Used for various length calculations */
 
@@ -623,18 +631,22 @@
 #endif
 
 /* This is the length of the last part of a backtracking frame that must be
 copied when a new frame is created. */
 
 frame_copy_size = frame_size - offsetof(heapframe, eptr);
 
-/* Set up the first current frame at the start of the vector, and initialize
-fields that are not reset for new frames. */
+/* Set up the first frame and the end of the frames vector. We set the local
+heapframes_size to the usuable amount of the vector, that is, a whole number of
+frames. */
+
+F = match_data->heapframes;
+heapframes_size = (match_data->heapframes_size / frame_size) * frame_size;
+frames_top = (heapframe *)((char *)F + heapframes_size);
 
-F = mb->match_frames;
 Frdepth = 0;                        /* "Recursion" depth */
 Fcapture_last = 0;                  /* Number of most recent capture */
 Fcurrent_recurse = RECURSE_UNSET;   /* Not pattern recursing. */
 Fstart_match = Feptr = start_eptr;  /* Current data pointer and start match */
 Fmark = NULL;                       /* Most recent mark */
 Foffset_top = 0;                    /* End of captures within the frame */
 Flast_group_offset = PCRE2_UNSET;   /* Saved frame of most recent group */
@@ -642,42 +654,43 @@
 goto NEW_FRAME;                     /* Start processing with this frame */
 
 /* Come back here when we want to create a new frame for remembering a
 backtracking point. */
 
 MATCH_RECURSE:
 
-/* Set up a new backtracking frame. If the vector is full, get a new one
-on the heap, doubling the size, but constrained by the heap limit. */
+/* Set up a new backtracking frame. If the vector is full, get a new one,
+doubling the size, but constrained by the heap limit (which is in KiB). */
 
 N = (heapframe *)((char *)F + frame_size);
-if (N >= mb->match_frames_top)
+if (N >= frames_top)
   {
-  PCRE2_SIZE newsize = mb->frame_vector_size * 2;
   heapframe *new;
+  PCRE2_SIZE newsize = match_data->heapframes_size * 2;
 
-  if ((newsize / 1024) > mb->heap_limit)
+  if (newsize > mb->heap_limit)
     {
-    PCRE2_SIZE maxsize = ((mb->heap_limit * 1024)/frame_size) * frame_size;
-    if (mb->frame_vector_size >= maxsize) return PCRE2_ERROR_HEAPLIMIT;
+    PCRE2_SIZE maxsize = (mb->heap_limit/frame_size) * frame_size;
+    if (match_data->heapframes_size >= maxsize) return PCRE2_ERROR_HEAPLIMIT;
     newsize = maxsize;
     }
 
-  new = mb->memctl.malloc(newsize, mb->memctl.memory_data);
+  new = match_data->memctl.malloc(newsize, match_data->memctl.memory_data);
   if (new == NULL) return PCRE2_ERROR_NOMEMORY;
-  memcpy(new, mb->match_frames, mb->frame_vector_size);
+  memcpy(new, match_data->heapframes, heapframes_size);
 
-  F = (heapframe *)((char *)new + ((char *)F - (char *)mb->match_frames));
+  F = (heapframe *)((char *)new + ((char *)F - (char *)match_data->heapframes));
   N = (heapframe *)((char *)F + frame_size);
 
-  if (mb->match_frames != mb->stack_frames)
-    mb->memctl.free(mb->match_frames, mb->memctl.memory_data);
-  mb->match_frames = new;
-  mb->match_frames_top = (heapframe *)((char *)mb->match_frames + newsize);
-  mb->frame_vector_size = newsize;
+  match_data->memctl.free(match_data->heapframes, match_data->memctl.memory_data);
+  match_data->heapframes = new;
+  match_data->heapframes_size = newsize;
+
+  heapframes_size = (newsize / frame_size) * frame_size;
+  frames_top = (heapframe *)((char *)new + heapframes_size);
   }
 
 #ifdef DEBUG_SHOW_RMATCH
 fprintf(stderr, "++ RMATCH %2d frame=%d", Freturn_id, Frdepth + 1);
 if (group_frame_type != 0)
   {
   fprintf(stderr, " type=%x ", group_frame_type);
@@ -727,15 +740,15 @@
 
 /* If this is a special type of group frame, remember its offset for quick
 access at the end of the group. If this is a recursion, set a new current
 recursion value. */
 
 if (group_frame_type != 0)
   {
-  Flast_group_offset = (char *)F - (char *)mb->match_frames;
+  Flast_group_offset = (char *)F - (char *)match_data->heapframes;
   if (GF_IDMASK(group_frame_type) == GF_RECURSE)
     Fcurrent_recurse = GF_DATAMASK(group_frame_type);
   group_frame_type = 0;
   }
 
 
 /* ========================================================================= */
@@ -769,15 +782,15 @@
     if (Fcurrent_recurse == RECURSE_UNSET)
       {
       number = GET2(Fecode, 1);
       offset = Flast_group_offset;
       for(;;)
         {
         if (offset == PCRE2_UNSET) return PCRE2_ERROR_INTERNAL;
-        N = (heapframe *)((char *)mb->match_frames + offset);
+        N = (heapframe *)((char *)match_data->heapframes + offset);
         P = (heapframe *)((char *)N - frame_size);
         if (N->group_frame_type == (GF_CAPTURE | number)) break;
         offset = P->last_group_offset;
         }
       offset = (number << 1) - 2;
       Fcapture_last = number;
       Fovector[offset] = P->eptr - mb->start_subject;
@@ -807,15 +820,15 @@
 
     if (Fcurrent_recurse != RECURSE_UNSET)
       {
       offset = Flast_group_offset;
       for(;;)
         {
         if (offset == PCRE2_UNSET) return PCRE2_ERROR_INTERNAL;
-        N = (heapframe *)((char *)mb->match_frames + offset);
+        N = (heapframe *)((char *)match_data->heapframes + offset);
         P = (heapframe *)((char *)N - frame_size);
         if (GF_IDMASK(N->group_frame_type) == GF_RECURSE) break;
         offset = P->last_group_offset;
         }
 
       /* N is now the frame of the recursion; the previous frame is at the
       OP_RECURSE position. Go back there, copying the current subject position
@@ -860,22 +873,23 @@
     dynamically. It is only those at the end that need setting here. */
 
     mb->end_match_ptr = Feptr;           /* Record where we ended */
     mb->end_offset_top = Foffset_top;    /* and how many extracts were taken */
     mb->mark = Fmark;                    /* and the last success mark */
     if (Feptr > mb->last_used_ptr) mb->last_used_ptr = Feptr;
 
-    ovector[0] = Fstart_match - mb->start_subject;
-    ovector[1] = Feptr - mb->start_subject;
+    match_data->ovector[0] = Fstart_match - mb->start_subject;
+    match_data->ovector[1] = Feptr - mb->start_subject;
 
     /* Set i to the smaller of the sizes of the external and frame ovectors. */
 
-    i = 2 * ((top_bracket + 1 > oveccount)? oveccount : top_bracket + 1);
-    memcpy(ovector + 2, Fovector, (i - 2) * sizeof(PCRE2_SIZE));
-    while (--i >= Foffset_top + 2) ovector[i] = PCRE2_UNSET;
+    i = 2 * ((top_bracket + 1 > match_data->oveccount)?
+      match_data->oveccount : top_bracket + 1);
+    memcpy(match_data->ovector + 2, Fovector, (i - 2) * sizeof(PCRE2_SIZE));
+    while (--i >= Foffset_top + 2) match_data->ovector[i] = PCRE2_UNSET;
     return MATCH_MATCH;  /* Note: NOT RRETURN */
 
 
     /*===================================================================== */
     /* Match any single character type except newline; have to take care with
     CRLF newlines and partial matching. */
 
@@ -5324,15 +5338,15 @@
     recursions. (Some simple cases are caught at compile time.) */
 
     if (Fcurrent_recurse != RECURSE_UNSET)
       {
       offset = Flast_group_offset;
       while (offset != PCRE2_UNSET)
         {
-        N = (heapframe *)((char *)mb->match_frames + offset);
+        N = (heapframe *)((char *)match_data->heapframes + offset);
         P = (heapframe *)((char *)N - frame_size);
         if (N->group_frame_type == (GF_RECURSE | number))
           {
           if (Feptr == P->eptr) return PCRE2_ERROR_RECURSELOOP;
           break;
           }
         offset = P->last_group_offset;
@@ -5725,15 +5739,15 @@
     bracode = Fecode - GET(Fecode, 1);
 
     /* Point N to the frame at the start of the most recent group.
     Remember the subject pointer at the start of the group. */
 
     if (*bracode != OP_BRA && *bracode != OP_COND)
       {
-      N = (heapframe *)((char *)mb->match_frames + Flast_group_offset);
+      N = (heapframe *)((char *)match_data->heapframes + Flast_group_offset);
       P = (heapframe *)((char *)N - frame_size);
       Flast_group_offset = P->last_group_offset;
 
 #ifdef DEBUG_SHOW_RMATCH
       fprintf(stderr, "++ KET for frame=%d type=%x prev char offset=%lu\n",
         N->rdepth, N->group_frame_type,
         (char *)P->eptr - (char *)mb->start_subject);
@@ -6342,31 +6356,23 @@
 uint32_t fragment_options = 0;
 #ifdef SUPPORT_JIT
 BOOL jit_checked_utf = FALSE;
 #endif
 #endif  /* SUPPORT_UNICODE */
 
 PCRE2_SIZE frame_size;
+PCRE2_SIZE heapframes_size;
 
 /* We need to have mb as a pointer to a match block, because the IS_NEWLINE
 macro is used below, and it expects NLBLOCK to be defined as a pointer. */
 
 pcre2_callout_block cb;
 match_block actual_match_block;
 match_block *mb = &actual_match_block;
 
-/* Allocate an initial vector of backtracking frames on the stack. If this
-proves to be too small, it is replaced by a larger one on the heap. To get a
-vector of the size required that is aligned for pointers, allocate it as a
-vector of pointers. */
-
-PCRE2_SPTR stack_frames_vector[START_FRAMES_SIZE/sizeof(PCRE2_SPTR)]
-    PCRE2_KEEP_UNINITIALIZED;
-mb->stack_frames = (heapframe *)stack_frames_vector;
-
 /* Recognize NULL, length 0 as an empty string. */
 
 if (subject == NULL && length == 0) subject = (PCRE2_SPTR)"";
 
 /* Plausibility checks */
 
 if ((options & ~PUBLIC_MATCH_OPTIONS) != 0) return PCRE2_ERROR_BADOPTION;
@@ -6789,73 +6795,74 @@
   default: return PCRE2_ERROR_INTERNAL;
   }
 
 /* The backtracking frames have fixed data at the front, and a PCRE2_SIZE
 vector at the end, whose size depends on the number of capturing parentheses in
 the pattern. It is not used at all if there are no capturing parentheses.
 
-  frame_size             is the total size of each frame
-  mb->frame_vector_size  is the total usable size of the vector (rounded down
-                           to a whole number of frames)
-
-The last of these is changed within the match() function if the frame vector
-has to be expanded. We therefore put it into the match block so that it is
-correct when calling match() more than once for non-anchored patterns.
+  frame_size                   is the total size of each frame
+  match_data->heapframes       is the pointer to the frames vector
+  match_data->heapframes_size  is the total size of the vector
 
-We must also pad frame_size for alignment to ensure subsequent frames are as
+We must pad the frame_size for alignment to ensure subsequent frames are as
 aligned as heapframe. Whilst ovector is word-aligned due to being a PCRE2_SIZE
 array, that does not guarantee it is suitably aligned for pointers, as some
 architectures have pointers that are larger than a size_t. */
 
 frame_size = (offsetof(heapframe, ovector) +
   re->top_bracket * 2 * sizeof(PCRE2_SIZE) + HEAPFRAME_ALIGNMENT - 1) &
   ~(HEAPFRAME_ALIGNMENT - 1);
 
 /* Limits set in the pattern override the match context only if they are
 smaller. */
 
-mb->heap_limit = (mcontext->heap_limit < re->limit_heap)?
-  mcontext->heap_limit : re->limit_heap;
+mb->heap_limit = ((mcontext->heap_limit < re->limit_heap)?
+  mcontext->heap_limit : re->limit_heap) * 1024;
 
 mb->match_limit = (mcontext->match_limit < re->limit_match)?
   mcontext->match_limit : re->limit_match;
 
 mb->match_limit_depth = (mcontext->depth_limit < re->limit_depth)?
   mcontext->depth_limit : re->limit_depth;
 
 /* If a pattern has very many capturing parentheses, the frame size may be very
-large. Ensure that there are at least 10 available frames by getting an initial
-vector on the heap if necessary, except when the heap limit prevents this. Get
-fewer if possible. (The heap limit is in kibibytes.) */
-
-if (frame_size <= START_FRAMES_SIZE/10)
+large. Set the initial frame vector size to ensure that there are at least 10
+available frames, but enforce a minimum of START_FRAMES_SIZE. If this is
+greater than the heap limit, get as large a vector as possible. Always round
+the size to a multiple of the frame size. */
+
+heapframes_size = frame_size * 10;
+if (heapframes_size < START_FRAMES_SIZE) heapframes_size = START_FRAMES_SIZE;
+if (heapframes_size > mb->heap_limit)
   {
-  mb->match_frames = mb->stack_frames;   /* Initial frame vector on the stack */
-  mb->frame_vector_size = ((START_FRAMES_SIZE/frame_size) * frame_size);
+  if (frame_size > mb->heap_limit ) return PCRE2_ERROR_HEAPLIMIT;
+  heapframes_size = mb->heap_limit;
   }
-else
+
+/* If an existing frame vector in the match_data block is large enough, we can
+use it.Otherwise, free any pre-existing vector and get a new one. */
+
+if (match_data->heapframes_size < heapframes_size)
   {
-  mb->frame_vector_size = frame_size * 10;
-  if ((mb->frame_vector_size / 1024) > mb->heap_limit)
+  match_data->memctl.free(match_data->heapframes,
+    match_data->memctl.memory_data);
+  match_data->heapframes = match_data->memctl.malloc(heapframes_size,
+    match_data->memctl.memory_data);
+  if (match_data->heapframes == NULL)
     {
-    if (frame_size > mb->heap_limit * 1024) return PCRE2_ERROR_HEAPLIMIT;
-    mb->frame_vector_size = ((mb->heap_limit * 1024)/frame_size) * frame_size;
+    match_data->heapframes_size = 0;
+    return PCRE2_ERROR_NOMEMORY;
     }
-  mb->match_frames = mb->memctl.malloc(mb->frame_vector_size,
-    mb->memctl.memory_data);
-  if (mb->match_frames == NULL) return PCRE2_ERROR_NOMEMORY;
+  match_data->heapframes_size = heapframes_size;
   }
 
-mb->match_frames_top =
-  (heapframe *)((char *)mb->match_frames + mb->frame_vector_size);
-
 /* Write to the ovector within the first frame to mark every capture unset and
 to avoid uninitialized memory read errors when it is copied to a new frame. */
 
-memset((char *)(mb->match_frames) + offsetof(heapframe, ovector), 0xff,
+memset((char *)(match_data->heapframes) + offsetof(heapframe, ovector), 0xff,
   frame_size - offsetof(heapframe, ovector));
 
 /* Pointers to the individual character tables */
 
 mb->lcc = re->tables + lcc_offset;
 mb->fcc = re->tables + fcc_offset;
 mb->ctypes = re->tables + ctypes_offset;
@@ -7275,16 +7282,16 @@
 #else
   mb->moptions = options;
 #endif
   mb->match_call_count = 0;
   mb->end_offset_top = 0;
   mb->skip_arg_count = 0;
 
-  rc = match(start_match, mb->start_code, match_data->ovector,
-    match_data->oveccount, re->top_bracket, frame_size, mb);
+  rc = match(start_match, mb->start_code, re->top_bracket, frame_size,
+    match_data, mb);
 
   if (mb->hitend && start_partial == NULL)
     {
     start_partial = mb->start_used_ptr;
     match_partial = start_match;
     }
 
@@ -7459,19 +7466,14 @@
         goto FRAGMENT_RESTART;
         }
       }
     }
   }
 #endif  /* SUPPORT_UNICODE */
 
-/* Release an enlarged frame vector that is on the heap. */
-
-if (mb->match_frames != mb->stack_frames)
-  mb->memctl.free(mb->match_frames, mb->memctl.memory_data);
-
 /* Fill in fields that are always returned in the match data. */
 
 match_data->code = re;
 match_data->mark = mb->mark;
 match_data->matchedby = PCRE2_MATCHEDBY_INTERPRETER;
 
 /* Handle a fully successful match. Set the return code to the number of
@@ -7529,8 +7531,14 @@
 /* Else this is the classic nomatch case. */
 
 else match_data->rc = PCRE2_ERROR_NOMATCH;
 
 return match_data->rc;
 }
 
+/* These #undefs are here to enable unity builds with CMake. */
+
+#undef NLBLOCK /* Block containing newline information */
+#undef PSSTART /* Field containing processed string start */
+#undef PSEND   /* Field containing processed string end */
+
 /* End of pcre2_match.c */
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_match_data.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_match_data.c`

 * *Files 5% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 *************************************************/
 
 /* PCRE is a library of functions to support regular expressions whose syntax
 and semantics are as close as possible to those of the Perl 5 language.
 
                        Written by Philip Hazel
      Original API code Copyright (c) 1997-2012 University of Cambridge
-          New API code Copyright (c) 2016-2019 University of Cambridge
+          New API code Copyright (c) 2016-2022 University of Cambridge
 
 -----------------------------------------------------------------------------
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 
     * Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
@@ -47,27 +47,31 @@
 
 
 
 /*************************************************
 *  Create a match data block given ovector size  *
 *************************************************/
 
-/* A minimum of 1 is imposed on the number of ovector pairs. */
+/* A minimum of 1 is imposed on the number of ovector pairs. A maximum is also
+imposed because the oveccount field in a match data block is uintt6_t. */
 
 PCRE2_EXP_DEFN pcre2_match_data * PCRE2_CALL_CONVENTION
 pcre2_match_data_create(uint32_t oveccount, pcre2_general_context *gcontext)
 {
 pcre2_match_data *yield;
 if (oveccount < 1) oveccount = 1;
+if (oveccount > UINT16_MAX) oveccount = UINT16_MAX;
 yield = PRIV(memctl_malloc)(
   offsetof(pcre2_match_data, ovector) + 2*oveccount*sizeof(PCRE2_SIZE),
   (pcre2_memctl *)gcontext);
 if (yield == NULL) return NULL;
 yield->oveccount = oveccount;
 yield->flags = 0;
+yield->heapframes = NULL;
+yield->heapframes_size = 0;
 return yield;
 }
 
 
 
 /*************************************************
 *  Create a match data block using pattern data  *
@@ -91,14 +95,17 @@
 *************************************************/
 
 PCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION
 pcre2_match_data_free(pcre2_match_data *match_data)
 {
 if (match_data != NULL)
   {
+  if (match_data->heapframes != NULL)
+    match_data->memctl.free(match_data->heapframes,
+      match_data->memctl.memory_data);
   if ((match_data->flags & PCRE2_MD_COPIED_SUBJECT) != 0)
     match_data->memctl.free((void *)match_data->subject,
       match_data->memctl.memory_data);
   match_data->memctl.free(match_data, match_data->memctl.memory_data);
   }
 }
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_newline.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_newline.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_ord2utf.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_ord2utf.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_pattern_info.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_pattern_info.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_printint.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_printint.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_script_run.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_script_run.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_serialize.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_serialize.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_string_utils.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_string_utils.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_study.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_study.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_substitute.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_substitute.c`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 *************************************************/
 
 /* PCRE is a library of functions to support regular expressions whose syntax
 and semantics are as close as possible to those of the Perl 5 language.
 
                        Written by Philip Hazel
      Original API code Copyright (c) 1997-2012 University of Cambridge
-          New API code Copyright (c) 2016-2021 University of Cambridge
+          New API code Copyright (c) 2016-2022 University of Cambridge
 
 -----------------------------------------------------------------------------
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 
     * Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
@@ -255,39 +255,40 @@
 ovecsave[0] = ovecsave[1] = ovecsave[2] = PCRE2_UNSET;
 
 /* Partial matching is not valid. This must come after setting *blength to
 PCRE2_UNSET, so as not to imply an offset in the replacement. */
 
 if ((options & (PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT)) != 0)
   return PCRE2_ERROR_BADOPTION;
-  
-/* Validate length and find the end of the replacement. A NULL replacement of 
+
+/* Validate length and find the end of the replacement. A NULL replacement of
 zero length is interpreted as an empty string. */
 
-if (replacement == NULL) 
+if (replacement == NULL)
   {
   if (rlength != 0) return PCRE2_ERROR_NULL;
-  replacement = (PCRE2_SPTR)""; 
-  } 
-   
+  replacement = (PCRE2_SPTR)"";
+  }
+
 if (rlength == PCRE2_ZERO_TERMINATED) rlength = PRIV(strlen)(replacement);
 repend = replacement + rlength;
 
 /* Check for using a match that has already happened. Note that the subject
 pointer in the match data may be NULL after a no-match. */
 
 use_existing_match = ((options & PCRE2_SUBSTITUTE_MATCHED) != 0);
 replacement_only = ((options & PCRE2_SUBSTITUTE_REPLACEMENT_ONLY) != 0);
 
 /* If starting from an existing match, there must be an externally provided
 match data block. We create an internal match_data block in two cases: (a) an
 external one is not supplied (and we are not starting from an existing match);
 (b) an existing match is to be used for the first substitution. In the latter
-case, we copy the existing match into the internal block. This ensures that no
-changes are made to the existing match data block. */
+case, we copy the existing match into the internal block, except for any cached
+heap frame size and pointer. This ensures that no changes are made to the
+external match data block. */
 
 if (match_data == NULL)
   {
   pcre2_general_context *gcontext;
   if (use_existing_match) return PCRE2_ERROR_NULL;
   gcontext = (mcontext == NULL)?
     (pcre2_general_context *)code :
@@ -305,14 +306,16 @@
   int pairs = (code->top_bracket + 1 < match_data->oveccount)?
     code->top_bracket + 1 : match_data->oveccount;
   internal_match_data = pcre2_match_data_create(match_data->oveccount,
     gcontext);
   if (internal_match_data == NULL) return PCRE2_ERROR_NOMEMORY;
   memcpy(internal_match_data, match_data, offsetof(pcre2_match_data, ovector)
     + 2*pairs*sizeof(PCRE2_SIZE));
+  internal_match_data->heapframes = NULL;
+  internal_match_data->heapframes_size = 0;
   match_data = internal_match_data;
   }
 
 /* Remember ovector details */
 
 ovector = pcre2_get_ovector_pointer(match_data);
 ovector_count = pcre2_get_ovector_count(match_data);
@@ -324,17 +327,17 @@
 scb.output = (PCRE2_SPTR)buffer;
 scb.ovector = ovector;
 
 /* A NULL subject of zero length is treated as an empty string. */
 
 if (subject == NULL)
   {
-  if (length != 0) return PCRE2_ERROR_NULL; 
+  if (length != 0) return PCRE2_ERROR_NULL;
   subject = (PCRE2_SPTR)"";
-  } 
+  }
 
 /* Find length of zero-terminated subject */
 
 if (length == PCRE2_ZERO_TERMINATED)
   length = subject? PRIV(strlen)(subject) : 0;
 
 /* Check UTF replacement string if necessary. */
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_substring.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_substring.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_tables.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_tables.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_ucd.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_ucd.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_ucp.h` & `pcre2-0.2.0/src/libpcre2/src/pcre2_ucp.h`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_ucptables.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_ucptables.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_valid_utf.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_valid_utf.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2_xclass.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2_xclass.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2demo.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2demo.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2grep.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2grep.c`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 
 Note that for native z/OS, in addition to defining the NATIVE_ZOS macro, an
 additional header is required. That header is not included in the main PCRE2
 distribution because other apparatus is needed to compile pcre2grep for z/OS.
 The header can be found in the special z/OS distribution, which is available
 from www.zaconsultants.net or from www.cbttape.org.
 
-           Copyright (c) 1997-2020 University of Cambridge
+           Copyright (c) 1997-2022 University of Cambridge
 
 -----------------------------------------------------------------------------
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 
     * Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
@@ -201,42 +201,44 @@
 
 
 
 /*************************************************
 *               Global variables                 *
 *************************************************/
 
-/* Jeffrey Friedl has some debugging requirements that are not part of the
-regular code. */
-
 static const char *colour_string = "1;31";
 static const char *colour_option = NULL;
 static const char *dee_option = NULL;
 static const char *DEE_option = NULL;
 static const char *locale = NULL;
 static const char *newline_arg = NULL;
 static const char *om_separator = NULL;
 static const char *stdin_name = "(standard input)";
 static const char *output_text = NULL;
 
 static char *main_buffer = NULL;
 
+static const char *printname_nl = STDOUT_NL;  /* Changed to NULL for -Z */
+static int printname_colon = ':';             /* Changed to 0 for -Z */
+static int printname_hyphen = '-';            /* Changed to 0 for -Z */
+
 static int after_context = 0;
 static int before_context = 0;
 static int binary_files = BIN_BINARY;
 static int both_context = 0;
-static int bufthird = PCRE2GREP_BUFSIZE;
-static int max_bufthird = PCRE2GREP_MAX_BUFSIZE;
-static int bufsize = 3*PCRE2GREP_BUFSIZE;
 static int endlinetype;
 
 static int count_limit = -1;  /* Not long, so that it works with OP_NUMBER */
 static unsigned long int counts_printed = 0;
 static unsigned long int total_count = 0;
 
+static PCRE2_SIZE bufthird = PCRE2GREP_BUFSIZE;
+static PCRE2_SIZE max_bufthird = PCRE2GREP_MAX_BUFSIZE;
+static PCRE2_SIZE bufsize = 3*PCRE2GREP_BUFSIZE;
+
 #ifdef WIN32
 static int dee_action = dee_SKIP;
 #else
 static int dee_action = dee_READ;
 #endif
 
 static int DEE_action = DEE_READ;
@@ -255,19 +257,21 @@
 static uint32_t extra_options = 0;
 static PCRE2_SIZE heap_limit = PCRE2_UNSET;
 static uint32_t match_limit = 0;
 static uint32_t depth_limit = 0;
 
 static pcre2_compile_context *compile_context;
 static pcre2_match_context *match_context;
-static pcre2_match_data *match_data;
-static PCRE2_SIZE *offsets;
+static pcre2_match_data *match_data, *match_data_pair[2];
+static PCRE2_SIZE *offsets, *offsets_pair[2];
+static int match_data_toggle;
 static uint32_t offset_size;
 static uint32_t capture_max = DEFAULT_CAPTURE_MAX;
 
+static BOOL all_matches = FALSE;
 static BOOL count_only = FALSE;
 static BOOL do_colour = FALSE;
 #ifdef WIN32
 static BOOL do_ansi = FALSE;
 #endif
 static BOOL file_offsets = FALSE;
 static BOOL hyphenpending = FALSE;
@@ -421,16 +425,16 @@
 static option_item optionlist[] = {
   { OP_NODATA,     N_NULL,   NULL,              "",              "terminate options" },
   { OP_NODATA,     N_HELP,   NULL,              "help",          "display this help and exit" },
   { OP_NUMBER,     'A',      &after_context,    "after-context=number", "set number of following context lines" },
   { OP_NODATA,     'a',      NULL,              "text",          "treat binary files as text" },
   { OP_NUMBER,     'B',      &before_context,   "before-context=number", "set number of prior context lines" },
   { OP_BINFILES,   N_BINARY_FILES, NULL,        "binary-files=word", "set treatment of binary files" },
-  { OP_NUMBER,     N_BUFSIZE,&bufthird,         "buffer-size=number", "set processing buffer starting size" },
-  { OP_NUMBER,     N_MAX_BUFSIZE,&max_bufthird, "max-buffer-size=number",  "set processing buffer maximum size" },
+  { OP_SIZE,       N_BUFSIZE,&bufthird,         "buffer-size=number", "set processing buffer starting size" },
+  { OP_SIZE,       N_MAX_BUFSIZE,&max_bufthird, "max-buffer-size=number",  "set processing buffer maximum size" },
   { OP_OP_STRING,  N_COLOUR, &colour_option,    "color=option",  "matched text color option" },
   { OP_OP_STRING,  N_COLOUR, &colour_option,    "colour=option", "matched text colour option" },
   { OP_NUMBER,     'C',      &both_context,     "context=number", "set number of context lines, before & after" },
   { OP_NODATA,     'c',      NULL,              "count",         "print only a count of matching lines per FILE" },
   { OP_STRING,     'D',      &DEE_option,       "devices=action","how to handle devices, FIFOs, and sockets" },
   { OP_STRING,     'd',      &dee_option,       "directories=action", "how to handle directories" },
   { OP_PATLIST,    'e',      &match_patdata,    "regex(p)=pattern", "specify pattern (may be used more than once)" },
@@ -478,14 +482,15 @@
   { OP_NODATA,    'u',      NULL,              "utf",           "use UTF mode" },
   { OP_NODATA,    'U',      NULL,              "utf-allow-invalid", "use UTF mode, allow for invalid code units" },
   { OP_NODATA,    'V',      NULL,              "version",       "print version information and exit" },
   { OP_NODATA,    'v',      NULL,              "invert-match",  "select non-matching lines" },
   { OP_NODATA,    'w',      NULL,              "word-regex(p)", "force patterns to match only as words"  },
   { OP_NODATA,    'x',      NULL,              "line-regex(p)", "force patterns to match only whole lines" },
   { OP_NODATA,   N_ALLABSK, NULL,              "allow-lookaround-bsk", "allow \\K in lookarounds" },
+  { OP_NODATA,    'Z',      NULL,              "null",          "output 0 byte after file names"  },
   { OP_NODATA,    0,        NULL,               NULL,            NULL }
 };
 
 /* Table of names for newline types. Must be kept in step with the definitions
 of PCRE2_NEWLINE_xx in pcre2.h. */
 
 static const char *newlines[] = {
@@ -671,26 +676,32 @@
 Returns:     new pattern block or NULL on error
 */
 
 static patstr *
 add_pattern(char *s, PCRE2_SIZE patlen, patstr *after)
 {
 patstr *p = (patstr *)malloc(sizeof(patstr));
+
+/* LCOV_EXCL_START - These won't be hit in normal testing. */
+
 if (p == NULL)
   {
   fprintf(stderr, "pcre2grep: malloc failed\n");
   pcre2grep_exit(2);
   }
 if (patlen > MAXPATLEN)
   {
   fprintf(stderr, "pcre2grep: pattern is too long (limit is %d bytes)\n",
     MAXPATLEN);
   free(p);
   return NULL;
   }
+
+/* LCOV_EXCL_STOP */
+
 p->next = NULL;
 p->string = s;
 p->length = patlen;
 p->compiled = NULL;
 
 if (after != NULL)
   {
@@ -1364,19 +1375,24 @@
 */
 
 static omstr *
 add_number(int n, omstr *after)
 {
 omstr *om = (omstr *)malloc(sizeof(omstr));
 
+/* LCOV_EXCL_START - These lines won't be hit in normal testing. */
+
 if (om == NULL)
   {
   fprintf(stderr, "pcre2grep: malloc failed\n");
   pcre2grep_exit(2);
   }
+
+/* LCOV_EXCL_STOP */
+
 om->next = NULL;
 om->groupnum = n;
 
 if (after != NULL)
   {
   om->next = after->next;
   after->next = om;
@@ -1404,18 +1420,18 @@
   length     the maximum number of characters to read
   f          the file
 
 Returns:     the number of characters read, zero at end of file
 */
 
 static PCRE2_SIZE
-read_one_line(char *buffer, int length, FILE *f)
+read_one_line(char *buffer, PCRE2_SIZE length, FILE *f)
 {
 int c;
-int yield = 0;
+PCRE2_SIZE yield = 0;
 while ((c = fgetc(f)) != EOF)
   {
   buffer[yield++] = c;
   if (c == '\n' || yield >= length) break;
   }
 return yield;
 }
@@ -1768,15 +1784,15 @@
   {
   int count = 0;
   int ellength = 0;
   while (lastmatchrestart < endptr && count < after_context)
     {
     char *pp = end_of_line(lastmatchrestart, endptr, &ellength);
     if (ellength == 0 && pp == main_buffer + bufsize) break;
-    if (printname != NULL) fprintf(stdout, "%s-", printname);
+    if (printname != NULL) fprintf(stdout, "%s%c", printname, printname_hyphen);
     if (number) fprintf(stdout, "%lu-", lastmatchnumber++);
     FWRITE_IGNORE(lastmatchrestart, 1, pp - lastmatchrestart, stdout);
     lastmatchrestart = pp;
     count++;
     }
 
   /* If we have printed any lines, arrange for a hyphen separator if anything
@@ -1794,76 +1810,115 @@
 
 
 
 /*************************************************
 *   Apply patterns to subject till one matches   *
 *************************************************/
 
-/* This function is called to run through all patterns, looking for a match. It
-is used multiple times for the same subject when colouring is enabled, in order
-to find all possible matches.
+/* This function is called to run through all the patterns, looking for a
+match. When all possible matches are required, for example, for colouring, it
+checks all patterns for matching, and returns the earliest match. Otherwise, it
+returns the first pattern that has matched.
 
 Arguments:
   matchptr     the start of the subject
   length       the length of the subject to match
   options      options for pcre2_match
   startoffset  where to start matching
   mrc          address of where to put the result of pcre2_match()
 
-Returns:      TRUE if there was a match
-              FALSE if there was no match
-              invert if there was a non-fatal error
+Returns:       TRUE if there was a match, match_data and offsets are set
+               FALSE if there was no match (but no errors)
+               invert if there was a non-fatal error
 */
 
 static BOOL
 match_patterns(char *matchptr, PCRE2_SIZE length, unsigned int options,
   PCRE2_SIZE startoffset, int *mrc)
 {
-int i;
 PCRE2_SIZE slen = length;
+int first = -1;
+int firstrc = 0;
 patstr *p = patterns;
 const char *msg = "this text:\n\n";
 
 if (slen > 200)
   {
   slen = 200;
   msg = "text that starts:\n\n";
   }
 
-for (i = 1; p != NULL; p = p->next, i++)
+for (int i = 1; p != NULL; p = p->next, i++)
   {
-  *mrc = pcre2_match(p->compiled, (PCRE2_SPTR)matchptr, (int)length,
+  int rc = pcre2_match(p->compiled, (PCRE2_SPTR)matchptr, (int)length,
     startoffset, options, match_data, match_context);
-  if (*mrc >= 0) return TRUE;
-  if (*mrc == PCRE2_ERROR_NOMATCH) continue;
-  fprintf(stderr, "pcre2grep: pcre2_match() gave error %d while matching ", *mrc);
+  if (rc == PCRE2_ERROR_NOMATCH) continue;
+
+  /* Handle a successful match. When all_matches is false, we are done.
+  Otherwise we must save the earliest match. */
+
+  if (rc >= 0)
+    {
+    if (!all_matches)
+      {
+      *mrc = rc;
+      return TRUE;
+      }
+
+    if (first < 0 || offsets[0] < offsets_pair[first][0] ||
+         (offsets[0] == offsets_pair[first][0] &&
+          offsets[1] > offsets_pair[first][1]))
+      {
+      first = match_data_toggle;
+      firstrc = rc;
+      match_data_toggle ^= 1;
+      match_data = match_data_pair[match_data_toggle];
+      offsets = offsets_pair[match_data_toggle];
+      }
+    continue;
+    }
+
+  /* Deal with PCRE2 error. */
+
+  fprintf(stderr, "pcre2grep: pcre2_match() gave error %d while matching ", rc);
   if (patterns->next != NULL) fprintf(stderr, "pattern number %d to ", i);
   fprintf(stderr, "%s", msg);
   FWRITE_IGNORE(matchptr, 1, slen, stderr);   /* In case binary zero included */
   fprintf(stderr, "\n\n");
-  if (*mrc <= PCRE2_ERROR_UTF8_ERR1 &&
-      *mrc >= PCRE2_ERROR_UTF8_ERR21)
+  if (rc <= PCRE2_ERROR_UTF8_ERR1 &&
+      rc >= PCRE2_ERROR_UTF8_ERR21)
     {
     unsigned char mbuffer[256];
     PCRE2_SIZE startchar = pcre2_get_startchar(match_data);
-    (void)pcre2_get_error_message(*mrc, mbuffer, sizeof(mbuffer));
+    (void)pcre2_get_error_message(rc, mbuffer, sizeof(mbuffer));
     fprintf(stderr, "%s at offset %" SIZ_FORM "\n\n", mbuffer, startchar);
     }
-  if (*mrc == PCRE2_ERROR_MATCHLIMIT || *mrc == PCRE2_ERROR_DEPTHLIMIT ||
-      *mrc == PCRE2_ERROR_HEAPLIMIT || *mrc == PCRE2_ERROR_JIT_STACKLIMIT)
+  if (rc == PCRE2_ERROR_MATCHLIMIT || rc == PCRE2_ERROR_DEPTHLIMIT ||
+      rc == PCRE2_ERROR_HEAPLIMIT || rc == PCRE2_ERROR_JIT_STACKLIMIT)
     resource_error = TRUE;
   if (error_count++ > 20)
     {
     fprintf(stderr, "pcre2grep: Too many errors - abandoned.\n");
     pcre2grep_exit(2);
     }
   return invert;    /* No more matching; don't show the line again */
   }
 
-return FALSE;  /* No match, no errors */
+/* We get here when all patterns have been tried. If all_matches is false,
+this means that none of them matched. If all_matches is true, matched_first
+will be non-NULL if there was at least one match, and it will point to the
+appropriate match_data block. */
+
+if (!all_matches || first < 0) return FALSE;
+
+match_data_toggle = first;
+match_data = match_data_pair[first];
+offsets = offsets_pair[first];
+*mrc = firstrc;
+return TRUE;
 }
 
 
 
 /*************************************************
 *          Decode dollar escape sequence         *
 *************************************************/
@@ -2156,26 +2211,27 @@
           {
           print_match(subject + ovector[value], capturesize);
           printed = TRUE;
           }
         }
       continue;
 
+      /* LCOV_EXCL_START */
       default:  /* Should not occur */
       break;
+      /* LCOV_EXCL_STOP */
       }
     }
 
   else value = *string;  /* Not a $ escape */
 
-  if (utf && value <= 127) fprintf(stdout, "%c", *string); else
+  if (!utf || value <= 127) fprintf(stdout, "%c", value); else
     {
-    int i;
     int n = ord2utf8(value);
-    for (i = 0; i < n; i++) fputc(utf8_buffer[i], stdout);
+    for (int i = 0; i < n; i++) fputc(utf8_buffer[i], stdout);
     }
 
   printed = TRUE;
   }
 
 return printed;
 }
@@ -2299,17 +2355,19 @@
       break;
 
       case DDE_CHAR:
       if (value == STDOUT_NL_CODE) argslen += STDOUT_NL_LEN - 1;
         else if (utf && value > 127) argslen += ord2utf8(value) - 1;
       break;
 
+      /* LCOV_EXCL_START */
       default:         /* Should not occur */
       case DDE_ERROR:
       return 0;
+      /* LCOV_EXCL_STOP */
       }
 
     length -= (string - begin);
     }
 
   string++;
   length--;
@@ -2320,16 +2378,18 @@
 
 args = (char*)malloc(argslen);
 if (args == NULL) return 0;
 
 argsvector = (char**)malloc(argsvectorlen * sizeof(char*));
 if (argsvector == NULL)
   {
+  /* LCOV_EXCL_START */
   free(args);
   return 0;
+  /* LCOV_EXCL_STOP */
   }
 
 /* Now reprocess the string and set up the arguments. */
 
 argsptr = args;
 argsvectorptr = argsvector;
 *argsvectorptr++ = argsptr;
@@ -2377,19 +2437,21 @@
         }
       else
         {
         *argsptr++ = value;
         }
       break;
 
+      /* LCOV_EXCL_START */
       default:         /* Even though this should not occur, the string having */
       case DDE_ERROR:  /* been checked above, we need to include the free() */
       free(args);      /* calls so that source checkers do not complain. */
       free(argsvector);
       return 0;
+      /* LCOV_EXCL_STOP */
       }
 
     length -= (string - begin);
     }
 
   else *argsptr++ = *string;
 
@@ -2433,15 +2495,19 @@
 if (pid == 0)
   {
   (void)execv(argsvector[0], argsvector);
   /* Control gets here if there is an error, e.g. a non-existent program */
   exit(1);
   }
 else if (pid > 0)
+  {
+  (void)fflush(stdout);
   (void)waitpid(pid, &result, 0);
+  (void)fflush(stdout);
+  }
 #endif  /* End Windows/VMS/other handling */
 
 free(args);
 free(argsvector);
 
 /* Currently negative return values are not supported, only zero (match
 continues) or non-zero (match fails). */
@@ -2453,29 +2519,29 @@
 
 
 
 /*************************************************
 *     Read a portion of the file into buffer     *
 *************************************************/
 
-static int
-fill_buffer(void *handle, int frtype, char *buffer, int length,
+static PCRE2_SIZE
+fill_buffer(void *handle, int frtype, char *buffer, PCRE2_SIZE length,
   BOOL input_line_buffered)
 {
 (void)frtype;  /* Avoid warning when not used */
 
 #ifdef SUPPORT_LIBZ
 if (frtype == FR_LIBZ)
   return gzread((gzFile)handle, buffer, length);
 else
 #endif
 
 #ifdef SUPPORT_LIBBZ2
 if (frtype == FR_LIBBZ2)
-  return BZ2_bzread((BZFILE *)handle, buffer, length);
+  return (PCRE2_SIZE)BZ2_bzread((BZFILE *)handle, buffer, length);
 else
 #endif
 
 return (input_line_buffered ?
   read_one_line(buffer, length, (FILE *)handle) :
   fread(buffer, 1, length, (FILE *)handle));
 }
@@ -2533,31 +2599,29 @@
 of what we have. In the case of libz, a non-zipped .gz file will be read as a
 plain file. However, if a .bz2 file isn't actually bzipped, the first read will
 fail. */
 
 if (frtype != FR_LIBZ && frtype != FR_LIBBZ2)
   {
   in = (FILE *)handle;
-  if (feof(in))
-    return 1;
-  if (is_file_tty(in))
-    input_line_buffered = TRUE;
+  if (feof(in)) return 1;
+  if (is_file_tty(in)) input_line_buffered = TRUE;
   else
     {
     if (count_limit >= 0  && filename == stdin_name)
       stream_start = ftell(in);
     }
   }
 else input_line_buffered = FALSE;
 
 bufflength = fill_buffer(handle, frtype, main_buffer, bufsize,
   input_line_buffered);
 
 #ifdef SUPPORT_LIBBZ2
-if (frtype == FR_LIBBZ2 && (int)bufflength < 0) return 2;   /* Gotcha: bufflength is PCRE2_SIZE */
+if (frtype == FR_LIBBZ2 && (int)bufflength < 0) return 3;   /* Gotcha: bufflength is PCRE2_SIZE */
 #endif
 
 endptr = main_buffer + bufflength;
 
 /* Unless binary-files=text, see if we have a binary file. This uses the same
 rule as GNU grep, namely, a search for a binary zero byte near the start of the
 file. However, when the newline convention is binary zero, we can't do this. */
@@ -2616,29 +2680,32 @@
   try doubling it and reading more data. */
 
   if (endlinelength == 0 && t == main_buffer + bufsize)
     {
     if (bufthird < max_bufthird)
       {
       char *new_buffer;
-      int new_bufthird = 2*bufthird;
+      PCRE2_SIZE new_bufthird = 2*bufthird;
 
       if (new_bufthird > max_bufthird) new_bufthird = max_bufthird;
       new_buffer = (char *)malloc(3*new_bufthird);
 
       if (new_buffer == NULL)
         {
+        /* LCOV_EXCL_START */
         fprintf(stderr,
           "pcre2grep: line %lu%s%s is too long for the internal buffer\n"
-          "pcre2grep: not enough memory to increase the buffer size to %d\n",
+          "pcre2grep: not enough memory to increase the buffer size to %"
+            SIZ_FORM "\n",
           linenumber,
           (filename == NULL)? "" : " of file ",
           (filename == NULL)? "" : filename,
           new_bufthird);
         return 2;
+        /* LCOV_EXCL_STOP */
         }
 
       /* Copy the data and adjust pointers to the new buffer location. */
 
       memcpy(new_buffer, main_buffer, bufsize);
       bufthird = new_bufthird;
       bufsize = 3*bufthird;
@@ -2655,15 +2722,15 @@
       endptr = main_buffer + bufflength;
       continue;
       }
     else
       {
       fprintf(stderr,
         "pcre2grep: line %lu%s%s is too long for the internal buffer\n"
-        "pcre2grep: the maximum buffer size is %d\n"
+        "pcre2grep: the maximum buffer size is %" SIZ_FORM "\n"
         "pcre2grep: use the --max-buffer-size option to change it\n",
         linenumber,
         (filename == NULL)? "" : " of file ",
         (filename == NULL)? "" : filename,
         bufthird);
       return 2;
       }
@@ -2720,15 +2787,17 @@
       }
 
     /* Likewise, if all we want is a file name, there is no need to scan any
     more lines in the file. */
 
     else if (filenames == FN_MATCH_ONLY)
       {
-      fprintf(stdout, "%s" STDOUT_NL, printname);
+      fprintf(stdout, "%s", printname);
+      if (printname_nl == NULL) fprintf(stdout, "%c", 0);
+        else fprintf(stdout, "%s", printname_nl);
       return 0;
       }
 
     /* The --only-matching option prints just the substring that matched,
     and/or one or more captured portions of it, as long as these strings are
     not empty. The --file-offsets and --line-offsets options output offsets for
     the matching substring (all three set only_matching_count non-zero). None
@@ -2739,15 +2808,16 @@
 
     else if (only_matching_count != 0)
       {
       if (!invert)
         {
         PCRE2_SIZE oldstartoffset;
 
-        if (printname != NULL) fprintf(stdout, "%s:", printname);
+        if (printname != NULL) fprintf(stdout, "%s%c", printname,
+          printname_colon);
         if (number) fprintf(stdout, "%lu:", linenumber);
 
         /* Handle --line-offsets */
 
         if (line_offsets)
           fprintf(stdout, "%d,%d" STDOUT_NL, (int)(ptr + offsets[0] - ptr),
             (int)(offsets[1] - offsets[0]));
@@ -2759,18 +2829,17 @@
             (int)(filepos + ptr + offsets[0] - ptr),
             (int)(offsets[1] - offsets[0]));
 
         /* Handle --output (which has already been syntax checked) */
 
         else if (output_text != NULL)
           {
-          if (display_output_text((PCRE2_SPTR)output_text, FALSE,
-              (PCRE2_SPTR)ptr, offsets, mrc) || printname != NULL ||
-              number)
-            fprintf(stdout, STDOUT_NL);
+          (void)display_output_text((PCRE2_SPTR)output_text, FALSE,
+              (PCRE2_SPTR)ptr, offsets, mrc);
+          fprintf(stdout, STDOUT_NL);
           }
 
         /* Handle --only-matching, which may occur many times */
 
         else
           {
           BOOL printed = FALSE;
@@ -2787,15 +2856,14 @@
                 if (printed && om_separator != NULL)
                   fprintf(stdout, "%s", om_separator);
                 print_match(ptr + offsets[n*2], plen);
                 printed = TRUE;
                 }
               }
             }
-
           if (printed || printname != NULL || number)
             fprintf(stdout, STDOUT_NL);
           }
 
         /* Prepare to repeat to find the next match in the line. */
 
         match = FALSE;
@@ -2861,15 +2929,16 @@
         /* It is important to advance lastmatchrestart during this printing so
         that it interacts correctly with any "before" printing below. Print
         each line's data using fwrite() in case there are binary zeroes. */
 
         while (lastmatchrestart < p)
           {
           char *pp = lastmatchrestart;
-          if (printname != NULL) fprintf(stdout, "%s-", printname);
+          if (printname != NULL) fprintf(stdout, "%s%c", printname,
+            printname_hyphen);
           if (number) fprintf(stdout, "%lu-", lastmatchnumber++);
           pp = end_of_line(pp, endptr, &ellength);
           FWRITE_IGNORE(lastmatchrestart, 1, pp - lastmatchrestart, stdout);
           lastmatchrestart = pp;
           }
         if (lastmatchrestart != ptr) hyphenpending = TRUE;
         }
@@ -2902,29 +2971,31 @@
         if (lastmatchnumber > 0 && p > lastmatchrestart && !hyphenprinted)
           fprintf(stdout, "--" STDOUT_NL);
 
         while (p < ptr)
           {
           int ellength;
           char *pp = p;
-          if (printname != NULL) fprintf(stdout, "%s-", printname);
+          if (printname != NULL) fprintf(stdout, "%s%c", printname,
+            printname_hyphen);
           if (number) fprintf(stdout, "%lu-", linenumber - linecount--);
           pp = end_of_line(pp, endptr, &ellength);
           FWRITE_IGNORE(p, 1, pp - p, stdout);
           p = pp;
           }
         }
 
       /* Now print the matching line(s); ensure we set hyphenpending at the end
       of the file if any context lines are being output. */
 
       if (after_context > 0 || before_context > 0)
         endhyphenpending = TRUE;
 
-      if (printname != NULL) fprintf(stdout, "%s:", printname);
+      if (printname != NULL) fprintf(stdout, "%s%c", printname,
+        printname_colon);
       if (number) fprintf(stdout, "%lu:", linenumber);
 
       /* In multiline mode, or if colouring, we have to split the line(s) up
       and search for further matches, but not of course if the line is a
       non-match. In multiline mode this is necessary in case there is another
       match that spans the end of the current line. When colouring we want to
       colour all matches. */
@@ -3072,15 +3143,15 @@
   if (line_matched) count_matched_lines++;
 
   /* If input is line buffered, and the buffer is not yet full, read another
   line and add it into the buffer. */
 
   if (input_line_buffered && bufflength < (PCRE2_SIZE)bufsize)
     {
-    int add = read_one_line(ptr, bufsize - (int)(ptr - main_buffer), in);
+    PCRE2_SIZE add = read_one_line(ptr, bufsize - (ptr - main_buffer), in);
     bufflength += add;
     endptr += add;
     }
 
   /* If we haven't yet reached the end of the file (the buffer is full), and
   the current point is in the top 1/3 of the buffer, slide the buffer down by
   1/3 and refill it. Before we do this, if some unprinted "after" lines are
@@ -3121,26 +3192,28 @@
   }
 
 /* Print the file name if we are looking for those without matches and there
 were none. If we found a match, we won't have got this far. */
 
 if (filenames == FN_NOMATCH_ONLY)
   {
-  fprintf(stdout, "%s" STDOUT_NL, printname);
+  fprintf(stdout, "%s", printname);
+  if (printname_nl == NULL) fprintf(stdout, "%c", 0);
+    else fprintf(stdout, "%s", printname_nl);
   return 0;
   }
 
 /* Print the match count if wanted */
 
 if (count_only && !quiet)
   {
   if (count > 0 || !omit_zero_count)
     {
     if (printname != NULL && filenames != FN_NONE)
-      fprintf(stdout, "%s:", printname);
+      fprintf(stdout, "%s%c", printname, printname_colon);
     fprintf(stdout, "%lu" STDOUT_NL, count);
     counts_printed++;
     }
   }
 
 total_count += count;   /* Can be set without count_only */
 return rc;
@@ -3264,29 +3337,33 @@
     {
     char childpath[FNBUFSIZ];
     char *nextfile;
     directory_type *dir = opendirectory(pathname);
 
     if (dir == NULL)
       {
+      /* LCOV_EXCL_START - this is a "never" event */
       if (!silent)
         fprintf(stderr, "pcre2grep: Failed to open directory %s: %s\n", pathname,
           strerror(errno));
       return 2;
+      /* LCOV_EXCL_STOP */
       }
 
     while ((nextfile = readdirectory(dir)) != NULL)
       {
       int frc;
       int fnlength = strlen(pathname) + strlen(nextfile) + 2;
       if (fnlength > FNBUFSIZ)
         {
+        /* LCOV_EXCL_START - this is a "never" event */
         fprintf(stderr, "pcre2grep: recursive filename is too long\n");
         rc = 2;
         break;
+        /* LCOV_EXCL_STOP */
         }
       sprintf(childpath, "%s%c%s", pathname, FILESEP, nextfile);
 
       /* If the realpath() function is available, we can try to prevent endless
       recursion caused by a symlink pointing to a parent directory (GitHub
       issue #2 (old Bugzilla #2794). Original patch from Thomas Tempelmann.
       Modified to avoid using strlcat() because that isn't a standard C
@@ -3295,15 +3372,17 @@
 
 #ifdef HAVE_REALPATH
       {
       char resolvedpath[PATH_MAX];
       BOOL isSame;
       size_t rlen;
       if (realpath(childpath, resolvedpath) == NULL)
+        /* LCOV_EXCL_START - this is a "never" event */
         continue;     /* This path is invalid - we can skip processing this */
+        /* LCOV_EXCL_STOP */
       isSame = strcmp(pathname, resolvedpath) == 0;
       if (isSame) continue;    /* We have a recursion */
       rlen = strlen(resolvedpath);
       if (rlen++ < sizeof(resolvedpath) - 3)
         {
         BOOL contained;
         strcat(resolvedpath, "/");
@@ -3384,18 +3463,20 @@
 
 #ifdef SUPPORT_LIBZ
 if (pathlen > 3 && strcmp(pathname + pathlen - 3, ".gz") == 0)
   {
   ingz = gzopen(pathname, "rb");
   if (ingz == NULL)
     {
+    /* LCOV_EXCL_START */
     if (!silent)
       fprintf(stderr, "pcre2grep: Failed to open %s: %s\n", pathname,
         strerror(errno));
     return 2;
+    /* LCOV_EXCL_STOP */
     }
   handle = (void *)ingz;
   frtype = FR_LIBZ;
   }
 else
 #endif
 
@@ -3458,18 +3539,20 @@
     int errnum;
     const char *err = BZ2_bzerror(inbz2, &errnum);
     if (errnum == BZ_DATA_ERROR_MAGIC)
       {
       BZ2_bzclose(inbz2);
       goto PLAIN_FILE;
       }
+    /* LCOV_EXCL_START */
     else if (!silent)
       fprintf(stderr, "pcre2grep: Failed to read %s using bzlib: %s\n",
         pathname, err);
     rc = 2;    /* The normal "something went wrong" code */
+    /* LCOV_EXCL_STOP */
     }
   BZ2_bzclose(inbz2);
   }
 else
 #endif
 
 /* Normal file close */
@@ -3483,14 +3566,16 @@
 
 
 
 /*************************************************
 *          Handle a no-data option               *
 *************************************************/
 
+/* This is called when a known option has been identified. */
+
 static int
 handle_option(int letter, int options)
 {
 switch(letter)
   {
   case N_FOFFSETS: file_offsets = TRUE; break;
   case N_HELP: help(); pcre2grep_exit(0); break; /* Stops compiler warning */
@@ -3518,29 +3603,33 @@
   case 'q': quiet = TRUE; break;
   case 'r': dee_action = dee_RECURSE; break;
   case 's': silent = TRUE; break;
   case 't': show_total_count = TRUE; break;
   case 'u': options |= PCRE2_UTF; utf = TRUE; break;
   case 'U': options |= PCRE2_UTF|PCRE2_MATCH_INVALID_UTF; utf = TRUE; break;
   case 'v': invert = TRUE; break;
-  case 'w': extra_options |= PCRE2_EXTRA_MATCH_WORD; break;
-  case 'x': extra_options |= PCRE2_EXTRA_MATCH_LINE; break;
 
   case 'V':
     {
     unsigned char buffer[128];
     (void)pcre2_config(PCRE2_CONFIG_VERSION, buffer);
     fprintf(stdout, "pcre2grep version %s" STDOUT_NL, buffer);
     }
   pcre2grep_exit(0);
-  break;
+  break;  /* LCOV_EXCL_LINE - statement kept to avoid compiler warning */
 
+  case 'w': extra_options |= PCRE2_EXTRA_MATCH_WORD; break;
+  case 'x': extra_options |= PCRE2_EXTRA_MATCH_LINE; break;
+  case 'Z': printname_colon = printname_hyphen = 0; printname_nl = NULL; break;
+
+  /* LCOV_EXCL_START - this is a "never event" */
   default:
   fprintf(stderr, "pcre2grep: Unknown option -%c\n", letter);
   pcre2grep_exit(usage(2));
+  /* LCOV_EXCL_STOP */
   }
 
 return options;
 }
 
 
 
@@ -3710,16 +3799,18 @@
   "buffer" into the pattern chain. However, that pointer is used only when
   compiling the pattern, which happens immediately below, so we flatten it
   afterwards, as a precaution against any later code trying to use it. */
 
   *patlastptr = add_pattern(buffer, patlen, *patlastptr);
   if (*patlastptr == NULL)
     {
+    /* LCOV_EXCL_START - won't happen in testing */
     if (f != stdin) fclose(f);
     return FALSE;
+    /* LCOV_EXCL_STOP */
     }
   if (*patptr == NULL) *patptr = *patlastptr;
 
   /* This loop is needed because compiling a "pattern" when -F is set may add
   on additional literal patterns if the original contains a newline. In the
   common case, it never will, because read_one_line() stops at a newline.
   However, the -N option can be used to give pcre2grep a different newline
@@ -3864,17 +3955,19 @@
 
         if ((ret = snprintf(buff1, sizeof(buff1), "%.*s", baselen, op->long_name),
              ret < 0 || ret > (int)sizeof(buff1)) ||
             (ret = snprintf(buff2, sizeof(buff2), "%s%.*s", buff1,
                      fulllen - baselen - 2, opbra + 1),
              ret < 0 || ret > (int)sizeof(buff2)))
           {
+          /* LCOV_EXCL_START - this is a "never" event */
           fprintf(stderr, "pcre2grep: Buffer overflow when parsing %s option\n",
             op->long_name);
           pcre2grep_exit(2);
+          /* LCOV_EXCL_STOP */
           }
 
         if (strncmp(arg, buff1, arglen) == 0 ||
            strncmp(arg, buff2, arglen) == 0)
           {
           if (equals != NULL && argequals != NULL)
             {
@@ -4020,16 +4113,18 @@
 
   else if (op->type == OP_FILELIST)
     {
     fndatastr *fd = (fndatastr *)op->dataptr;
     fn = (fnstr *)malloc(sizeof(fnstr));
     if (fn == NULL)
       {
+      /* LCOV_EXCL_START */
       fprintf(stderr, "pcre2grep: malloc failed\n");
       goto EXIT2;
+      /* LCOV_EXCL_STOP */
       }
     fn->next = NULL;
     fn->name = option_data;
     if (*(fd->anchor) == NULL)
       *(fd->anchor) = fn;
     else
       (*(fd->lastptr))->next = fn;
@@ -4089,15 +4184,14 @@
 if (only_matching_count > 1)
   {
   fprintf(stderr, "pcre2grep: Cannot mix --only-matching, --output, "
     "--file-offsets and/or --line-offsets\n");
   pcre2grep_exit(usage(2));
   }
 
-
 /* Check that there is a big enough ovector for all -o settings. */
 
 for (om = only_matching; om != NULL; om = om->next)
   {
   int n = om->groupnum;
   if (n > (int)capture_max)
     {
@@ -4109,21 +4203,26 @@
 
 /* Check the text supplied to --output for errors. */
 
 if (output_text != NULL &&
     !syntax_check_output_text((PCRE2_SPTR)output_text, FALSE))
   goto EXIT2;
 
-/* Set up default compile and match contexts and a match data block. */
+/* Set up default compile and match contexts and match data blocks. */
 
 offset_size = capture_max + 1;
 compile_context = pcre2_compile_context_create(NULL);
 match_context = pcre2_match_context_create(NULL);
-match_data = pcre2_match_data_create(offset_size, NULL);
-offsets = pcre2_get_ovector_pointer(match_data);
+match_data_pair[0] = pcre2_match_data_create(offset_size, NULL);
+match_data_pair[1] = pcre2_match_data_create(offset_size, NULL);
+offsets_pair[0] = pcre2_get_ovector_pointer(match_data_pair[0]);
+offsets_pair[1] = pcre2_get_ovector_pointer(match_data_pair[1]);
+match_data = match_data_pair[0];
+offsets = offsets_pair[0];
+match_data_toggle = 0;
 
 /* If string (script) callouts are supported, set up the callout processing
 function. */
 
 #ifdef SUPPORT_PCRE2GREP_CALLOUT
 pcre2_set_callout(match_context, pcre2grep_callout, NULL);
 #endif
@@ -4194,14 +4293,19 @@
       }
 #ifdef WIN32
     init_colour_output();
 #endif
     }
   }
 
+/* When colouring or otherwise identifying matching substrings, we need to find
+all possible matches when there are multiple patterns. */
+
+all_matches = do_colour || only_matching_count != 0;
+
 /* Sort out a newline setting. */
 
 if (newline_arg != NULL)
   {
   for (endlinetype = 1; endlinetype < (int)(sizeof(newlines)/sizeof(char *));
        endlinetype++)
     {
@@ -4249,16 +4353,14 @@
     }
   }
 
 /* Set the extra options */
 
 (void)pcre2_set_compile_extra_options(compile_context, extra_options);
 
-/* Check the values for Jeffrey Friedl's debugging options. */
-
 /* If use_jit is set, check whether JIT is available. If not, do not try
 to use JIT. */
 
 if (use_jit)
   {
   uint32_t answer;
   (void)pcre2_config(PCRE2_CONFIG_JIT, &answer);
@@ -4274,16 +4376,18 @@
   }
 
 bufsize = 3*bufthird;
 main_buffer = (char *)malloc(bufsize);
 
 if (main_buffer == NULL)
   {
+  /* LCOV_EXCL_START */
   fprintf(stderr, "pcre2grep: malloc failed\n");
   goto EXIT2;
+  /* LCOV_EXCL_STOP */
   }
 
 /* If no patterns were provided by -e, and there are no files provided by -f,
 the first argument is the one and only pattern, and it must exist. */
 
 if (patterns == NULL && pattern_files == NULL)
   {
@@ -4417,22 +4521,14 @@
   {
   int frc = grep_or_recurse(argv[i], dee_action == dee_RECURSE,
     only_one_at_top);
   if (frc > 1) rc = frc;
     else if (frc == 0 && rc == 1) rc = 0;
   }
 
-#ifdef SUPPORT_PCRE2GREP_CALLOUT
-/* If separating builtin echo callouts by implicit newline, add one more for
-the final item. */
-
-if (om_separator != NULL && strcmp(om_separator, STDOUT_NL) == 0)
-  fprintf(stdout, STDOUT_NL);
-#endif
-
 /* Show the total number of matches if requested, but not if only one file's
 count was printed. */
 
 if (show_total_count && counts_printed != 1 && filenames != FN_NOMATCH_ONLY)
   {
   if (counts_printed != 0 && filenames >= FN_DEFAULT)
     fprintf(stdout, "TOTAL:");
@@ -4446,15 +4542,16 @@
 #endif
 
 free(main_buffer);
 if (character_tables != NULL) pcre2_maketables_free(NULL, character_tables);
 
 pcre2_compile_context_free(compile_context);
 pcre2_match_context_free(match_context);
-pcre2_match_data_free(match_data);
+pcre2_match_data_free(match_data_pair[0]);
+pcre2_match_data_free(match_data_pair[1]);
 
 free_pattern_chain(patterns);
 free_pattern_chain(include_patterns);
 free_pattern_chain(include_dir_patterns);
 free_pattern_chain(exclude_patterns);
 free_pattern_chain(exclude_dir_patterns);
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2posix.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2posix.c`

 * *Files 3% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 *************************************************/
 
 /* PCRE is a library of functions to support regular expressions whose syntax
 and semantics are as close as possible to those of the Perl 5 language.
 
                        Written by Philip Hazel
      Original API code Copyright (c) 1997-2012 University of Cambridge
-          New API code Copyright (c) 2016-2021 University of Cambridge
+          New API code Copyright (c) 2016-2022 University of Cambridge
 
 -----------------------------------------------------------------------------
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 
     * Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
@@ -88,28 +88,14 @@
 #include <string.h>
 
 /* PCRE2 headers */
 
 #include "pcre2.h"
 #include "pcre2posix.h"
 
-/* When compiling with the MSVC compiler, it is sometimes necessary to include
-a "calling convention" before exported function names. (This is secondhand
-information; I know nothing about MSVC myself). For example, something like
-
-  void __cdecl function(....)
-
-might be needed. In order to make this easy, all the exported functions have
-PCRE2_CALL_CONVENTION just before their names. It is rarely needed; if not
-set, we ensure here that it has no effect. */
-
-#ifndef PCRE2_CALL_CONVENTION
-#define PCRE2_CALL_CONVENTION
-#endif
-
 /* Table to translate PCRE2 compile time error codes into POSIX error codes.
 Only a few PCRE2 errors with a value greater than 23 turn into special POSIX
 codes: most go to REG_BADPAT. The second table lists, in pairs, those that
 don't. */
 
 static const int eint1[] = {
   0,           /* No error */
@@ -338,16 +324,18 @@
   PCRE2_INFO_CAPTURECOUNT, &re_nsub);
 preg->re_nsub = (size_t)re_nsub;
 preg->re_match_data = pcre2_match_data_create(re_nsub + 1, NULL);
 preg->re_erroffset = (size_t)(-1);  /* No meaning after successful compile */
 
 if (preg->re_match_data == NULL)
   {
+  /* LCOV_EXCL_START */
   pcre2_code_free(preg->re_pcre2_code);
   return REG_ESPACE;
+  /* LCOV_EXCL_STOP */
   }
 
 return 0;
 }
 
 
 
@@ -419,22 +407,29 @@
   }
 
 /* Unsuccessful match */
 
 if (rc <= PCRE2_ERROR_UTF8_ERR1 && rc >= PCRE2_ERROR_UTF8_ERR21)
   return REG_INVARG;
 
+/* Most of these are events that won't occur during testing, so exclude them
+from coverage. */
+
 switch(rc)
   {
-  default: return REG_ASSERT;
+  case PCRE2_ERROR_HEAPLIMIT: return REG_ESPACE;
+  case PCRE2_ERROR_NOMATCH: return REG_NOMATCH;
+
+  /* LCOV_EXCL_START */
   case PCRE2_ERROR_BADMODE: return REG_INVARG;
   case PCRE2_ERROR_BADMAGIC: return REG_INVARG;
   case PCRE2_ERROR_BADOPTION: return REG_INVARG;
   case PCRE2_ERROR_BADUTFOFFSET: return REG_INVARG;
   case PCRE2_ERROR_MATCHLIMIT: return REG_ESPACE;
-  case PCRE2_ERROR_NOMATCH: return REG_NOMATCH;
   case PCRE2_ERROR_NOMEMORY: return REG_ESPACE;
   case PCRE2_ERROR_NULL: return REG_INVARG;
+  default: return REG_ASSERT;
+  /* LCOV_EXCL_STOP */
   }
 }
 
 /* End of pcre2posix.c */
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2posix.h` & `pcre2-0.2.0/src/libpcre2/src/pcre2posix.h`

 * *Files 10% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 /* PCRE2 is a library of functions to support regular expressions whose syntax
 and semantics are as close as possible to those of the Perl 5 language. This is
 the public header file to be #included by applications that call PCRE2 via the
 POSIX wrapper interface.
 
                        Written by Philip Hazel
      Original API code Copyright (c) 1997-2012 University of Cambridge
-          New API code Copyright (c) 2016-2019 University of Cambridge
+          New API code Copyright (c) 2016-2022 University of Cambridge
 
 -----------------------------------------------------------------------------
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 
     * Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
@@ -112,14 +112,28 @@
 typedef int regoff_t;
 
 typedef struct {
   regoff_t rm_so;
   regoff_t rm_eo;
 } regmatch_t;
 
+/* When compiling with the MSVC compiler, it is sometimes necessary to include
+a "calling convention" before exported function names. (This is secondhand
+information; I know nothing about MSVC myself). For example, something like
+
+  void __cdecl function(....)
+
+might be needed. In order to make this easy, all the exported functions have
+PCRE2_CALL_CONVENTION just before their names. It is rarely needed; if not
+set, we ensure here that it has no effect. */
+
+#ifndef PCRE2_CALL_CONVENTION
+#define PCRE2_CALL_CONVENTION
+#endif
+
 /* When an application links to a PCRE2 DLL in Windows, the symbols that are
 imported have to be identified as such. When building PCRE2, the appropriate
 export settings are needed, and are set in pcre2posix.c before including this
 file. */
 
 #if defined(_WIN32) && !defined(PCRE2_STATIC) && !defined(PCRE2POSIX_EXP_DECL)
 #  define PCRE2POSIX_EXP_DECL  extern __declspec(dllimport)
@@ -140,19 +154,19 @@
 
 /* The functions. The actual code is in functions with pcre2_xxx names for
 uniqueness. POSIX names are provided as macros for API compatibility with POSIX
 regex functions. It's done this way to ensure to they are always linked from
 the PCRE2 library and not by accident from elsewhere (regex_t differs in size
 elsewhere). */
 
-PCRE2POSIX_EXP_DECL int pcre2_regcomp(regex_t *, const char *, int);
-PCRE2POSIX_EXP_DECL int pcre2_regexec(const regex_t *, const char *, size_t,
+PCRE2POSIX_EXP_DECL int PCRE2_CALL_CONVENTION pcre2_regcomp(regex_t *, const char *, int);
+PCRE2POSIX_EXP_DECL int PCRE2_CALL_CONVENTION pcre2_regexec(const regex_t *, const char *, size_t,
                      regmatch_t *, int);
-PCRE2POSIX_EXP_DECL size_t pcre2_regerror(int, const regex_t *, char *, size_t);
-PCRE2POSIX_EXP_DECL void pcre2_regfree(regex_t *);
+PCRE2POSIX_EXP_DECL size_t PCRE2_CALL_CONVENTION pcre2_regerror(int, const regex_t *, char *, size_t);
+PCRE2POSIX_EXP_DECL void PCRE2_CALL_CONVENTION pcre2_regfree(regex_t *);
 
 #define regcomp  pcre2_regcomp
 #define regexec  pcre2_regexec
 #define regerror pcre2_regerror
 #define regfree  pcre2_regfree
 
 /* Debian had a patch that used different names. These are now here to save
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/pcre2test.c` & `pcre2-0.2.0/src/libpcre2/src/pcre2test.c`

 * *Files 2% similar despite different names*

```diff
@@ -475,15 +475,15 @@
 #define CTL_BINCODE                      0x00000020u
 #define CTL_CALLOUT_CAPTURE              0x00000040u
 #define CTL_CALLOUT_INFO                 0x00000080u
 #define CTL_CALLOUT_NONE                 0x00000100u
 #define CTL_DFA                          0x00000200u
 #define CTL_EXPAND                       0x00000400u
 #define CTL_FINDLIMITS                   0x00000800u
-#define CTL_FRAMESIZE                    0x00001000u
+#define CTL_FINDLIMITS_NOHEAP            0x00001000u
 #define CTL_FULLBINCODE                  0x00002000u
 #define CTL_GETALL                       0x00004000u
 #define CTL_GLOBAL                       0x00008000u
 #define CTL_HEXPAT                       0x00010000u  /* Same word as USE_LENGTH */
 #define CTL_INFO                         0x00020000u
 #define CTL_JITFAST                      0x00040000u
 #define CTL_JITVERIFY                    0x00080000u
@@ -518,14 +518,15 @@
 #define CTL2_SUBSTITUTE_UNSET_EMPTY      0x00000080u
 #define CTL2_SUBJECT_LITERAL             0x00000100u
 #define CTL2_CALLOUT_NO_WHERE            0x00000200u
 #define CTL2_CALLOUT_EXTRA               0x00000400u
 #define CTL2_ALLVECTOR                   0x00000800u
 #define CTL2_NULL_SUBJECT                0x00001000u
 #define CTL2_NULL_REPLACEMENT            0x00002000u
+#define CTL2_FRAMESIZE                   0x00004000u
 
 #define CTL2_NL_SET                      0x40000000u  /* Informational */
 #define CTL2_BSR_SET                     0x80000000u  /* Informational */
 
 /* These are the matching controls that may be set either on a pattern or on a
 data line. They are copied from the pattern controls as initial settings for
 data line controls. Note that CTL_MEMORY is not included here, because it does
@@ -669,16 +670,17 @@
   { "endanchored",                 MOD_PD,   MOD_OPT, PCRE2_ENDANCHORED,          PD(options) },
   { "escaped_cr_is_lf",            MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ESCAPED_CR_IS_LF, CO(extra_options) },
   { "expand",                      MOD_PAT,  MOD_CTL, CTL_EXPAND,                 PO(control) },
   { "extended",                    MOD_PATP, MOD_OPT, PCRE2_EXTENDED,             PO(options) },
   { "extended_more",               MOD_PATP, MOD_OPT, PCRE2_EXTENDED_MORE,        PO(options) },
   { "extra_alt_bsux",              MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ALT_BSUX,       CO(extra_options) },
   { "find_limits",                 MOD_DAT,  MOD_CTL, CTL_FINDLIMITS,             DO(control) },
+  { "find_limits_noheap",          MOD_DAT,  MOD_CTL, CTL_FINDLIMITS_NOHEAP,      DO(control) },
   { "firstline",                   MOD_PAT,  MOD_OPT, PCRE2_FIRSTLINE,            PO(options) },
-  { "framesize",                   MOD_PAT,  MOD_CTL, CTL_FRAMESIZE,              PO(control) },
+  { "framesize",                   MOD_PAT,  MOD_CTL, CTL2_FRAMESIZE,             PO(control2) },
   { "fullbincode",                 MOD_PAT,  MOD_CTL, CTL_FULLBINCODE,            PO(control) },
   { "get",                         MOD_DAT,  MOD_NN,  DO(get_numbers),            DO(get_names) },
   { "getall",                      MOD_DAT,  MOD_CTL, CTL_GETALL,                 DO(control) },
   { "global",                      MOD_PNDP, MOD_CTL, CTL_GLOBAL,                 PO(control) },
   { "heap_limit",                  MOD_CTM,  MOD_INT, 0,                          MO(heap_limit) },
   { "hex",                         MOD_PAT,  MOD_CTL, CTL_HEXPAT,                 PO(control) },
   { "info",                        MOD_PAT,  MOD_CTL, CTL_INFO,                   PO(control) },
@@ -777,18 +779,19 @@
 #define POSIX_SUPPORTED_MATCH_CONTROLS  (CTL_AFTERTEXT|CTL_ALLAFTERTEXT)
 #define POSIX_SUPPORTED_MATCH_CONTROLS2 (CTL2_NULL_SUBJECT)
 
 /* Control bits that are not ignored with 'push'. */
 
 #define PUSH_SUPPORTED_COMPILE_CONTROLS ( \
   CTL_BINCODE|CTL_CALLOUT_INFO|CTL_FULLBINCODE|CTL_HEXPAT|CTL_INFO| \
-  CTL_JITVERIFY|CTL_MEMORY|CTL_FRAMESIZE|CTL_PUSH|CTL_PUSHCOPY| \
+  CTL_JITVERIFY|CTL_MEMORY|CTL_PUSH|CTL_PUSHCOPY| \
   CTL_PUSHTABLESCOPY|CTL_USE_LENGTH)
 
-#define PUSH_SUPPORTED_COMPILE_CONTROLS2 (CTL2_BSR_SET|CTL2_NL_SET)
+#define PUSH_SUPPORTED_COMPILE_CONTROLS2 (CTL2_BSR_SET|CTL2_FRAMESIZE| \
+  CTL2_NL_SET)
 
 /* Controls that apply only at compile time with 'push'. */
 
 #define PUSH_COMPILE_ONLY_CONTROLS   CTL_JITVERIFY
 #define PUSH_COMPILE_ONLY_CONTROLS2  (0)
 
 /* Controls that are forbidden with #pop or #popcopy. */
@@ -809,16 +812,17 @@
   CTL_PUSHCOPY | CTL_PUSHTABLESCOPY,
   CTL_EXPAND   | CTL_HEXPAT };
 
 /* Data controls that are mutually exclusive. At present these are all in the
 first control word. */
 
 static uint32_t exclusive_dat_controls[] = {
-  CTL_ALLUSEDTEXT | CTL_STARTCHAR,
-  CTL_FINDLIMITS  | CTL_NULLCONTEXT };
+  CTL_ALLUSEDTEXT        | CTL_STARTCHAR,
+  CTL_FINDLIMITS         | CTL_NULLCONTEXT,
+  CTL_FINDLIMITS_NOHEAP  | CTL_NULLCONTEXT };
 
 /* Table of single-character abbreviated modifiers. The index field is
 initialized to -1, but the first time the modifier is encountered, it is filled
 in with the index of the full entry in modlist, to save repeated searching when
 processing multiple test items. This short list is searched serially, so its
 order does not matter. */
 
@@ -923,24 +927,24 @@
 static size_t jit_stack_size = 0;
 
 static BOOL first_callout;
 static BOOL jit_was_used;
 static BOOL restrict_for_perl_test = FALSE;
 static BOOL show_memory = FALSE;
 
-static int code_unit_size;                    /* Bytes */
 static int jitrc;                             /* Return from JIT compile */
 static int test_mode = DEFAULT_TEST_MODE;
 static int timeit = 0;
 static int timeitm = 0;
 
 clock_t total_compile_time = 0;
 clock_t total_jit_compile_time = 0;
 clock_t total_match_time = 0;
 
+static uint32_t code_unit_size;               /* Bytes */
 static uint32_t dfa_matched;
 static uint32_t forbid_utf = 0;
 static uint32_t maxlookbehind;
 static uint32_t max_oveccount;
 static uint32_t callout_count;
 static uint32_t maxcapcount;
 
@@ -1223,42 +1227,47 @@
   if (test_mode == PCRE8_MODE) \
     pcre2_jit_stack_free_8((pcre2_jit_stack_8 *)a); \
   else if (test_mode == PCRE16_MODE) \
     pcre2_jit_stack_free_16((pcre2_jit_stack_16 *)a); \
   else \
     pcre2_jit_stack_free_32((pcre2_jit_stack_32 *)a);
 
-#define PCRE2_MAKETABLES(a) \
-  if (test_mode == PCRE8_MODE) a = pcre2_maketables_8(NULL); \
-  else if (test_mode == PCRE16_MODE) a = pcre2_maketables_16(NULL); \
-  else a = pcre2_maketables_32(NULL)
+#define PCRE2_MAKETABLES(a,c) \
+  if (test_mode == PCRE8_MODE) a = pcre2_maketables_8(G(c,8)); \
+  else if (test_mode == PCRE16_MODE) a = pcre2_maketables_16(G(c,16)); \
+  else a = pcre2_maketables_32(G(c,32))
+
+#define PCRE2_MAKETABLES_FREE(c,a) \
+  if (test_mode == PCRE8_MODE) pcre2_maketables_free_8(G(c,8),a); \
+  else if (test_mode == PCRE16_MODE) pcre2_maketables_free_16(G(c,16),a); \
+  else pcre2_maketables_free_32(G(c,32),a)
 
 #define PCRE2_MATCH(a,b,c,d,e,f,g,h) \
   if (test_mode == PCRE8_MODE) \
     a = pcre2_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h); \
   else if (test_mode == PCRE16_MODE) \
     a = pcre2_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h); \
   else \
     a = pcre2_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)
 
 #define PCRE2_MATCH_DATA_CREATE(a,b,c) \
   if (test_mode == PCRE8_MODE) \
-    G(a,8) = pcre2_match_data_create_8(b,c); \
+    G(a,8) = pcre2_match_data_create_8(b,G(c,8)); \
   else if (test_mode == PCRE16_MODE) \
-    G(a,16) = pcre2_match_data_create_16(b,c); \
+    G(a,16) = pcre2_match_data_create_16(b,G(c,16)); \
   else \
-    G(a,32) = pcre2_match_data_create_32(b,c)
+    G(a,32) = pcre2_match_data_create_32(b,G(c,32))
 
 #define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \
   if (test_mode == PCRE8_MODE) \
-    G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),c); \
+    G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),G(c,8)); \
   else if (test_mode == PCRE16_MODE) \
-    G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),c); \
+    G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),G(c,16)); \
   else \
-    G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),c)
+    G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),G(c,32))
 
 #define PCRE2_MATCH_DATA_FREE(a) \
   if (test_mode == PCRE8_MODE) \
     pcre2_match_data_free_8(G(a,8)); \
   else if (test_mode == PCRE16_MODE) \
     pcre2_match_data_free_16(G(a,16)); \
   else \
@@ -1742,39 +1751,45 @@
 
 #define PCRE2_JIT_STACK_FREE(a) \
   if (test_mode == G(G(PCRE,BITONE),_MODE)) \
     G(pcre2_jit_stack_free_,BITONE)((G(pcre2_jit_stack_,BITONE) *)a); \
   else \
     G(pcre2_jit_stack_free_,BITTWO)((G(pcre2_jit_stack_,BITTWO) *)a);
 
-#define PCRE2_MAKETABLES(a) \
+#define PCRE2_MAKETABLES(a,c) \
   if (test_mode == G(G(PCRE,BITONE),_MODE)) \
-    a = G(pcre2_maketables_,BITONE)(NULL); \
+    a = G(pcre2_maketables_,BITONE)(G(c,BITONE)); \
   else \
-    a = G(pcre2_maketables_,BITTWO)(NULL)
+    a = G(pcre2_maketables_,BITTWO)(G(c,BITTWO))
+
+#define PCRE2_MAKETABLES_FREE(c,a) \
+  if (test_mode == G(G(PCRE,BITONE),_MODE)) \
+    G(pcre2_maketables_free_,BITONE)(G(c,BITONE),a); \
+  else \
+    G(pcre2_maketables_free_,BITTWO)(G(c,BITTWO),a)
 
 #define PCRE2_MATCH(a,b,c,d,e,f,g,h) \
   if (test_mode == G(G(PCRE,BITONE),_MODE)) \
     a = G(pcre2_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \
       G(g,BITONE),h); \
   else \
     a = G(pcre2_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \
       G(g,BITTWO),h)
 
 #define PCRE2_MATCH_DATA_CREATE(a,b,c) \
   if (test_mode == G(G(PCRE,BITONE),_MODE)) \
-    G(a,BITONE) = G(pcre2_match_data_create_,BITONE)(b,c); \
+    G(a,BITONE) = G(pcre2_match_data_create_,BITONE)(b,G(c,BITONE)); \
   else \
-    G(a,BITTWO) = G(pcre2_match_data_create_,BITTWO)(b,c)
+    G(a,BITTWO) = G(pcre2_match_data_create_,BITTWO)(b,G(c,BITTWO))
 
 #define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \
   if (test_mode == G(G(PCRE,BITONE),_MODE)) \
-    G(a,BITONE) = G(pcre2_match_data_create_from_pattern_,BITONE)(G(b,BITONE),c); \
+    G(a,BITONE) = G(pcre2_match_data_create_from_pattern_,BITONE)(G(b,BITONE),G(c,BITONE)); \
   else \
-    G(a,BITTWO) = G(pcre2_match_data_create_from_pattern_,BITTWO)(G(b,BITTWO),c)
+    G(a,BITTWO) = G(pcre2_match_data_create_from_pattern_,BITTWO)(G(b,BITTWO),G(c,BITTWO))
 
 #define PCRE2_MATCH_DATA_FREE(a) \
   if (test_mode == G(G(PCRE,BITONE),_MODE)) \
     G(pcre2_match_data_free_,BITONE)(G(a,BITONE)); \
   else \
     G(pcre2_match_data_free_,BITTWO)(G(a,BITTWO))
 
@@ -2063,20 +2078,21 @@
 #define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \
   a = pcre2_jit_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h)
 #define PCRE2_JIT_STACK_CREATE(a,b,c,d) \
   a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_8(b,c,d);
 #define PCRE2_JIT_STACK_ASSIGN(a,b,c) \
   pcre2_jit_stack_assign_8(G(a,8),(pcre2_jit_callback_8)b,c);
 #define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_8((pcre2_jit_stack_8 *)a);
-#define PCRE2_MAKETABLES(a) a = pcre2_maketables_8(NULL)
+#define PCRE2_MAKETABLES(a,c) a = pcre2_maketables_8(G(c,8))
+#define PCRE2_MAKETABLES_FREE(c,a) pcre2_maketables_free_8(G(c,8),a)
 #define PCRE2_MATCH(a,b,c,d,e,f,g,h) \
   a = pcre2_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h)
-#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,8) = pcre2_match_data_create_8(b,c)
+#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,8) = pcre2_match_data_create_8(b,G(c,8))
 #define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \
-  G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),c)
+  G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),G(c,8))
 #define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_8(G(a,8))
 #define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_8(G(b,8),c,d,(PCRE2_UCHAR8 **)e,f,G(g,8))
 #define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_8(G(b,8),c,d)
 #define PCRE2_PRINTINT(a) pcre2_printint_8(compiled_code8,outfile,a)
 #define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \
   r = pcre2_serialize_decode_8((pcre2_code_8 **)a,b,c,G(d,8))
 #define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \
@@ -2170,20 +2186,21 @@
 #define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \
   a = pcre2_jit_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h)
 #define PCRE2_JIT_STACK_CREATE(a,b,c,d) \
   a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_16(b,c,d);
 #define PCRE2_JIT_STACK_ASSIGN(a,b,c) \
   pcre2_jit_stack_assign_16(G(a,16),(pcre2_jit_callback_16)b,c);
 #define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_16((pcre2_jit_stack_16 *)a);
-#define PCRE2_MAKETABLES(a) a = pcre2_maketables_16(NULL)
+#define PCRE2_MAKETABLES(a,c) a = pcre2_maketables_16(G(c,16))
+#define PCRE2_MAKETABLES_FREE(c,a) pcre2_maketables_free_16(G(c,16),a)
 #define PCRE2_MATCH(a,b,c,d,e,f,g,h) \
   a = pcre2_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h)
-#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,16) = pcre2_match_data_create_16(b,c)
+#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,16) = pcre2_match_data_create_16(b,G(c,16))
 #define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \
-  G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),c)
+  G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),G(c,16))
 #define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_16(G(a,16))
 #define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_16(G(b,16),c,d,(PCRE2_UCHAR16 **)e,f,G(g,16))
 #define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_16(G(b,16),c,d)
 #define PCRE2_PRINTINT(a) pcre2_printint_16(compiled_code16,outfile,a)
 #define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \
   r = pcre2_serialize_decode_16((pcre2_code_16 **)a,b,c,G(d,16))
 #define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \
@@ -2277,20 +2294,21 @@
 #define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \
   a = pcre2_jit_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)
 #define PCRE2_JIT_STACK_CREATE(a,b,c,d) \
   a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_32(b,c,d);
 #define PCRE2_JIT_STACK_ASSIGN(a,b,c) \
   pcre2_jit_stack_assign_32(G(a,32),(pcre2_jit_callback_32)b,c);
 #define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_32((pcre2_jit_stack_32 *)a);
-#define PCRE2_MAKETABLES(a) a = pcre2_maketables_32(NULL)
+#define PCRE2_MAKETABLES(a,c) a = pcre2_maketables_32(G(c,32))
+#define PCRE2_MAKETABLES_FREE(c,a) pcre2_maketables_free_32(G(c,32),a)
 #define PCRE2_MATCH(a,b,c,d,e,f,g,h) \
   a = pcre2_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)
-#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,32) = pcre2_match_data_create_32(b,c)
+#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,32) = pcre2_match_data_create_32(b,G(c,32))
 #define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \
-  G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),c)
+  G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),G(c,32))
 #define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_32(G(a,32))
 #define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_32(G(b,32),c,d,(PCRE2_UCHAR32 **)e,f,G(g,32))
 #define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_32(G(b,32),c,d)
 #define PCRE2_PRINTINT(a) pcre2_printint_32(compiled_code32,outfile,a)
 #define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \
   r = pcre2_serialize_decode_32((pcre2_code_32 **)a,b,c,G(d,32))
 #define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \
@@ -2776,15 +2794,15 @@
   }
 return block;
 }
 
 static void my_free(void *block, void *data)
 {
 (void)data;
-if (show_memory)
+if (show_memory && block != NULL)
   {
   uint32_t i, j;
   BOOL found = FALSE;
 
   fprintf(outfile, "free");
   for (i = 0; i < malloclistptr; i++)
     {
@@ -4108,15 +4126,15 @@
 
 Returns:      nothing
 */
 
 static void
 show_controls(uint32_t controls, uint32_t controls2, const char *before)
 {
-fprintf(outfile, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
+fprintf(outfile, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
   before,
   ((controls & CTL_AFTERTEXT) != 0)? " aftertext" : "",
   ((controls & CTL_ALLAFTERTEXT) != 0)? " allaftertext" : "",
   ((controls & CTL_ALLCAPTURES) != 0)? " allcaptures" : "",
   ((controls & CTL_ALLUSEDTEXT) != 0)? " allusedtext" : "",
   ((controls2 & CTL2_ALLVECTOR) != 0)? " allvector" : "",
   ((controls & CTL_ALTGLOBAL) != 0)? " altglobal" : "",
@@ -4126,15 +4144,16 @@
   ((controls2 & CTL2_CALLOUT_EXTRA) != 0)? " callout_extra" : "",
   ((controls & CTL_CALLOUT_INFO) != 0)? " callout_info" : "",
   ((controls & CTL_CALLOUT_NONE) != 0)? " callout_none" : "",
   ((controls2 & CTL2_CALLOUT_NO_WHERE) != 0)? " callout_no_where" : "",
   ((controls & CTL_DFA) != 0)? " dfa" : "",
   ((controls & CTL_EXPAND) != 0)? " expand" : "",
   ((controls & CTL_FINDLIMITS) != 0)? " find_limits" : "",
-  ((controls & CTL_FRAMESIZE) != 0)? " framesize" : "",
+  ((controls & CTL_FINDLIMITS_NOHEAP) != 0)? " find_limits_noheap" : "",
+  ((controls2 & CTL2_FRAMESIZE) != 0)? " framesize" : "",
   ((controls & CTL_FULLBINCODE) != 0)? " fullbincode" : "",
   ((controls & CTL_GETALL) != 0)? " getall" : "",
   ((controls & CTL_GLOBAL) != 0)? " global" : "",
   ((controls & CTL_HEXPAT) != 0)? " hex" : "",
   ((controls & CTL_INFO) != 0)? " info" : "",
   ((controls & CTL_JITFAST) != 0)? " jitfast" : "",
   ((controls & CTL_JITVERIFY) != 0)? " jitverify" : "",
@@ -4303,35 +4322,41 @@
 #ifdef SUPPORT_PCRE2_32
 if (test_mode == PCRE32_MODE) cblock_size = sizeof(pcre2_real_code_32);
 #endif
 
 (void)pattern_info(PCRE2_INFO_SIZE, &size, FALSE);
 (void)pattern_info(PCRE2_INFO_NAMECOUNT, &name_count, FALSE);
 (void)pattern_info(PCRE2_INFO_NAMEENTRYSIZE, &name_entry_size, FALSE);
-fprintf(outfile, "Memory allocation (code space): %d\n",
-  (int)(size - name_count*name_entry_size*code_unit_size - cblock_size));
+
+/* The uint32_t variables are cast before multiplying to stop code analyzers
+grumbling about potential overflow. */
+
+fprintf(outfile, "Memory allocation (code space): %" SIZ_FORM "\n", size -
+  (size_t)name_count * (size_t)name_entry_size * (size_t)code_unit_size -
+  cblock_size);
+
 if (pat_patctl.jit != 0)
   {
   (void)pattern_info(PCRE2_INFO_JITSIZE, &size, FALSE);
-  fprintf(outfile, "Memory allocation (JIT code): %d\n", (int)size);
+  fprintf(outfile, "Memory allocation (JIT code): %" SIZ_FORM "\n", size);
   }
 }
 
 
 
 /*************************************************
 *       Show frame size info for a pattern       *
 *************************************************/
 
 static void
 show_framesize(void)
 {
 size_t frame_size;
 (void)pattern_info(PCRE2_INFO_FRAMESIZE, &frame_size, FALSE);
-fprintf(outfile, "Frame size for pcre2_match(): %d\n", (int)frame_size);
+fprintf(outfile, "Frame size for pcre2_match(): %" SIZ_FORM "\n", frame_size);
 }
 
 
 
 /*************************************************
 *         Get and output an error message        *
 *************************************************/
@@ -4745,27 +4770,27 @@
     }
 
   if ((FLD(compiled_code, overall_options) & PCRE2_NO_START_OPTIMIZE) == 0)
     fprintf(outfile, "Subject length lower bound = %d\n", minlength);
 
   if (pat_patctl.jit != 0 && (pat_patctl.control & CTL_JITVERIFY) != 0)
     {
+#ifdef SUPPORT_JIT
     if (FLD(compiled_code, executable_jit) != NULL)
       fprintf(outfile, "JIT compilation was successful\n");
     else
       {
-#ifdef SUPPORT_JIT
       fprintf(outfile, "JIT compilation was not successful");
       if (jitrc != 0 && !print_error_message(jitrc, " (", ")"))
         return PR_ABEND;
       fprintf(outfile, "\n");
+      }
 #else
       fprintf(outfile, "JIT support is not available in this version of PCRE2\n");
 #endif
-      }
     }
   }
 
 if ((pat_patctl.control & CTL_CALLOUT_INFO) != 0)
   {
   int errorcode;
   PCRE2_CALLOUT_ENUMERATE(errorcode, callout_callback, 0);
@@ -4976,15 +5001,15 @@
     }
 
   if (pat_patctl.jit != 0)
     {
     PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);
     }
   if ((pat_patctl.control & CTL_MEMORY) != 0) show_memory_info();
-  if ((pat_patctl.control & CTL_FRAMESIZE) != 0) show_framesize();
+  if ((pat_patctl.control2 & CTL2_FRAMESIZE) != 0) show_framesize();
   if ((pat_patctl.control & CTL_ANYINFO) != 0)
     {
     rc = show_pattern_info();
     if (rc != PR_OK) return rc;
     }
   break;
 
@@ -5422,16 +5447,19 @@
     {
     fprintf(outfile, "** Failed to set locale '%s'\n", pat_patctl.locale);
     return PR_SKIP;
     }
   if (strcmp((const char *)pat_patctl.locale, (const char *)locale_name) != 0)
     {
     strcpy((char *)locale_name, (char *)pat_patctl.locale);
-    if (locale_tables != NULL) free((void *)locale_tables);
-    PCRE2_MAKETABLES(locale_tables);
+    if (locale_tables != NULL)
+      {
+      PCRE2_MAKETABLES_FREE(general_context, (void *)locale_tables);
+      }
+    PCRE2_MAKETABLES(locale_tables, general_context);
     }
   use_tables = locale_tables;
   }
 
 else switch (pat_patctl.tables_id)
   {
   case 0: use_tables = NULL; break;
@@ -5938,15 +5966,15 @@
   {
   SETFLD(compiled_code, flags, FLD(compiled_code, flags) | PCRE2_NL_SET);
   }
 
 /* Output code size and other information if requested. */
 
 if ((pat_patctl.control & CTL_MEMORY) != 0) show_memory_info();
-if ((pat_patctl.control & CTL_FRAMESIZE) != 0) show_framesize();
+if ((pat_patctl.control2 & CTL2_FRAMESIZE) != 0) show_framesize();
 if ((pat_patctl.control & CTL_ANYINFO) != 0)
   {
   int rc = show_pattern_info();
   if (rc != PR_OK) return rc;
   }
 
 /* The "push" control requests that the compiled pattern be remembered on a
@@ -6017,27 +6045,65 @@
 PCRE2_SET_DEPTH_LIMIT(dat_context, max);
 PCRE2_SET_HEAP_LIMIT(dat_context, max);
 
 for (;;)
   {
   uint32_t stack_start = 0;
 
+  /* If we are checking the heap limit, free any frames vector that is cached
+  in the match_data so we always start without one. */
+
   if (errnumber == PCRE2_ERROR_HEAPLIMIT)
     {
     PCRE2_SET_HEAP_LIMIT(dat_context, mid);
+
+#ifdef SUPPORT_PCRE2_8
+    if (code_unit_size == 1)
+      {
+      match_data8->memctl.free(match_data8->heapframes,
+        match_data8->memctl.memory_data);
+      match_data8->heapframes = NULL;
+      match_data8->heapframes_size = 0;
+      }
+#endif
+
+#ifdef SUPPORT_PCRE2_16
+    if (code_unit_size == 2)
+      {
+      match_data16->memctl.free(match_data16->heapframes,
+        match_data16->memctl.memory_data);
+      match_data16->heapframes = NULL;
+      match_data16->heapframes_size = 0;
+      }
+#endif
+
+#ifdef SUPPORT_PCRE2_32
+    if (code_unit_size == 4)
+      {
+      match_data32->memctl.free(match_data32->heapframes,
+        match_data32->memctl.memory_data);
+      match_data32->heapframes = NULL;
+      match_data32->heapframes_size = 0;
+      }
+#endif
     }
+
+  /* No need to mess with the frames vector for match or depth limits. */
+
   else if (errnumber == PCRE2_ERROR_MATCHLIMIT)
     {
     PCRE2_SET_MATCH_LIMIT(dat_context, mid);
     }
   else
     {
     PCRE2_SET_DEPTH_LIMIT(dat_context, mid);
     }
 
+  /* Do the appropriate match */
+
   if ((dat_datctl.control & CTL_DFA) != 0)
     {
     stack_start = DFA_START_RWS_SIZE/1024;
     if (dfa_workspace == NULL)
       dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));
     if (dfa_matched++ == 0)
       dfa_workspace[0] = -1;  /* To catch bad restart */
@@ -6048,15 +6114,14 @@
 
   else if ((pat_patctl.control & CTL_JITFAST) != 0)
     PCRE2_JIT_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,
       dat_datctl.options, match_data, PTR(dat_context));
 
   else
     {
-    stack_start = START_FRAMES_SIZE/1024;
     PCRE2_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,
       dat_datctl.options, match_data, PTR(dat_context));
     }
 
   if (capcount == errnumber)
     {
     if ((mid & 0x80000000u) != 0)
@@ -6753,16 +6818,14 @@
 
   /* ] may mark the end of a replicated sequence */
 
   if (c == ']' && start_rep != NULL)
     {
     long li;
     char *endptr;
-    size_t qoffset = CAST8VAR(q) - dbuffer;
-    size_t rep_offset = start_rep - dbuffer;
 
     if (*p++ != '{')
       {
       fprintf(outfile, "** Expected '{' after \\[....]\n");
       return PR_OK;
       }
 
@@ -6777,25 +6840,27 @@
     if (*p++ != '}')
       {
       fprintf(outfile, "** Expected '}' after \\[...]{...\n");
       return PR_OK;
       }
 
     i = (int32_t)li;
-    if (i-- == 0)
+    if (i-- <= 0)
       {
-      fprintf(outfile, "** Zero repeat not allowed\n");
+      fprintf(outfile, "** Zero or negative repeat not allowed\n");
       return PR_OK;
       }
 
     replen = CAST8VAR(q) - start_rep;
     needlen += replen * i;
 
     if (needlen >= dbuffer_size)
       {
+      size_t qoffset = CAST8VAR(q) - dbuffer;
+      size_t rep_offset = start_rep - dbuffer;
       while (needlen >= dbuffer_size) dbuffer_size *= 2;
       dbuffer = (uint8_t *)realloc(dbuffer, dbuffer_size);
       if (dbuffer == NULL)
         {
         fprintf(stderr, "pcre2test: realloc(%d) failed\n", (int)dbuffer_size);
         exit(1);
         }
@@ -7266,26 +7331,27 @@
 
 /* Adjust match_data according to size of offsets required. A size of zero
 causes a new match data block to be obtained that exactly fits the pattern. */
 
 if (dat_datctl.oveccount == 0)
   {
   PCRE2_MATCH_DATA_FREE(match_data);
-  PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(match_data, compiled_code, NULL);
+  PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(match_data, compiled_code,
+    general_context);
   PCRE2_GET_OVECTOR_COUNT(max_oveccount, match_data);
   }
 else if (dat_datctl.oveccount <= max_oveccount)
   {
   SETFLD(match_data, oveccount, dat_datctl.oveccount);
   }
 else
   {
   max_oveccount = dat_datctl.oveccount;
   PCRE2_MATCH_DATA_FREE(match_data);
-  PCRE2_MATCH_DATA_CREATE(match_data, max_oveccount, NULL);
+  PCRE2_MATCH_DATA_CREATE(match_data, max_oveccount, general_context);
   }
 
 if (CASTVAR(void *, match_data) == NULL)
   {
   fprintf(outfile, "** Failed to get memory for recording matching "
     "information (size requested: %d)\n", dat_datctl.oveccount);
   max_oveccount = 0;
@@ -7574,20 +7640,21 @@
         (double)CLOCKS_PER_SEC);
     }
 
   /* Find the heap, match and depth limits if requested. The depth and heap
   limits are not relevant for JIT. The return from check_match_limit() is the
   return from the final call to pcre2_match() or pcre2_dfa_match(). */
 
-  if ((dat_datctl.control & CTL_FINDLIMITS) != 0)
+  if ((dat_datctl.control & (CTL_FINDLIMITS|CTL_FINDLIMITS_NOHEAP)) != 0)
     {
     capcount = 0;  /* This stops compiler warnings */
 
-    if (FLD(compiled_code, executable_jit) == NULL ||
-          (dat_datctl.options & PCRE2_NO_JIT) != 0)
+    if ((dat_datctl.control & CTL_FINDLIMITS_NOHEAP) == 0 &&
+        (FLD(compiled_code, executable_jit) == NULL ||
+          (dat_datctl.options & PCRE2_NO_JIT) != 0))
       {
       (void)check_match_limit(pp, arg_ulen, PCRE2_ERROR_HEAPLIMIT, "heap");
       }
 
     capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_MATCHLIMIT,
       "match");
 
@@ -8931,17 +8998,21 @@
       }
     stack_size = (uint32_t)uli;
     getrlimit(RLIMIT_STACK, &rlim);
     rlim.rlim_cur = stack_size * 1024 * 1024;
     if (rlim.rlim_cur > rlim.rlim_max)
       {
       fprintf(stderr,
-        "pcre2test: requested stack size %luMiB is greater than hard limit "
-          "%luMiB\n", (unsigned long int)stack_size,
-          (unsigned long int)(rlim.rlim_max));
+        "pcre2test: requested stack size %luMiB is greater than hard limit ",
+          (unsigned long int)stack_size);
+      if (rlim.rlim_max % (1024*1024) == 0) fprintf(stderr, "%luMiB\n",
+        (unsigned long int)(rlim.rlim_max/(1024 * 1024)));
+      else if (rlim.rlim_max % 1024 == 0) fprintf(stderr, "%luKiB\n",
+        (unsigned long int)(rlim.rlim_max/1024));
+      else fprintf(stderr, "%lu bytes\n", (unsigned long int)(rlim.rlim_max));
       exit(1);
       }
     rc = setrlimit(RLIMIT_STACK, &rlim);
     if (rc != 0)
       {
       fprintf(stderr, "pcre2test: setting stack size %luMiB failed: %s\n",
         (unsigned long int)stack_size, strerror(errno));
@@ -9166,15 +9237,14 @@
   G(con_context,BITS) = G(pcre2_convert_context_copy_,BITS)(G(default_con_context,BITS)); \
   G(match_data,BITS) = G(pcre2_match_data_create_,BITS)(max_oveccount, G(general_context,BITS))
 
 #define CONTEXTTESTS \
   (void)G(pcre2_set_compile_extra_options_,BITS)(G(pat_context,BITS), 0); \
   (void)G(pcre2_set_max_pattern_length_,BITS)(G(pat_context,BITS), 0); \
   (void)G(pcre2_set_offset_limit_,BITS)(G(dat_context,BITS), 0); \
-  (void)G(pcre2_set_recursion_memory_management_,BITS)(G(dat_context,BITS), my_malloc, my_free, NULL); \
   (void)G(pcre2_get_match_data_size_,BITS)(G(match_data,BITS))
 
 
 /* Call the appropriate functions for the current mode, and exercise some
 functions that are not otherwise called. */
 
 #ifdef SUPPORT_PCRE2_8
@@ -9389,16 +9459,16 @@
 if (infile != NULL && infile != stdin) fclose(infile);
 if (outfile != NULL && outfile != stdout) fclose(outfile);
 
 free(buffer);
 free(dbuffer);
 free(pbuffer8);
 free(dfa_workspace);
-free((void *)locale_tables);
 free(tables3);
+PCRE2_MAKETABLES_FREE(general_context, (void *)locale_tables);
 PCRE2_MATCH_DATA_FREE(match_data);
 SUB1(pcre2_code_free, compiled_code);
 
 while(patstacknext-- > 0)
   {
   SET(compiled_code, patstack[patstacknext]);
   SUB1(pcre2_code_free, compiled_code);
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitConfig.h` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitConfig.h`

 * *Files 4% similar despite different names*

```diff
@@ -49,15 +49,16 @@
 /* #define SLJIT_CONFIG_ARM_V7 1 */
 /* #define SLJIT_CONFIG_ARM_THUMB2 1 */
 /* #define SLJIT_CONFIG_ARM_64 1 */
 /* #define SLJIT_CONFIG_PPC_32 1 */
 /* #define SLJIT_CONFIG_PPC_64 1 */
 /* #define SLJIT_CONFIG_MIPS_32 1 */
 /* #define SLJIT_CONFIG_MIPS_64 1 */
-/* #define SLJIT_CONFIG_SPARC_32 1 */
+/* #define SLJIT_CONFIG_RISCV_32 1 */
+/* #define SLJIT_CONFIG_RISCV_64 1 */
 /* #define SLJIT_CONFIG_S390X 1 */
 
 /* #define SLJIT_CONFIG_AUTO 1 */
 /* #define SLJIT_CONFIG_UNSUPPORTED 1 */
 
 /* --------------------------------------------------------------------- */
 /*  Utilities                                                            */
@@ -123,25 +124,14 @@
 #ifndef SLJIT_WX_EXECUTABLE_ALLOCATOR
 /* Disabled by default. */
 #define SLJIT_WX_EXECUTABLE_ALLOCATOR 0
 #endif
 
 #endif /* !SLJIT_EXECUTABLE_ALLOCATOR */
 
-/* Force cdecl calling convention even if a better calling
-   convention (e.g. fastcall) is supported by the C compiler.
-   If this option is disabled (this is the default), functions
-   called from JIT should be defined with SLJIT_FUNC attribute.
-   Standard C functions can still be called by using the
-   SLJIT_CALL_CDECL jump type. */
-#ifndef SLJIT_USE_CDECL_CALLING_CONVENTION
-/* Disabled by default */
-#define SLJIT_USE_CDECL_CALLING_CONVENTION 0
-#endif
-
 /* Return with error when an invalid argument is passed. */
 #ifndef SLJIT_ARGUMENT_CHECKS
 /* Disabled by default */
 #define SLJIT_ARGUMENT_CHECKS 0
 #endif
 
 /* Debug checks (assertions, etc.). */
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitConfigInternal.h` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitConfigInternal.h`

 * *Files 5% similar despite different names*

```diff
@@ -55,15 +55,16 @@
      sljit_f64            : 64 bit double precision floating point value
 
    Macros for feature detection (boolean):
      SLJIT_32BIT_ARCHITECTURE : 32 bit architecture
      SLJIT_64BIT_ARCHITECTURE : 64 bit architecture
      SLJIT_LITTLE_ENDIAN : little endian architecture
      SLJIT_BIG_ENDIAN : big endian architecture
-     SLJIT_UNALIGNED : allows unaligned memory accesses for non-fpu operations (only!)
+     SLJIT_UNALIGNED : unaligned memory accesses for non-fpu operations are supported
+     SLJIT_FPU_UNALIGNED : unaligned memory accesses for fpu operations are supported
      SLJIT_INDIRECT_CALL : see SLJIT_FUNC_ADDR() for more information
 
    Constants:
      SLJIT_NUMBER_OF_REGISTERS : number of available registers
      SLJIT_NUMBER_OF_SCRATCH_REGISTERS : number of available scratch registers
      SLJIT_NUMBER_OF_SAVED_REGISTERS : number of available saved registers
      SLJIT_NUMBER_OF_FLOAT_REGISTERS : number of available floating point registers
@@ -94,15 +95,16 @@
 	+ (defined SLJIT_CONFIG_ARM_V7 && SLJIT_CONFIG_ARM_V7) \
 	+ (defined SLJIT_CONFIG_ARM_THUMB2 && SLJIT_CONFIG_ARM_THUMB2) \
 	+ (defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
 	+ (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) \
 	+ (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64) \
 	+ (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32) \
 	+ (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64) \
-	+ (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32) \
+	+ (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32) \
+	+ (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64) \
 	+ (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X) \
 	+ (defined SLJIT_CONFIG_AUTO && SLJIT_CONFIG_AUTO) \
 	+ (defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED) >= 2
 #error "Multiple architectures are selected"
 #endif
 
 #if !(defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32) \
@@ -111,15 +113,16 @@
 	&& !(defined SLJIT_CONFIG_ARM_V7 && SLJIT_CONFIG_ARM_V7) \
 	&& !(defined SLJIT_CONFIG_ARM_THUMB2 && SLJIT_CONFIG_ARM_THUMB2) \
 	&& !(defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
 	&& !(defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) \
 	&& !(defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64) \
 	&& !(defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32) \
 	&& !(defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64) \
-	&& !(defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32) \
+	&& !(defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32) \
+	&& !(defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64) \
 	&& !(defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X) \
 	&& !(defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED) \
 	&& !(defined SLJIT_CONFIG_AUTO && SLJIT_CONFIG_AUTO)
 #if defined SLJIT_CONFIG_AUTO && !SLJIT_CONFIG_AUTO
 #error "An architecture must be selected"
 #else /* SLJIT_CONFIG_AUTO */
 #define SLJIT_CONFIG_AUTO 1
@@ -152,16 +155,18 @@
 #define SLJIT_CONFIG_PPC_64 1
 #elif defined(__ppc__) || defined(__powerpc__) || defined(_ARCH_PPC) || defined(_ARCH_PWR) || defined(_ARCH_PWR2) || defined(_POWER)
 #define SLJIT_CONFIG_PPC_32 1
 #elif defined(__mips__) && !defined(_LP64)
 #define SLJIT_CONFIG_MIPS_32 1
 #elif defined(__mips64)
 #define SLJIT_CONFIG_MIPS_64 1
-#elif (defined(__sparc__) || defined(__sparc)) && !defined(_LP64)
-#define SLJIT_CONFIG_SPARC_32 1
+#elif defined (__riscv_xlen) && (__riscv_xlen == 32)
+#define SLJIT_CONFIG_RISCV_32 1
+#elif defined (__riscv_xlen) && (__riscv_xlen == 64)
+#define SLJIT_CONFIG_RISCV_64 1
 #elif defined(__s390x__)
 #define SLJIT_CONFIG_S390X 1
 #else
 /* Unsupported architecture */
 #define SLJIT_CONFIG_UNSUPPORTED 1
 #endif
 
@@ -201,16 +206,16 @@
 #define SLJIT_CONFIG_X86 1
 #elif (defined SLJIT_CONFIG_ARM_32 && SLJIT_CONFIG_ARM_32) || (defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64)
 #define SLJIT_CONFIG_ARM 1
 #elif (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) || (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
 #define SLJIT_CONFIG_PPC 1
 #elif (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32) || (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
 #define SLJIT_CONFIG_MIPS 1
-#elif (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32) || (defined SLJIT_CONFIG_SPARC_64 && SLJIT_CONFIG_SPARC_64)
-#define SLJIT_CONFIG_SPARC 1
+#elif (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32) || (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+#define SLJIT_CONFIG_RISCV 1
 #endif
 
 /***********************************************************/
 /* Intel Control-flow Enforcement Technology (CET) spport. */
 /***********************************************************/
 
 #ifdef SLJIT_CONFIG_X86
@@ -326,26 +331,32 @@
 /*
  * TODO:
  *
  * clang >= 15 could be safe to enable below
  * older versions are known to abort in some targets
  * https://github.com/PhilipHazel/pcre2/issues/92
  *
- * beware APPLE is known to have removed the code in iOS so
- * it will need to be excempted or result in broken builds
+ * beware some vendors (ex: Microsoft, Apple) are known to have
+ * removed the code to support this builtin even if the call for
+ * __has_builtin reports it is available.
+ *
+ * make sure linking doesn't fail because __clear_cache() is
+ * missing before changing it or add an exception so that the
+ * system provided method that should be defined below is used
+ * instead.
  */
 #if (!defined SLJIT_CACHE_FLUSH && defined __has_builtin)
 #if __has_builtin(__builtin___clear_cache) && !defined(__clang__)
 
 /*
  * https://gcc.gnu.org/bugzilla//show_bug.cgi?id=91248
  * https://gcc.gnu.org/bugzilla//show_bug.cgi?id=93811
- * gcc's clear_cache builtin for power and sparc are broken
+ * gcc's clear_cache builtin for power is broken
  */
-#if !defined(SLJIT_CONFIG_PPC) && !defined(SLJIT_CONFIG_SPARC_32)
+#if !defined(SLJIT_CONFIG_PPC)
 #define SLJIT_CACHE_FLUSH(from, to) \
 	__builtin___clear_cache((char*)(from), (char*)(to))
 #endif
 
 #endif /* gcc >= 10 */
 #endif /* (!defined SLJIT_CACHE_FLUSH && defined __has_builtin) */
 
@@ -369,38 +380,31 @@
 #elif (defined SLJIT_CONFIG_PPC && SLJIT_CONFIG_PPC)
 
 /* The __clear_cache() implementation of GCC is a dummy function on PowerPC. */
 #define SLJIT_CACHE_FLUSH(from, to) \
 	ppc_cache_flush((from), (to))
 #define SLJIT_CACHE_FLUSH_OWN_IMPL 1
 
-#elif (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32)
+#elif defined(_WIN32)
 
-/* The __clear_cache() implementation of GCC is a dummy function on Sparc. */
 #define SLJIT_CACHE_FLUSH(from, to) \
-	sparc_cache_flush((from), (to))
-#define SLJIT_CACHE_FLUSH_OWN_IMPL 1
+	FlushInstructionCache(GetCurrentProcess(), (void*)(from), (char*)(to) - (char*)(from))
 
 #elif (defined(__GNUC__) && (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))) || defined(__clang__)
 
 #define SLJIT_CACHE_FLUSH(from, to) \
 	__builtin___clear_cache((char*)(from), (char*)(to))
 
 #elif defined __ANDROID__
 
 /* Android ARMv7 with gcc lacks __clear_cache; use cacheflush instead. */
 #include <sys/cachectl.h>
 #define SLJIT_CACHE_FLUSH(from, to) \
 	cacheflush((long)(from), (long)(to), 0)
 
-#elif defined _WIN32
-
-#define SLJIT_CACHE_FLUSH(from, to) \
-	FlushInstructionCache(GetCurrentProcess(), (void*)(from), (char*)(to) - (char*)(from))
-
 #else
 
 /* Call __ARM_NR_cacheflush on ARM-Linux or the corresponding MIPS syscall. */
 #define SLJIT_CACHE_FLUSH(from, to) \
 	__clear_cache((char*)(from), (char*)(to))
 
 #endif
@@ -431,14 +435,15 @@
 #define SLJIT_WORD_SHIFT 0
 typedef unsigned long int sljit_uw;
 typedef long int sljit_sw;
 #elif !(defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64) \
 	&& !(defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
 	&& !(defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64) \
 	&& !(defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64) \
+	&& !(defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64) \
 	&& !(defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 #define SLJIT_32BIT_ARCHITECTURE 1
 #define SLJIT_WORD_SHIFT 2
 typedef unsigned int sljit_uw;
 typedef int sljit_sw;
 #else
 #define SLJIT_64BIT_ARCHITECTURE 1
@@ -491,25 +496,23 @@
 /*************************/
 /* Endianness detection. */
 /*************************/
 
 #if !defined(SLJIT_BIG_ENDIAN) && !defined(SLJIT_LITTLE_ENDIAN)
 
 /* These macros are mostly useful for the applications. */
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) \
-	|| (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#if (defined SLJIT_CONFIG_PPC && SLJIT_CONFIG_PPC)
 
 #ifdef __LITTLE_ENDIAN__
 #define SLJIT_LITTLE_ENDIAN 1
 #else
 #define SLJIT_BIG_ENDIAN 1
 #endif
 
-#elif (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32) \
-	|| (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
+#elif (defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS)
 
 #ifdef __MIPSEL__
 #define SLJIT_LITTLE_ENDIAN 1
 #else
 #define SLJIT_BIG_ENDIAN 1
 #endif
 
@@ -528,16 +531,15 @@
  * (should be set to N exactly) so we cannot rely on this too.
  */
 #define SLJIT_MIPS_REV 1
 #endif
 
 #endif /* !SLJIT_MIPS_REV */
 
-#elif (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32) \
-	|| (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
+#elif (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 
 #define SLJIT_BIG_ENDIAN 1
 
 #else
 #define SLJIT_LITTLE_ENDIAN 1
 #endif
 
@@ -550,89 +552,65 @@
 
 #if !(defined SLJIT_BIG_ENDIAN && SLJIT_BIG_ENDIAN) && !(defined SLJIT_LITTLE_ENDIAN && SLJIT_LITTLE_ENDIAN)
 #error "Exactly one endianness must be selected"
 #endif
 
 #ifndef SLJIT_UNALIGNED
 
-#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32) \
-	|| (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64) \
+#if (defined SLJIT_CONFIG_X86 && SLJIT_CONFIG_X86) \
 	|| (defined SLJIT_CONFIG_ARM_V7 && SLJIT_CONFIG_ARM_V7) \
 	|| (defined SLJIT_CONFIG_ARM_THUMB2 && SLJIT_CONFIG_ARM_THUMB2) \
 	|| (defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
-	|| (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) \
-	|| (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64) \
+	|| (defined SLJIT_CONFIG_PPC && SLJIT_CONFIG_PPC) \
+	|| (defined SLJIT_CONFIG_RISCV && SLJIT_CONFIG_RISCV) \
 	|| (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 #define SLJIT_UNALIGNED 1
 #endif
 
 #endif /* !SLJIT_UNALIGNED */
 
+#ifndef SLJIT_FPU_UNALIGNED
+
+#if (defined SLJIT_CONFIG_X86 && SLJIT_CONFIG_X86) \
+	|| (defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
+	|| (defined SLJIT_CONFIG_PPC && SLJIT_CONFIG_PPC) \
+	|| (defined SLJIT_CONFIG_RISCV && SLJIT_CONFIG_RISCV) \
+	|| (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
+#define SLJIT_FPU_UNALIGNED 1
+#endif
+
+#endif /* !SLJIT_FPU_UNALIGNED */
+
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
 /* Auto detect SSE2 support using CPUID.
    On 64 bit x86 cpus, sse2 must be present. */
 #define SLJIT_DETECT_SSE2 1
 #endif
 
 /*****************************************************************************************/
 /* Calling convention of functions generated by SLJIT or called from the generated code. */
 /*****************************************************************************************/
 
 #ifndef SLJIT_FUNC
-
-#if (defined SLJIT_USE_CDECL_CALLING_CONVENTION && SLJIT_USE_CDECL_CALLING_CONVENTION) \
-	|| !(defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
-
 #define SLJIT_FUNC
-
-#elif defined(__GNUC__) && !defined(__APPLE__)
-
-#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
-#define SLJIT_FUNC __attribute__ ((fastcall))
-#define SLJIT_X86_32_FASTCALL 1
-#else
-#define SLJIT_FUNC
-#endif /* gcc >= 3.4 */
-
-#elif defined(_MSC_VER)
-
-#define SLJIT_FUNC __fastcall
-#define SLJIT_X86_32_FASTCALL 1
-
-#elif defined(__BORLANDC__)
-
-#define SLJIT_FUNC __msfastcall
-#define SLJIT_X86_32_FASTCALL 1
-
-#else /* Unknown compiler. */
-
-/* The cdecl calling convention is usually the x86 default. */
-#define SLJIT_FUNC
-
-#endif /* SLJIT_USE_CDECL_CALLING_CONVENTION */
-
 #endif /* !SLJIT_FUNC */
 
 #ifndef SLJIT_INDIRECT_CALL
 #if ((defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64) && (!defined _CALL_ELF || _CALL_ELF == 1)) \
 	|| ((defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) && defined _AIX)
 /* It seems certain ppc compilers use an indirect addressing for functions
    which makes things complicated. */
 #define SLJIT_INDIRECT_CALL 1
 #endif
 #endif /* SLJIT_INDIRECT_CALL */
 
-/* The offset which needs to be substracted from the return address to
+/* The offset which needs to be subtracted from the return address to
 determine the next executed instruction after return. */
 #ifndef SLJIT_RETURN_ADDRESS_OFFSET
-#if (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32)
-#define SLJIT_RETURN_ADDRESS_OFFSET 8
-#else
 #define SLJIT_RETURN_ADDRESS_OFFSET 0
-#endif
 #endif /* SLJIT_RETURN_ADDRESS_OFFSET */
 
 /***************************************************/
 /* Functions of the built-in executable allocator. */
 /***************************************************/
 
 #if (defined SLJIT_EXECUTABLE_ALLOCATOR && SLJIT_EXECUTABLE_ALLOCATOR)
@@ -662,32 +640,32 @@
 /**********************************************/
 /* Registers and locals offset determination. */
 /**********************************************/
 
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
 
 #define SLJIT_NUMBER_OF_REGISTERS 12
-#define SLJIT_NUMBER_OF_SAVED_REGISTERS 9
+#define SLJIT_NUMBER_OF_SAVED_REGISTERS 7
 #define SLJIT_NUMBER_OF_FLOAT_REGISTERS 7
 #define SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS 0
-#define SLJIT_LOCALS_OFFSET_BASE (compiler->locals_offset)
+#define SLJIT_LOCALS_OFFSET_BASE (8 * SSIZE_OF(sw))
 #define SLJIT_PREF_SHIFT_REG SLJIT_R2
 
 #elif (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
 
 #define SLJIT_NUMBER_OF_REGISTERS 13
 #define SLJIT_NUMBER_OF_FLOAT_REGISTERS 15
 #ifndef _WIN64
 #define SLJIT_NUMBER_OF_SAVED_REGISTERS 6
 #define SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS 0
 #define SLJIT_LOCALS_OFFSET_BASE 0
 #else /* _WIN64 */
 #define SLJIT_NUMBER_OF_SAVED_REGISTERS 8
 #define SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS 10
-#define SLJIT_LOCALS_OFFSET_BASE (4 * (sljit_s32)sizeof(sljit_sw))
+#define SLJIT_LOCALS_OFFSET_BASE (4 * SSIZE_OF(sw))
 #endif /* !_WIN64 */
 #define SLJIT_PREF_SHIFT_REG SLJIT_R3
 
 #elif (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5) || (defined SLJIT_CONFIG_ARM_V7 && SLJIT_CONFIG_ARM_V7)
 
 #define SLJIT_NUMBER_OF_REGISTERS 12
 #define SLJIT_NUMBER_OF_SAVED_REGISTERS 8
@@ -736,25 +714,21 @@
 #define SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS 6
 #else
 #define SLJIT_LOCALS_OFFSET_BASE 0
 #define SLJIT_NUMBER_OF_FLOAT_REGISTERS 29
 #define SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS 8
 #endif
 
-#elif (defined SLJIT_CONFIG_SPARC && SLJIT_CONFIG_SPARC)
+#elif (defined SLJIT_CONFIG_RISCV && SLJIT_CONFIG_RISCV)
 
-#define SLJIT_NUMBER_OF_REGISTERS 18
-#define SLJIT_NUMBER_OF_SAVED_REGISTERS 14
-#define SLJIT_NUMBER_OF_FLOAT_REGISTERS 14
-#define SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS 0
-#if (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32)
-/* saved registers (16), return struct pointer (1), space for 6 argument words (1),
-   4th double arg (2), double alignment (1). */
-#define SLJIT_LOCALS_OFFSET_BASE ((16 + 1 + 6 + 2 + 1) * (sljit_s32)sizeof(sljit_sw))
-#endif
+#define SLJIT_NUMBER_OF_REGISTERS 23
+#define SLJIT_NUMBER_OF_SAVED_REGISTERS 12
+#define SLJIT_LOCALS_OFFSET_BASE 0
+#define SLJIT_NUMBER_OF_FLOAT_REGISTERS 30
+#define SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS 12
 
 #elif (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 
 /*
  * https://refspecs.linuxbase.org/ELF/zSeries/lzsabi0_zSeries.html#STACKFRAME
  *
  * 160
@@ -802,15 +776,15 @@
 /********************************/
 /* CPU status flags management. */
 /********************************/
 
 #if (defined SLJIT_CONFIG_ARM && SLJIT_CONFIG_ARM) \
 	|| (defined SLJIT_CONFIG_PPC && SLJIT_CONFIG_PPC) \
 	|| (defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS) \
-	|| (defined SLJIT_CONFIG_SPARC && SLJIT_CONFIG_SPARC) \
+	|| (defined SLJIT_CONFIG_RISCV && SLJIT_CONFIG_RISCV) \
 	|| (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 #define SLJIT_HAS_STATUS_FLAGS_STATE 1
 #endif
 
 /*************************************/
 /* Debug and verbose related macros. */
 /*************************************/
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitExecAllocator.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitExecAllocator.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitLir.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitLir.c`

 * *Files 13% similar despite different names*

```diff
@@ -129,36 +129,44 @@
 /* When reg cannot be unused. */
 #define FAST_IS_REG(reg)	((reg) <= REG_MASK)
 
 /* Mask for argument types. */
 #define SLJIT_ARG_MASK		0x7
 #define SLJIT_ARG_FULL_MASK	(SLJIT_ARG_MASK | SLJIT_ARG_TYPE_SCRATCH_REG)
 
+/* Mask for sljit_emit_mem. */
+#define REG_PAIR_MASK		0xff00
+#define REG_PAIR_FIRST(reg)	((reg) & 0xff)
+#define REG_PAIR_SECOND(reg)	((reg) >> 8)
+
+/* Mask for sljit_emit_enter. */
+#define SLJIT_KEPT_SAVEDS_COUNT(options) ((options) & 0x3)
+
 /* Jump flags. */
 #define JUMP_LABEL	0x1
 #define JUMP_ADDR	0x2
 /* SLJIT_REWRITABLE_JUMP is 0x1000. */
 
 #if (defined SLJIT_CONFIG_X86 && SLJIT_CONFIG_X86)
 #	define PATCH_MB		0x4
 #	define PATCH_MW		0x8
 #if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
 #	define PATCH_MD		0x10
 #endif
 #	define TYPE_SHIFT	13
-#endif
+#endif /* SLJIT_CONFIG_X86 */
 
 #if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5) || (defined SLJIT_CONFIG_ARM_V7 && SLJIT_CONFIG_ARM_V7)
 #	define IS_BL		0x4
 #	define PATCH_B		0x8
-#endif
+#endif /* SLJIT_CONFIG_ARM_V5 || SLJIT_CONFIG_ARM_V7 */
 
 #if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
 #	define CPOOL_SIZE	512
-#endif
+#endif /* SLJIT_CONFIG_ARM_V5 */
 
 #if (defined SLJIT_CONFIG_ARM_THUMB2 && SLJIT_CONFIG_ARM_THUMB2)
 #	define IS_COND		0x04
 #	define IS_BL		0x08
 	/* conditional + imm8 */
 #	define PATCH_TYPE1	0x10
 	/* conditional + imm20 */
@@ -168,37 +176,37 @@
 	/* imm11 */
 #	define PATCH_TYPE4	0x40
 	/* imm24 */
 #	define PATCH_TYPE5	0x50
 	/* BL + imm24 */
 #	define PATCH_BL		0x60
 	/* 0xf00 cc code for branches */
-#endif
+#endif /* SLJIT_CONFIG_ARM_THUMB2 */
 
 #if (defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64)
 #	define IS_COND		0x004
 #	define IS_CBZ		0x008
 #	define IS_BL		0x010
 #	define PATCH_B		0x020
 #	define PATCH_COND	0x040
 #	define PATCH_ABS48	0x080
 #	define PATCH_ABS64	0x100
-#endif
+#endif /* SLJIT_CONFIG_ARM_64 */
 
 #if (defined SLJIT_CONFIG_PPC && SLJIT_CONFIG_PPC)
 #	define IS_COND		0x004
 #	define IS_CALL		0x008
 #	define PATCH_B		0x010
 #	define PATCH_ABS_B	0x020
 #if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
 #	define PATCH_ABS32	0x040
 #	define PATCH_ABS48	0x080
-#endif
+#endif /* SLJIT_CONFIG_PPC_64 */
 #	define REMOVE_COND	0x100
-#endif
+#endif /* SLJIT_CONFIG_PPC */
 
 #if (defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS)
 #	define IS_MOVABLE	0x004
 #	define IS_JAL		0x008
 #	define IS_CALL		0x010
 #	define IS_BIT26_COND	0x020
 #	define IS_BIT16_COND	0x040
@@ -208,45 +216,41 @@
 
 #	define PATCH_B		0x100
 #	define PATCH_J		0x200
 
 #if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
 #	define PATCH_ABS32	0x400
 #	define PATCH_ABS48	0x800
-#endif
+#endif /* SLJIT_CONFIG_MIPS_64 */
 
 	/* instruction types */
 #	define MOVABLE_INS	0
 	/* 1 - 31 last destination register */
 	/* no destination (i.e: store) */
 #	define UNMOVABLE_INS	32
 	/* FPU status register */
 #	define FCSR_FCC		33
-#endif
-
-#if (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32)
-#	define IS_MOVABLE	0x04
-#	define IS_COND		0x08
-#	define IS_CALL		0x10
+#endif /* SLJIT_CONFIG_MIPS */
 
-#	define PATCH_B		0x20
-#	define PATCH_CALL	0x40
-
-	/* instruction types */
-#	define MOVABLE_INS	0
-	/* 1 - 31 last destination register */
-	/* no destination (i.e: store) */
-#	define UNMOVABLE_INS	32
+#if (defined SLJIT_CONFIG_RISCV && SLJIT_CONFIG_RISCV)
+#	define IS_COND		0x004
+#	define IS_CALL		0x008
 
-#	define DST_INS_MASK	0xff
+#	define PATCH_B		0x010
+#	define PATCH_J		0x020
 
-	/* ICC_SET is the same as SET_FLAGS. */
-#	define ICC_IS_SET	(1 << 23)
-#	define FCC_IS_SET	(1 << 24)
-#endif
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+#	define PATCH_REL32	0x040
+#	define PATCH_ABS32	0x080
+#	define PATCH_ABS44	0x100
+#	define PATCH_ABS52	0x200
+#else /* !SLJIT_CONFIG_RISCV_64 */
+#	define PATCH_REL32	0x0
+#endif /* SLJIT_CONFIG_RISCV_64 */
+#endif /* SLJIT_CONFIG_RISCV */
 
 /* Stack management. */
 
 #define GET_SAVED_REGISTERS_SIZE(scratches, saveds, extra) \
 	(((scratches < SLJIT_NUMBER_OF_SCRATCH_REGISTERS ? 0 : (scratches - SLJIT_NUMBER_OF_SCRATCH_REGISTERS)) + \
 		(saveds) + (sljit_s32)(extra)) * (sljit_s32)sizeof(sljit_sw))
 
@@ -381,15 +385,15 @@
 		&& (sizeof(sljit_p) == 4 || sizeof(sljit_p) == 8)
 		&& sizeof(sljit_p) <= sizeof(sljit_sw)
 		&& (sizeof(sljit_sw) == 4 || sizeof(sljit_sw) == 8)
 		&& (sizeof(sljit_uw) == 4 || sizeof(sljit_uw) == 8),
 		invalid_integer_types);
 	SLJIT_COMPILE_ASSERT(SLJIT_REWRITABLE_JUMP != SLJIT_32,
 		rewritable_jump_and_single_op_must_not_be_the_same);
-	SLJIT_COMPILE_ASSERT(!(SLJIT_EQUAL & 0x1) && !(SLJIT_LESS & 0x1) && !(SLJIT_EQUAL_F64 & 0x1) && !(SLJIT_JUMP & 0x1),
+	SLJIT_COMPILE_ASSERT(!(SLJIT_EQUAL & 0x1) && !(SLJIT_LESS & 0x1) && !(SLJIT_F_EQUAL & 0x1) && !(SLJIT_JUMP & 0x1),
 		conditional_flags_must_be_even_numbers);
 
 	/* Only the non-zero members must be set. */
 	compiler->error = SLJIT_SUCCESS;
 
 	compiler->allocator_data = allocator_data;
 	compiler->exec_allocator_data = exec_allocator_data;
@@ -433,18 +437,14 @@
 	compiler->cpool_diff = 0xffffffff;
 #endif
 
 #if (defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS)
 	compiler->delay_slot = UNMOVABLE_INS;
 #endif
 
-#if (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32)
-	compiler->delay_slot = UNMOVABLE_INS;
-#endif
-
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS) \
 		|| (defined SLJIT_DEBUG && SLJIT_DEBUG)
 	compiler->last_flags = 0;
 	compiler->last_return = -1;
 	compiler->logical_local_size = 0;
 #endif
 
@@ -818,14 +818,17 @@
 {
 	if (compiler->scratches == -1 || compiler->saveds == -1)
 		return 0;
 
 	if (!(p & SLJIT_MEM))
 		return 0;
 
+	if (p == SLJIT_MEM1(SLJIT_SP))
+		return (i >= 0 && i < compiler->logical_local_size);
+
 	if (!(!(p & REG_MASK) || FUNCTION_CHECK_IS_REG(p & REG_MASK)))
 		return 0;
 
 	if (CHECK_IF_VIRTUAL_REGISTER(p & REG_MASK))
 		return 0;
 
 	if (p & OFFS_REG_MASK) {
@@ -855,51 +858,42 @@
 
 	if (FUNCTION_CHECK_IS_REG(p))
 		return (i == 0);
 
 	if (p == SLJIT_IMM)
 		return 1;
 
-	if (p == SLJIT_MEM1(SLJIT_SP))
-		return (i >= 0 && i < compiler->logical_local_size);
-
 	return function_check_src_mem(compiler, p, i);
 }
 
 #define FUNCTION_CHECK_SRC(p, i) \
 	CHECK_ARGUMENT(function_check_src(compiler, p, i));
 
 static sljit_s32 function_check_dst(struct sljit_compiler *compiler, sljit_s32 p, sljit_sw i)
 {
 	if (compiler->scratches == -1 || compiler->saveds == -1)
 		return 0;
 
 	if (FUNCTION_CHECK_IS_REG(p))
 		return (i == 0);
 
-	if (p == SLJIT_MEM1(SLJIT_SP))
-		return (i >= 0 && i < compiler->logical_local_size);
-
 	return function_check_src_mem(compiler, p, i);
 }
 
 #define FUNCTION_CHECK_DST(p, i) \
 	CHECK_ARGUMENT(function_check_dst(compiler, p, i));
 
 static sljit_s32 function_fcheck(struct sljit_compiler *compiler, sljit_s32 p, sljit_sw i)
 {
 	if (compiler->scratches == -1 || compiler->saveds == -1)
 		return 0;
 
 	if (FUNCTION_CHECK_IS_FREG(p))
 		return (i == 0);
 
-	if (p == SLJIT_MEM1(SLJIT_SP))
-		return (i >= 0 && i < compiler->logical_local_size);
-
 	return function_check_src_mem(compiler, p, i);
 }
 
 #define FUNCTION_FCHECK(p, i) \
 	CHECK_ARGUMENT(function_fcheck(compiler, p, i));
 
 #endif /* SLJIT_ARGUMENT_CHECKS */
@@ -909,15 +903,19 @@
 SLJIT_API_FUNC_ATTRIBUTE void sljit_compiler_verbose(struct sljit_compiler *compiler, FILE* verbose)
 {
 	compiler->verbose = verbose;
 }
 
 #if (defined SLJIT_64BIT_ARCHITECTURE && SLJIT_64BIT_ARCHITECTURE)
 #ifdef _WIN64
+#ifdef __GNUC__
+#	define SLJIT_PRINT_D	"ll"
+#else
 #	define SLJIT_PRINT_D	"I64"
+#endif
 #else
 #	define SLJIT_PRINT_D	"l"
 #endif
 #else
 #	define SLJIT_PRINT_D	""
 #endif
 
@@ -991,21 +989,22 @@
 	"divmod.u", "divmod.s", "div.u", "div.s",
 	"endbr", "skip_frames_before_return"
 };
 
 static const char* op1_names[] = {
 	"", ".u8", ".s8", ".u16",
 	".s16", ".u32", ".s32", "32",
-	".p", "not", "clz",
+	".p", "not", "clz", "ctz"
 };
 
 static const char* op2_names[] = {
 	"add", "addc", "sub", "subc",
 	"mul", "and", "or", "xor",
-	"shl", "lshr", "ashr",
+	"shl", "mshl", "lshr", "mlshr",
+	"ashr", "mashr", "rotl", "rotr"
 };
 
 static const char* op_src_names[] = {
 	"fast_return", "skip_frames_before_fast_return",
 	"prefetch_l1", "prefetch_l2",
 	"prefetch_l3", "prefetch_once",
 };
@@ -1016,32 +1015,34 @@
 	"abs",
 };
 
 static const char* fop2_names[] = {
 	"add", "sub", "mul", "div"
 };
 
-#define JUMP_POSTFIX(type) \
-	((type & 0xff) <= SLJIT_NOT_OVERFLOW ? ((type & SLJIT_32) ? "32" : "") \
-	: ((type & 0xff) <= SLJIT_ORDERED_F64 ? ((type & SLJIT_32) ? ".f32" : ".f64") : ""))
-
 static const char* jump_names[] = {
 	"equal", "not_equal",
 	"less", "greater_equal",
 	"greater", "less_equal",
 	"sig_less", "sig_greater_equal",
 	"sig_greater", "sig_less_equal",
 	"overflow", "not_overflow",
 	"carry", "",
-	"equal", "not_equal",
-	"less", "greater_equal",
-	"greater", "less_equal",
+	"f_equal", "f_not_equal",
+	"f_less", "f_greater_equal",
+	"f_greater", "f_less_equal",
 	"unordered", "ordered",
+	"ordered_equal", "unordered_or_not_equal",
+	"ordered_less", "unordered_or_greater_equal",
+	"ordered_greater", "unordered_or_less_equal",
+	"unordered_or_equal", "ordered_not_equal",
+	"unordered_or_less", "ordered_greater_equal",
+	"unordered_or_greater", "ordered_less_equal",
 	"jump", "fast_call",
-	"call", "call.cdecl"
+	"call", "call_reg_arg"
 };
 
 static const char* call_arg_names[] = {
 	"void", "w", "32", "p", "f64", "f32"
 };
 
 #endif /* SLJIT_VERBOSE */
@@ -1049,14 +1050,16 @@
 /* --------------------------------------------------------------------- */
 /*  Arch dependent                                                       */
 /* --------------------------------------------------------------------- */
 
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS) \
 	|| (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 
+#define SLJIT_SKIP_CHECKS(compiler) (compiler)->skip_checks = 1
+
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_generate_code(struct sljit_compiler *compiler)
 {
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
 	struct sljit_jump *jump;
 #endif
 
 	SLJIT_UNUSED_ARG(compiler);
@@ -1076,24 +1079,29 @@
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_enter(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
 	SLJIT_UNUSED_ARG(compiler);
 
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	CHECK_ARGUMENT(!(options & ~SLJIT_ENTER_CDECL));
+	if (options & SLJIT_ENTER_REG_ARG) {
+		CHECK_ARGUMENT(!(options & ~(0x3 | SLJIT_ENTER_REG_ARG)));
+	} else {
+		CHECK_ARGUMENT(options == 0);
+	}
+	CHECK_ARGUMENT(SLJIT_KEPT_SAVEDS_COUNT(options) <= 3 && SLJIT_KEPT_SAVEDS_COUNT(options) <= saveds);
 	CHECK_ARGUMENT(scratches >= 0 && scratches <= SLJIT_NUMBER_OF_REGISTERS);
 	CHECK_ARGUMENT(saveds >= 0 && saveds <= SLJIT_NUMBER_OF_SAVED_REGISTERS);
 	CHECK_ARGUMENT(scratches + saveds <= SLJIT_NUMBER_OF_REGISTERS);
 	CHECK_ARGUMENT(fscratches >= 0 && fscratches <= SLJIT_NUMBER_OF_FLOAT_REGISTERS);
 	CHECK_ARGUMENT(fsaveds >= 0 && fsaveds <= SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS);
 	CHECK_ARGUMENT(fscratches + fsaveds <= SLJIT_NUMBER_OF_FLOAT_REGISTERS);
 	CHECK_ARGUMENT(local_size >= 0 && local_size <= SLJIT_MAX_LOCAL_SIZE);
-	CHECK_ARGUMENT((arg_types & SLJIT_ARG_FULL_MASK) < SLJIT_ARG_TYPE_F64);
-	CHECK_ARGUMENT(function_check_arguments(arg_types, scratches, saveds, fscratches));
+	CHECK_ARGUMENT((arg_types & SLJIT_ARG_FULL_MASK) <= SLJIT_ARG_TYPE_F32);
+	CHECK_ARGUMENT(function_check_arguments(arg_types, scratches, (options & SLJIT_ENTER_REG_ARG) ? 0 : saveds, fscratches));
 
 	compiler->last_flags = 0;
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
 		fprintf(compiler->verbose, "  enter ret[%s", call_arg_names[arg_types & SLJIT_ARG_MASK]);
 
@@ -1105,39 +1113,52 @@
 					(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG) ? "_r" : "");
 				arg_types >>= SLJIT_ARG_SHIFT;
 				if (arg_types)
 					fprintf(compiler->verbose, ",");
 			} while (arg_types);
 		}
 
-		fprintf(compiler->verbose, "],%s scratches:%d, saveds:%d, fscratches:%d, fsaveds:%d, local_size:%d\n",
-			(options & SLJIT_ENTER_CDECL) ? " enter:cdecl," : "",
+		fprintf(compiler->verbose, "],");
+
+		if (options & SLJIT_ENTER_REG_ARG) {
+			fprintf(compiler->verbose, " enter:reg_arg,");
+
+			if (SLJIT_KEPT_SAVEDS_COUNT(options) > 0)
+				fprintf(compiler->verbose, " keep:%d,", SLJIT_KEPT_SAVEDS_COUNT(options));
+		}
+
+		fprintf(compiler->verbose, "scratches:%d, saveds:%d, fscratches:%d, fsaveds:%d, local_size:%d\n",
 			scratches, saveds, fscratches, fsaveds, local_size);
 	}
 #endif
 	CHECK_RETURN_OK;
 }
 
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_set_context(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
 	SLJIT_UNUSED_ARG(compiler);
 
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	CHECK_ARGUMENT(!(options & ~SLJIT_ENTER_CDECL));
+	if (options & SLJIT_ENTER_REG_ARG) {
+		CHECK_ARGUMENT(!(options & ~(0x3 | SLJIT_ENTER_REG_ARG)));
+	} else {
+		CHECK_ARGUMENT(options == 0);
+	}
+	CHECK_ARGUMENT(SLJIT_KEPT_SAVEDS_COUNT(options) <= 3 && SLJIT_KEPT_SAVEDS_COUNT(options) <= saveds);
 	CHECK_ARGUMENT(scratches >= 0 && scratches <= SLJIT_NUMBER_OF_REGISTERS);
 	CHECK_ARGUMENT(saveds >= 0 && saveds <= SLJIT_NUMBER_OF_SAVED_REGISTERS);
 	CHECK_ARGUMENT(scratches + saveds <= SLJIT_NUMBER_OF_REGISTERS);
 	CHECK_ARGUMENT(fscratches >= 0 && fscratches <= SLJIT_NUMBER_OF_FLOAT_REGISTERS);
 	CHECK_ARGUMENT(fsaveds >= 0 && fsaveds <= SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS);
 	CHECK_ARGUMENT(fscratches + fsaveds <= SLJIT_NUMBER_OF_FLOAT_REGISTERS);
 	CHECK_ARGUMENT(local_size >= 0 && local_size <= SLJIT_MAX_LOCAL_SIZE);
 	CHECK_ARGUMENT((arg_types & SLJIT_ARG_FULL_MASK) < SLJIT_ARG_TYPE_F64);
-	CHECK_ARGUMENT(function_check_arguments(arg_types, scratches, saveds, fscratches));
+	CHECK_ARGUMENT(function_check_arguments(arg_types, scratches, (options & SLJIT_ENTER_REG_ARG) ? 0 : saveds, fscratches));
 
 	compiler->last_flags = 0;
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
 		fprintf(compiler->verbose, "  set_context ret[%s", call_arg_names[arg_types & SLJIT_ARG_MASK]);
 
@@ -1149,16 +1170,24 @@
 					(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG) ? "_r" : "");
 				arg_types >>= SLJIT_ARG_SHIFT;
 				if (arg_types)
 					fprintf(compiler->verbose, ",");
 			} while (arg_types);
 		}
 
-		fprintf(compiler->verbose, "],%s scratches:%d, saveds:%d, fscratches:%d, fsaveds:%d, local_size:%d\n",
-			(options & SLJIT_ENTER_CDECL) ? " enter:cdecl," : "",
+		fprintf(compiler->verbose, "],");
+
+		if (options & SLJIT_ENTER_REG_ARG) {
+			fprintf(compiler->verbose, " enter:reg_arg,");
+
+			if (SLJIT_KEPT_SAVEDS_COUNT(options) > 0)
+				fprintf(compiler->verbose, " keep:%d,", SLJIT_KEPT_SAVEDS_COUNT(options));
+		}
+
+		fprintf(compiler->verbose, " scratches:%d, saveds:%d, fscratches:%d, fsaveds:%d, local_size:%d\n",
 			scratches, saveds, fscratches, fsaveds, local_size);
 	}
 #endif
 	CHECK_RETURN_OK;
 }
 
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_return_void(struct sljit_compiler *compiler)
@@ -1191,26 +1220,60 @@
 		break;
 	case SLJIT_ARG_TYPE_32:
 		CHECK_ARGUMENT(op == SLJIT_MOV32 || (op >= SLJIT_MOV32_U8 && op <= SLJIT_MOV32_S16));
 		break;
 	case SLJIT_ARG_TYPE_P:
 		CHECK_ARGUMENT(op == SLJIT_MOV_P);
 		break;
+	case SLJIT_ARG_TYPE_F64:
+		CHECK_ARGUMENT(sljit_has_cpu_feature(SLJIT_HAS_FPU));
+		CHECK_ARGUMENT(op == SLJIT_MOV_F64);
+		break;
+	case SLJIT_ARG_TYPE_F32:
+		CHECK_ARGUMENT(sljit_has_cpu_feature(SLJIT_HAS_FPU));
+		CHECK_ARGUMENT(op == SLJIT_MOV_F32);
+		break;
 	default:
 		/* Context not initialized, void, etc. */
 		CHECK_ARGUMENT(0);
 		break;
 	}
-	FUNCTION_CHECK_SRC(src, srcw);
+
+	if (GET_OPCODE(op) < SLJIT_MOV_F64) {
+		FUNCTION_CHECK_SRC(src, srcw);
+	} else {
+		FUNCTION_FCHECK(src, srcw);
+	}
 	compiler->last_flags = 0;
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
-		fprintf(compiler->verbose, "  return%s%s ", !(op & SLJIT_32) ? "" : "32",
-			op1_names[GET_OPCODE(op) - SLJIT_OP1_BASE]);
+		if (GET_OPCODE(op) < SLJIT_MOV_F64) {
+			fprintf(compiler->verbose, "  return%s%s ", !(op & SLJIT_32) ? "" : "32",
+				op1_names[GET_OPCODE(op) - SLJIT_OP1_BASE]);
+			sljit_verbose_param(compiler, src, srcw);
+		} else {
+			fprintf(compiler->verbose, "  return%s ", !(op & SLJIT_32) ? ".f64" : ".f32");
+			sljit_verbose_fparam(compiler, src, srcw);
+		}
+		fprintf(compiler->verbose, "\n");
+	}
+#endif
+	CHECK_RETURN_OK;
+}
+
+static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_return_to(struct sljit_compiler *compiler,
+	sljit_s32 src, sljit_sw srcw)
+{
+#if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
+	FUNCTION_CHECK_SRC(src, srcw);
+#endif
+#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
+	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
+		fprintf(compiler->verbose, "  return_to ");
 		sljit_verbose_param(compiler, src, srcw);
 		fprintf(compiler->verbose, "\n");
 	}
 #endif
 	CHECK_RETURN_OK;
 }
 
@@ -1259,15 +1322,15 @@
 {
 	if (SLJIT_UNLIKELY(compiler->skip_checks)) {
 		compiler->skip_checks = 0;
 		CHECK_RETURN_OK;
 	}
 
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	CHECK_ARGUMENT(GET_OPCODE(op) >= SLJIT_MOV && GET_OPCODE(op) <= SLJIT_CLZ);
+	CHECK_ARGUMENT(GET_OPCODE(op) >= SLJIT_MOV && GET_OPCODE(op) <= SLJIT_CTZ);
 
 	switch (GET_OPCODE(op)) {
 	case SLJIT_NOT:
 		/* Only SLJIT_32 and SLJIT_SET_Z are allowed. */
 		CHECK_ARGUMENT(!(op & VARIABLE_FLAG_MASK));
 		break;
 	case SLJIT_MOV:
@@ -1320,23 +1383,26 @@
 {
 	if (SLJIT_UNLIKELY(compiler->skip_checks)) {
 		compiler->skip_checks = 0;
 		CHECK_RETURN_OK;
 	}
 
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	CHECK_ARGUMENT(GET_OPCODE(op) >= SLJIT_ADD && GET_OPCODE(op) <= SLJIT_ASHR);
+	CHECK_ARGUMENT(GET_OPCODE(op) >= SLJIT_ADD && GET_OPCODE(op) <= SLJIT_ROTR);
 
 	switch (GET_OPCODE(op)) {
 	case SLJIT_AND:
 	case SLJIT_OR:
 	case SLJIT_XOR:
 	case SLJIT_SHL:
+	case SLJIT_MSHL:
 	case SLJIT_LSHR:
+	case SLJIT_MLSHR:
 	case SLJIT_ASHR:
+	case SLJIT_MASHR:
 		CHECK_ARGUMENT(!(op & VARIABLE_FLAG_MASK));
 		break;
 	case SLJIT_MUL:
 		CHECK_ARGUMENT(!(op & SLJIT_SET_Z));
 		CHECK_ARGUMENT(!(op & VARIABLE_FLAG_MASK)
 			|| GET_FLAG_TYPE(op) == SLJIT_OVERFLOW);
 		break;
@@ -1353,14 +1419,18 @@
 	case SLJIT_ADDC:
 	case SLJIT_SUBC:
 		CHECK_ARGUMENT(!(op & VARIABLE_FLAG_MASK)
 			|| GET_FLAG_TYPE(op) == GET_FLAG_TYPE(SLJIT_SET_CARRY));
 		CHECK_ARGUMENT((compiler->last_flags & 0xff) == GET_FLAG_TYPE(SLJIT_SET_CARRY));
 		CHECK_ARGUMENT((op & SLJIT_32) == (compiler->last_flags & SLJIT_32));
 		break;
+	case SLJIT_ROTL:
+	case SLJIT_ROTR:
+		CHECK_ARGUMENT(!(op & (SLJIT_SET_Z | VARIABLE_FLAG_MASK)));
+		break;
 	default:
 		SLJIT_UNREACHABLE();
 		break;
 	}
 
 	if (unset) {
 		CHECK_ARGUMENT(HAS_FLAGS(op));
@@ -1386,14 +1456,43 @@
 		sljit_verbose_param(compiler, src2, src2w);
 		fprintf(compiler->verbose, "\n");
 	}
 #endif
 	CHECK_RETURN_OK;
 }
 
+static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_shift_into(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 src_dst,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+#if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
+	CHECK_ARGUMENT(GET_OPCODE(op) == SLJIT_SHL || GET_OPCODE(op) == SLJIT_LSHR
+		|| GET_OPCODE(op) == SLJIT_MSHL || GET_OPCODE(op) == SLJIT_MLSHR);
+	CHECK_ARGUMENT((op & ~(0xff | SLJIT_32 | SLJIT_SHIFT_INTO_NON_ZERO)) == 0);
+	CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG(src_dst));
+	FUNCTION_CHECK_SRC(src1, src1w);
+	FUNCTION_CHECK_SRC(src2, src2w);
+#endif
+#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
+	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
+		fprintf(compiler->verbose, "  %s%s.into%s ", op2_names[GET_OPCODE(op) - SLJIT_OP2_BASE], !(op & SLJIT_32) ? "" : "32",
+			(op & SLJIT_SHIFT_INTO_NON_ZERO) ? ".nz" : "");
+
+		sljit_verbose_reg(compiler, src_dst);
+		fprintf(compiler->verbose, ", ");
+		sljit_verbose_param(compiler, src1, src1w);
+		fprintf(compiler->verbose, ", ");
+		sljit_verbose_param(compiler, src2, src2w);
+		fprintf(compiler->verbose, "\n");
+	}
+#endif
+	CHECK_RETURN_OK;
+}
+
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_op_src(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src, sljit_sw srcw)
 {
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
 	CHECK_ARGUMENT(op >= SLJIT_FAST_RETURN && op <= SLJIT_PREFETCH_ONCE);
 	FUNCTION_CHECK_SRC(src, srcw);
 
@@ -1506,36 +1605,36 @@
 }
 
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_fop1_cmp(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->last_flags = GET_FLAG_TYPE(op) | (op & (SLJIT_32 | SLJIT_SET_Z));
+	compiler->last_flags = GET_FLAG_TYPE(op) | (op & SLJIT_32);
 #endif
 
 	if (SLJIT_UNLIKELY(compiler->skip_checks)) {
 		compiler->skip_checks = 0;
 		CHECK_RETURN_OK;
 	}
 
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
 	CHECK_ARGUMENT(sljit_has_cpu_feature(SLJIT_HAS_FPU));
 	CHECK_ARGUMENT(GET_OPCODE(op) == SLJIT_CMP_F64);
 	CHECK_ARGUMENT(!(op & SLJIT_SET_Z));
 	CHECK_ARGUMENT((op & VARIABLE_FLAG_MASK)
-		|| (GET_FLAG_TYPE(op) >= SLJIT_EQUAL_F64 && GET_FLAG_TYPE(op) <= SLJIT_ORDERED_F64));
+		|| (GET_FLAG_TYPE(op) >= SLJIT_F_EQUAL && GET_FLAG_TYPE(op) <= SLJIT_ORDERED_LESS_EQUAL));
 	FUNCTION_FCHECK(src1, src1w);
 	FUNCTION_FCHECK(src2, src2w);
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
 		fprintf(compiler->verbose, "  %s%s", fop1_names[SLJIT_CMP_F64 - SLJIT_FOP1_BASE], (op & SLJIT_32) ? ".f32" : ".f64");
 		if (op & VARIABLE_FLAG_MASK) {
-			fprintf(compiler->verbose, ".%s_f", jump_names[GET_FLAG_TYPE(op)]);
+			fprintf(compiler->verbose, ".%s", jump_names[GET_FLAG_TYPE(op)]);
 		}
 		fprintf(compiler->verbose, " ");
 		sljit_verbose_fparam(compiler, src1, src1w);
 		fprintf(compiler->verbose, ", ");
 		sljit_verbose_fparam(compiler, src2, src2w);
 		fprintf(compiler->verbose, "\n");
 	}
@@ -1646,55 +1745,72 @@
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose))
 		fprintf(compiler->verbose, "label:\n");
 #endif
 	CHECK_RETURN_OK;
 }
 
+#if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
+#if (defined SLJIT_CONFIG_X86 && SLJIT_CONFIG_X86) \
+	|| (defined SLJIT_CONFIG_ARM && SLJIT_CONFIG_ARM)
+#define CHECK_UNORDERED(type, last_flags) \
+	((((type) & 0xff) == SLJIT_UNORDERED || ((type) & 0xff) == SLJIT_ORDERED) && \
+		((last_flags) & 0xff) >= SLJIT_UNORDERED && ((last_flags) & 0xff) <= SLJIT_ORDERED_LESS_EQUAL)
+#else
+#define CHECK_UNORDERED(type, last_flags) 0
+#endif
+#endif /* SLJIT_ARGUMENT_CHECKS */
+
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_jump(struct sljit_compiler *compiler, sljit_s32 type)
 {
 	if (SLJIT_UNLIKELY(compiler->skip_checks)) {
 		compiler->skip_checks = 0;
 		CHECK_RETURN_OK;
 	}
 
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	CHECK_ARGUMENT(!(type & ~(0xff | SLJIT_REWRITABLE_JUMP | SLJIT_32)));
+	CHECK_ARGUMENT(!(type & ~(0xff | SLJIT_REWRITABLE_JUMP)));
 	CHECK_ARGUMENT((type & 0xff) >= SLJIT_EQUAL && (type & 0xff) <= SLJIT_FAST_CALL);
-	CHECK_ARGUMENT((type & 0xff) < SLJIT_JUMP || !(type & SLJIT_32));
 
 	if ((type & 0xff) < SLJIT_JUMP) {
 		if ((type & 0xff) <= SLJIT_NOT_ZERO)
 			CHECK_ARGUMENT(compiler->last_flags & SLJIT_SET_Z);
 		else if ((compiler->last_flags & 0xff) == SLJIT_CARRY) {
 			CHECK_ARGUMENT((type & 0xff) == SLJIT_CARRY || (type & 0xff) == SLJIT_NOT_CARRY);
 			compiler->last_flags = 0;
 		} else
 			CHECK_ARGUMENT((type & 0xff) == (compiler->last_flags & 0xff)
-				|| ((type & 0xff) == SLJIT_NOT_OVERFLOW && (compiler->last_flags & 0xff) == SLJIT_OVERFLOW));
+				|| ((type & 0xff) == SLJIT_NOT_OVERFLOW && (compiler->last_flags & 0xff) == SLJIT_OVERFLOW)
+				|| CHECK_UNORDERED(type, compiler->last_flags));
 	}
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose))
-		fprintf(compiler->verbose, "  jump%s %s%s\n", !(type & SLJIT_REWRITABLE_JUMP) ? "" : ".r",
-			jump_names[type & 0xff], JUMP_POSTFIX(type));
+		fprintf(compiler->verbose, "  jump%s %s\n", !(type & SLJIT_REWRITABLE_JUMP) ? "" : ".r",
+			jump_names[type & 0xff]);
 #endif
 	CHECK_RETURN_OK;
 }
 
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 arg_types)
 {
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
 	CHECK_ARGUMENT(!(type & ~(0xff | SLJIT_REWRITABLE_JUMP | SLJIT_CALL_RETURN)));
-	CHECK_ARGUMENT((type & 0xff) == SLJIT_CALL || (type & 0xff) == SLJIT_CALL_CDECL);
+	CHECK_ARGUMENT((type & 0xff) >= SLJIT_CALL && (type & 0xff) <= SLJIT_CALL_REG_ARG);
 	CHECK_ARGUMENT(function_check_arguments(arg_types, compiler->scratches, -1, compiler->fscratches));
 
 	if (type & SLJIT_CALL_RETURN) {
 		CHECK_ARGUMENT((arg_types & SLJIT_ARG_MASK) == compiler->last_return);
+
+		if (compiler->options & SLJIT_ENTER_REG_ARG) {
+			CHECK_ARGUMENT((type & 0xff) == SLJIT_CALL_REG_ARG);
+		} else {
+			CHECK_ARGUMENT((type & 0xff) != SLJIT_CALL_REG_ARG);
+		}
 	}
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
 		fprintf(compiler->verbose, "  %s%s%s ret[%s", jump_names[type & 0xff],
 			!(type & SLJIT_REWRITABLE_JUMP) ? "" : ".r",
 			!(type & SLJIT_CALL_RETURN) ? "" : ".ret",
@@ -1725,16 +1841,16 @@
 	CHECK_ARGUMENT((type & 0xff) >= SLJIT_EQUAL && (type & 0xff) <= SLJIT_SIG_LESS_EQUAL);
 	FUNCTION_CHECK_SRC(src1, src1w);
 	FUNCTION_CHECK_SRC(src2, src2w);
 	compiler->last_flags = 0;
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
-		fprintf(compiler->verbose, "  cmp%s %s%s, ", !(type & SLJIT_REWRITABLE_JUMP) ? "" : ".r",
-			jump_names[type & 0xff], (type & SLJIT_32) ? "32" : "");
+		fprintf(compiler->verbose, "  cmp%s%s %s, ", (type & SLJIT_32) ? "32" : "",
+			!(type & SLJIT_REWRITABLE_JUMP) ? "" : ".r", jump_names[type & 0xff]);
 		sljit_verbose_param(compiler, src1, src1w);
 		fprintf(compiler->verbose, ", ");
 		sljit_verbose_param(compiler, src2, src2w);
 		fprintf(compiler->verbose, "\n");
 	}
 #endif
 	CHECK_RETURN_OK;
@@ -1743,23 +1859,24 @@
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_fcmp(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
 	CHECK_ARGUMENT(sljit_has_cpu_feature(SLJIT_HAS_FPU));
 	CHECK_ARGUMENT(!(type & ~(0xff | SLJIT_REWRITABLE_JUMP | SLJIT_32)));
-	CHECK_ARGUMENT((type & 0xff) >= SLJIT_EQUAL_F64 && (type & 0xff) <= SLJIT_ORDERED_F64);
+	CHECK_ARGUMENT((type & 0xff) >= SLJIT_F_EQUAL && (type & 0xff) <= SLJIT_ORDERED_LESS_EQUAL
+				&& ((type & 0xff) <= SLJIT_ORDERED || sljit_cmp_info(type & 0xff)));
 	FUNCTION_FCHECK(src1, src1w);
 	FUNCTION_FCHECK(src2, src2w);
 	compiler->last_flags = 0;
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
-		fprintf(compiler->verbose, "  fcmp%s %s%s, ", !(type & SLJIT_REWRITABLE_JUMP) ? "" : ".r",
-			jump_names[type & 0xff], (type & SLJIT_32) ? ".f32" : ".f64");
+		fprintf(compiler->verbose, "  fcmp%s%s %s, ", (type & SLJIT_32) ? ".f32" : ".f64",
+			!(type & SLJIT_REWRITABLE_JUMP) ? "" : ".r", jump_names[type & 0xff]);
 		sljit_verbose_fparam(compiler, src1, src1w);
 		fprintf(compiler->verbose, ", ");
 		sljit_verbose_fparam(compiler, src2, src2w);
 		fprintf(compiler->verbose, "\n");
 	}
 #endif
 	CHECK_RETURN_OK;
@@ -1789,20 +1906,26 @@
 
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_icall(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 arg_types,
 	sljit_s32 src, sljit_sw srcw)
 {
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
 	CHECK_ARGUMENT(!(type & ~(0xff | SLJIT_CALL_RETURN)));
-	CHECK_ARGUMENT((type & 0xff) == SLJIT_CALL || (type & 0xff) == SLJIT_CALL_CDECL);
+	CHECK_ARGUMENT((type & 0xff) >= SLJIT_CALL && (type & 0xff) <= SLJIT_CALL_REG_ARG);
 	CHECK_ARGUMENT(function_check_arguments(arg_types, compiler->scratches, -1, compiler->fscratches));
 	FUNCTION_CHECK_SRC(src, srcw);
 
 	if (type & SLJIT_CALL_RETURN) {
 		CHECK_ARGUMENT((arg_types & SLJIT_ARG_MASK) == compiler->last_return);
+
+		if (compiler->options & SLJIT_ENTER_REG_ARG) {
+			CHECK_ARGUMENT((type & 0xff) == SLJIT_CALL_REG_ARG);
+		} else {
+			CHECK_ARGUMENT((type & 0xff) != SLJIT_CALL_REG_ARG);
+		}
 	}
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
 		fprintf(compiler->verbose, "  i%s%s ret[%s", jump_names[type & 0xff],
 			!(type & SLJIT_CALL_RETURN) ? "" : ".ret",
 			call_arg_names[arg_types & SLJIT_ARG_MASK]);
@@ -1826,106 +1949,204 @@
 }
 
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_op_flags(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 type)
 {
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	CHECK_ARGUMENT(!(type & ~(0xff | SLJIT_32)));
-	CHECK_ARGUMENT((type & 0xff) >= SLJIT_EQUAL && (type & 0xff) <= SLJIT_ORDERED_F64);
+	CHECK_ARGUMENT(type >= SLJIT_EQUAL && type <= SLJIT_ORDERED_LESS_EQUAL);
 	CHECK_ARGUMENT(op == SLJIT_MOV || op == SLJIT_MOV32
 		|| (GET_OPCODE(op) >= SLJIT_AND && GET_OPCODE(op) <= SLJIT_XOR));
 	CHECK_ARGUMENT(!(op & VARIABLE_FLAG_MASK));
 
-	if ((type & 0xff) <= SLJIT_NOT_ZERO)
+	if (type <= SLJIT_NOT_ZERO)
 		CHECK_ARGUMENT(compiler->last_flags & SLJIT_SET_Z);
 	else
-		CHECK_ARGUMENT((type & 0xff) == (compiler->last_flags & 0xff)
-			|| ((type & 0xff) == SLJIT_NOT_CARRY && (compiler->last_flags & 0xff) == SLJIT_CARRY)
-			|| ((type & 0xff) == SLJIT_NOT_OVERFLOW && (compiler->last_flags & 0xff) == SLJIT_OVERFLOW));
+		CHECK_ARGUMENT(type == (compiler->last_flags & 0xff)
+			|| (type == SLJIT_NOT_CARRY && (compiler->last_flags & 0xff) == SLJIT_CARRY)
+			|| (type == SLJIT_NOT_OVERFLOW && (compiler->last_flags & 0xff) == SLJIT_OVERFLOW)
+			|| CHECK_UNORDERED(type, compiler->last_flags));
 
 	FUNCTION_CHECK_DST(dst, dstw);
 
 	if (GET_OPCODE(op) >= SLJIT_ADD)
 		compiler->last_flags = GET_FLAG_TYPE(op) | (op & (SLJIT_32 | SLJIT_SET_Z));
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
-		fprintf(compiler->verbose, "  flags%s %s%s, ",
-			!(op & SLJIT_SET_Z) ? "" : ".z",
+		fprintf(compiler->verbose, "  flags.%s%s%s ",
 			GET_OPCODE(op) < SLJIT_OP2_BASE ? "mov" : op2_names[GET_OPCODE(op) - SLJIT_OP2_BASE],
-			GET_OPCODE(op) < SLJIT_OP2_BASE ? op1_names[GET_OPCODE(op) - SLJIT_OP1_BASE] : ((op & SLJIT_32) ? "32" : ""));
+			GET_OPCODE(op) < SLJIT_OP2_BASE ? op1_names[GET_OPCODE(op) - SLJIT_OP1_BASE] : ((op & SLJIT_32) ? "32" : ""),
+			!(op & SLJIT_SET_Z) ? "" : ".z");
 		sljit_verbose_param(compiler, dst, dstw);
-		fprintf(compiler->verbose, ", %s%s\n", jump_names[type & 0xff], JUMP_POSTFIX(type));
+		fprintf(compiler->verbose, ", %s\n", jump_names[type]);
 	}
 #endif
 	CHECK_RETURN_OK;
 }
 
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_cmov(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 dst_reg,
 	sljit_s32 src, sljit_sw srcw)
 {
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	CHECK_ARGUMENT(!(type & ~(0xff | SLJIT_32)));
-	CHECK_ARGUMENT((type & 0xff) >= SLJIT_EQUAL && (type & 0xff) <= SLJIT_ORDERED_F64);
+	sljit_s32 cond = type & ~SLJIT_32;
+
+	CHECK_ARGUMENT(cond >= SLJIT_EQUAL && cond <= SLJIT_ORDERED_LESS_EQUAL);
 
 	CHECK_ARGUMENT(compiler->scratches != -1 && compiler->saveds != -1);
-	CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG(dst_reg & ~SLJIT_32));
+	CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG(dst_reg));
 	if (src != SLJIT_IMM) {
 		CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG(src));
 		CHECK_ARGUMENT(srcw == 0);
 	}
 
-	if ((type & 0xff) <= SLJIT_NOT_ZERO)
+	if (cond <= SLJIT_NOT_ZERO)
 		CHECK_ARGUMENT(compiler->last_flags & SLJIT_SET_Z);
 	else
-		CHECK_ARGUMENT((type & 0xff) == (compiler->last_flags & 0xff)
-			|| ((type & 0xff) == SLJIT_NOT_OVERFLOW && (compiler->last_flags & 0xff) == SLJIT_OVERFLOW));
+		CHECK_ARGUMENT(cond == (compiler->last_flags & 0xff)
+			|| (cond == SLJIT_NOT_CARRY && (compiler->last_flags & 0xff) == SLJIT_CARRY)
+			|| (cond == SLJIT_NOT_OVERFLOW && (compiler->last_flags & 0xff) == SLJIT_OVERFLOW)
+			|| CHECK_UNORDERED(cond, compiler->last_flags));
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
-		fprintf(compiler->verbose, "  cmov%s %s%s, ",
-			!(dst_reg & SLJIT_32) ? "" : "32",
-			jump_names[type & 0xff], JUMP_POSTFIX(type));
-		sljit_verbose_reg(compiler, dst_reg & ~SLJIT_32);
+		fprintf(compiler->verbose, "  cmov%s %s, ",
+			!(type & SLJIT_32) ? "" : "32",
+			jump_names[type & ~SLJIT_32]);
+		sljit_verbose_reg(compiler, dst_reg);
 		fprintf(compiler->verbose, ", ");
 		sljit_verbose_param(compiler, src, srcw);
 		fprintf(compiler->verbose, "\n");
 	}
 #endif
 	CHECK_RETURN_OK;
 }
 
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_mem(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 reg,
 	sljit_s32 mem, sljit_sw memw)
 {
+	if (SLJIT_UNLIKELY(compiler->skip_checks)) {
+		compiler->skip_checks = 0;
+		CHECK_RETURN_OK;
+	}
+
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	CHECK_ARGUMENT((type & 0xff) >= SLJIT_MOV && (type & 0xff) <= SLJIT_MOV_P);
-	CHECK_ARGUMENT(!(type & SLJIT_32) || ((type & 0xff) != SLJIT_MOV && (type & 0xff) != SLJIT_MOV_U32 && (type & 0xff) != SLJIT_MOV_P));
-	CHECK_ARGUMENT((type & SLJIT_MEM_PRE) || (type & SLJIT_MEM_POST));
-	CHECK_ARGUMENT((type & (SLJIT_MEM_PRE | SLJIT_MEM_POST)) != (SLJIT_MEM_PRE | SLJIT_MEM_POST));
-	CHECK_ARGUMENT((type & ~(0xff | SLJIT_32 | SLJIT_MEM_STORE | SLJIT_MEM_SUPP | SLJIT_MEM_PRE | SLJIT_MEM_POST)) == 0);
+	sljit_s32 allowed_flags;
+
+	if (type & SLJIT_MEM_UNALIGNED) {
+		CHECK_ARGUMENT(!(type & (SLJIT_MEM_UNALIGNED_16 | SLJIT_MEM_UNALIGNED_32)));
+	} else if (type & SLJIT_MEM_UNALIGNED_16) {
+		CHECK_ARGUMENT(!(type & SLJIT_MEM_UNALIGNED_32));
+	} else {
+		CHECK_ARGUMENT((reg & REG_PAIR_MASK) || (type & SLJIT_MEM_UNALIGNED_32));
+	}
+
+	allowed_flags = SLJIT_MEM_UNALIGNED;
+
+	switch (type & 0xff) {
+	case SLJIT_MOV_U32:
+	case SLJIT_MOV_S32:
+	case SLJIT_MOV32:
+		allowed_flags = SLJIT_MEM_UNALIGNED | SLJIT_MEM_UNALIGNED_16;
+		break;
+	case SLJIT_MOV:
+	case SLJIT_MOV_P:
+		allowed_flags = SLJIT_MEM_UNALIGNED | SLJIT_MEM_UNALIGNED_16 | SLJIT_MEM_UNALIGNED_32;
+		break;
+	}
+
+	CHECK_ARGUMENT((type & ~(0xff | SLJIT_32 | SLJIT_MEM_STORE | allowed_flags)) == 0);
+
+	if (reg & REG_PAIR_MASK) {
+		CHECK_ARGUMENT((type & 0xff) == SLJIT_MOV);
+		CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG(REG_PAIR_FIRST(reg)));
+		CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG(REG_PAIR_SECOND(reg)));
+		CHECK_ARGUMENT(REG_PAIR_FIRST(reg) != REG_PAIR_SECOND(reg));
+	} else {
+		CHECK_ARGUMENT((type & 0xff) >= SLJIT_MOV && (type & 0xff) <= SLJIT_MOV_P);
+		CHECK_ARGUMENT(!(type & SLJIT_32) || ((type & 0xff) >= SLJIT_MOV_U8 && (type & 0xff) <= SLJIT_MOV_S16));
+		CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG(reg));
+	}
 
 	FUNCTION_CHECK_SRC_MEM(mem, memw);
-	CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG(reg));
+#endif
+#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
+	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
+		if ((type & 0xff) == SLJIT_MOV32)
+			fprintf(compiler->verbose, "  %s32",
+				(type & SLJIT_MEM_STORE) ? "store" : "load");
+		else
+			fprintf(compiler->verbose, "  %s%s%s",
+				(type & SLJIT_MEM_STORE) ? "store" : "load",
+				!(type & SLJIT_32) ? "" : "32",
+				op1_names[(type & 0xff) - SLJIT_OP1_BASE]);
+
+		if (type & SLJIT_MEM_UNALIGNED)
+			printf(".un");
+		else if (type & SLJIT_MEM_UNALIGNED_16)
+			printf(".un16");
+		else if (type & SLJIT_MEM_UNALIGNED_32)
+			printf(".un32");
+
+		if (reg & REG_PAIR_MASK) {
+			fprintf(compiler->verbose, " {");
+			sljit_verbose_reg(compiler, REG_PAIR_FIRST(reg));
+			fprintf(compiler->verbose, ", ");
+			sljit_verbose_reg(compiler, REG_PAIR_SECOND(reg));
+			fprintf(compiler->verbose, "}, ");
+		} else {
+			fprintf(compiler->verbose, " ");
+			sljit_verbose_reg(compiler, reg);
+			fprintf(compiler->verbose, ", ");
+		}
+		sljit_verbose_param(compiler, mem, memw);
+		fprintf(compiler->verbose, "\n");
+	}
+#endif
+	CHECK_RETURN_OK;
+}
 
+static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_mem_update(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	if (SLJIT_UNLIKELY(compiler->skip_checks)) {
+		compiler->skip_checks = 0;
+		CHECK_RETURN_OK;
+	}
+
+#if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
+	CHECK_ARGUMENT((type & 0xff) >= SLJIT_MOV && (type & 0xff) <= SLJIT_MOV_P);
+	CHECK_ARGUMENT((type & ~(0xff | SLJIT_32 | SLJIT_MEM_STORE | SLJIT_MEM_SUPP | SLJIT_MEM_POST)) == 0);
 	CHECK_ARGUMENT((mem & REG_MASK) != 0 && (mem & REG_MASK) != reg);
+
+	FUNCTION_CHECK_SRC_MEM(mem, memw);
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
-	if (!(type & SLJIT_MEM_SUPP) && SLJIT_UNLIKELY(!!compiler->verbose)) {
-		if (sljit_emit_mem(compiler, type | SLJIT_MEM_SUPP, reg, mem, memw) == SLJIT_ERR_UNSUPPORTED)
-			fprintf(compiler->verbose, "  //");
+	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
+		if (type & SLJIT_MEM_SUPP)
+			CHECK_RETURN_OK;
+		if (sljit_emit_mem_update(compiler, type | SLJIT_MEM_SUPP, reg, mem, memw) == SLJIT_ERR_UNSUPPORTED) {
+			fprintf(compiler->verbose, "    # mem: unsupported form, no instructions are emitted\n");
+			CHECK_RETURN_OK;
+		}
+
+		if ((type & 0xff) == SLJIT_MOV32)
+			fprintf(compiler->verbose, "  %s32.%s ",
+				(type & SLJIT_MEM_STORE) ? "store" : "load",
+				(type & SLJIT_MEM_POST) ? "post" : "pre");
+		else
+			fprintf(compiler->verbose, "  %s%s%s.%s ",
+				(type & SLJIT_MEM_STORE) ? "store" : "load",
+				!(type & SLJIT_32) ? "" : "32",
+				op1_names[(type & 0xff) - SLJIT_OP1_BASE],
+				(type & SLJIT_MEM_POST) ? "post" : "pre");
 
-		fprintf(compiler->verbose, "  mem%s.%s%s%s ",
-			!(type & SLJIT_32) ? "" : "32",
-			(type & SLJIT_MEM_STORE) ? "st" : "ld",
-			op1_names[(type & 0xff) - SLJIT_OP1_BASE],
-			(type & SLJIT_MEM_PRE) ? ".pre" : ".post");
 		sljit_verbose_reg(compiler, reg);
 		fprintf(compiler->verbose, ", ");
 		sljit_verbose_param(compiler, mem, memw);
 		fprintf(compiler->verbose, "\n");
 	}
 #endif
 	CHECK_RETURN_OK;
@@ -1933,37 +2154,83 @@
 
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_fmem(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 freg,
 	sljit_s32 mem, sljit_sw memw)
 {
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
 	CHECK_ARGUMENT((type & 0xff) == SLJIT_MOV_F64);
-	CHECK_ARGUMENT((type & SLJIT_MEM_PRE) || (type & SLJIT_MEM_POST));
-	CHECK_ARGUMENT((type & (SLJIT_MEM_PRE | SLJIT_MEM_POST)) != (SLJIT_MEM_PRE | SLJIT_MEM_POST));
-	CHECK_ARGUMENT((type & ~(0xff | SLJIT_32 | SLJIT_MEM_STORE | SLJIT_MEM_SUPP | SLJIT_MEM_PRE | SLJIT_MEM_POST)) == 0);
 
+	if (type & SLJIT_MEM_UNALIGNED) {
+		CHECK_ARGUMENT(!(type & (SLJIT_MEM_UNALIGNED_16 | SLJIT_MEM_UNALIGNED_32)));
+	} else if (type & SLJIT_MEM_UNALIGNED_16) {
+		CHECK_ARGUMENT(!(type & SLJIT_MEM_UNALIGNED_32));
+	} else {
+		CHECK_ARGUMENT(type & SLJIT_MEM_UNALIGNED_32);
+		CHECK_ARGUMENT(!(type & SLJIT_32));
+	}
+
+	CHECK_ARGUMENT(!(type & ~(0xff | SLJIT_32 | SLJIT_MEM_STORE | SLJIT_MEM_UNALIGNED | SLJIT_MEM_UNALIGNED_16 | SLJIT_MEM_UNALIGNED_32)));
+	CHECK_ARGUMENT(FUNCTION_CHECK_IS_FREG(freg));
+	FUNCTION_CHECK_SRC_MEM(mem, memw);
+#endif
+#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
+	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
+		fprintf(compiler->verbose, "  %s.%s",
+			(type & SLJIT_MEM_STORE) ? "store" : "load",
+			!(type & SLJIT_32) ? "f64" : "f32");
+
+		if (type & SLJIT_MEM_UNALIGNED)
+			printf(".un");
+		else if (type & SLJIT_MEM_UNALIGNED_16)
+			printf(".un16");
+		else if (type & SLJIT_MEM_UNALIGNED_32)
+			printf(".un32");
+
+		fprintf(compiler->verbose, " ");
+		sljit_verbose_freg(compiler, freg);
+		fprintf(compiler->verbose, ", ");
+		sljit_verbose_param(compiler, mem, memw);
+		fprintf(compiler->verbose, "\n");
+	}
+#endif
+	CHECK_RETURN_OK;
+}
+
+static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_fmem_update(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 freg,
+	sljit_s32 mem, sljit_sw memw)
+{
+#if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
+	CHECK_ARGUMENT((type & 0xff) == SLJIT_MOV_F64);
+	CHECK_ARGUMENT((type & ~(0xff | SLJIT_32 | SLJIT_MEM_STORE | SLJIT_MEM_SUPP | SLJIT_MEM_POST)) == 0);
 	FUNCTION_CHECK_SRC_MEM(mem, memw);
 	CHECK_ARGUMENT(FUNCTION_CHECK_IS_FREG(freg));
 #endif
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
-	if (!(type & SLJIT_MEM_SUPP) && SLJIT_UNLIKELY(!!compiler->verbose)) {
-		if (sljit_emit_fmem(compiler, type | SLJIT_MEM_SUPP, freg, mem, memw) == SLJIT_ERR_UNSUPPORTED)
-			fprintf(compiler->verbose, "  //");
-
-		fprintf(compiler->verbose, "  fmem.%s%s%s ",
-			(type & SLJIT_MEM_STORE) ? "st" : "ld",
-			!(type & SLJIT_32) ? ".f64" : ".f32",
-			(type & SLJIT_MEM_PRE) ? ".pre" : ".post");
+	if (SLJIT_UNLIKELY(!!compiler->verbose)) {
+		if (type & SLJIT_MEM_SUPP)
+			CHECK_RETURN_OK;
+		if (sljit_emit_fmem_update(compiler, type | SLJIT_MEM_SUPP, freg, mem, memw) == SLJIT_ERR_UNSUPPORTED) {
+			fprintf(compiler->verbose, "    # fmem: unsupported form, no instructions are emitted\n");
+			CHECK_RETURN_OK;
+		}
+
+		fprintf(compiler->verbose, "  %s.%s.%s ",
+			(type & SLJIT_MEM_STORE) ? "store" : "load",
+			!(type & SLJIT_32) ? "f64" : "f32",
+			(type & SLJIT_MEM_POST) ? "post" : "pre");
+
 		sljit_verbose_freg(compiler, freg);
 		fprintf(compiler->verbose, ", ");
 		sljit_verbose_param(compiler, mem, memw);
 		fprintf(compiler->verbose, "\n");
 	}
 #endif
 	CHECK_RETURN_OK;
+
 }
 
 static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_get_local_base(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw offset)
 {
 	/* Any offset is allowed. */
 	SLJIT_UNUSED_ARG(offset);
 
@@ -2008,14 +2275,18 @@
 		sljit_verbose_param(compiler, dst, dstw);
 		fprintf(compiler->verbose, "\n");
 	}
 #endif
 	CHECK_RETURN_OK;
 }
 
+#else /* !SLJIT_ARGUMENT_CHECKS && !SLJIT_VERBOSE */
+
+#define SLJIT_SKIP_CHECKS(compiler)
+
 #endif /* SLJIT_ARGUMENT_CHECKS || SLJIT_VERBOSE */
 
 #define SELECT_FOP1_OPERATION_WITH_CHECKS(compiler, op, dst, dstw, src, srcw) \
 	SLJIT_COMPILE_ASSERT(!(SLJIT_CONV_SW_FROM_F64 & 0x1) && !(SLJIT_CONV_F64_FROM_SW & 0x1), \
 		invalid_float_opcodes); \
 	if (GET_OPCODE(op) >= SLJIT_CONV_SW_FROM_F64 && GET_OPCODE(op) <= SLJIT_CMP_F64) { \
 		if (GET_OPCODE(op) == SLJIT_CMP_F64) { \
@@ -2035,88 +2306,77 @@
 		ADJUST_LOCAL_OFFSET(src, srcw); \
 		return sljit_emit_fop1_conv_f64_from_sw(compiler, op, dst, dstw, src, srcw); \
 	} \
 	CHECK(check_sljit_emit_fop1(compiler, op, dst, dstw, src, srcw)); \
 	ADJUST_LOCAL_OFFSET(dst, dstw); \
 	ADJUST_LOCAL_OFFSET(src, srcw);
 
-static SLJIT_INLINE sljit_s32 emit_mov_before_return(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 src, sljit_sw srcw)
-{
-#if (defined SLJIT_64BIT_ARCHITECTURE && SLJIT_64BIT_ARCHITECTURE)
-	/* At the moment the pointer size is always equal to sljit_sw. May be changed in the future. */
-	if (src == SLJIT_RETURN_REG && (op == SLJIT_MOV || op == SLJIT_MOV_P))
-		return SLJIT_SUCCESS;
-#else
-	if (src == SLJIT_RETURN_REG && (op == SLJIT_MOV || op == SLJIT_MOV_U32 || op == SLJIT_MOV_S32 || op == SLJIT_MOV_P))
-		return SLJIT_SUCCESS;
-#endif
-
-#if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS) \
-		|| (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
-	compiler->skip_checks = 1;
-#endif
-	return sljit_emit_op1(compiler, op, SLJIT_RETURN_REG, 0, src, srcw);
-}
-
-#if !(defined SLJIT_CONFIG_SPARC && SLJIT_CONFIG_SPARC)
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 src, sljit_sw srcw)
-{
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_return(compiler, op, src, srcw));
-
-	FAIL_IF(emit_mov_before_return(compiler, op, src, srcw));
-
-#if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS) \
-		|| (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
-	compiler->skip_checks = 1;
-#endif
-	return sljit_emit_return_void(compiler);
-}
-
-#endif
-
 #if (defined SLJIT_CONFIG_X86 && SLJIT_CONFIG_X86) \
 		|| (defined SLJIT_CONFIG_PPC && SLJIT_CONFIG_PPC) \
-		|| (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32) \
-		|| ((defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS) && !(defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1 && SLJIT_MIPS_REV < 6))
+		|| ((defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS) && !(defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1 && SLJIT_MIPS_REV < 6)) \
+		|| (defined SLJIT_CONFIG_RISCV && SLJIT_CONFIG_RISCV) \
+		|| (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 
 static SLJIT_INLINE sljit_s32 sljit_emit_cmov_generic(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 dst_reg,
 	sljit_s32 src, sljit_sw srcw)
 {
 	struct sljit_label *label;
 	struct sljit_jump *jump;
-	sljit_s32 op = (dst_reg & SLJIT_32) ? SLJIT_MOV32 : SLJIT_MOV;
+	sljit_s32 op = (type & SLJIT_32) ? SLJIT_MOV32 : SLJIT_MOV;
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
-	jump = sljit_emit_jump(compiler, type ^ 0x1);
+	SLJIT_SKIP_CHECKS(compiler);
+	jump = sljit_emit_jump(compiler, (type & ~SLJIT_32) ^ 0x1);
 	FAIL_IF(!jump);
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
-	FAIL_IF(sljit_emit_op1(compiler, op, dst_reg & ~SLJIT_32, 0, src, srcw));
-
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
+	FAIL_IF(sljit_emit_op1(compiler, op, dst_reg, 0, src, srcw));
+
+	SLJIT_SKIP_CHECKS(compiler);
 	label = sljit_emit_label(compiler);
 	FAIL_IF(!label);
+
 	sljit_set_label(jump, label);
 	return SLJIT_SUCCESS;
 }
 
 #endif
 
+#if (!(defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS) || (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)) \
+	&& !(defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
+
+static sljit_s32 sljit_emit_mem_unaligned(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	SLJIT_SKIP_CHECKS(compiler);
+
+	if (type & SLJIT_MEM_STORE)
+		return sljit_emit_op1(compiler, type & (0xff | SLJIT_32), mem, memw, reg, 0);
+	return sljit_emit_op1(compiler, type & (0xff | SLJIT_32), reg, 0, mem, memw);
+}
+
+#endif /* (!SLJIT_CONFIG_MIPS || SLJIT_MIPS_REV >= 6) && !SLJIT_CONFIG_ARM_V5 */
+
+#if (!(defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS) || (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)) \
+	&& !(defined SLJIT_CONFIG_ARM_32 && SLJIT_CONFIG_ARM_32)
+
+static sljit_s32 sljit_emit_fmem_unaligned(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 freg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	SLJIT_SKIP_CHECKS(compiler);
+
+	if (type & SLJIT_MEM_STORE)
+		return sljit_emit_fop1(compiler, type & (0xff | SLJIT_32), mem, memw, freg, 0);
+	return sljit_emit_fop1(compiler, type & (0xff | SLJIT_32), freg, 0, mem, memw);
+}
+
+#endif /* (!SLJIT_CONFIG_MIPS || SLJIT_MIPS_REV >= 6) && !SLJIT_CONFIG_ARM */
+
 /* CPU description section */
 
 #if (defined SLJIT_32BIT_ARCHITECTURE && SLJIT_32BIT_ARCHITECTURE)
 #define SLJIT_CPUINFO_PART1 " 32bit ("
 #elif (defined SLJIT_64BIT_ARCHITECTURE && SLJIT_64BIT_ARCHITECTURE)
 #define SLJIT_CPUINFO_PART1 " 64bit ("
 #else
@@ -2149,21 +2409,66 @@
 #	include "sljitNativeARM_T2_32.c"
 #elif (defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64)
 #	include "sljitNativeARM_64.c"
 #elif (defined SLJIT_CONFIG_PPC && SLJIT_CONFIG_PPC)
 #	include "sljitNativePPC_common.c"
 #elif (defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS)
 #	include "sljitNativeMIPS_common.c"
-#elif (defined SLJIT_CONFIG_SPARC && SLJIT_CONFIG_SPARC)
-#	include "sljitNativeSPARC_common.c"
+#elif (defined SLJIT_CONFIG_RISCV && SLJIT_CONFIG_RISCV)
+#	include "sljitNativeRISCV_common.c"
 #elif (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 #	include "sljitNativeS390X.c"
 #endif
 
-#if !(defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS)
+static SLJIT_INLINE sljit_s32 emit_mov_before_return(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 src, sljit_sw srcw)
+{
+#if (defined SLJIT_64BIT_ARCHITECTURE && SLJIT_64BIT_ARCHITECTURE)
+	/* At the moment the pointer size is always equal to sljit_sw. May be changed in the future. */
+	if (src == SLJIT_RETURN_REG && (op == SLJIT_MOV || op == SLJIT_MOV_P))
+		return SLJIT_SUCCESS;
+#else
+	if (src == SLJIT_RETURN_REG && (op == SLJIT_MOV || op == SLJIT_MOV_U32 || op == SLJIT_MOV_S32 || op == SLJIT_MOV_P))
+		return SLJIT_SUCCESS;
+#endif
+
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_op1(compiler, op, SLJIT_RETURN_REG, 0, src, srcw);
+}
+
+#if !(defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32) \
+	&& !((defined SLJIT_CONFIG_ARM_32 && SLJIT_CONFIG_ARM_32) && defined __SOFTFP__)
+
+static SLJIT_INLINE sljit_s32 emit_fmov_before_return(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 src, sljit_sw srcw)
+{
+	if (src == SLJIT_FR0)
+		return SLJIT_SUCCESS;
+
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_fop1(compiler, op, SLJIT_RETURN_FREG, 0, src, srcw);
+}
+
+#endif /* !SLJIT_CONFIG_X86_32 && !(SLJIT_CONFIG_ARM_32 && __SOFTFP__) */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 src, sljit_sw srcw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_return(compiler, op, src, srcw));
+
+	if (GET_OPCODE(op) < SLJIT_MOV_F64) {
+		FAIL_IF(emit_mov_before_return(compiler, op, src, srcw));
+	} else {
+		FAIL_IF(emit_fmov_before_return(compiler, op, src, srcw));
+	}
+
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_return_void(compiler);
+}
+
+#if !(defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS) \
+	&& !(defined SLJIT_CONFIG_RISCV && SLJIT_CONFIG_RISCV)
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_cmp(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 	/* Default compare for most architectures. */
 	sljit_s32 flags, tmp_src, condition;
@@ -2225,105 +2530,121 @@
 	}
 
 	if (condition <= SLJIT_NOT_ZERO)
 		flags = SLJIT_SET_Z;
 	else
 		flags = condition << VARIABLE_FLAG_SHIFT;
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	PTR_FAIL_IF(sljit_emit_op2u(compiler,
 		SLJIT_SUB | flags | (type & SLJIT_32), src1, src1w, src2, src2w));
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_jump(compiler, condition | (type & (SLJIT_REWRITABLE_JUMP | SLJIT_32)));
 }
 
-#endif
+#endif /* !SLJIT_CONFIG_MIPS */
+
+#if (defined SLJIT_CONFIG_ARM && SLJIT_CONFIG_ARM)
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_cmp_info(sljit_s32 type)
+{
+	if (type < SLJIT_UNORDERED || type > SLJIT_ORDERED_LESS_EQUAL)
+		return 0;
+
+	switch (type) {
+	case SLJIT_UNORDERED_OR_EQUAL:
+	case SLJIT_ORDERED_NOT_EQUAL:
+		return 0;
+	}
+
+	return 1;
+}
+
+#endif /* SLJIT_CONFIG_ARM */
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_fcmp(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 	CHECK_ERROR_PTR();
 	CHECK_PTR(check_sljit_emit_fcmp(compiler, type, src1, src1w, src2, src2w));
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	sljit_emit_fop1(compiler, SLJIT_CMP_F64 | ((type & 0xff) << VARIABLE_FLAG_SHIFT) | (type & SLJIT_32), src1, src1w, src2, src2w);
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_jump(compiler, type);
 }
 
-#if !(defined SLJIT_CONFIG_ARM_32 && SLJIT_CONFIG_ARM_32) \
-	&& !(defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
+#if !(defined SLJIT_CONFIG_ARM && SLJIT_CONFIG_ARM) \
 	&& !(defined SLJIT_CONFIG_PPC && SLJIT_CONFIG_PPC)
 
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem(struct sljit_compiler *compiler, sljit_s32 type,
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem_update(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 reg,
 	sljit_s32 mem, sljit_sw memw)
 {
-	SLJIT_UNUSED_ARG(compiler);
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_mem_update(compiler, type, reg, mem, memw));
 	SLJIT_UNUSED_ARG(type);
 	SLJIT_UNUSED_ARG(reg);
 	SLJIT_UNUSED_ARG(mem);
 	SLJIT_UNUSED_ARG(memw);
 
+	return SLJIT_ERR_UNSUPPORTED;
+}
+
+#endif /* !SLJIT_CONFIG_ARM && !SLJIT_CONFIG_PPC */
+
+#if !(defined SLJIT_CONFIG_ARM_32 && SLJIT_CONFIG_ARM_32) \
+	&& !(defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS)
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 freg,
+	sljit_s32 mem, sljit_sw memw)
+{
 	CHECK_ERROR();
-	CHECK(check_sljit_emit_mem(compiler, type, reg, mem, memw));
+	CHECK(check_sljit_emit_fmem(compiler, type, freg, mem, memw));
 
-	return SLJIT_ERR_UNSUPPORTED;
+	return sljit_emit_fmem_unaligned(compiler, type, freg, mem, memw);
 }
 
-#endif
+#endif /* !SLJIT_CONFIG_ARM_32 && !SLJIT_CONFIG_MIPS */
 
 #if !(defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
 	&& !(defined SLJIT_CONFIG_PPC && SLJIT_CONFIG_PPC)
 
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem(struct sljit_compiler *compiler, sljit_s32 type,
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem_update(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 freg,
 	sljit_s32 mem, sljit_sw memw)
 {
-	SLJIT_UNUSED_ARG(compiler);
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_fmem_update(compiler, type, freg, mem, memw));
 	SLJIT_UNUSED_ARG(type);
 	SLJIT_UNUSED_ARG(freg);
 	SLJIT_UNUSED_ARG(mem);
 	SLJIT_UNUSED_ARG(memw);
 
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_fmem(compiler, type, freg, mem, memw));
-
 	return SLJIT_ERR_UNSUPPORTED;
 }
 
-#endif
+#endif /* !SLJIT_CONFIG_ARM_64 && !SLJIT_CONFIG_PPC */
 
 #if !(defined SLJIT_CONFIG_X86 && SLJIT_CONFIG_X86) \
 	&& !(defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64)
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_local_base(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw offset)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_get_local_base(compiler, dst, dstw, offset));
 
 	ADJUST_LOCAL_OFFSET(SLJIT_MEM1(SLJIT_SP), offset);
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+
+	SLJIT_SKIP_CHECKS(compiler);
+
 	if (offset != 0)
 		return sljit_emit_op2(compiler, SLJIT_ADD, dst, dstw, SLJIT_SP, 0, SLJIT_IMM, offset);
 	return sljit_emit_op1(compiler, SLJIT_MOV, dst, dstw, SLJIT_SP, 0);
 }
 
 #endif
 
@@ -2383,14 +2704,21 @@
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_has_cpu_feature(sljit_s32 feature_type)
 {
 	SLJIT_UNUSED_ARG(feature_type);
 	SLJIT_UNREACHABLE();
 	return 0;
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_cmp_info(sljit_s32 type)
+{
+	SLJIT_UNUSED_ARG(type);
+	SLJIT_UNREACHABLE();
+	return 0;
+}
+
 SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code, void *exec_allocator_data)
 {
 	SLJIT_UNUSED_ARG(code);
 	SLJIT_UNUSED_ARG(exec_allocator_data);
 	SLJIT_UNREACHABLE();
 }
 
@@ -2422,27 +2750,36 @@
 	SLJIT_UNUSED_ARG(fscratches);
 	SLJIT_UNUSED_ARG(fsaveds);
 	SLJIT_UNUSED_ARG(local_size);
 	SLJIT_UNREACHABLE();
 	return SLJIT_ERR_UNSUPPORTED;
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_void(struct sljit_compiler *compiler)
+{
+	SLJIT_UNUSED_ARG(compiler);
+	SLJIT_UNREACHABLE();
+	return SLJIT_ERR_UNSUPPORTED;
+}
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 src, sljit_sw srcw)
 {
 	SLJIT_UNUSED_ARG(compiler);
 	SLJIT_UNUSED_ARG(op);
 	SLJIT_UNUSED_ARG(src);
 	SLJIT_UNUSED_ARG(srcw);
 	SLJIT_UNREACHABLE();
 	return SLJIT_ERR_UNSUPPORTED;
 }
 
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_void(struct sljit_compiler *compiler)
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_to(struct sljit_compiler *compiler, sljit_s32 src, sljit_sw srcw)
 {
 	SLJIT_UNUSED_ARG(compiler);
+	SLJIT_UNUSED_ARG(src);
+	SLJIT_UNUSED_ARG(srcw);
 	SLJIT_UNREACHABLE();
 	return SLJIT_ERR_UNSUPPORTED;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw)
 {
 	SLJIT_UNUSED_ARG(compiler);
@@ -2501,14 +2838,30 @@
 	SLJIT_UNUSED_ARG(src1w);
 	SLJIT_UNUSED_ARG(src2);
 	SLJIT_UNUSED_ARG(src2w);
 	SLJIT_UNREACHABLE();
 	return SLJIT_ERR_UNSUPPORTED;
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_shift_into(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 src_dst,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+	SLJIT_UNUSED_ARG(compiler);
+	SLJIT_UNUSED_ARG(op);
+	SLJIT_UNUSED_ARG(src_dst);
+	SLJIT_UNUSED_ARG(src1);
+	SLJIT_UNUSED_ARG(src1w);
+	SLJIT_UNUSED_ARG(src2);
+	SLJIT_UNUSED_ARG(src2w);
+	SLJIT_UNREACHABLE();
+	return SLJIT_ERR_UNSUPPORTED;
+}
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_src(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src, sljit_sw srcw)
 {
 	SLJIT_UNUSED_ARG(compiler);
 	SLJIT_UNUSED_ARG(op);
 	SLJIT_UNUSED_ARG(src);
 	SLJIT_UNUSED_ARG(srcw);
@@ -2699,22 +3052,44 @@
 	SLJIT_UNUSED_ARG(reg);
 	SLJIT_UNUSED_ARG(mem);
 	SLJIT_UNUSED_ARG(memw);
 	SLJIT_UNREACHABLE();
 	return SLJIT_ERR_UNSUPPORTED;
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem_update(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 reg, sljit_s32 mem, sljit_sw memw)
+{
+	SLJIT_UNUSED_ARG(compiler);
+	SLJIT_UNUSED_ARG(type);
+	SLJIT_UNUSED_ARG(reg);
+	SLJIT_UNUSED_ARG(mem);
+	SLJIT_UNUSED_ARG(memw);
+	SLJIT_UNREACHABLE();
+	return SLJIT_ERR_UNSUPPORTED;
+}
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 freg, sljit_s32 mem, sljit_sw memw)
 {
 	SLJIT_UNUSED_ARG(compiler);
 	SLJIT_UNUSED_ARG(type);
 	SLJIT_UNUSED_ARG(freg);
 	SLJIT_UNUSED_ARG(mem);
 	SLJIT_UNUSED_ARG(memw);
 	SLJIT_UNREACHABLE();
+	return SLJIT_ERR_UNSUPPORTED;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem_update(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 freg, sljit_s32 mem, sljit_sw memw)
+{
+	SLJIT_UNUSED_ARG(compiler);
+	SLJIT_UNUSED_ARG(type);
+	SLJIT_UNUSED_ARG(freg);
+	SLJIT_UNUSED_ARG(mem);
+	SLJIT_UNUSED_ARG(memw);
+	SLJIT_UNREACHABLE();
 	return SLJIT_ERR_UNSUPPORTED;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_local_base(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw offset)
 {
 	SLJIT_UNUSED_ARG(compiler);
 	SLJIT_UNUSED_ARG(dst);
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitLir.h` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitLir.h`

 * *Files 4% similar despite different names*

```diff
@@ -32,34 +32,32 @@
     Stack-Less JIT compiler for multiple architectures (x86, ARM, PowerPC)
    ------------------------------------------------------------------------
 
    Short description
     Advantages:
       - The execution can be continued from any LIR instruction. In other
         words, it is possible to jump to any label from anywhere, even from
-        a code fragment, which is compiled later, if both compiled code
-        shares the same context. See sljit_emit_enter for more details
-      - Supports self modifying code: target of (conditional) jump and call
+        a code fragment, which is compiled later, as long as the compiling
+        context is the same. See sljit_emit_enter for more details.
+      - Supports self modifying code: target of any jump and call
         instructions and some constant values can be dynamically modified
-        during runtime
+        during runtime. See SLJIT_REWRITABLE_JUMP.
         - although it is not suggested to do it frequently
         - can be used for inline caching: save an important value once
           in the instruction stream
-        - since this feature limits the optimization possibilities, a
-          special flag must be passed at compile time when these
-          instructions are emitted
       - A fixed stack space can be allocated for local variables
       - The compiler is thread-safe
       - The compiler is highly configurable through preprocessor macros.
         You can disable unneeded features (multithreading in single
         threaded applications), and you can use your own system functions
-        (including memory allocators). See sljitConfig.h
+        (including memory allocators). See sljitConfig.h.
     Disadvantages:
-      - No automatic register allocation, and temporary results are
-        not stored on the stack. (hence the name comes)
+      - The compiler is more like a platform independent assembler, so
+        there is no built-in variable management. Registers and stack must
+        be managed manually (the name of the compiler refers to this).
     In practice:
       - This approach is very effective for interpreters
         - One of the saved registers typically points to a stack interface
         - It can jump to any exception handler anytime (even if it belongs
           to another function)
         - Hot paths can be modified during runtime reflecting the changes
           of the fastest execution path of the dynamic language
@@ -73,61 +71,63 @@
 #if (defined SLJIT_HAVE_CONFIG_PRE && SLJIT_HAVE_CONFIG_PRE)
 #include "sljitConfigPre.h"
 #endif /* SLJIT_HAVE_CONFIG_PRE */
 
 #include "sljitConfig.h"
 
 /* The following header file defines useful macros for fine tuning
-sljit based code generators. They are listed in the beginning
+SLJIT based code generators. They are listed in the beginning
 of sljitConfigInternal.h */
 
 #include "sljitConfigInternal.h"
 
 #if (defined SLJIT_HAVE_CONFIG_POST && SLJIT_HAVE_CONFIG_POST)
 #include "sljitConfigPost.h"
 #endif /* SLJIT_HAVE_CONFIG_POST */
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+/* Version numbers. */
+#define SLJIT_MAJOR_VERSION	0
+#define SLJIT_MINOR_VERSION	95
+
 /* --------------------------------------------------------------------- */
 /*  Error codes                                                          */
 /* --------------------------------------------------------------------- */
 
 /* Indicates no error. */
 #define SLJIT_SUCCESS			0
 /* After the call of sljit_generate_code(), the error code of the compiler
-   is set to this value to avoid future sljit calls (in debug mode at least).
+   is set to this value to avoid further code generation.
    The complier should be freed after sljit_generate_code(). */
 #define SLJIT_ERR_COMPILED		1
-/* Cannot allocate non executable memory. */
+/* Cannot allocate non-executable memory. */
 #define SLJIT_ERR_ALLOC_FAILED		2
 /* Cannot allocate executable memory.
-   Only for sljit_generate_code() */
+   Only sljit_generate_code() returns with this error code. */
 #define SLJIT_ERR_EX_ALLOC_FAILED	3
 /* Return value for SLJIT_CONFIG_UNSUPPORTED placeholder architecture. */
 #define SLJIT_ERR_UNSUPPORTED		4
 /* An ivalid argument is passed to any SLJIT function. */
 #define SLJIT_ERR_BAD_ARGUMENT		5
-/* Dynamic code modification is not enabled. */
-#define SLJIT_ERR_DYN_CODE_MOD		6
 
 /* --------------------------------------------------------------------- */
 /*  Registers                                                            */
 /* --------------------------------------------------------------------- */
 
 /*
-  Scratch (R) registers: registers whose may not preserve their values
+  Scratch (R) registers: registers which may not preserve their values
   across function calls.
 
-  Saved (S) registers: registers whose preserve their values across
+  Saved (S) registers: registers which preserve their values across
   function calls.
 
-  The scratch and saved register sets are overlap. The last scratch register
+  The scratch and saved register sets overlap. The last scratch register
   is the first saved register, the one before the last is the second saved
   register, and so on.
 
   If an architecture provides two scratch and three saved registers,
   its scratch and saved register sets are the following:
 
      R0   |        |   R0 is always a scratch register
@@ -205,15 +205,15 @@
 
 /* Registers >= SLJIT_FIRST_SAVED_REG are saved registers. */
 #define SLJIT_FIRST_SAVED_REG (SLJIT_S0 - SLJIT_NUMBER_OF_SAVED_REGISTERS + 1)
 
 /* The SLJIT_SP provides direct access to the linear stack space allocated by
    sljit_emit_enter. It can only be used in the following form: SLJIT_MEM1(SLJIT_SP).
    The immediate offset is extended by the relative stack offset automatically.
-   The sljit_get_local_base can be used to obtain the absolute offset. */
+   The sljit_get_local_base can be used to obtain the real address of a value. */
 #define SLJIT_SP	(SLJIT_NUMBER_OF_REGISTERS + 1)
 
 /* Return with machine word. */
 
 #define SLJIT_RETURN_REG	SLJIT_R0
 
 /* --------------------------------------------------------------------- */
@@ -245,14 +245,18 @@
 /* All S registers provided by the architecture can be accessed by SLJIT_FS(i)
    The i parameter must be >= 0 and < SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS. */
 #define SLJIT_FS(i)	(SLJIT_NUMBER_OF_FLOAT_REGISTERS - (i))
 
 /* Float registers >= SLJIT_FIRST_SAVED_FLOAT_REG are saved registers. */
 #define SLJIT_FIRST_SAVED_FLOAT_REG (SLJIT_FS0 - SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS + 1)
 
+/* Return with floating point arg. */
+
+#define SLJIT_RETURN_FREG	SLJIT_FR0
+
 /* --------------------------------------------------------------------- */
 /*  Argument type definitions                                            */
 /* --------------------------------------------------------------------- */
 
 /* The following argument type definitions are used by sljit_emit_enter,
    sljit_set_context, sljit_emit_call, and sljit_emit_icall functions.
 
@@ -382,14 +386,15 @@
 	/* The maximum size difference. */
 	sljit_uw size;
 };
 
 struct sljit_jump {
 	struct sljit_jump *next;
 	sljit_uw addr;
+	/* Architecture dependent flags. */
 	sljit_uw flags;
 	union {
 		sljit_uw target;
 		struct sljit_label *label;
 	} u;
 };
 
@@ -419,39 +424,37 @@
 	struct sljit_put_label *last_put_label;
 
 	void *allocator_data;
 	void *exec_allocator_data;
 	struct sljit_memory_fragment *buf;
 	struct sljit_memory_fragment *abuf;
 
-	/* Used scratch registers. */
+	/* Available scratch registers. */
 	sljit_s32 scratches;
-	/* Used saved registers. */
+	/* Available saved registers. */
 	sljit_s32 saveds;
-	/* Used float scratch registers. */
+	/* Available float scratch registers. */
 	sljit_s32 fscratches;
-	/* Used float saved registers. */
+	/* Available float saved registers. */
 	sljit_s32 fsaveds;
 	/* Local stack size. */
 	sljit_s32 local_size;
-	/* Code size. */
+	/* Maximum code size. */
 	sljit_uw size;
 	/* Relative offset of the executable mapping from the writable mapping. */
 	sljit_sw executable_offset;
 	/* Executable size for statistical purposes. */
 	sljit_uw executable_size;
 
 #if (defined SLJIT_HAS_STATUS_FLAGS_STATE && SLJIT_HAS_STATUS_FLAGS_STATE)
 	sljit_s32 status_flags_state;
 #endif
 
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
 	sljit_s32 args_size;
-	sljit_s32 locals_offset;
-	sljit_s32 scratches_offset;
 #endif
 
 #if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
 	sljit_s32 mode32;
 #endif
 
 #if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
@@ -484,16 +487,15 @@
 	sljit_sw cache_argw;
 #endif
 
 #if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
 	sljit_uw args_size;
 #endif
 
-#if (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32)
-	sljit_s32 delay_slot;
+#if (defined SLJIT_CONFIG_RISCV && SLJIT_CONFIG_RISCV)
 	sljit_s32 cache_arg;
 	sljit_sw cache_argw;
 #endif
 
 #if (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 	/* Need to allocate register save area to make calls. */
 	sljit_s32 mode;
@@ -513,73 +515,74 @@
 	/* Local size passed to entry functions. */
 	sljit_s32 logical_local_size;
 #endif
 
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS) \
 		|| (defined SLJIT_DEBUG && SLJIT_DEBUG) \
 		|| (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
-	/* Trust arguments when the API function is called. */
+	/* Trust arguments when an API function is called.
+	   Used internally for calling API functions. */
 	sljit_s32 skip_checks;
 #endif
 };
 
 /* --------------------------------------------------------------------- */
 /*  Main functions                                                       */
 /* --------------------------------------------------------------------- */
 
-/* Creates an sljit compiler. The allocator_data is required by some
+/* Creates an SLJIT compiler. The allocator_data is required by some
    custom memory managers. This pointer is passed to SLJIT_MALLOC
    and SLJIT_FREE macros. Most allocators (including the default
    one) ignores this value, and it is recommended to pass NULL
    as a dummy value for allocator_data. The exec_allocator_data
    has the same purpose but this one is passed to SLJIT_MALLOC_EXEC /
    SLJIT_MALLOC_FREE functions.
 
    Returns NULL if failed. */
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_compiler* sljit_create_compiler(void *allocator_data, void *exec_allocator_data);
 
 /* Frees everything except the compiled machine code. */
 SLJIT_API_FUNC_ATTRIBUTE void sljit_free_compiler(struct sljit_compiler *compiler);
 
-/* Returns the current error code. If an error is occurred, future sljit
-   calls which uses the same compiler argument returns early with the same
+/* Returns the current error code. If an error occurres, future calls
+   which uses the same compiler argument returns early with the same
    error code. Thus there is no need for checking the error after every
-   call, it is enough to do it before the code is compiled. Removing
+   call, it is enough to do it after the code is compiled. Removing
    these checks increases the performance of the compiling process. */
 static SLJIT_INLINE sljit_s32 sljit_get_compiler_error(struct sljit_compiler *compiler) { return compiler->error; }
 
 /* Sets the compiler error code to SLJIT_ERR_ALLOC_FAILED except
    if an error was detected before. After the error code is set
    the compiler behaves as if the allocation failure happened
-   during an sljit function call. This can greatly simplify error
-   checking, since only the compiler status needs to be checked
-   after the compilation. */
+   during an SLJIT function call. This can greatly simplify error
+   checking, since it is enough to check the compiler status
+   after the code is compiled. */
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_compiler_memory_error(struct sljit_compiler *compiler);
 
 /*
    Allocate a small amount of memory. The size must be <= 64 bytes on 32 bit,
    and <= 128 bytes on 64 bit architectures. The memory area is owned by the
    compiler, and freed by sljit_free_compiler. The returned pointer is
    sizeof(sljit_sw) aligned. Excellent for allocating small blocks during
-   the compiling, and no need to worry about freeing them. The size is
-   enough to contain at most 16 pointers. If the size is outside of the range,
+   compiling, and no need to worry about freeing them. The size is enough
+   to contain at most 16 pointers. If the size is outside of the range,
    the function will return with NULL. However, this return value does not
    indicate that there is no more memory (does not set the current error code
    of the compiler to out-of-memory status).
 */
 SLJIT_API_FUNC_ATTRIBUTE void* sljit_alloc_memory(struct sljit_compiler *compiler, sljit_s32 size);
 
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
 /* Passing NULL disables verbose. */
 SLJIT_API_FUNC_ATTRIBUTE void sljit_compiler_verbose(struct sljit_compiler *compiler, FILE* verbose);
 #endif
 
 /*
-   Create executable code from the sljit instruction stream. This is the final step
-   of the code generation so no more instructions can be added after this call.
+   Create executable code from the instruction stream. This is the final step
+   of the code generation so no more instructions can be emitted after this call.
 */
 
 SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compiler);
 
 /* Free executable code. */
 
 SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code, void *exec_allocator_data);
@@ -602,75 +605,94 @@
    this function. The returned value can be used for statistical purposes.
 
    Before a successful code generation, this function returns with 0.
 */
 static SLJIT_INLINE sljit_uw sljit_get_generated_code_size(struct sljit_compiler *compiler) { return compiler->executable_size; }
 
 /* Returns with non-zero if the feature or limitation type passed as its
-   argument is present on the current CPU.
+   argument is present on the current CPU. The return value is one, if a
+   feature is fully supported, and it is two, if partially supported.
 
    Some features (e.g. floating point operations) require hardware (CPU)
    support while others (e.g. move with update) are emulated if not available.
-   However even if a feature is emulated, specialized code paths can be faster
-   than the emulation. Some limitations are emulated as well so their general
-   case is supported but it has extra performance costs. */
+   However, even when a feature is emulated, specialized code paths may be
+   faster than the emulation. Some limitations are emulated as well so their
+   general case is supported but it has extra performance costs. */
 
 /* [Not emulated] Floating-point support is available. */
 #define SLJIT_HAS_FPU			0
 /* [Limitation] Some registers are virtual registers. */
 #define SLJIT_HAS_VIRTUAL_REGISTERS	1
 /* [Emulated] Has zero register (setting a memory location to zero is efficient). */
 #define SLJIT_HAS_ZERO_REGISTER		2
 /* [Emulated] Count leading zero is supported. */
 #define SLJIT_HAS_CLZ			3
+/* [Emulated] Count trailing zero is supported. */
+#define SLJIT_HAS_CTZ			4
+/* [Emulated] Rotate left/right is supported. */
+#define SLJIT_HAS_ROT			5
 /* [Emulated] Conditional move is supported. */
-#define SLJIT_HAS_CMOV			4
-/* [Emulated] Conditional move is supported. */
-#define SLJIT_HAS_PREFETCH		5
+#define SLJIT_HAS_CMOV			6
+/* [Emulated] Prefetch instruction is available (emulated as a nop). */
+#define SLJIT_HAS_PREFETCH		7
 
 #if (defined SLJIT_CONFIG_X86 && SLJIT_CONFIG_X86)
 /* [Not emulated] SSE2 support is available on x86. */
 #define SLJIT_HAS_SSE2			100
 #endif
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_has_cpu_feature(sljit_s32 feature_type);
 
-/* Instruction generation. Returns with any error code. If there is no
-   error, they return with SLJIT_SUCCESS. */
+/* If type is between SLJIT_ORDERED_EQUAL and SLJIT_ORDERED_LESS_EQUAL,
+   sljit_cmp_info returns one, if the cpu supports the passed floating
+   point comparison type.
+
+   If type is SLJIT_UNORDERED or SLJIT_ORDERED, sljit_cmp_info returns
+   one, if the cpu supports checking the unordered comparison result
+   regardless of the comparison type passed to the comparison instruction.
+   The returned value is always one, if there is at least one type between
+   SLJIT_ORDERED_EQUAL and SLJIT_ORDERED_LESS_EQUAL where sljit_cmp_info
+   returns with a zero value.
+
+   Otherwise it returns zero. */
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_cmp_info(sljit_s32 type);
+
+/* The following functions generate machine code. If there is no
+   error, they return with SLJIT_SUCCESS, otherwise they return
+   with an error code. */
 
 /*
    The executable code is a function from the viewpoint of the C
    language. The function calls must obey to the ABI (Application
    Binary Interface) of the platform, which specify the purpose of
    machine registers and stack handling among other things. The
    sljit_emit_enter function emits the necessary instructions for
-   setting up a new context for the executable code and moves function
-   arguments to the saved registers. Furthermore the options argument
+   setting up a new context for the executable code. This is often
+   called as function prologue. Furthermore the options argument
    can be used to pass configuration options to the compiler. The
    available options are listed before sljit_emit_enter.
 
-   The function argument list is the combination of SLJIT_ARGx
-   (SLJIT_DEF_ARG1) macros. Currently maximum 4 arguments are
-   supported. The first integer argument is loaded into SLJIT_S0,
-   the second one is loaded into SLJIT_S1, and so on. Similarly,
-   the first floating point argument is loaded into SLJIT_FR0,
-   the second one is loaded into SLJIT_FR1, and so on. Furthermore
-   the register set used by the function must be declared as well.
-   The number of scratch and saved registers used by the function
-   must be passed to sljit_emit_enter. Only R registers between R0
+   The function argument list is specified by the SLJIT_ARGSx
+   (SLJIT_ARGS0 .. SLJIT_ARGS4) macros. Currently maximum four
+   arguments are supported. See the description of SLJIT_ARGSx
+   macros about argument passing. Furthermore the register set
+   used by the function must be declared as well. The number of
+   scratch and saved registers available to the function must
+   be passed to sljit_emit_enter. Only R registers between R0
    and "scratches" argument can be used later. E.g. if "scratches"
-   is set to 2, the scratch register set will be limited to SLJIT_R0
-    and SLJIT_R1. The S registers and the floating point registers
-   ("fscratches" and "fsaveds") are specified in a similar manner.
-   The sljit_emit_enter is also capable of allocating a stack space
-   for local variables. The "local_size" argument contains the size
-   in bytes of this local area and its staring address is stored
-   in SLJIT_SP. The memory area between SLJIT_SP (inclusive) and
-   SLJIT_SP + local_size (exclusive) can be modified freely until
-   the function returns. The stack space is not initialized.
+   is set to two, the scratch register set will be limited to
+   SLJIT_R0 and SLJIT_R1. The S registers and the floating point
+   registers ("fscratches" and "fsaveds") are specified in a
+   similar manner. The sljit_emit_enter is also capable of
+   allocating a stack space for local data. The "local_size"
+   argument contains the size in bytes of this local area, and
+   it can be accessed using SLJIT_MEM1(SLJIT_SP). The memory
+   area between SLJIT_SP (inclusive) and SLJIT_SP + local_size
+   (exclusive) can be modified freely until the function returns.
+   The stack space is not initialized to zero.
 
    Note: the following conditions must met:
          0 <= scratches <= SLJIT_NUMBER_OF_REGISTERS
          0 <= saveds <= SLJIT_NUMBER_OF_SAVED_REGISTERS
          scratches + saveds <= SLJIT_NUMBER_OF_REGISTERS
          0 <= fscratches <= SLJIT_NUMBER_OF_FLOAT_REGISTERS
          0 <= fsaveds <= SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS
@@ -679,84 +701,111 @@
    Note: the compiler can use saved registers as scratch registers,
          but the opposite is not supported
 
    Note: every call of sljit_emit_enter and sljit_set_context
          overwrites the previous context.
 */
 
-/* The compiled function uses cdecl calling
- * convention instead of SLJIT_FUNC. */
-#define SLJIT_ENTER_CDECL 0x00000001
+/* Saved registers between SLJIT_S0 and SLJIT_S(n - 1) (inclusive)
+   are not saved / restored on function enter / return. Instead,
+   these registers can be used to pass / return data (such as
+   global / local context pointers) across function calls. The
+   value of n must be between 1 and 3. This option is only
+   supported by SLJIT_ENTER_REG_ARG calling convention. */
+#define SLJIT_ENTER_KEEP(n)	(n)
+
+/* The compiled function uses an SLJIT specific register argument
+   calling convention. This is a lightweight function call type where
+   both the caller and the called functions must be compiled by
+   SLJIT. The type argument of the call must be SLJIT_CALL_REG_ARG
+   and all arguments must be stored in scratch registers. */
+#define SLJIT_ENTER_REG_ARG	0x00000004
 
 /* The local_size must be >= 0 and <= SLJIT_MAX_LOCAL_SIZE. */
 #define SLJIT_MAX_LOCAL_SIZE	65536
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_enter(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size);
 
-/* The machine code has a context (which contains the local stack space size,
-   number of used registers, etc.) which initialized by sljit_emit_enter. Several
-   functions (such as sljit_emit_return) requres this context to be able to generate
-   the appropriate code. However, some code fragments (like inline cache) may have
-   no normal entry point so their context is unknown for the compiler. Their context
-   can be provided to the compiler by the sljit_set_context function.
+/* The SLJIT compiler has a current context (which contains the local
+   stack space size, number of used registers, etc.) which is initialized
+   by sljit_emit_enter. Several functions (such as sljit_emit_return)
+   requires this context to be able to generate the appropriate code.
+   However, some code fragments (compiled separately) may have no
+   normal entry point so their context is unknown for the compiler.
+
+   The sljit_set_context and sljit_emit_enter have the same arguments,
+   but sljit_set_context does not generate any machine code.
 
    Note: every call of sljit_emit_enter and sljit_set_context overwrites
          the previous context. */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_set_context(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size);
 
-/* Return from machine code. The sljit_emit_return_void function does not return with
-   any value. The sljit_emit_return function returns with a single value which stores
-   the result of a data move instruction. The instruction is specified by the op
-   argument, and must be between SLJIT_MOV and SLJIT_MOV_P (see sljit_emit_op1). */
+/* Return to the caller function. The sljit_emit_return_void function
+   does not return with any value. The sljit_emit_return function returns
+   with a single value loaded from its source operand. The load operation
+   can be between SLJIT_MOV and SLJIT_MOV_P (see sljit_emit_op1) and
+   SLJIT_MOV_F32/SLJIT_MOV_F64 (see sljit_emit_fop1) depending on the
+   return value specified by sljit_emit_enter/sljit_set_context. */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_void(struct sljit_compiler *compiler);
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src, sljit_sw srcw);
 
+/* Restores the saved registers and free the stack area, then the execution
+   continues from the address specified by the source operand. This
+   operation is similar to sljit_emit_return, but it ignores the return
+   address. The code where the exection continues should use the same context
+   as the caller function (see sljit_set_context). A word (pointer) value
+   can be passed in the SLJIT_RETURN_REG register. This function can be used
+   to jump to exception handlers. */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_to(struct sljit_compiler *compiler,
+	sljit_s32 src, sljit_sw srcw);
+
 /* Generating entry and exit points for fast call functions (see SLJIT_FAST_CALL).
    Both sljit_emit_fast_enter and SLJIT_FAST_RETURN operations preserve the
    values of all registers and stack frame. The return address is stored in the
    dst argument of sljit_emit_fast_enter, and this return address can be passed
    to SLJIT_FAST_RETURN to continue the execution after the fast call.
 
    Fast calls are cheap operations (usually only a single call instruction is
    emitted) but they do not preserve any registers. However the callee function
-   can freely use / update any registers and stack values which can be
+   can freely use / update any registers and the local area which can be
    efficiently exploited by various optimizations. Registers can be saved
-   manually by the callee function if needed.
+   and restored manually if needed.
 
    Although returning to different address by SLJIT_FAST_RETURN is possible,
    this address usually cannot be predicted by the return address predictor of
    modern CPUs which may reduce performance. Furthermore certain security
    enhancement technologies such as Intel Control-flow Enforcement Technology
    (CET) may disallow returning to a different address.
 
    Flags: - (does not modify flags). */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw);
 
 /*
    Source and destination operands for arithmetical instructions
     imm              - a simple immediate value (cannot be used as a destination)
-    reg              - any of the registers (immediate argument must be 0)
-    [imm]            - absolute immediate memory address
+    reg              - any of the available registers (immediate argument must be 0)
+    [imm]            - absolute memory address
     [reg+imm]        - indirect memory address
     [reg+(reg<<imm)] - indirect indexed memory address (shift must be between 0 and 3)
-                       useful for (byte, half, int, sljit_sw) array access
-                       (fully supported by both x86 and ARM architectures, and cheap operation on others)
+                       useful for accessing arrays (fully supported by both x86 and
+                       ARM architectures, and cheap operation on others)
 */
 
 /*
-   IMPORTANT NOTE: memory access MUST be naturally aligned unless
+   IMPORTANT NOTE: memory accesses MUST be naturally aligned unless
                    SLJIT_UNALIGNED macro is defined and its value is 1.
 
      length | alignment
    ---------+-----------
      byte   | 1 byte (any physical_address is accepted)
      half   | 2 byte (physical_address & 0x1 == 0)
      int    | 4 byte (physical_address & 0x3 == 0)
@@ -788,41 +837,44 @@
    ppc:    [reg+imm], -65536 <= imm <= 65535. 64 bit loads/stores and 32 bit
                 signed load on 64 bit requires immediates divisible by 4.
                 [reg+imm] is not supported for signed 8 bit values.
            [reg+reg] is supported
            Write-back is supported except for one instruction: 32 bit signed
                 load with [reg+imm] addressing mode on 64 bit.
    mips:   [reg+imm], -65536 <= imm <= 65535
-   sparc:  [reg+imm], -4096 <= imm <= 4095
-           [reg+reg] is supported
+           Write-back is not supported
+   riscv:  [reg+imm], -2048 <= imm <= 2047
+           Write-back is not supported
    s390x:  [reg+imm], -2^19 <= imm < 2^19
            [reg+reg] is supported
            Write-back is not supported
 */
 
 /* Macros for specifying operand types. */
 #define SLJIT_MEM		0x80
 #define SLJIT_MEM0()		(SLJIT_MEM)
 #define SLJIT_MEM1(r1)		(SLJIT_MEM | (r1))
 #define SLJIT_MEM2(r1, r2)	(SLJIT_MEM | (r1) | ((r2) << 8))
 #define SLJIT_IMM		0x40
+#define SLJIT_REG_PAIR(r1, r2)	((r1) | ((r2) << 8))
 
 /* Sets 32 bit operation mode on 64 bit CPUs. This option is ignored on
    32 bit CPUs. When this option is set for an arithmetic operation, only
-   the lower 32 bit of the input registers are used, and the CPU status
+   the lower 32 bits of the input registers are used, and the CPU status
    flags are set according to the 32 bit result. Although the higher 32 bit
    of the input and the result registers are not defined by SLJIT, it might
    be defined by the CPU architecture (e.g. MIPS). To satisfy these CPU
    requirements all source registers must be the result of those operations
    where this option was also set. Memory loads read 32 bit values rather
    than 64 bit ones. In other words 32 bit and 64 bit operations cannot be
-   mixed. The only exception is SLJIT_MOV32 whose source register can hold
+   mixed. The only exception is SLJIT_MOV32 which source register can hold
    any 32 or 64 bit value, and it is converted to a 32 bit compatible format
-   first. This conversion is free (no instructions are emitted) on most CPUs.
-   A 32 bit value can also be converted to a 64 bit value by SLJIT_MOV_S32
+   first. When the source and destination registers are the same, this
+   conversion is free (no instructions are emitted) on most CPUs. A 32 bit
+   value can also be converted to a 64 bit value by SLJIT_MOV_S32
    (sign extension) or SLJIT_MOV_U32 (zero extension).
 
    As for floating-point operations, this option sets 32 bit single
    precision mode. Similar to the integer operations, all register arguments
    must be the result of those operations where this option was also set.
 
    Note: memory addressing always uses 64 bit values on 64 bit systems so
@@ -831,26 +883,28 @@
 
    This option is part of the instruction name, so there is no need to
    manually set it. E.g:
 
      SLJIT_ADD32 == (SLJIT_ADD | SLJIT_32) */
 #define SLJIT_32		0x100
 
-/* Many CPUs (x86, ARM, PPC) have status flags which can be set according
+/* Many CPUs (x86, ARM, PPC) have status flag bits which can be set according
    to the result of an operation. Other CPUs (MIPS) do not have status
-   flags, and results must be stored in registers. To cover both architecture
-   types efficiently only two flags are defined by SLJIT:
+   flag bits, and results must be stored in registers. To cover both
+   architecture types efficiently only two flags are defined by SLJIT:
 
     * Zero (equal) flag: it is set if the result is zero
-    * Variable flag: its value is defined by the last arithmetic operation
+    * Variable flag: its value is defined by the arithmetic operation
 
    SLJIT instructions can set any or both of these flags. The value of
-   these flags is undefined if the instruction does not specify their value.
-   The description of each instruction contains the list of allowed flag
-   types.
+   these flags is undefined if the instruction does not specify their
+   value. The description of each instruction contains the list of
+   allowed flag types.
+
+   Note: the logical or operation can be used to set flags.
 
    Example: SLJIT_ADD can set the Z, OVERFLOW, CARRY flags hence
 
      sljit_op2(..., SLJIT_ADD, ...)
        Both the zero and variable flags are undefined so they can
        have any value after the operation is completed.
 
@@ -863,40 +917,48 @@
        it otherwise. The zero flag is undefined.
 
      sljit_op2(..., SLJIT_ADD | SLJIT_SET_Z | SLJIT_SET_CARRY, ...)
        Sets the zero flag if the result is zero, clears it otherwise.
        Sets the variable flag if unsigned overflow (carry) occurs,
        clears it otherwise.
 
-   If an instruction (e.g. SLJIT_MOV) does not modify flags the flags are
-   unchanged.
+   Certain instructions (e.g. SLJIT_MOV) does not modify flags, so
+   status flags are unchanged.
+
+   Example:
+
+     sljit_op2(..., SLJIT_ADD | SLJIT_SET_Z, ...)
+     sljit_op1(..., SLJIT_MOV, ...)
+       Zero flag is set according to the result of SLJIT_ADD.
 
-   Using these flags can reduce the number of emitted instructions. E.g. a
-   fast loop can be implemented by decreasing a counter register and set the
-   zero flag to jump back if the counter register has not reached zero.
-
-   Motivation: although CPUs can set a large number of flags, usually their
-   values are ignored or only one of them is used. Emulating a large number
-   of flags on systems without flag register is complicated so SLJIT
-   instructions must specify the flag they want to use and only that flag
-   will be emulated. The last arithmetic instruction can be repeated if
+     sljit_op2(..., SLJIT_ADD | SLJIT_SET_Z, ...)
+     sljit_op2(..., SLJIT_ADD, ...)
+       Zero flag has unknown value.
+
+   These flags can be used for code optimization. E.g. a fast loop can be
+   implemented by decreasing a counter register and set the zero flag
+   using a single instruction. The zero register can be used by a
+   conditional jump to restart the loop. A single comparison can set a
+   zero and less flags to check if a value is less, equal, or greater
+   than another value.
+
+   Motivation: although some CPUs can set a large number of flag bits,
+   usually their values are ignored or only a few of them are used. Emulating
+   a large number of flags on systems without a flag register is complicated
+   so SLJIT instructions must specify the flag they want to use and only
+   that flag is computed. The last arithmetic instruction can be repeated if
    multiple flags need to be checked.
 */
 
 /* Set Zero status flag. */
 #define SLJIT_SET_Z			0x0200
 /* Set the variable status flag if condition is true.
-   See comparison types. */
+   See comparison types (e.g. SLJIT_SET_LESS, SLJIT_SET_F_EQUAL). */
 #define SLJIT_SET(condition)			((condition) << 10)
 
-/* Notes:
-     - you cannot postpone conditional jump instructions except if noted that
-       the instruction does not set flags (See: SLJIT_KEEP_FLAGS).
-     - flag combinations: '|' means 'logical or'. */
-
 /* Starting index of opcodes for sljit_emit_op0. */
 #define SLJIT_OP0_BASE			0
 
 /* Flags: - (does not modify flags)
    Note: breakpoint instruction is not supported by all architectures (e.g. ppc)
          It falls back to SLJIT_NOP in those cases. */
 #define SLJIT_BREAKPOINT		(SLJIT_OP0_BASE + 0)
@@ -939,18 +1001,20 @@
    Note: if SLJIT_R1 is -1 and SLJIT_R0 is integer min (0x800..00),
          the behaviour is undefined. */
 #define SLJIT_DIV_SW			(SLJIT_OP0_BASE + 7)
 #define SLJIT_DIV_S32			(SLJIT_DIV_SW | SLJIT_32)
 /* Flags: - (does not modify flags)
    ENDBR32 instruction for x86-32 and ENDBR64 instruction for x86-64
    when Intel Control-flow Enforcement Technology (CET) is enabled.
-   No instruction for other architectures.  */
+   No instructions are emitted for other architectures. */
 #define SLJIT_ENDBR			(SLJIT_OP0_BASE + 8)
 /* Flags: - (may destroy flags)
-   Skip stack frames before return.  */
+   Skip stack frames before return when Intel Control-flow
+   Enforcement Technology (CET) is enabled. No instructions
+   are emitted for other architectures. */
 #define SLJIT_SKIP_FRAMES_BEFORE_RETURN	(SLJIT_OP0_BASE + 9)
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op0(struct sljit_compiler *compiler, sljit_s32 op);
 
 /* Starting index of opcodes for sljit_emit_op1. */
 #define SLJIT_OP1_BASE			32
 
@@ -986,27 +1050,31 @@
 #define SLJIT_MOV_U32			(SLJIT_OP1_BASE + 5)
 /* Flags: - (does not modify flags)
    Note: no SLJIT_MOV32_S32 form, since it is the same as SLJIT_MOV32 */
 #define SLJIT_MOV_S32			(SLJIT_OP1_BASE + 6)
 /* Flags: - (does not modify flags) */
 #define SLJIT_MOV32			(SLJIT_OP1_BASE + 7)
 /* Flags: - (does not modify flags)
-   Note: load a pointer sized data, useful on x32 (a 32 bit mode on x86-64
-         where all x64 features are available, e.g. 16 register) or similar
-         compiling modes */
+   Note: loads a pointer sized data, useful on x32 mode (a 64 bit mode
+         on x86-64 which uses 32 bit pointers) or similar compiling modes */
 #define SLJIT_MOV_P			(SLJIT_OP1_BASE + 8)
 /* Flags: Z
    Note: immediate source argument is not supported */
 #define SLJIT_NOT			(SLJIT_OP1_BASE + 9)
 #define SLJIT_NOT32			(SLJIT_NOT | SLJIT_32)
 /* Count leading zeroes
    Flags: - (may destroy flags)
    Note: immediate source argument is not supported */
 #define SLJIT_CLZ			(SLJIT_OP1_BASE + 10)
 #define SLJIT_CLZ32			(SLJIT_CLZ | SLJIT_32)
+/* Count trailing zeroes
+   Flags: - (may destroy flags)
+   Note: immediate source argument is not supported */
+#define SLJIT_CTZ			(SLJIT_OP1_BASE + 11)
+#define SLJIT_CTZ32			(SLJIT_CTZ | SLJIT_32)
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op1(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src, sljit_sw srcw);
 
 /* Starting index of opcodes for sljit_emit_op2. */
 #define SLJIT_OP2_BASE			96
@@ -1015,15 +1083,15 @@
 #define SLJIT_ADD			(SLJIT_OP2_BASE + 0)
 #define SLJIT_ADD32			(SLJIT_ADD | SLJIT_32)
 /* Flags: CARRY */
 #define SLJIT_ADDC			(SLJIT_OP2_BASE + 1)
 #define SLJIT_ADDC32			(SLJIT_ADDC | SLJIT_32)
 /* Flags: Z | LESS | GREATER_EQUAL | GREATER | LESS_EQUAL
           SIG_LESS | SIG_GREATER_EQUAL | SIG_GREATER
-          SIG_LESS_EQUAL | CARRY */
+          SIG_LESS_EQUAL | OVERFLOW | CARRY */
 #define SLJIT_SUB			(SLJIT_OP2_BASE + 2)
 #define SLJIT_SUB32			(SLJIT_SUB | SLJIT_32)
 /* Flags: CARRY */
 #define SLJIT_SUBC			(SLJIT_OP2_BASE + 3)
 #define SLJIT_SUBC32			(SLJIT_SUBC | SLJIT_32)
 /* Note: integer mul
    Flags: OVERFLOW */
@@ -1042,39 +1110,108 @@
    Let bit_length be the length of the shift operation: 32 or 64.
    If src2 is immediate, src2w is masked by (bit_length - 1).
    Otherwise, if the content of src2 is outside the range from 0
    to bit_length - 1, the result is undefined. */
 #define SLJIT_SHL			(SLJIT_OP2_BASE + 8)
 #define SLJIT_SHL32			(SLJIT_SHL | SLJIT_32)
 /* Flags: Z
+   Same as SLJIT_SHL, except the the second operand is
+   always masked by the length of the shift operation. */
+#define SLJIT_MSHL			(SLJIT_OP2_BASE + 9)
+#define SLJIT_MSHL32			(SLJIT_MSHL | SLJIT_32)
+/* Flags: Z
    Let bit_length be the length of the shift operation: 32 or 64.
    If src2 is immediate, src2w is masked by (bit_length - 1).
    Otherwise, if the content of src2 is outside the range from 0
    to bit_length - 1, the result is undefined. */
-#define SLJIT_LSHR			(SLJIT_OP2_BASE + 9)
+#define SLJIT_LSHR			(SLJIT_OP2_BASE + 10)
 #define SLJIT_LSHR32			(SLJIT_LSHR | SLJIT_32)
 /* Flags: Z
+   Same as SLJIT_LSHR, except the the second operand is
+   always masked by the length of the shift operation. */
+#define SLJIT_MLSHR			(SLJIT_OP2_BASE + 11)
+#define SLJIT_MLSHR32			(SLJIT_MLSHR | SLJIT_32)
+/* Flags: Z
    Let bit_length be the length of the shift operation: 32 or 64.
    If src2 is immediate, src2w is masked by (bit_length - 1).
    Otherwise, if the content of src2 is outside the range from 0
    to bit_length - 1, the result is undefined. */
-#define SLJIT_ASHR			(SLJIT_OP2_BASE + 10)
+#define SLJIT_ASHR			(SLJIT_OP2_BASE + 12)
 #define SLJIT_ASHR32			(SLJIT_ASHR | SLJIT_32)
+/* Flags: Z
+   Same as SLJIT_ASHR, except the the second operand is
+   always masked by the length of the shift operation. */
+#define SLJIT_MASHR			(SLJIT_OP2_BASE + 13)
+#define SLJIT_MASHR32			(SLJIT_MASHR | SLJIT_32)
+/* Flags: - (may destroy flags)
+   Let bit_length be the length of the rotate operation: 32 or 64.
+   The second operand is always masked by (bit_length - 1). */
+#define SLJIT_ROTL			(SLJIT_OP2_BASE + 14)
+#define SLJIT_ROTL32			(SLJIT_ROTL | SLJIT_32)
+/* Flags: - (may destroy flags)
+   Let bit_length be the length of the rotate operation: 32 or 64.
+   The second operand is always masked by (bit_length - 1). */
+#define SLJIT_ROTR			(SLJIT_OP2_BASE + 15)
+#define SLJIT_ROTR32			(SLJIT_ROTR | SLJIT_32)
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w);
 
-/* The sljit_emit_op2u function is the same as sljit_emit_op2 except the result is discarded. */
+/* The sljit_emit_op2u function is the same as sljit_emit_op2
+   except the result is discarded. */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2u(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w);
 
+/* Emit a left or right shift operation, where the bits shifted
+   in comes from a separate source operand. All operands are
+   interpreted as unsigned integers.
+
+   In the followings the value_mask variable is 31 for 32 bit
+     operations and word_size - 1 otherwise.
+
+   op must be one of the following operations:
+     SLJIT_SHL or SLJIT_SHL32:
+       src_dst <<= src2
+       src_dst |= ((src1 >> 1) >> (src2 ^ value_mask))
+     SLJIT_MSHL or SLJIT_MSHL32:
+       src2 &= value_mask
+       perform the SLJIT_SHL or SLJIT_SHL32 operation
+     SLJIT_LSHR or SLJIT_LSHR32:
+       src_dst >>= src2
+       src_dst |= ((src1 << 1) << (src2 ^ value_mask))
+     SLJIT_MLSHR or SLJIT_MLSHR32:
+       src2 &= value_mask
+       perform the SLJIT_LSHR or SLJIT_LSHR32 operation
+
+   op can be combined (or'ed) with SLJIT_SHIFT_INTO_NON_ZERO
+
+   src_dst must be a register which content is updated after
+     the operation is completed
+   src1 / src1w contains the bits which shifted into src_dst
+   src2 / src2w contains the shift amount
+
+   Note: a rotate operation can be performed if src_dst and
+         src1 are set to the same register
+
+   Flags: - (may destroy flags) */
+
+/* The src2 contains a non-zero value. Improves the generated
+   code on certain architectures, which provides a small
+   performance improvement. */
+#define SLJIT_SHIFT_INTO_NON_ZERO	0x200
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_shift_into(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 src_dst,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w);
+
 /* Starting index of opcodes for sljit_emit_op2. */
 #define SLJIT_OP_SRC_BASE		128
 
 /* Note: src cannot be an immedate value
    Flags: - (does not modify flags) */
 #define SLJIT_FAST_RETURN		(SLJIT_OP_SRC_BASE + 0)
 /* Skip stack frames before fast return.
@@ -1112,16 +1249,16 @@
 /* Starting index of opcodes for sljit_emit_fop1. */
 #define SLJIT_FOP1_BASE			160
 
 /* Flags: - (does not modify flags) */
 #define SLJIT_MOV_F64			(SLJIT_FOP1_BASE + 0)
 #define SLJIT_MOV_F32			(SLJIT_MOV_F64 | SLJIT_32)
 /* Convert opcodes: CONV[DST_TYPE].FROM[SRC_TYPE]
-   SRC/DST TYPE can be: D - double, S - single, W - signed word, I - signed int
-   Rounding mode when the destination is W or I: round towards zero. */
+   SRC/DST TYPE can be: F64, F32, S32, SW
+   Rounding mode when the destination is SW or S32: round towards zero. */
 /* Flags: - (may destroy flags) */
 #define SLJIT_CONV_F64_FROM_F32		(SLJIT_FOP1_BASE + 1)
 #define SLJIT_CONV_F32_FROM_F64		(SLJIT_CONV_F64_FROM_F32 | SLJIT_32)
 /* Flags: - (may destroy flags) */
 #define SLJIT_CONV_SW_FROM_F64		(SLJIT_FOP1_BASE + 2)
 #define SLJIT_CONV_SW_FROM_F32		(SLJIT_CONV_SW_FROM_F64 | SLJIT_32)
 /* Flags: - (may destroy flags) */
@@ -1129,15 +1266,15 @@
 #define SLJIT_CONV_S32_FROM_F32		(SLJIT_CONV_S32_FROM_F64 | SLJIT_32)
 /* Flags: - (may destroy flags) */
 #define SLJIT_CONV_F64_FROM_SW		(SLJIT_FOP1_BASE + 4)
 #define SLJIT_CONV_F32_FROM_SW		(SLJIT_CONV_F64_FROM_SW | SLJIT_32)
 /* Flags: - (may destroy flags) */
 #define SLJIT_CONV_F64_FROM_S32		(SLJIT_FOP1_BASE + 5)
 #define SLJIT_CONV_F32_FROM_S32		(SLJIT_CONV_F64_FROM_S32 | SLJIT_32)
-/* Note: dst is the left and src is the right operand for SLJIT_CMPD.
+/* Note: dst is the left and src is the right operand for SLJIT_CMP_F32/64.
    Flags: EQUAL_F | LESS_F | GREATER_EQUAL_F | GREATER_F | LESS_EQUAL_F */
 #define SLJIT_CMP_F64			(SLJIT_FOP1_BASE + 6)
 #define SLJIT_CMP_F32			(SLJIT_CMP_F64 | SLJIT_32)
 /* Flags: - (may destroy flags) */
 #define SLJIT_NEG_F64			(SLJIT_FOP1_BASE + 7)
 #define SLJIT_NEG_F32			(SLJIT_NEG_F64 | SLJIT_32)
 /* Flags: - (may destroy flags) */
@@ -1198,104 +1335,129 @@
 #define SLJIT_SIG_LESS_EQUAL		9
 #define SLJIT_SET_SIG_LESS_EQUAL	SLJIT_SET(SLJIT_SIG_LESS_EQUAL)
 
 #define SLJIT_OVERFLOW			10
 #define SLJIT_SET_OVERFLOW		SLJIT_SET(SLJIT_OVERFLOW)
 #define SLJIT_NOT_OVERFLOW		11
 
-/* Unlike other flags, sljit_emit_jump may destroy this flag. */
+/* Unlike other flags, sljit_emit_jump may destroy the carry flag. */
 #define SLJIT_CARRY			12
 #define SLJIT_SET_CARRY			SLJIT_SET(SLJIT_CARRY)
 #define SLJIT_NOT_CARRY			13
 
-/* Floating point comparison types. */
-#define SLJIT_EQUAL_F64			14
-#define SLJIT_EQUAL_F32			(SLJIT_EQUAL_F64 | SLJIT_32)
-#define SLJIT_SET_EQUAL_F		SLJIT_SET(SLJIT_EQUAL_F64)
-#define SLJIT_NOT_EQUAL_F64		15
-#define SLJIT_NOT_EQUAL_F32		(SLJIT_NOT_EQUAL_F64 | SLJIT_32)
-#define SLJIT_SET_NOT_EQUAL_F		SLJIT_SET(SLJIT_NOT_EQUAL_F64)
-#define SLJIT_LESS_F64			16
-#define SLJIT_LESS_F32			(SLJIT_LESS_F64 | SLJIT_32)
-#define SLJIT_SET_LESS_F		SLJIT_SET(SLJIT_LESS_F64)
-#define SLJIT_GREATER_EQUAL_F64		17
-#define SLJIT_GREATER_EQUAL_F32		(SLJIT_GREATER_EQUAL_F64 | SLJIT_32)
-#define SLJIT_SET_GREATER_EQUAL_F	SLJIT_SET(SLJIT_GREATER_EQUAL_F64)
-#define SLJIT_GREATER_F64		18
-#define SLJIT_GREATER_F32		(SLJIT_GREATER_F64 | SLJIT_32)
-#define SLJIT_SET_GREATER_F		SLJIT_SET(SLJIT_GREATER_F64)
-#define SLJIT_LESS_EQUAL_F64		19
-#define SLJIT_LESS_EQUAL_F32		(SLJIT_LESS_EQUAL_F64 | SLJIT_32)
-#define SLJIT_SET_LESS_EQUAL_F		SLJIT_SET(SLJIT_LESS_EQUAL_F64)
-#define SLJIT_UNORDERED_F64		20
-#define SLJIT_UNORDERED_F32		(SLJIT_UNORDERED_F64 | SLJIT_32)
-#define SLJIT_SET_UNORDERED_F		SLJIT_SET(SLJIT_UNORDERED_F64)
-#define SLJIT_ORDERED_F64		21
-#define SLJIT_ORDERED_F32		(SLJIT_ORDERED_F64 | SLJIT_32)
-#define SLJIT_SET_ORDERED_F		SLJIT_SET(SLJIT_ORDERED_F64)
+/* Basic floating point comparison types.
+
+   Note: when the comparison result is unordered, their behaviour is unspecified. */
+
+#define SLJIT_F_EQUAL				14
+#define SLJIT_SET_F_EQUAL			SLJIT_SET(SLJIT_F_EQUAL)
+#define SLJIT_F_NOT_EQUAL			15
+#define SLJIT_SET_F_NOT_EQUAL			SLJIT_SET(SLJIT_F_NOT_EQUAL)
+#define SLJIT_F_LESS				16
+#define SLJIT_SET_F_LESS			SLJIT_SET(SLJIT_F_LESS)
+#define SLJIT_F_GREATER_EQUAL			17
+#define SLJIT_SET_F_GREATER_EQUAL		SLJIT_SET(SLJIT_F_GREATER_EQUAL)
+#define SLJIT_F_GREATER				18
+#define SLJIT_SET_F_GREATER			SLJIT_SET(SLJIT_F_GREATER)
+#define SLJIT_F_LESS_EQUAL			19
+#define SLJIT_SET_F_LESS_EQUAL			SLJIT_SET(SLJIT_F_LESS_EQUAL)
+
+/* Jumps when either argument contains a NaN value. */
+#define SLJIT_UNORDERED				20
+#define SLJIT_SET_UNORDERED			SLJIT_SET(SLJIT_UNORDERED)
+/* Jumps when neither argument contains a NaN value. */
+#define SLJIT_ORDERED				21
+#define SLJIT_SET_ORDERED			SLJIT_SET(SLJIT_ORDERED)
+
+/* Ordered / unordered floating point comparison types.
+
+   Note: each comparison type has an ordered and unordered form. Some
+         architectures supports only either of them (see: sljit_cmp_info). */
+
+#define SLJIT_ORDERED_EQUAL			22
+#define SLJIT_SET_ORDERED_EQUAL			SLJIT_SET(SLJIT_ORDERED_EQUAL)
+#define SLJIT_UNORDERED_OR_NOT_EQUAL		23
+#define SLJIT_SET_UNORDERED_OR_NOT_EQUAL	SLJIT_SET(SLJIT_UNORDERED_OR_NOT_EQUAL)
+#define SLJIT_ORDERED_LESS			24
+#define SLJIT_SET_ORDERED_LESS			SLJIT_SET(SLJIT_ORDERED_LESS)
+#define SLJIT_UNORDERED_OR_GREATER_EQUAL	25
+#define SLJIT_SET_UNORDERED_OR_GREATER_EQUAL	SLJIT_SET(SLJIT_UNORDERED_OR_GREATER_EQUAL)
+#define SLJIT_ORDERED_GREATER			26
+#define SLJIT_SET_ORDERED_GREATER		SLJIT_SET(SLJIT_ORDERED_GREATER)
+#define SLJIT_UNORDERED_OR_LESS_EQUAL		27
+#define SLJIT_SET_UNORDERED_OR_LESS_EQUAL	SLJIT_SET(SLJIT_UNORDERED_OR_LESS_EQUAL)
+
+#define SLJIT_UNORDERED_OR_EQUAL		28
+#define SLJIT_SET_UNORDERED_OR_EQUAL		SLJIT_SET(SLJIT_UNORDERED_OR_EQUAL)
+#define SLJIT_ORDERED_NOT_EQUAL			29
+#define SLJIT_SET_ORDERED_NOT_EQUAL		SLJIT_SET(SLJIT_ORDERED_NOT_EQUAL)
+#define SLJIT_UNORDERED_OR_LESS			30
+#define SLJIT_SET_UNORDERED_OR_LESS		SLJIT_SET(SLJIT_UNORDERED_OR_LESS)
+#define SLJIT_ORDERED_GREATER_EQUAL		31
+#define SLJIT_SET_ORDERED_GREATER_EQUAL		SLJIT_SET(SLJIT_ORDERED_GREATER_EQUAL)
+#define SLJIT_UNORDERED_OR_GREATER		32
+#define SLJIT_SET_UNORDERED_OR_GREATER		SLJIT_SET(SLJIT_UNORDERED_OR_GREATER)
+#define SLJIT_ORDERED_LESS_EQUAL		33
+#define SLJIT_SET_ORDERED_LESS_EQUAL		SLJIT_SET(SLJIT_ORDERED_LESS_EQUAL)
 
 /* Unconditional jump types. */
-#define SLJIT_JUMP			22
-	/* Fast calling method. See sljit_emit_fast_enter / SLJIT_FAST_RETURN. */
-#define SLJIT_FAST_CALL			23
-	/* Called function must be declared with the SLJIT_FUNC attribute. */
-#define SLJIT_CALL			24
-	/* Called function must be declared with cdecl attribute.
-	   This is the default attribute for C functions. */
-#define SLJIT_CALL_CDECL		25
+#define SLJIT_JUMP			34
+/* Fast calling method. See sljit_emit_fast_enter / SLJIT_FAST_RETURN. */
+#define SLJIT_FAST_CALL			35
+/* Default C calling convention. */
+#define SLJIT_CALL			36
+/* Called function must be compiled by SLJIT.
+   See SLJIT_ENTER_REG_ARG option. */
+#define SLJIT_CALL_REG_ARG		37
 
 /* The target can be changed during runtime (see: sljit_set_jump_addr). */
 #define SLJIT_REWRITABLE_JUMP		0x1000
 /* When this flag is passed, the execution of the current function ends and
    the called function returns to the caller of the current function. The
    stack usage is reduced before the call, but it is not necessarily reduced
    to zero. In the latter case the compiler needs to allocate space for some
-   arguments and the return register must be kept as well.
-
-   This feature is highly experimental and not supported on SPARC platform
-   at the moment. */
-#define SLJIT_CALL_RETURN			0x2000
+   arguments and the return address must be stored on the stack as well. */
+#define SLJIT_CALL_RETURN		0x2000
 
 /* Emit a jump instruction. The destination is not set, only the type of the jump.
     type must be between SLJIT_EQUAL and SLJIT_FAST_CALL
     type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP
 
    Flags: does not modify flags. */
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_jump(struct sljit_compiler *compiler, sljit_s32 type);
 
 /* Emit a C compiler (ABI) compatible function call.
-    type must be SLJIT_CALL or SLJIT_CALL_CDECL
-    type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP and SLJIT_CALL_RETURN
-    arg_types is the combination of SLJIT_RET / SLJIT_ARGx (SLJIT_DEF_RET / SLJIT_DEF_ARGx) macros
+    type must be SLJIT_CALL or SLJIT_CALL_REG_ARG
+    type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP and/or SLJIT_CALL_RETURN
+    arg_types can be specified by SLJIT_ARGSx (SLJIT_ARG_RETURN / SLJIT_ARG_VALUE) macros
 
    Flags: destroy all flags. */
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 arg_types);
 
 /* Basic arithmetic comparison. In most architectures it is implemented as
-   an compare operation followed by a sljit_emit_jump. However some
-   architectures (i.e: ARM64 or MIPS) may employ special optimizations here.
-   It is suggested to use this comparison form when appropriate.
-    type must be between SLJIT_EQUAL and SLJIT_I_SIG_LESS_EQUAL
+   a compare operation followed by a sljit_emit_jump. However some
+   architectures (i.e: ARM64 or MIPS) may employ special optimizations
+   here. It is suggested to use this comparison form when appropriate.
+    type must be between SLJIT_EQUAL and SLJIT_SIG_LESS_EQUAL
     type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP
 
    Flags: may destroy flags. */
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_cmp(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w);
 
 /* Basic floating point comparison. In most architectures it is implemented as
-   an SLJIT_FCMP operation (setting appropriate flags) followed by a
+   a SLJIT_CMP_F32/64 operation (setting appropriate flags) followed by a
    sljit_emit_jump. However some architectures (i.e: MIPS) may employ
    special optimizations here. It is suggested to use this comparison form
    when appropriate.
-    type must be between SLJIT_EQUAL_F64 and SLJIT_ORDERED_F32
+    type must be between SLJIT_F_EQUAL and SLJIT_ORDERED_LESS_EQUAL
     type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP
    Flags: destroy flags.
-   Note: if either operand is NaN, the behaviour is undefined for
-         types up to SLJIT_S_LESS_EQUAL. */
+   Note: when an operand is NaN the behaviour depends on the comparison type. */
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_fcmp(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w);
 
 /* Set the destination of the jump to this label. */
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_label(struct sljit_jump *jump, struct sljit_label* label);
 /* Set the destination address of the jump to this label. */
@@ -1308,104 +1470,174 @@
 
    Flags: does not modify flags. */
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_ijump(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 src, sljit_sw srcw);
 
 /* Emit a C compiler (ABI) compatible function call.
    Direct form: set src to SLJIT_IMM() and srcw to the address
    Indirect form: any other valid addressing mode
-    type must be SLJIT_CALL or SLJIT_CALL_CDECL
+    type must be SLJIT_CALL or SLJIT_CALL_REG_ARG
     type can be combined (or'ed) with SLJIT_CALL_RETURN
-    arg_types is the combination of SLJIT_RET / SLJIT_ARGx (SLJIT_DEF_RET / SLJIT_DEF_ARGx) macros
+    arg_types can be specified by SLJIT_ARGSx (SLJIT_ARG_RETURN / SLJIT_ARG_VALUE) macros
 
    Flags: destroy all flags. */
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_icall(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 arg_types, sljit_s32 src, sljit_sw srcw);
 
-/* Perform the operation using the conditional flags as the second argument.
-   Type must always be between SLJIT_EQUAL and SLJIT_ORDERED_F64. The value
-   represented by the type is 1, if the condition represented by the type
-   is fulfilled, and 0 otherwise.
+/* Perform an operation using the conditional flags as the second argument.
+   Type must always be between SLJIT_EQUAL and SLJIT_ORDERED_LESS_EQUAL.
+   The value represented by the type is 1, if the condition represented
+   by the type is fulfilled, and 0 otherwise.
 
-   If op == SLJIT_MOV, SLJIT_MOV32:
+   When op is SLJIT_MOV or SLJIT_MOV32:
      Set dst to the value represented by the type (0 or 1).
      Flags: - (does not modify flags)
-   If op == SLJIT_OR, op == SLJIT_AND, op == SLJIT_XOR
+   When op is SLJIT_AND, SLJIT_AND32, SLJIT_OR, SLJIT_OR32, SLJIT_XOR, or SLJIT_XOR32
      Performs the binary operation using dst as the first, and the value
      represented by type as the second argument. Result is written into dst.
      Flags: Z (may destroy flags) */
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_flags(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 type);
 
 /* Emit a conditional mov instruction which moves source to destination,
    if the condition is satisfied. Unlike other arithmetic operations this
    instruction does not support memory access.
 
-   type must be between SLJIT_EQUAL and SLJIT_ORDERED_F64
-   dst_reg must be a valid register and it can be combined
-      with SLJIT_32 to perform a 32 bit arithmetic operation
-   src must be register or immediate (SLJIT_IMM)
+   type must be between SLJIT_EQUAL and SLJIT_ORDERED_LESS_EQUAL
+   type can be combined (or'ed) with SLJIT_32
+   dst_reg must be a valid register
+   src must be a valid register or immediate (SLJIT_IMM)
 
    Flags: - (does not modify flags) */
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_cmov(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 dst_reg,
 	sljit_s32 src, sljit_sw srcw);
 
+/* The following flags are used by sljit_emit_mem(), sljit_emit_mem_update(),
+   sljit_emit_fmem(), and sljit_emit_fmem_update(). */
+
+/* Memory load operation. This is the default. */
+#define SLJIT_MEM_LOAD		0x000000
+/* Memory store operation. */
+#define SLJIT_MEM_STORE		0x000200
+
 /* The following flags are used by sljit_emit_mem() and sljit_emit_fmem(). */
 
+/* Load or stora data from an unaligned (byte aligned) address. */
+#define SLJIT_MEM_UNALIGNED	0x000400
+/* Load or stora data from a 16 bit aligned address. */
+#define SLJIT_MEM_UNALIGNED_16	0x000800
+/* Load or stora data from a 32 bit aligned address. */
+#define SLJIT_MEM_UNALIGNED_32	0x001000
+
+/* The following flags are used by sljit_emit_mem_update(),
+   and sljit_emit_fmem_update(). */
+
+/* Base register is updated before the memory access (default). */
+#define SLJIT_MEM_PRE		0x000000
+/* Base register is updated after the memory access. */
+#define SLJIT_MEM_POST		0x000400
+
 /* When SLJIT_MEM_SUPP is passed, no instructions are emitted.
    Instead the function returns with SLJIT_SUCCESS if the instruction
    form is supported and SLJIT_ERR_UNSUPPORTED otherwise. This flag
    allows runtime checking of available instruction forms. */
-#define SLJIT_MEM_SUPP		0x0200
-/* Memory load operation. This is the default. */
-#define SLJIT_MEM_LOAD		0x0000
-/* Memory store operation. */
-#define SLJIT_MEM_STORE		0x0400
-/* Base register is updated before the memory access. */
-#define SLJIT_MEM_PRE		0x0800
-/* Base register is updated after the memory access. */
-#define SLJIT_MEM_POST		0x1000
+#define SLJIT_MEM_SUPP		0x000800
 
-/* Emit a single memory load or store with update instruction. When the
-   requested instruction form is not supported by the CPU, it returns
-   with SLJIT_ERR_UNSUPPORTED instead of emulating the instruction. This
-   allows specializing tight loops based on the supported instruction
-   forms (see SLJIT_MEM_SUPP flag).
+/* The sljit_emit_mem emits instructions for various memory operations:
+
+   When SLJIT_MEM_UNALIGNED / SLJIT_MEM_UNALIGNED_16 /
+        SLJIT_MEM_UNALIGNED_32 is set in type argument:
+     Emit instructions for unaligned memory loads or stores. When
+     SLJIT_UNALIGNED is not defined, the only way to access unaligned
+     memory data is using sljit_emit_mem. Otherwise all operations (e.g.
+     sljit_emit_op1/2, or sljit_emit_fop1/2) supports unaligned access.
+     In general, the performance of unaligned memory accesses are often
+     lower than aligned and should be avoided.
+
+   When a pair of registers is passed in reg argument:
+     Emit instructions for moving data between a register pair and
+     memory. The register pair can be specified by the SLJIT_REG_PAIR
+     macro. The first register is loaded from or stored into the
+     location specified by the mem/memw arguments, and the end address
+     of this operation is the starting address of the data transfer
+     between the second register and memory. The type argument must
+     be SLJIT_MOV. The SLJIT_MEM_UNALIGNED* options are allowed for
+     this operation.
 
    type must be between SLJIT_MOV and SLJIT_MOV_P and can be
-     combined with SLJIT_MEM_* flags. Either SLJIT_MEM_PRE
-     or SLJIT_MEM_POST must be specified.
-   reg is the source or destination register, and must be
-     different from the base register of the mem operand
-   mem must be a SLJIT_MEM1() or SLJIT_MEM2() operand
+     combined (or'ed) with SLJIT_MEM_* flags
+   reg is a register or register pair, which is the source or
+     destination of the operation
+   mem must be a memory operand
 
    Flags: - (does not modify flags) */
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 reg,
 	sljit_s32 mem, sljit_sw memw);
 
+/* Emit a single memory load or store with update instruction.
+   When the requested instruction form is not supported by the CPU,
+   it returns with SLJIT_ERR_UNSUPPORTED instead of emulating the
+   instruction. This allows specializing tight loops based on
+   the supported instruction forms (see SLJIT_MEM_SUPP flag).
+   Absolute address (SLJIT_MEM0) forms are never supported
+   and the base (first) register specified by the mem argument
+   must not be SLJIT_SP and must also be different from the
+   register specified by the reg argument.
+
+   type must be between SLJIT_MOV and SLJIT_MOV_P and can be
+     combined (or'ed) with SLJIT_MEM_* flags
+   reg is the source or destination register of the operation
+   mem must be a memory operand
+
+   Flags: - (does not modify flags) */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem_update(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw);
+
 /* Same as sljit_emit_mem except the followings:
 
+   Loading or storing a pair of registers is not supported.
+
    type must be SLJIT_MOV_F64 or SLJIT_MOV_F32 and can be
-     combined with SLJIT_MEM_* flags. Either SLJIT_MEM_PRE
-     or SLJIT_MEM_POST must be specified.
-   freg is the source or destination floating point register */
+     combined (or'ed) with SLJIT_MEM_* flags.
+   freg is the source or destination floating point register
+     of the operation
+   mem must be a memory operand
+
+   Flags: - (does not modify flags) */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 freg,
 	sljit_s32 mem, sljit_sw memw);
 
-/* Copies the base address of SLJIT_SP + offset to dst. The offset can be
-   anything to negate the effect of relative addressing. For example if an
-   array of sljit_sw values is stored on the stack from offset 0x40, and R0
-   contains the offset of an array item plus 0x120, this item can be
-   overwritten by two SLJIT instructions:
+/* Same as sljit_emit_mem_update except the followings:
+
+   type must be SLJIT_MOV_F64 or SLJIT_MOV_F32 and can be
+     combined (or'ed) with SLJIT_MEM_* flags
+   freg is the source or destination floating point register
+     of the operation
+   mem must be a memory operand
+
+   Flags: - (does not modify flags) */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem_update(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 freg,
+	sljit_s32 mem, sljit_sw memw);
+
+/* Copies the base address of SLJIT_SP + offset to dst. The offset can
+   represent the starting address of a value in the local data (stack).
+   The offset is not limited by the local data limits, it can be any value.
+   For example if an array of bytes are stored on the stack from
+   offset 0x40, and R0 contains the offset of an array item plus 0x120,
+   this item can be changed by two SLJIT instructions:
 
    sljit_get_local_base(compiler, SLJIT_R1, 0, 0x40 - 0x120);
-   sljit_emit_op1(compiler, SLJIT_MOV, SLJIT_MEM2(SLJIT_R1, SLJIT_R0), 0, SLJIT_IMM, 0x5);
+   sljit_emit_op1(compiler, SLJIT_MOV_U8, SLJIT_MEM2(SLJIT_R1, SLJIT_R0), 0, SLJIT_IMM, 0x5);
 
    Flags: - (may destroy flags) */
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_local_base(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw offset);
 
 /* Store a value that can be changed runtime (see: sljit_get_const_addr / sljit_set_const)
    Flags: - (does not modify flags) */
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_const* sljit_emit_const(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw init_value);
@@ -1426,23 +1658,75 @@
 
 /* Only the address and executable offset are required to perform dynamic
    code modifications. See sljit_get_executable_offset function. */
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset);
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset);
 
 /* --------------------------------------------------------------------- */
-/*  Miscellaneous utility functions                                      */
+/*  CPU specific functions                                               */
 /* --------------------------------------------------------------------- */
 
-#define SLJIT_MAJOR_VERSION	0
-#define SLJIT_MINOR_VERSION	94
+/* The following function is a helper function for sljit_emit_op_custom.
+   It returns with the real machine register index ( >=0 ) of any SLJIT_R,
+   SLJIT_S and SLJIT_SP registers.
+
+   Note: it returns with -1 for virtual registers (only on x86-32). */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_register_index(sljit_s32 reg);
+
+/* The following function is a helper function for sljit_emit_op_custom.
+   It returns with the real machine register ( >= 0 ) index of any SLJIT_FR,
+   and SLJIT_FS register.
+
+   Note: the index is always an even number on ARM-32, MIPS. */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_float_register_index(sljit_s32 reg);
+
+/* Any instruction can be inserted into the instruction stream by
+   sljit_emit_op_custom. It has a similar purpose as inline assembly.
+   The size parameter must match to the instruction size of the target
+   architecture:
+
+         x86: 0 < size <= 15. The instruction argument can be byte aligned.
+      Thumb2: if size == 2, the instruction argument must be 2 byte aligned.
+              if size == 4, the instruction argument must be 4 byte aligned.
+   Otherwise: size must be 4 and instruction argument must be 4 byte aligned. */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_custom(struct sljit_compiler *compiler,
+	void *instruction, sljit_u32 size);
+
+/* Flags were set by a 32 bit operation. */
+#define SLJIT_CURRENT_FLAGS_32			SLJIT_32
+
+/* Flags were set by an ADD or ADDC operations. */
+#define SLJIT_CURRENT_FLAGS_ADD			0x01
+/* Flags were set by a SUB, SUBC, or NEG operation. */
+#define SLJIT_CURRENT_FLAGS_SUB			0x02
+
+/* Flags were set by sljit_emit_op2u with SLJIT_SUB opcode.
+   Must be combined with SLJIT_CURRENT_FLAGS_SUB. */
+#define SLJIT_CURRENT_FLAGS_COMPARE		0x04
+
+/* Define the currently available CPU status flags. It is usually used after
+   an sljit_emit_label or sljit_emit_op_custom operations to define which CPU
+   status flags are available.
+
+   The current_flags must be a valid combination of SLJIT_SET_* and
+   SLJIT_CURRENT_FLAGS_* constants. */
+
+SLJIT_API_FUNC_ATTRIBUTE void sljit_set_current_flags(struct sljit_compiler *compiler,
+	sljit_s32 current_flags);
+
+/* --------------------------------------------------------------------- */
+/*  Miscellaneous utility functions                                      */
+/* --------------------------------------------------------------------- */
 
 /* Get the human readable name of the platform. Can be useful on platforms
-   like ARM, where ARM and Thumb2 functions can be mixed, and
-   it is useful to know the type of the code generator. */
+   like ARM, where ARM and Thumb2 functions can be mixed, and it is useful
+   to know the type of the code generator. */
 SLJIT_API_FUNC_ATTRIBUTE const char* sljit_get_platform_name(void);
 
 /* Portable helper function to get an offset of a member. */
 #define SLJIT_OFFSETOF(base, member) ((sljit_sw)(&((base*)0x10)->member) - 0x10)
 
 #if (defined SLJIT_UTIL_STACK && SLJIT_UTIL_STACK)
 
@@ -1528,66 +1812,12 @@
    around to reduce the number of OS executable memory allocations.
    This improves performance since these calls are costly. However
    it is sometimes desired to free all unused memory regions, e.g.
    before the application terminates. */
 SLJIT_API_FUNC_ATTRIBUTE void sljit_free_unused_memory_exec(void);
 #endif
 
-/* --------------------------------------------------------------------- */
-/*  CPU specific functions                                               */
-/* --------------------------------------------------------------------- */
-
-/* The following function is a helper function for sljit_emit_op_custom.
-   It returns with the real machine register index ( >=0 ) of any SLJIT_R,
-   SLJIT_S and SLJIT_SP registers.
-
-   Note: it returns with -1 for virtual registers (only on x86-32). */
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_register_index(sljit_s32 reg);
-
-/* The following function is a helper function for sljit_emit_op_custom.
-   It returns with the real machine register index of any SLJIT_FLOAT register.
-
-   Note: the index is always an even number on ARM (except ARM-64), MIPS, and SPARC. */
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_float_register_index(sljit_s32 reg);
-
-/* Any instruction can be inserted into the instruction stream by
-   sljit_emit_op_custom. It has a similar purpose as inline assembly.
-   The size parameter must match to the instruction size of the target
-   architecture:
-
-         x86: 0 < size <= 15. The instruction argument can be byte aligned.
-      Thumb2: if size == 2, the instruction argument must be 2 byte aligned.
-              if size == 4, the instruction argument must be 4 byte aligned.
-   Otherwise: size must be 4 and instruction argument must be 4 byte aligned. */
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_custom(struct sljit_compiler *compiler,
-	void *instruction, sljit_u32 size);
-
-/* Flags were set by a 32 bit operation. */
-#define SLJIT_CURRENT_FLAGS_32			SLJIT_32
-
-/* Flags were set by an ADD or ADDC operations. */
-#define SLJIT_CURRENT_FLAGS_ADD			0x01
-/* Flags were set by a SUB, SUBC, or NEG operation. */
-#define SLJIT_CURRENT_FLAGS_SUB			0x02
-
-/* Flags were set by sljit_emit_op2u with SLJIT_SUB opcode.
-   Must be combined with SLJIT_CURRENT_FLAGS_SUB. */
-#define SLJIT_CURRENT_FLAGS_COMPARE		0x04
-
-/* Define the currently available CPU status flags. It is usually used after
-   an sljit_emit_label or sljit_emit_op_custom operations to define which CPU
-   status flags are available.
-
-   The current_flags must be a valid combination of SLJIT_SET_* and
-   SLJIT_CURRENT_FLAGS_* constants. */
-
-SLJIT_API_FUNC_ATTRIBUTE void sljit_set_current_flags(struct sljit_compiler *compiler,
-	sljit_s32 current_flags);
-
 #ifdef __cplusplus
 } /* extern "C" */
 #endif
 
 #endif /* SLJIT_LIR_H_ */
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeARM_32.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeARM_32.c`

 * *Files 10% similar despite different names*

```diff
@@ -96,25 +96,29 @@
 #define BLX		0xe12fff30
 #define BX		0xe12fff10
 #define CLZ		0xe16f0f10
 #define CMN		0xe1600000
 #define CMP		0xe1400000
 #define BKPT		0xe1200070
 #define EOR		0xe0200000
+#define LDR		0xe5100000
+#define LDR_POST	0xe4100000
 #define MOV		0xe1a00000
 #define MUL		0xe0000090
 #define MVN		0xe1e00000
 #define NOP		0xe1a00000
 #define ORR		0xe1800000
 #define PUSH		0xe92d0000
 #define POP		0xe8bd0000
+#define RBIT		0xe6ff0f30
 #define RSB		0xe0600000
 #define RSC		0xe0e00000
 #define SBC		0xe0c00000
 #define SMULL		0xe0c00090
+#define STR		0xe5000000
 #define SUB		0xe0400000
 #define TST		0xe1000000
 #define UMULL		0xe0800090
 #define VABS_F32	0xeeb00ac0
 #define VADD_F32	0xee300a00
 #define VCMP_F32	0xeeb40a40
 #define VCVT_F32_S32	0xeeb80ac0
@@ -560,14 +564,15 @@
 		SLJIT_CACHE_FLUSH(inst, inst + 2);
 	}
 #endif
 }
 
 static sljit_uw get_imm(sljit_uw imm);
 static sljit_s32 load_immediate(struct sljit_compiler *compiler, sljit_s32 reg, sljit_uw imm);
+static sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg, sljit_s32 arg, sljit_sw argw, sljit_s32 tmp_reg);
 
 static SLJIT_INLINE void inline_set_const(sljit_uw addr, sljit_sw executable_offset, sljit_uw new_constant, sljit_s32 flush_cache)
 {
 #if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
 	sljit_uw *ptr = (sljit_uw*)addr;
 	sljit_uw *inst = (sljit_uw*)ptr[0];
 	sljit_uw ldr_literal = ptr[1];
@@ -951,20 +956,27 @@
 		return SLJIT_IS_FPU_AVAILABLE;
 #else
 		/* Available by default. */
 		return 1;
 #endif
 
 	case SLJIT_HAS_CLZ:
+	case SLJIT_HAS_ROT:
 	case SLJIT_HAS_CMOV:
 #if (defined SLJIT_CONFIG_ARM_V7 && SLJIT_CONFIG_ARM_V7)
+	case SLJIT_HAS_CTZ:
 	case SLJIT_HAS_PREFETCH:
 #endif
 		return 1;
 
+#if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
+	case SLJIT_HAS_CTZ:
+		return 2;
+#endif
+
 	default:
 		return 0;
 	}
 }
 
 /* --------------------------------------------------------------------- */
 /*  Entry, exit                                                          */
@@ -1045,15 +1057,16 @@
 	sljit_s32 src2, sljit_sw src2w);
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_enter(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
 	sljit_uw imm, offset;
-	sljit_s32 i, tmp, size, word_arg_count, saved_arg_count;
+	sljit_s32 i, tmp, size, word_arg_count;
+	sljit_s32 saved_arg_count = SLJIT_KEPT_SAVEDS_COUNT(options);
 #ifdef __SOFTFP__
 	sljit_u32 float_arg_count;
 #else
 	sljit_u32 old_offset, f32_offset;
 	sljit_u32 remap[3];
 	sljit_u32 *remap_ptr = remap;
 #endif
@@ -1061,15 +1074,15 @@
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
 	imm = 0;
 
 	tmp = SLJIT_S0 - saveds;
-	for (i = SLJIT_S0; i > tmp; i--)
+	for (i = SLJIT_S0 - saved_arg_count; i > tmp; i--)
 		imm |= (sljit_uw)1 << reg_map[i];
 
 	for (i = scratches; i >= SLJIT_FIRST_SAVED_REG; i--)
 		imm |= (sljit_uw)1 << reg_map[i];
 
 	SLJIT_ASSERT(reg_map[TMP_REG2] == 14);
 
@@ -1078,15 +1091,15 @@
 	   single register: str reg, [sp, #-4]! */
 	if (imm != 0)
 		FAIL_IF(push_inst(compiler, PUSH | (1 << 14) | imm));
 	else
 		FAIL_IF(push_inst(compiler, 0xe52d0004 | RD(TMP_REG2)));
 
 	/* Stack must be aligned to 8 bytes: */
-	size = GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1);
+	size = GET_SAVED_REGISTERS_SIZE(scratches, saveds - saved_arg_count, 1);
 
 	if (fsaveds > 0 || fscratches >= SLJIT_FIRST_SAVED_FLOAT_REG) {
 		if ((size & SSIZE_OF(sw)) != 0) {
 			FAIL_IF(push_inst(compiler, SUB | RD(SLJIT_SP) | RN(SLJIT_SP) | SRC2_IMM | sizeof(sljit_sw)));
 			size += SSIZE_OF(sw);
 		}
 
@@ -1099,14 +1112,17 @@
 				FAIL_IF(push_inst(compiler, VPUSH | VD(fscratches) | ((sljit_uw)(fscratches - (SLJIT_FIRST_SAVED_FLOAT_REG - 1)) << 1)));
 		}
 	}
 
 	local_size = ((size + local_size + 0x7) & ~0x7) - size;
 	compiler->local_size = local_size;
 
+	if (options & SLJIT_ENTER_REG_ARG)
+		arg_types = 0;
+
 	arg_types >>= SLJIT_ARG_SHIFT;
 	word_arg_count = 0;
 	saved_arg_count = 0;
 #ifdef __SOFTFP__
 	SLJIT_COMPILE_ASSERT(SLJIT_FR0 == 1, float_register_index_start);
 
 	offset = 0;
@@ -1144,16 +1160,15 @@
 				tmp = word_arg_count;
 			else
 				break;
 
 			if (offset < 4 * sizeof(sljit_sw))
 				FAIL_IF(push_inst(compiler, MOV | RD(tmp) | (offset >> 2)));
 			else
-				FAIL_IF(push_inst(compiler, data_transfer_insts[WORD_SIZE | LOAD_DATA] | 0x800000
-						| RN(SLJIT_SP) | RD(tmp) | (offset + (sljit_uw)size - 4 * sizeof(sljit_sw))));
+				FAIL_IF(push_inst(compiler, LDR | 0x800000 | RN(SLJIT_SP) | RD(tmp) | (offset + (sljit_uw)size - 4 * sizeof(sljit_sw))));
 			break;
 		}
 
 		offset += sizeof(sljit_sw);
 		arg_types >>= SLJIT_ARG_SHIFT;
 	}
 
@@ -1213,42 +1228,46 @@
 {
 	sljit_s32 size;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
-	size = GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1);
+	size = GET_SAVED_REGISTERS_SIZE(scratches, saveds - SLJIT_KEPT_SAVEDS_COUNT(options), 1);
 
 	if ((size & SSIZE_OF(sw)) != 0 && (fsaveds > 0 || fscratches >= SLJIT_FIRST_SAVED_FLOAT_REG))
 		size += SSIZE_OF(sw);
 
 	compiler->local_size = ((size + local_size + 0x7) & ~0x7) - size;
 	return SLJIT_SUCCESS;
 }
 
 static sljit_s32 emit_add_sp(struct sljit_compiler *compiler, sljit_uw imm)
 {
 	sljit_uw imm2 = get_imm(imm);
 
 	if (imm2 == 0) {
-		FAIL_IF(load_immediate(compiler, TMP_REG2, imm));
-		imm2 = RM(TMP_REG2);
+		imm2 = (imm & ~(sljit_uw)0x3ff) >> 10;
+		imm = (imm & 0x3ff) >> 2;
+
+		FAIL_IF(push_inst(compiler, ADD | SRC2_IMM | RD(SLJIT_SP) | RN(SLJIT_SP) | 0xb00 | imm2));
+		return push_inst(compiler, ADD | SRC2_IMM | RD(SLJIT_SP) | RN(SLJIT_SP) | 0xf00 | (imm & 0xff));
 	}
 
 	return push_inst(compiler, ADD | RD(SLJIT_SP) | RN(SLJIT_SP) | imm2);
 }
 
 static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler, sljit_s32 frame_size)
 {
 	sljit_s32 local_size, fscratches, fsaveds, i, tmp;
+	sljit_s32 restored_reg = 0;
 	sljit_s32 lr_dst = TMP_PC;
-	sljit_uw reg_list;
+	sljit_uw reg_list = 0;
 
-	SLJIT_ASSERT(reg_map[TMP_REG2] == 14);
+	SLJIT_ASSERT(reg_map[TMP_REG2] == 14 && frame_size <= 128);
 
 	local_size = compiler->local_size;
 	fscratches = compiler->fscratches;
 	fsaveds = compiler->fsaveds;
 
 	if (fsaveds > 0 || fscratches >= SLJIT_FIRST_SAVED_FLOAT_REG) {
 		if (local_size > 0)
@@ -1265,104 +1284,158 @@
 
 		local_size = GET_SAVED_REGISTERS_SIZE(compiler->scratches, compiler->saveds, 1) & 0x7;
 	}
 
 	if (frame_size < 0) {
 		lr_dst = TMP_REG2;
 		frame_size = 0;
-	} else if (frame_size > 0)
+	} else if (frame_size > 0) {
+		SLJIT_ASSERT(frame_size == 1 || (frame_size & 0x7) == 0);
 		lr_dst = 0;
+		frame_size &= ~0x7;
+	}
 
-	reg_list = 0;
 	if (lr_dst != 0)
 		reg_list |= (sljit_uw)1 << reg_map[lr_dst];
 
 	tmp = SLJIT_S0 - compiler->saveds;
-	for (i = SLJIT_S0; i > tmp; i--)
-		reg_list |= (sljit_uw)1 << reg_map[i];
+	i = SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options);
+	if (tmp < i) {
+		restored_reg = i;
+		do {
+			reg_list |= (sljit_uw)1 << reg_map[i];
+		} while (--i > tmp);
+	}
+
+	i = compiler->scratches;
+	if (i >= SLJIT_FIRST_SAVED_REG) {
+		restored_reg = i;
+		do {
+			reg_list |= (sljit_uw)1 << reg_map[i];
+		} while (--i >= SLJIT_FIRST_SAVED_REG);
+	}
 
-	for (i = compiler->scratches; i >= SLJIT_FIRST_SAVED_REG; i--)
-		reg_list |= (sljit_uw)1 << reg_map[i];
+	if (lr_dst == TMP_REG2 && reg_list == 0) {
+		restored_reg = TMP_REG2;
+		lr_dst = 0;
+	}
 
 	if (lr_dst == 0 && (reg_list & (reg_list - 1)) == 0) {
 		/* The local_size does not include the saved registers. */
-		local_size += SSIZE_OF(sw);
+		tmp = 0;
+		if (reg_list != 0) {
+			tmp = 2;
+			if (local_size <= 0xfff) {
+				if (local_size == 0) {
+					SLJIT_ASSERT(restored_reg != TMP_REG2);
+					if (frame_size == 0)
+						return push_inst(compiler, LDR_POST | RN(SLJIT_SP) | RD(restored_reg) | 0x800008);
+					if (frame_size > 2 * SSIZE_OF(sw))
+						return push_inst(compiler, LDR_POST | RN(SLJIT_SP) | RD(restored_reg) | (sljit_uw)(frame_size - (2 * SSIZE_OF(sw))));
+				}
 
-		if (reg_list != 0)
-			local_size += SSIZE_OF(sw);
+				FAIL_IF(push_inst(compiler, LDR | 0x800000 | RN(SLJIT_SP) | RD(restored_reg) | (sljit_uw)local_size));
+				tmp = 1;
+			} else if (frame_size == 0) {
+				frame_size = (restored_reg == TMP_REG2) ? SSIZE_OF(sw) : 2 * SSIZE_OF(sw);
+				tmp = 3;
+			}
+
+			/* Place for the saved register. */
+			if (restored_reg != TMP_REG2)
+				local_size += SSIZE_OF(sw);
+		}
+
+		/* Place for the lr register. */
+		local_size += SSIZE_OF(sw);
 
 		if (frame_size > local_size)
 			FAIL_IF(push_inst(compiler, SUB | RD(SLJIT_SP) | RN(SLJIT_SP) | (1 << 25) | (sljit_uw)(frame_size - local_size)));
 		else if (frame_size < local_size)
 			FAIL_IF(emit_add_sp(compiler, (sljit_uw)(local_size - frame_size)));
 
-		if (reg_list == 0)
+		if (tmp <= 1)
 			return SLJIT_SUCCESS;
 
-		if (compiler->saveds > 0) {
-			SLJIT_ASSERT(reg_list == ((sljit_uw)1 << reg_map[SLJIT_S0]));
-			lr_dst = SLJIT_S0;
-		} else {
-			SLJIT_ASSERT(reg_list == ((sljit_uw)1 << reg_map[SLJIT_FIRST_SAVED_REG]));
-			lr_dst = SLJIT_FIRST_SAVED_REG;
+		if (tmp == 2) {
+			frame_size -= SSIZE_OF(sw);
+			if (restored_reg != TMP_REG2)
+				frame_size -= SSIZE_OF(sw);
+
+			return push_inst(compiler, LDR | 0x800000 | RN(SLJIT_SP) | RD(restored_reg) | (sljit_uw)frame_size);
 		}
 
-		return push_inst(compiler, data_transfer_insts[WORD_SIZE | LOAD_DATA] | 0x800000
-			| RN(SLJIT_SP) | RD(lr_dst) | (sljit_uw)(frame_size - 2 * SSIZE_OF(sw)));
+		tmp = (restored_reg == TMP_REG2) ? 0x800004 : 0x800008;
+		return push_inst(compiler, LDR_POST | RN(SLJIT_SP) | RD(restored_reg) | (sljit_uw)tmp);
 	}
 
 	if (local_size > 0)
 		FAIL_IF(emit_add_sp(compiler, (sljit_uw)local_size));
 
 	/* Pop saved and temporary registers
 	   multiple registers: ldmia sp!, {...}
 	   single register: ldr reg, [sp], #4 */
 	if ((reg_list & (reg_list - 1)) == 0) {
 		SLJIT_ASSERT(lr_dst != 0);
 		SLJIT_ASSERT(reg_list == (sljit_uw)1 << reg_map[lr_dst]);
 
-		return push_inst(compiler, 0xe49d0004 | RD(lr_dst));
+		return push_inst(compiler, LDR_POST | RN(SLJIT_SP) | RD(lr_dst) | 0x800004);
 	}
 
 	FAIL_IF(push_inst(compiler, POP | reg_list));
+
 	if (frame_size > 0)
 		return push_inst(compiler, SUB | RD(SLJIT_SP) | RN(SLJIT_SP) | (1 << 25) | ((sljit_uw)frame_size - sizeof(sljit_sw)));
-	return SLJIT_SUCCESS;
+
+	if (lr_dst != 0)
+		return SLJIT_SUCCESS;
+
+	return push_inst(compiler, ADD | RD(SLJIT_SP) | RN(SLJIT_SP) | (1 << 25) | sizeof(sljit_sw));
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_void(struct sljit_compiler *compiler)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_return_void(compiler));
 
 	return emit_stack_frame_release(compiler, 0);
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_to(struct sljit_compiler *compiler,
+	sljit_s32 src, sljit_sw srcw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_return_to(compiler, src, srcw));
+
+	if (src & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, WORD_SIZE | LOAD_DATA, TMP_REG1, src, srcw, TMP_REG1));
+		src = TMP_REG1;
+		srcw = 0;
+	} else if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
+		FAIL_IF(push_inst(compiler, MOV | RD(TMP_REG1) | RM(src)));
+		src = TMP_REG1;
+		srcw = 0;
+	}
+
+	FAIL_IF(emit_stack_frame_release(compiler, 1));
+
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_ijump(compiler, SLJIT_JUMP, src, srcw);
+}
+
 /* --------------------------------------------------------------------- */
 /*  Operators                                                            */
 /* --------------------------------------------------------------------- */
 
-#define EMIT_SHIFT_INS_AND_RETURN(opcode) \
-	SLJIT_ASSERT(!(flags & INV_IMM) && !(src2 & SRC2_IMM)); \
-	if (compiler->shift_imm != 0x20) { \
-		SLJIT_ASSERT(src1 == TMP_REG1); \
-		SLJIT_ASSERT(!(flags & ARGS_SWAPPED)); \
-		\
-		if (compiler->shift_imm != 0) \
-			return push_inst(compiler, MOV | (flags & SET_FLAGS) | \
-				RD(dst) | (compiler->shift_imm << 7) | (opcode << 5) | RM(src2)); \
-		return push_inst(compiler, MOV | (flags & SET_FLAGS) | RD(dst) | RM(src2)); \
-	} \
-	return push_inst(compiler, MOV | (flags & SET_FLAGS) | RD(dst) \
-		| RM8((flags & ARGS_SWAPPED) ? src1 : src2) | (sljit_uw)(opcode << 5) \
-		| 0x10 | RM((flags & ARGS_SWAPPED) ? src2 : src1));
-
 static SLJIT_INLINE sljit_s32 emit_single_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 flags,
 	sljit_uw dst, sljit_uw src1, sljit_uw src2)
 {
+	sljit_s32 is_masked;
+	sljit_uw shift_type;
+
 	switch (GET_OPCODE(op)) {
 	case SLJIT_MOV:
 		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & ARGS_SWAPPED));
 		if (dst != src2) {
 			if (src2 & SRC2_IMM) {
 				return push_inst(compiler, ((flags & INV_IMM) ? MVN : MOV) | RD(dst) | src2);
 			}
@@ -1409,19 +1482,32 @@
 	case SLJIT_NOT:
 		if (src2 & SRC2_IMM)
 			return push_inst(compiler, ((flags & INV_IMM) ? MOV : MVN) | (flags & SET_FLAGS) | RD(dst) | src2);
 
 		return push_inst(compiler, MVN | (flags & SET_FLAGS) | RD(dst) | RM(src2));
 
 	case SLJIT_CLZ:
-		SLJIT_ASSERT(!(flags & INV_IMM));
-		SLJIT_ASSERT(!(src2 & SRC2_IMM));
+		SLJIT_ASSERT(!(flags & INV_IMM) && !(src2 & SRC2_IMM));
 		FAIL_IF(push_inst(compiler, CLZ | RD(dst) | RM(src2)));
 		return SLJIT_SUCCESS;
 
+	case SLJIT_CTZ:
+		SLJIT_ASSERT(!(flags & INV_IMM) && !(src2 & SRC2_IMM));
+		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & ARGS_SWAPPED));
+#if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
+		FAIL_IF(push_inst(compiler, RSB | SRC2_IMM | RD(TMP_REG1) | RN(src2) | 0));
+		FAIL_IF(push_inst(compiler, AND | RD(TMP_REG2) | RN(src2) | RM(TMP_REG1)));
+		FAIL_IF(push_inst(compiler, CLZ | RD(dst) | RM(TMP_REG2)));
+		FAIL_IF(push_inst(compiler, CMP | SET_FLAGS | SRC2_IMM | RN(dst) | 32));
+		return push_inst(compiler, (EOR ^ 0xf0000000) | SRC2_IMM | RD(dst) | RN(dst) | 0x1f);
+#else /* !SLJIT_CONFIG_ARM_V5 */
+		FAIL_IF(push_inst(compiler, RBIT | RD(dst) | RM(src2)));
+		return push_inst(compiler, CLZ | RD(dst) | RM(dst));
+#endif /* SLJIT_CONFIG_ARM_V5 */
+
 	case SLJIT_ADD:
 		SLJIT_ASSERT(!(flags & INV_IMM));
 
 		if ((flags & (UNUSED_RETURN | ARGS_SWAPPED)) == UNUSED_RETURN)
 			return push_inst(compiler, CMN | SET_FLAGS | RN(src1) | ((src2 & SRC2_IMM) ? src2 : RM(src2)));
 		return push_inst(compiler, ADD | (flags & SET_FLAGS) | RD(dst) | RN(src1) | ((src2 & SRC2_IMM) ? src2 : RM(src2)));
 
@@ -1467,25 +1553,69 @@
 		return push_inst(compiler, ORR | (flags & SET_FLAGS) | RD(dst) | RN(src1) | ((src2 & SRC2_IMM) ? src2 : RM(src2)));
 
 	case SLJIT_XOR:
 		SLJIT_ASSERT(!(flags & INV_IMM));
 		return push_inst(compiler, EOR | (flags & SET_FLAGS) | RD(dst) | RN(src1) | ((src2 & SRC2_IMM) ? src2 : RM(src2)));
 
 	case SLJIT_SHL:
-		EMIT_SHIFT_INS_AND_RETURN(0);
+	case SLJIT_MSHL:
+		shift_type = 0;
+		is_masked = GET_OPCODE(op) == SLJIT_MSHL;
+		break;
 
 	case SLJIT_LSHR:
-		EMIT_SHIFT_INS_AND_RETURN(1);
+	case SLJIT_MLSHR:
+		shift_type = 1;
+		is_masked = GET_OPCODE(op) == SLJIT_MLSHR;
+		break;
 
 	case SLJIT_ASHR:
-		EMIT_SHIFT_INS_AND_RETURN(2);
+	case SLJIT_MASHR:
+		shift_type = 2;
+		is_masked = GET_OPCODE(op) == SLJIT_MASHR;
+		break;
+
+	case SLJIT_ROTL:
+		if (compiler->shift_imm == 0x20) {
+			FAIL_IF(push_inst(compiler, RSB | SRC2_IMM | RD(TMP_REG2) | RN(src2) | 0));
+			src2 = TMP_REG2;
+		} else
+			compiler->shift_imm = (sljit_uw)(-(sljit_sw)compiler->shift_imm) & 0x1f;
+		/* fallthrough */
+
+	case SLJIT_ROTR:
+		shift_type = 3;
+		is_masked = 0;
+		break;
+
+	default:
+		SLJIT_UNREACHABLE();
+		return SLJIT_SUCCESS;
 	}
 
-	SLJIT_UNREACHABLE();
-	return SLJIT_SUCCESS;
+	SLJIT_ASSERT(!(flags & ARGS_SWAPPED) && !(flags & INV_IMM) && !(src2 & SRC2_IMM));
+
+	if (compiler->shift_imm != 0x20) {
+		SLJIT_ASSERT(src1 == TMP_REG1);
+
+		if (compiler->shift_imm != 0)
+			return push_inst(compiler, MOV | (flags & SET_FLAGS) |
+				RD(dst) | (compiler->shift_imm << 7) | (shift_type << 5) | RM(src2));
+		return push_inst(compiler, MOV | (flags & SET_FLAGS) | RD(dst) | RM(src2));
+	}
+
+	SLJIT_ASSERT(src1 != TMP_REG2);
+
+	if (is_masked) {
+		FAIL_IF(push_inst(compiler, AND | RD(TMP_REG2) | RN(src2) | SRC2_IMM | 0x1f));
+		src2 = TMP_REG2;
+	}
+
+	return push_inst(compiler, MOV | (flags & SET_FLAGS) | RD(dst)
+		| RM8(src2) | (sljit_uw)(shift_type << 5) | 0x10 | RM(src1));
 }
 
 #undef EMIT_SHIFT_INS_AND_RETURN
 
 /* Tests whether the immediate can be stored in the 12 bit imm field.
    Returns with 0 if not possible. */
 static sljit_uw get_imm(sljit_uw imm)
@@ -1666,108 +1796,103 @@
 	FAIL_IF(push_inst(compiler, MOVW | RD(reg) | ((imm << 4) & 0xf0000) | (imm & 0xfff)));
 	if (imm <= 0xffff)
 		return SLJIT_SUCCESS;
 	return push_inst(compiler, MOVT | RD(reg) | ((imm >> 12) & 0xf0000) | ((imm >> 16) & 0xfff));
 #endif
 }
 
-static SLJIT_INLINE sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg,
+static sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg,
 	sljit_s32 arg, sljit_sw argw, sljit_s32 tmp_reg)
 {
-	sljit_uw imm, offset_reg;
-	sljit_uw is_type1_transfer = IS_TYPE1_TRANSFER(flags);
+	sljit_uw imm, offset_reg, tmp;
+	sljit_sw mask = IS_TYPE1_TRANSFER(flags) ? 0xfff : 0xff;
+	sljit_sw sign = IS_TYPE1_TRANSFER(flags) ? 0x1000 : 0x100;
 
-	SLJIT_ASSERT (arg & SLJIT_MEM);
-	SLJIT_ASSERT((arg & REG_MASK) != tmp_reg);
+	SLJIT_ASSERT(arg & SLJIT_MEM);
+	SLJIT_ASSERT((arg & REG_MASK) != tmp_reg || (arg == SLJIT_MEM1(tmp_reg) && argw >= -mask && argw <= mask));
 
-	if (!(arg & REG_MASK)) {
-		if (is_type1_transfer) {
-			FAIL_IF(load_immediate(compiler, tmp_reg, (sljit_uw)argw & ~(sljit_uw)0xfff));
-			argw &= 0xfff;
-		}
-		else {
-			FAIL_IF(load_immediate(compiler, tmp_reg, (sljit_uw)argw & ~(sljit_uw)0xff));
-			argw &= 0xff;
+	if (SLJIT_UNLIKELY(!(arg & REG_MASK))) {
+		tmp = (sljit_uw)(argw & (sign | mask));
+		tmp = (sljit_uw)((argw + (tmp <= (sljit_uw)sign ? 0 : sign)) & ~mask);
+
+		FAIL_IF(load_immediate(compiler, tmp_reg, tmp));
+
+		argw -= (sljit_sw)tmp;
+		tmp = 1;
+
+		if (argw < 0) {
+			argw = -argw;
+			tmp = 0;
 		}
 
-		return push_inst(compiler, EMIT_DATA_TRANSFER(flags, 1, reg, tmp_reg,
-			is_type1_transfer ? argw : TYPE2_TRANSFER_IMM(argw)));
+		return push_inst(compiler, EMIT_DATA_TRANSFER(flags, tmp, reg, tmp_reg,
+			(mask == 0xff) ? TYPE2_TRANSFER_IMM(argw) : argw));
 	}
 
 	if (arg & OFFS_REG_MASK) {
 		offset_reg = OFFS_REG(arg);
 		arg &= REG_MASK;
 		argw &= 0x3;
 
-		if (argw != 0 && !is_type1_transfer) {
+		if (argw != 0 && (mask == 0xff)) {
 			FAIL_IF(push_inst(compiler, ADD | RD(tmp_reg) | RN(arg) | RM(offset_reg) | ((sljit_uw)argw << 7)));
 			return push_inst(compiler, EMIT_DATA_TRANSFER(flags, 1, reg, tmp_reg, TYPE2_TRANSFER_IMM(0)));
 		}
 
 		/* Bit 25: RM is offset. */
 		return push_inst(compiler, EMIT_DATA_TRANSFER(flags, 1, reg, arg,
-			RM(offset_reg) | (is_type1_transfer ? (1 << 25) : 0) | ((sljit_uw)argw << 7)));
+			RM(offset_reg) | (mask == 0xff ? 0 : (1 << 25)) | ((sljit_uw)argw << 7)));
 	}
 
 	arg &= REG_MASK;
 
-	if (is_type1_transfer) {
-		if (argw > 0xfff) {
-			imm = get_imm((sljit_uw)argw & ~(sljit_uw)0xfff);
-			if (imm) {
-				FAIL_IF(push_inst(compiler, ADD | RD(tmp_reg) | RN(arg) | imm));
-				argw = argw & 0xfff;
-				arg = tmp_reg;
-			}
-		}
-		else if (argw < -0xfff) {
-			imm = get_imm((sljit_uw)-argw & ~(sljit_uw)0xfff);
-			if (imm) {
-				FAIL_IF(push_inst(compiler, SUB | RD(tmp_reg) | RN(arg) | imm));
-				argw = -(-argw & 0xfff);
-				arg = tmp_reg;
-			}
-		}
+	if (argw > mask) {
+		tmp = (sljit_uw)(argw & (sign | mask));
+		tmp = (sljit_uw)((argw + (tmp <= (sljit_uw)sign ? 0 : sign)) & ~mask);
+		imm = get_imm(tmp);
 
-		if (argw >= 0 && argw <= 0xfff)
-			return push_inst(compiler, EMIT_DATA_TRANSFER(flags, 1, reg, arg, argw));
+		if (imm) {
+			FAIL_IF(push_inst(compiler, ADD | RD(tmp_reg) | RN(arg) | imm));
+			argw -= (sljit_sw)tmp;
+			arg = tmp_reg;
+
+			SLJIT_ASSERT(argw >= -mask && argw <= mask);
+		}
+	} else if (argw < -mask) {
+		tmp = (sljit_uw)(-argw & (sign | mask));
+		tmp = (sljit_uw)((-argw + (tmp <= (sljit_uw)sign ? 0 : sign)) & ~mask);
+		imm = get_imm(tmp);
 
-		if (argw < 0 && argw >= -0xfff)
-			return push_inst(compiler, EMIT_DATA_TRANSFER(flags, 0, reg, arg, -argw));
-	}
-	else {
-		if (argw > 0xff) {
-			imm = get_imm((sljit_uw)argw & ~(sljit_uw)0xff);
-			if (imm) {
-				FAIL_IF(push_inst(compiler, ADD | RD(tmp_reg) | RN(arg) | imm));
-				argw = argw & 0xff;
-				arg = tmp_reg;
-			}
+		if (imm) {
+			FAIL_IF(push_inst(compiler, SUB | RD(tmp_reg) | RN(arg) | imm));
+			argw += (sljit_sw)tmp;
+			arg = tmp_reg;
+
+			SLJIT_ASSERT(argw >= -mask && argw <= mask);
 		}
-		else if (argw < -0xff) {
-			imm = get_imm((sljit_uw)-argw & ~(sljit_uw)0xff);
-			if (imm) {
-				FAIL_IF(push_inst(compiler, SUB | RD(tmp_reg) | RN(arg) | imm));
-				argw = -(-argw & 0xff);
-				arg = tmp_reg;
-			}
+	}
+
+	if (argw <= mask && argw >= -mask) {
+		if (argw >= 0) {
+			if (mask == 0xff)
+				argw = TYPE2_TRANSFER_IMM(argw);
+			return push_inst(compiler, EMIT_DATA_TRANSFER(flags, 1, reg, arg, argw));
 		}
 
-		if (argw >= 0 && argw <= 0xff)
-			return push_inst(compiler, EMIT_DATA_TRANSFER(flags, 1, reg, arg, TYPE2_TRANSFER_IMM(argw)));
+		argw = -argw;
 
-		if (argw < 0 && argw >= -0xff) {
-			argw = -argw;
-			return push_inst(compiler, EMIT_DATA_TRANSFER(flags, 0, reg, arg, TYPE2_TRANSFER_IMM(argw)));
-		}
+		if (mask == 0xff)
+			argw = TYPE2_TRANSFER_IMM(argw);
+
+		return push_inst(compiler, EMIT_DATA_TRANSFER(flags, 0, reg, arg, argw));
 	}
 
 	FAIL_IF(load_immediate(compiler, tmp_reg, (sljit_uw)argw));
 	return push_inst(compiler, EMIT_DATA_TRANSFER(flags, 1, reg, arg,
-		RM(tmp_reg) | (is_type1_transfer ? (1 << 25) : 0)));
+		RM(tmp_reg) | (mask == 0xff ? 0 : (1 << 25))));
 }
 
 static sljit_s32 emit_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 inp_flags,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
@@ -1957,43 +2082,43 @@
 			saved_reg_list[saved_reg_count++] = 3;
 		if (compiler->scratches >= 3)
 			saved_reg_list[saved_reg_count++] = 2;
 		if (op >= SLJIT_DIV_UW)
 			saved_reg_list[saved_reg_count++] = 1;
 
 		if (saved_reg_count > 0) {
-			FAIL_IF(push_inst(compiler, 0xe52d0000 | (saved_reg_count >= 3 ? 16 : 8)
+			FAIL_IF(push_inst(compiler, STR | 0x2d0000 | (saved_reg_count >= 3 ? 16 : 8)
 						| (saved_reg_list[0] << 12) /* str rX, [sp, #-8/-16]! */));
 			if (saved_reg_count >= 2) {
 				SLJIT_ASSERT(saved_reg_list[1] < 8);
-				FAIL_IF(push_inst(compiler, 0xe58d0004 | (saved_reg_list[1] << 12) /* str rX, [sp, #4] */));
+				FAIL_IF(push_inst(compiler, STR | 0x8d0004 | (saved_reg_list[1] << 12) /* str rX, [sp, #4] */));
 			}
 			if (saved_reg_count >= 3) {
 				SLJIT_ASSERT(saved_reg_list[2] < 8);
-				FAIL_IF(push_inst(compiler, 0xe58d0008 | (saved_reg_list[2] << 12) /* str rX, [sp, #8] */));
+				FAIL_IF(push_inst(compiler, STR | 0x8d0008 | (saved_reg_list[2] << 12) /* str rX, [sp, #8] */));
 			}
 		}
 
 #if defined(__GNUC__)
 		FAIL_IF(sljit_emit_ijump(compiler, SLJIT_FAST_CALL, SLJIT_IMM,
 			((op | 0x2) == SLJIT_DIV_UW ? SLJIT_FUNC_ADDR(__aeabi_uidivmod) : SLJIT_FUNC_ADDR(__aeabi_idivmod))));
 #else
 #error "Software divmod functions are needed"
 #endif
 
 		if (saved_reg_count > 0) {
 			if (saved_reg_count >= 3) {
 				SLJIT_ASSERT(saved_reg_list[2] < 8);
-				FAIL_IF(push_inst(compiler, 0xe59d0008 | (saved_reg_list[2] << 12) /* ldr rX, [sp, #8] */));
+				FAIL_IF(push_inst(compiler, LDR | 0x8d0008 | (saved_reg_list[2] << 12) /* ldr rX, [sp, #8] */));
 			}
 			if (saved_reg_count >= 2) {
 				SLJIT_ASSERT(saved_reg_list[1] < 8);
-				FAIL_IF(push_inst(compiler, 0xe59d0004 | (saved_reg_list[1] << 12) /* ldr rX, [sp, #4] */));
+				FAIL_IF(push_inst(compiler, LDR | 0x8d0004 | (saved_reg_list[1] << 12) /* ldr rX, [sp, #4] */));
 			}
-			return push_inst(compiler, 0xe49d0000 | (sljit_uw)(saved_reg_count >= 3 ? 16 : 8)
+			return push_inst(compiler, (LDR ^ (1 << 24)) | 0x8d0000 | (sljit_uw)(saved_reg_count >= 3 ? 16 : 8)
 						| (saved_reg_list[0] << 12) /* ldr rX, [sp], #8/16 */);
 		}
 		return SLJIT_SUCCESS;
 	case SLJIT_ENDBR:
 	case SLJIT_SKIP_FRAMES_BEFORE_RETURN:
 		return SLJIT_SUCCESS;
 	}
@@ -2030,14 +2155,15 @@
 	case SLJIT_MOV_S16:
 		return emit_op(compiler, SLJIT_MOV_S16, ALLOW_ANY_IMM | SIGNED | HALF_SIZE, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_s16)srcw : srcw);
 
 	case SLJIT_NOT:
 		return emit_op(compiler, op, ALLOW_ANY_IMM, dst, dstw, TMP_REG1, 0, src, srcw);
 
 	case SLJIT_CLZ:
+	case SLJIT_CTZ:
 		return emit_op(compiler, op, 0, dst, dstw, TMP_REG1, 0, src, srcw);
 	}
 
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2(struct sljit_compiler *compiler, sljit_s32 op,
@@ -2065,21 +2191,25 @@
 	case SLJIT_MUL:
 		return emit_op(compiler, op, 0, dst, dstw, src1, src1w, src2, src2w);
 
 	case SLJIT_AND:
 		return emit_op(compiler, op, ALLOW_ANY_IMM, dst, dstw, src1, src1w, src2, src2w);
 
 	case SLJIT_SHL:
+	case SLJIT_MSHL:
 	case SLJIT_LSHR:
+	case SLJIT_MLSHR:
 	case SLJIT_ASHR:
+	case SLJIT_MASHR:
+	case SLJIT_ROTL:
+	case SLJIT_ROTR:
 		if (src2 & SLJIT_IMM) {
 			compiler->shift_imm = src2w & 0x1f;
 			return emit_op(compiler, op, 0, dst, dstw, TMP_REG1, 0, src1, src1w);
-		}
-		else {
+		} else {
 			compiler->shift_imm = 0x20;
 			return emit_op(compiler, op, 0, dst, dstw, src1, src1w, src2, src2w);
 		}
 	}
 
 	return SLJIT_SUCCESS;
 }
@@ -2087,21 +2217,75 @@
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2u(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op2(compiler, op, 1, 0, 0, src1, src1w, src2, src2w));
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_op2(compiler, op, TMP_REG2, 0, src1, src1w, src2, src2w);
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_shift_into(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 src_dst,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+	sljit_s32 is_left;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_shift_into(compiler, op, src_dst, src1, src1w, src2, src2w));
+
+	op = GET_OPCODE(op);
+	is_left = (op == SLJIT_SHL || op == SLJIT_MSHL);
+
+	if (src_dst == src1) {
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_op2(compiler, is_left ? SLJIT_ROTL : SLJIT_ROTR, src_dst, 0, src_dst, 0, src2, src2w);
+	}
+
+	ADJUST_LOCAL_OFFSET(src1, src1w);
+	ADJUST_LOCAL_OFFSET(src2, src2w);
+
+	/* Shift type of ROR is 3. */
+	if (src2 & SLJIT_IMM) {
+		src2w &= 0x1f;
+
+		if (src2w == 0)
+			return SLJIT_SUCCESS;
+	} else if (src2 & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, WORD_SIZE | LOAD_DATA, TMP_REG2, src2, src2w, TMP_REG2));
+		src2 = TMP_REG2;
+	}
+
+	if (src1 & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, WORD_SIZE | LOAD_DATA, TMP_REG1, src1, src1w, TMP_REG1));
+		src1 = TMP_REG1;
+	} else if (src1 & SLJIT_IMM) {
+		FAIL_IF(load_immediate(compiler, TMP_REG1, (sljit_uw)src1w));
+		src1 = TMP_REG1;
+	}
+
+	if (src2 & SLJIT_IMM) {
+		FAIL_IF(push_inst(compiler, MOV | RD(src_dst) | RM(src_dst) | ((sljit_uw)(is_left ? 0 : 1) << 5) | ((sljit_uw)src2w << 7)));
+		src2w = (src2w ^ 0x1f) + 1;
+		return push_inst(compiler, ORR | RD(src_dst) | RN(src_dst) | RM(src1) | ((sljit_uw)(is_left ? 1 : 0) << 5) | ((sljit_uw)src2w << 7));
+	}
+
+	if (op == SLJIT_MSHL || op == SLJIT_MLSHR) {
+		FAIL_IF(push_inst(compiler, AND | SRC2_IMM | RD(TMP_REG2) | RN(src2) | 0x1f));
+		src2 = TMP_REG2;
+	}
+
+	FAIL_IF(push_inst(compiler, MOV | RD(src_dst) | RM8(src2) | ((sljit_uw)(is_left ? 0 : 1) << 5) | 0x10 | RM(src_dst)));
+	FAIL_IF(push_inst(compiler, MOV | RD(TMP_REG1) | RM(src1) | ((sljit_uw)(is_left ? 1 : 0) << 5) | (1 << 7)));
+	FAIL_IF(push_inst(compiler, EOR | SRC2_IMM | RD(TMP_REG2) | RN(src2) | 0x1f));
+	return push_inst(compiler, ORR | RD(src_dst) | RN(src_dst) | RM(TMP_REG1) | ((sljit_uw)(is_left ? 1 : 0) << 5) | 0x10 | RM8(TMP_REG2));
+}
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_src(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src, sljit_sw srcw)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_src(compiler, op, src, srcw));
 	ADJUST_LOCAL_OFFSET(src, srcw);
 
@@ -2366,15 +2550,14 @@
 
 	if (dst_r == TMP_FREG1)
 		FAIL_IF(emit_fop_mem(compiler, (op & SLJIT_32), TMP_FREG1, dst, dstw));
 
 	return SLJIT_SUCCESS;
 }
 
-#undef FPU_LOAD
 #undef EMIT_FPU_DATA_TRANSFER
 
 /* --------------------------------------------------------------------- */
 /*  Other instructions                                                   */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw)
@@ -2396,77 +2579,93 @@
 /*  Conditional instructions                                             */
 /* --------------------------------------------------------------------- */
 
 static sljit_uw get_cc(struct sljit_compiler *compiler, sljit_s32 type)
 {
 	switch (type) {
 	case SLJIT_EQUAL:
-	case SLJIT_EQUAL_F64:
+	case SLJIT_F_EQUAL:
+	case SLJIT_ORDERED_EQUAL:
+	case SLJIT_UNORDERED_OR_EQUAL: /* Not supported. */
 		return 0x00000000;
 
 	case SLJIT_NOT_EQUAL:
-	case SLJIT_NOT_EQUAL_F64:
+	case SLJIT_F_NOT_EQUAL:
+	case SLJIT_UNORDERED_OR_NOT_EQUAL:
+	case SLJIT_ORDERED_NOT_EQUAL: /* Not supported. */
 		return 0x10000000;
 
 	case SLJIT_CARRY:
 		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_ADD)
 			return 0x20000000;
 		/* fallthrough */
 
 	case SLJIT_LESS:
-	case SLJIT_LESS_F64:
 		return 0x30000000;
 
 	case SLJIT_NOT_CARRY:
 		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_ADD)
 			return 0x30000000;
 		/* fallthrough */
 
 	case SLJIT_GREATER_EQUAL:
-	case SLJIT_GREATER_EQUAL_F64:
 		return 0x20000000;
 
 	case SLJIT_GREATER:
-	case SLJIT_GREATER_F64:
+	case SLJIT_UNORDERED_OR_GREATER:
 		return 0x80000000;
 
 	case SLJIT_LESS_EQUAL:
-	case SLJIT_LESS_EQUAL_F64:
+	case SLJIT_F_LESS_EQUAL:
+	case SLJIT_ORDERED_LESS_EQUAL:
 		return 0x90000000;
 
 	case SLJIT_SIG_LESS:
+	case SLJIT_UNORDERED_OR_LESS:
 		return 0xb0000000;
 
 	case SLJIT_SIG_GREATER_EQUAL:
+	case SLJIT_F_GREATER_EQUAL:
+	case SLJIT_ORDERED_GREATER_EQUAL:
 		return 0xa0000000;
 
 	case SLJIT_SIG_GREATER:
+	case SLJIT_F_GREATER:
+	case SLJIT_ORDERED_GREATER:
 		return 0xc0000000;
 
 	case SLJIT_SIG_LESS_EQUAL:
+	case SLJIT_UNORDERED_OR_LESS_EQUAL:
 		return 0xd0000000;
 
 	case SLJIT_OVERFLOW:
 		if (!(compiler->status_flags_state & (SLJIT_CURRENT_FLAGS_ADD | SLJIT_CURRENT_FLAGS_SUB)))
 			return 0x10000000;
 		/* fallthrough */
 
-	case SLJIT_UNORDERED_F64:
+	case SLJIT_UNORDERED:
 		return 0x60000000;
 
 	case SLJIT_NOT_OVERFLOW:
 		if (!(compiler->status_flags_state & (SLJIT_CURRENT_FLAGS_ADD | SLJIT_CURRENT_FLAGS_SUB)))
 			return 0x00000000;
 		/* fallthrough */
 
-	case SLJIT_ORDERED_F64:
+	case SLJIT_ORDERED:
 		return 0x70000000;
 
+	case SLJIT_F_LESS:
+	case SLJIT_ORDERED_LESS:
+		return 0x40000000;
+
+	case SLJIT_UNORDERED_OR_GREATER_EQUAL:
+		return 0x50000000;
+
 	default:
-		SLJIT_ASSERT(type >= SLJIT_JUMP && type <= SLJIT_CALL_CDECL);
+		SLJIT_ASSERT(type >= SLJIT_JUMP && type <= SLJIT_CALL_REG_ARG);
 		return 0xe0000000;
 	}
 }
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_label* sljit_emit_label(struct sljit_compiler *compiler)
 {
 	struct sljit_label *label;
@@ -2635,15 +2834,15 @@
 					}
 					else if (src_offset == word_arg_offset) {
 						*src = (sljit_s32)(SLJIT_R0 + (offset >> 2));
 						src_offset = offset;
 					}
 					FAIL_IF(push_inst(compiler, MOV | (offset << 10) | (word_arg_offset >> 2)));
 				} else
-					FAIL_IF(push_inst(compiler, data_transfer_insts[WORD_SIZE] | 0x800000 | RN(SLJIT_SP) | (word_arg_offset << 10) | (offset - 4 * sizeof(sljit_sw))));
+					FAIL_IF(push_inst(compiler, STR | 0x800000 | RN(SLJIT_SP) | (word_arg_offset << 10) | (offset - 4 * sizeof(sljit_sw))));
 			}
 			break;
 		}
 
 		types >>= SLJIT_ARG_SHIFT;
 	}
 
@@ -2714,59 +2913,56 @@
 	sljit_u32 extra_space = (sljit_u32)type;
 #endif
 
 	CHECK_ERROR_PTR();
 	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
 
 #ifdef __SOFTFP__
-	PTR_FAIL_IF(softfloat_call_with_args(compiler, arg_types, NULL, &extra_space));
-	SLJIT_ASSERT((extra_space & 0x7) == 0);
-
-	if ((type & SLJIT_CALL_RETURN) && extra_space == 0)
-		type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG) {
+		PTR_FAIL_IF(softfloat_call_with_args(compiler, arg_types, NULL, &extra_space));
+		SLJIT_ASSERT((extra_space & 0x7) == 0);
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+		if ((type & SLJIT_CALL_RETURN) && extra_space == 0)
+			type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
 
-	jump = sljit_emit_jump(compiler, type);
-	PTR_FAIL_IF(jump == NULL);
+		SLJIT_SKIP_CHECKS(compiler);
+		jump = sljit_emit_jump(compiler, type);
+		PTR_FAIL_IF(jump == NULL);
 
-	if (extra_space > 0) {
-		if (type & SLJIT_CALL_RETURN)
-			PTR_FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(WORD_SIZE | LOAD_DATA, 1,
-				TMP_REG2, SLJIT_SP, extra_space - sizeof(sljit_sw))));
+		if (extra_space > 0) {
+			if (type & SLJIT_CALL_RETURN)
+				PTR_FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(WORD_SIZE | LOAD_DATA, 1,
+					TMP_REG2, SLJIT_SP, extra_space - sizeof(sljit_sw))));
 
-		PTR_FAIL_IF(push_inst(compiler, ADD | RD(SLJIT_SP) | RN(SLJIT_SP) | SRC2_IMM | extra_space));
+			PTR_FAIL_IF(push_inst(compiler, ADD | RD(SLJIT_SP) | RN(SLJIT_SP) | SRC2_IMM | extra_space));
 
-		if (type & SLJIT_CALL_RETURN) {
-			PTR_FAIL_IF(push_inst(compiler, BX | RM(TMP_REG2)));
-			return jump;
+			if (type & SLJIT_CALL_RETURN) {
+				PTR_FAIL_IF(push_inst(compiler, BX | RM(TMP_REG2)));
+				return jump;
+			}
 		}
+
+		SLJIT_ASSERT(!(type & SLJIT_CALL_RETURN));
+		PTR_FAIL_IF(softfloat_post_call_with_args(compiler, arg_types));
+		return jump;
 	}
+#endif /* __SOFTFP__ */
 
-	SLJIT_ASSERT(!(type & SLJIT_CALL_RETURN));
-	PTR_FAIL_IF(softfloat_post_call_with_args(compiler, arg_types));
-	return jump;
-#else /* !__SOFTFP__ */
 	if (type & SLJIT_CALL_RETURN) {
 		PTR_FAIL_IF(emit_stack_frame_release(compiler, -1));
 		type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
 	}
 
-	PTR_FAIL_IF(hardfloat_call_with_args(compiler, arg_types));
-
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+#ifndef __SOFTFP__
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG)
+		PTR_FAIL_IF(hardfloat_call_with_args(compiler, arg_types));
+#endif /* !__SOFTFP__ */
 
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_jump(compiler, type);
-#endif /* __SOFTFP__ */
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_ijump(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 src, sljit_sw srcw)
 {
 	struct sljit_jump *jump;
 
 	CHECK_ERROR();
@@ -2818,76 +3014,100 @@
 	CHECK(check_sljit_emit_icall(compiler, type, arg_types, src, srcw));
 
 	if (src & SLJIT_MEM) {
 		FAIL_IF(emit_op_mem(compiler, WORD_SIZE | LOAD_DATA, TMP_REG1, src, srcw, TMP_REG1));
 		src = TMP_REG1;
 	}
 
-	if ((type & SLJIT_CALL_RETURN) && (src >= SLJIT_FIRST_SAVED_REG && src <= SLJIT_S0)) {
+	if ((type & SLJIT_CALL_RETURN) && (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options)))) {
 		FAIL_IF(push_inst(compiler, MOV | RD(TMP_REG1) | RM(src)));
 		src = TMP_REG1;
 	}
 
 #ifdef __SOFTFP__
-	FAIL_IF(softfloat_call_with_args(compiler, arg_types, &src, &extra_space));
-	SLJIT_ASSERT((extra_space & 0x7) == 0);
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG) {
+		FAIL_IF(softfloat_call_with_args(compiler, arg_types, &src, &extra_space));
+		SLJIT_ASSERT((extra_space & 0x7) == 0);
 
-	if ((type & SLJIT_CALL_RETURN) && extra_space == 0)
-		type = SLJIT_JUMP;
+		if ((type & SLJIT_CALL_RETURN) && extra_space == 0)
+			type = SLJIT_JUMP;
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+		SLJIT_SKIP_CHECKS(compiler);
+		FAIL_IF(sljit_emit_ijump(compiler, type, src, srcw));
 
-	FAIL_IF(sljit_emit_ijump(compiler, type, src, srcw));
+		if (extra_space > 0) {
+			if (type & SLJIT_CALL_RETURN)
+				FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(WORD_SIZE | LOAD_DATA, 1,
+					TMP_REG2, SLJIT_SP, extra_space - sizeof(sljit_sw))));
 
-	if (extra_space > 0) {
-		if (type & SLJIT_CALL_RETURN)
-			FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(WORD_SIZE | LOAD_DATA, 1,
-				TMP_REG2, SLJIT_SP, extra_space - sizeof(sljit_sw))));
+			FAIL_IF(push_inst(compiler, ADD | RD(SLJIT_SP) | RN(SLJIT_SP) | SRC2_IMM | extra_space));
 
-		FAIL_IF(push_inst(compiler, ADD | RD(SLJIT_SP) | RN(SLJIT_SP) | SRC2_IMM | extra_space));
+			if (type & SLJIT_CALL_RETURN)
+				return push_inst(compiler, BX | RM(TMP_REG2));
+		}
 
-		if (type & SLJIT_CALL_RETURN)
-			return push_inst(compiler, BX | RM(TMP_REG2));
+		SLJIT_ASSERT(!(type & SLJIT_CALL_RETURN));
+		return softfloat_post_call_with_args(compiler, arg_types);
 	}
+#endif /* __SOFTFP__ */
 
-	SLJIT_ASSERT(!(type & SLJIT_CALL_RETURN));
-	return softfloat_post_call_with_args(compiler, arg_types);
-#else /* !__SOFTFP__ */
 	if (type & SLJIT_CALL_RETURN) {
 		FAIL_IF(emit_stack_frame_release(compiler, -1));
 		type = SLJIT_JUMP;
 	}
 
-	FAIL_IF(hardfloat_call_with_args(compiler, arg_types));
-
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+#ifndef __SOFTFP__
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG)
+		FAIL_IF(hardfloat_call_with_args(compiler, arg_types));
+#endif /* !__SOFTFP__ */
 
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_ijump(compiler, type, src, srcw);
-#endif /* __SOFTFP__ */
 }
 
+#ifdef __SOFTFP__
+
+static SLJIT_INLINE sljit_s32 emit_fmov_before_return(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 src, sljit_sw srcw)
+{
+	if (compiler->options & SLJIT_ENTER_REG_ARG) {
+		if (src == SLJIT_FR0)
+			return SLJIT_SUCCESS;
+
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_fop1(compiler, op, SLJIT_RETURN_FREG, 0, src, srcw);
+	}
+
+	if (FAST_IS_REG(src)) {
+		if (op & SLJIT_32)
+			return push_inst(compiler, VMOV | (1 << 20) | RD(SLJIT_R0) | VN(src));
+		return push_inst(compiler, VMOV2 | (1 << 20) | RD(SLJIT_R0) | RN(SLJIT_R1) | VM(src));
+	}
+
+	SLJIT_SKIP_CHECKS(compiler);
+
+	if (op & SLJIT_32)
+		return sljit_emit_op1(compiler, SLJIT_MOV, SLJIT_R0, 0, src, srcw);
+	return sljit_emit_mem(compiler, SLJIT_MOV, SLJIT_REG_PAIR(SLJIT_R0, SLJIT_R1), src, srcw);
+}
+
+#endif /* __SOFTFP__ */
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_flags(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 type)
 {
 	sljit_s32 dst_reg, flags = GET_ALL_FLAGS(op);
 	sljit_uw cc, ins;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_flags(compiler, op, dst, dstw, type));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 
 	op = GET_OPCODE(op);
-	cc = get_cc(compiler, type & 0xff);
+	cc = get_cc(compiler, type);
 	dst_reg = FAST_IS_REG(dst) ? dst : TMP_REG1;
 
 	if (op < SLJIT_ADD) {
 		FAIL_IF(push_inst(compiler, MOV | RD(dst_reg) | SRC2_IMM | 0));
 		FAIL_IF(push_inst(compiler, ((MOV | RD(dst_reg) | SRC2_IMM | 1) & ~COND_MASK) | cc));
 		if (dst & SLJIT_MEM)
 			return emit_op_mem(compiler, WORD_SIZE, TMP_REG1, dst, dstw, TMP_REG2);
@@ -2917,17 +3137,15 @@
 	sljit_s32 src, sljit_sw srcw)
 {
 	sljit_uw cc, tmp;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_cmov(compiler, type, dst_reg, src, srcw));
 
-	dst_reg &= ~SLJIT_32;
-
-	cc = get_cc(compiler, type & 0xff);
+	cc = get_cc(compiler, type & ~SLJIT_32);
 
 	if (SLJIT_UNLIKELY(src & SLJIT_IMM)) {
 		tmp = get_imm((sljit_uw)srcw);
 		if (tmp)
 			return push_inst(compiler, ((MOV | RD(dst_reg) | tmp) & ~COND_MASK) | cc);
 
 		tmp = get_imm(~(sljit_uw)srcw);
@@ -2945,24 +3163,293 @@
 		src = TMP_REG1;
 #endif
 	}
 
 	return push_inst(compiler, ((MOV | RD(dst_reg) | RM(src)) & ~COND_MASK) | cc);
 }
 
+static sljit_s32 update_mem_addr(struct sljit_compiler *compiler, sljit_s32 *mem, sljit_sw *memw, sljit_s32 max_offset)
+{
+	sljit_s32 arg = *mem;
+	sljit_sw argw = *memw;
+	sljit_uw imm, tmp;
+#if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
+	sljit_sw mask = max_offset >= 0xf00 ? 0xfff : 0xff;
+	sljit_sw sign = max_offset >= 0xf00 ? 0x1000 : 0x100;
+#else /* !SLJIT_CONFIG_ARM_V5 */
+	sljit_sw mask = 0xfff;
+	sljit_sw sign = 0x1000;
+
+	SLJIT_ASSERT(max_offset >= 0xf00);
+#endif /* SLJIT_CONFIG_ARM_V5 */
+
+	*mem = TMP_REG1;
+
+	if (SLJIT_UNLIKELY(arg & OFFS_REG_MASK)) {
+		*memw = 0;
+		return push_inst(compiler, ADD | RD(TMP_REG1) | RN(arg & REG_MASK) | RM(OFFS_REG(arg)) | ((sljit_uw)(argw & 0x3) << 7));
+	}
+
+	arg &= REG_MASK;
+
+	if (arg) {
+		if (argw <= max_offset && argw >= -mask) {
+			*mem = arg;
+			return SLJIT_SUCCESS;
+		}
+
+		if (argw >= 0) {
+			tmp = (sljit_uw)(argw & (sign | mask));
+			tmp = (sljit_uw)((argw + ((tmp <= (sljit_uw)max_offset || tmp == (sljit_uw)sign) ? 0 : sign)) & ~mask);
+			imm = get_imm(tmp);
+
+			if (imm) {
+				*memw = argw - (sljit_sw)tmp;
+				SLJIT_ASSERT(*memw >= -mask && *memw <= max_offset);
+
+				return push_inst(compiler, ADD | RD(TMP_REG1) | RN(arg) | imm);
+			}
+		} else {
+			tmp = (sljit_uw)(-argw & (sign | mask));
+			tmp = (sljit_uw)((-argw + ((tmp <= (sljit_uw)((sign << 1) - max_offset - 1)) ? 0 : sign)) & ~mask);
+			imm = get_imm(tmp);
+
+			if (imm) {
+				*memw = argw + (sljit_sw)tmp;
+				SLJIT_ASSERT(*memw >= -mask && *memw <= max_offset);
+
+				return push_inst(compiler, SUB | RD(TMP_REG1) | RN(arg) | imm);
+			}
+		}
+	}
+
+	tmp = (sljit_uw)(argw & (sign | mask));
+	tmp = (sljit_uw)((argw + ((tmp <= (sljit_uw)max_offset || tmp == (sljit_uw)sign) ? 0 : sign)) & ~mask);
+	*memw = argw - (sljit_sw)tmp;
+
+	FAIL_IF(load_immediate(compiler, TMP_REG1, tmp));
+
+	if (arg == 0)
+		return SLJIT_SUCCESS;
+
+	return push_inst(compiler, ADD | RD(TMP_REG1) | RN(TMP_REG1) | RM(arg));
+}
+
+#if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
+
+static sljit_s32 sljit_emit_mem_unaligned(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	sljit_s32 flags, steps, tmp_reg;
+	sljit_uw add, shift;
+
+	switch (type & 0xff) {
+	case SLJIT_MOV_U8:
+	case SLJIT_MOV_S8:
+		flags = BYTE_SIZE;
+		if (!(type & SLJIT_MEM_STORE))
+			flags |= LOAD_DATA;
+		if ((type & 0xff) == SLJIT_MOV_S8)
+			flags |= SIGNED;
+
+		return emit_op_mem(compiler, flags, reg, mem, memw, TMP_REG1);
+
+	case SLJIT_MOV_U16:
+		FAIL_IF(update_mem_addr(compiler, &mem, &memw, 0xfff - 1));
+		flags = BYTE_SIZE;
+		steps = 1;
+		break;
+
+	case SLJIT_MOV_S16:
+		FAIL_IF(update_mem_addr(compiler, &mem, &memw, 0xff - 1));
+		flags = BYTE_SIZE | SIGNED;
+		steps = 1;
+		break;
+
+	default:
+		if (type & SLJIT_MEM_UNALIGNED_32) {
+			flags = WORD_SIZE;
+			if (!(type & SLJIT_MEM_STORE))
+				flags |= LOAD_DATA;
+
+			return emit_op_mem(compiler, flags, reg, mem, memw, TMP_REG1);
+		}
+
+		if (!(type & SLJIT_MEM_UNALIGNED_16)) {
+			FAIL_IF(update_mem_addr(compiler, &mem, &memw, 0xfff - 3));
+			flags = BYTE_SIZE;
+			steps = 3;
+			break;
+		}
+
+		FAIL_IF(update_mem_addr(compiler, &mem, &memw, 0xff - 2));
+
+		add = 1;
+		if (memw < 0) {
+			add = 0;
+			memw = -memw;
+		}
+
+		tmp_reg = reg;
+
+		if (type & SLJIT_MEM_STORE) {
+			FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(HALF_SIZE, add, reg, mem, TYPE2_TRANSFER_IMM(memw))));
+			FAIL_IF(push_inst(compiler, MOV | RD(TMP_REG2) | RM(reg) | (16 << 7) | (2 << 4)));
+		} else {
+			if (reg == mem) {
+				SLJIT_ASSERT(reg != TMP_REG1);
+				tmp_reg = TMP_REG1;
+			}
+
+			FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(HALF_SIZE | LOAD_DATA, add, tmp_reg, mem, TYPE2_TRANSFER_IMM(memw))));
+		}
+
+		if (!add) {
+			memw -= 2;
+			if (memw <= 0) {
+				memw = -memw;
+				add = 1;
+			}
+		} else
+			memw += 2;
+
+		if (type & SLJIT_MEM_STORE)
+			return push_inst(compiler, EMIT_DATA_TRANSFER(HALF_SIZE, add, TMP_REG2, mem, TYPE2_TRANSFER_IMM(memw)));
+
+		FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(HALF_SIZE | LOAD_DATA, add, TMP_REG2, mem, TYPE2_TRANSFER_IMM(memw))));
+		return push_inst(compiler, ORR | RD(reg) | RN(tmp_reg) | RM(TMP_REG2) | (16 << 7));
+	}
+
+	SLJIT_ASSERT(steps > 0);
+
+	add = 1;
+	if (memw < 0) {
+		add = 0;
+		memw = -memw;
+	}
+
+	if (type & SLJIT_MEM_STORE) {
+		FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(BYTE_SIZE, add, reg, mem, memw)));
+		FAIL_IF(push_inst(compiler, MOV | RD(TMP_REG2) | RM(reg) | (8 << 7) | (2 << 4)));
+
+		while (1) {
+			if (!add) {
+				memw -= 1;
+				if (memw == 0)
+					add = 1;
+			} else
+				memw += 1;
+
+			FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(BYTE_SIZE, add, TMP_REG2, mem, memw)));
+
+			if (--steps == 0)
+				return SLJIT_SUCCESS;
+
+			FAIL_IF(push_inst(compiler, MOV | RD(TMP_REG2) | RM(TMP_REG2) | (8 << 7) | (2 << 4)));
+		}
+	}
+
+	tmp_reg = reg;
+
+	if (reg == mem) {
+		SLJIT_ASSERT(reg != TMP_REG1);
+		tmp_reg = TMP_REG1;
+	}
+
+	shift = 8;
+	FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(BYTE_SIZE | LOAD_DATA, add, tmp_reg, mem, memw)));
+
+	do {
+		if (!add) {
+			memw -= 1;
+			if (memw == 0)
+				add = 1;
+		} else
+			memw += 1;
+
+		if (steps > 1) {
+			FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(BYTE_SIZE | LOAD_DATA, add, TMP_REG2, mem, memw)));
+			FAIL_IF(push_inst(compiler, ORR | RD(tmp_reg) | RN(tmp_reg) | RM(TMP_REG2) | (shift << 7)));
+			shift += 8;
+		}
+	} while (--steps != 0);
+
+	flags |= LOAD_DATA;
+
+	if (flags & SIGNED)
+		FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(flags, add, TMP_REG2, mem, TYPE2_TRANSFER_IMM(memw))));
+	else
+		FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(flags, add, TMP_REG2, mem, memw)));
+
+	return push_inst(compiler, ORR | RD(reg) | RN(tmp_reg) | RM(TMP_REG2) | (shift << 7));
+}
+
+#endif /* SLJIT_CONFIG_ARM_V5 */
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 reg,
 	sljit_s32 mem, sljit_sw memw)
 {
 	sljit_s32 flags;
-	sljit_uw is_type1_transfer, inst;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_mem(compiler, type, reg, mem, memw));
 
+	if (!(reg & REG_PAIR_MASK)) {
+#if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
+		ADJUST_LOCAL_OFFSET(mem, memw);
+#endif /* SLJIT_CONFIG_ARM_V5 */
+
+		return sljit_emit_mem_unaligned(compiler, type, reg, mem, memw);
+	}
+
+	ADJUST_LOCAL_OFFSET(mem, memw);
+
+#if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
+	if (type & (SLJIT_MEM_UNALIGNED | SLJIT_MEM_UNALIGNED_16)) {
+		FAIL_IF(update_mem_addr(compiler, &mem, &memw, (type & SLJIT_MEM_UNALIGNED_16) ? 0xfff - 6 : 0xfff - 7));
+
+		if (!(type & SLJIT_MEM_STORE) && REG_PAIR_FIRST(reg) == (mem & REG_MASK)) {
+			FAIL_IF(sljit_emit_mem_unaligned(compiler, type, REG_PAIR_SECOND(reg), SLJIT_MEM1(mem), memw + SSIZE_OF(sw)));
+			return sljit_emit_mem_unaligned(compiler, type, REG_PAIR_FIRST(reg), SLJIT_MEM1(mem), memw);
+		}
+
+		FAIL_IF(sljit_emit_mem_unaligned(compiler, type, REG_PAIR_FIRST(reg), SLJIT_MEM1(mem), memw));
+		return sljit_emit_mem_unaligned(compiler, type, REG_PAIR_SECOND(reg), SLJIT_MEM1(mem), memw + SSIZE_OF(sw));
+	}
+#endif /* SLJIT_CONFIG_ARM_V5 */
+
+	FAIL_IF(update_mem_addr(compiler, &mem, &memw, 0xfff - 4));
+
+	flags = WORD_SIZE;
+
+	if (!(type & SLJIT_MEM_STORE)) {
+		if (REG_PAIR_FIRST(reg) == (mem & REG_MASK)) {
+			FAIL_IF(emit_op_mem(compiler, WORD_SIZE | LOAD_DATA, REG_PAIR_SECOND(reg), SLJIT_MEM1(mem), memw + SSIZE_OF(sw), TMP_REG1));
+			return emit_op_mem(compiler, WORD_SIZE | LOAD_DATA, REG_PAIR_FIRST(reg), SLJIT_MEM1(mem), memw, TMP_REG1);
+		}
+
+		flags = WORD_SIZE | LOAD_DATA;
+	}
+
+	FAIL_IF(emit_op_mem(compiler, flags, REG_PAIR_FIRST(reg), SLJIT_MEM1(mem), memw, TMP_REG1));
+	return emit_op_mem(compiler, flags, REG_PAIR_SECOND(reg), SLJIT_MEM1(mem), memw + SSIZE_OF(sw), TMP_REG1);
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem_update(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	sljit_s32 flags;
+	sljit_uw is_type1_transfer, inst;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_mem_update(compiler, type, reg, mem, memw));
+
 	is_type1_transfer = 1;
 
 	switch (type & 0xff) {
 	case SLJIT_MOV:
 	case SLJIT_MOV_U32:
 	case SLJIT_MOV_S32:
 	case SLJIT_MOV32:
@@ -2995,51 +3482,47 @@
 		flags |= LOAD_DATA;
 
 	SLJIT_ASSERT(is_type1_transfer == !!IS_TYPE1_TRANSFER(flags));
 
 	if (SLJIT_UNLIKELY(mem & OFFS_REG_MASK)) {
 		if (!is_type1_transfer && memw != 0)
 			return SLJIT_ERR_UNSUPPORTED;
-	}
-	else {
+	} else {
 		if (is_type1_transfer) {
 			if (memw > 4095 || memw < -4095)
 				return SLJIT_ERR_UNSUPPORTED;
-		}
-		else {
-			if (memw > 255 || memw < -255)
-				return SLJIT_ERR_UNSUPPORTED;
-		}
+		} else if (memw > 255 || memw < -255)
+			return SLJIT_ERR_UNSUPPORTED;
 	}
 
 	if (type & SLJIT_MEM_SUPP)
 		return SLJIT_SUCCESS;
 
 	if (SLJIT_UNLIKELY(mem & OFFS_REG_MASK)) {
 		memw &= 0x3;
 
 		inst = EMIT_DATA_TRANSFER(flags, 1, reg, mem & REG_MASK, RM(OFFS_REG(mem)) | ((sljit_uw)memw << 7));
 
 		if (is_type1_transfer)
 			inst |= (1 << 25);
 
-		if (type & SLJIT_MEM_PRE)
-			inst |= (1 << 21);
-		else
+		if (type & SLJIT_MEM_POST)
 			inst ^= (1 << 24);
+		else
+			inst |= (1 << 21);
 
 		return push_inst(compiler, inst);
 	}
 
 	inst = EMIT_DATA_TRANSFER(flags, 0, reg, mem & REG_MASK, 0);
 
-	if (type & SLJIT_MEM_PRE)
-		inst |= (1 << 21);
-	else
+	if (type & SLJIT_MEM_POST)
 		inst ^= (1 << 24);
+	else
+		inst |= (1 << 21);
 
 	if (is_type1_transfer) {
 		if (memw >= 0)
 			inst |= (1 << 23);
 		else
 			memw = -memw;
 
@@ -3050,14 +3533,111 @@
 		inst |= (1 << 23);
 	else
 		memw = -memw;
 
 	return push_inst(compiler, inst | TYPE2_TRANSFER_IMM((sljit_uw)memw));
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 freg,
+	sljit_s32 mem, sljit_sw memw)
+{
+#if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
+	sljit_s32 max_offset;
+	sljit_s32 dst;
+#endif /* SLJIT_CONFIG_ARM_V5 */
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_fmem(compiler, type, freg, mem, memw));
+
+	if (type & SLJIT_MEM_UNALIGNED_32)
+		return emit_fop_mem(compiler, ((type ^ SLJIT_32) & SLJIT_32) | ((type & SLJIT_MEM_STORE) ? 0 : FPU_LOAD), freg, mem, memw);
+
+#if (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5)
+	if (type & SLJIT_MEM_STORE) {
+		FAIL_IF(push_inst(compiler, VMOV | (1 << 20) | VN(freg) | RD(TMP_REG2)));
+
+		if (type & SLJIT_32)
+			return sljit_emit_mem_unaligned(compiler, SLJIT_MOV | SLJIT_MEM_STORE | (type & SLJIT_MEM_UNALIGNED_16), TMP_REG2, mem, memw);
+
+		max_offset = 0xfff - 7;
+		if (type & SLJIT_MEM_UNALIGNED_16)
+			max_offset++;
+
+		FAIL_IF(update_mem_addr(compiler, &mem, &memw, max_offset));
+		mem |= SLJIT_MEM;
+
+		FAIL_IF(sljit_emit_mem_unaligned(compiler, SLJIT_MOV | SLJIT_MEM_STORE | (type & SLJIT_MEM_UNALIGNED_16), TMP_REG2, mem, memw));
+
+		FAIL_IF(push_inst(compiler, VMOV | (1 << 20) | VN(freg) | 0x80 | RD(TMP_REG2)));
+		return sljit_emit_mem_unaligned(compiler, SLJIT_MOV | SLJIT_MEM_STORE | (type & SLJIT_MEM_UNALIGNED_16), TMP_REG2, mem, memw + 4);
+	}
+
+	max_offset = (type & SLJIT_32) ? 0xfff - 3 : 0xfff - 7;
+	if (type & SLJIT_MEM_UNALIGNED_16)
+		max_offset++;
+
+	FAIL_IF(update_mem_addr(compiler, &mem, &memw, max_offset));
+
+	dst = TMP_REG1;
+
+	/* Stack offset adjustment is not needed because dst
+	   is not stored on the stack when mem is SLJIT_SP. */
+
+	if (mem == TMP_REG1) {
+		dst = SLJIT_R3;
+
+		if (compiler->scratches >= 4)
+			FAIL_IF(push_inst(compiler, STR | (1 << 21) | RN(SLJIT_SP) | RD(SLJIT_R3) | 8));
+	}
+
+	mem |= SLJIT_MEM;
+
+	FAIL_IF(sljit_emit_mem_unaligned(compiler, SLJIT_MOV | (type & SLJIT_MEM_UNALIGNED_16), dst, mem, memw));
+	FAIL_IF(push_inst(compiler, VMOV | VN(freg) | RD(dst)));
+
+	if (!(type & SLJIT_32)) {
+		FAIL_IF(sljit_emit_mem_unaligned(compiler, SLJIT_MOV | (type & SLJIT_MEM_UNALIGNED_16), dst, mem, memw + 4));
+		FAIL_IF(push_inst(compiler, VMOV | VN(freg) | 0x80 | RD(dst)));
+	}
+
+	if (dst == SLJIT_R3 && compiler->scratches >= 4)
+		FAIL_IF(push_inst(compiler, (LDR ^ (0x1 << 24)) | (0x1 << 23) | RN(SLJIT_SP) | RD(SLJIT_R3) | 8));
+	return SLJIT_SUCCESS;
+#else /* !SLJIT_CONFIG_ARM_V5 */
+	if (type & SLJIT_MEM_STORE) {
+		FAIL_IF(push_inst(compiler, VMOV | (1 << 20) | VN(freg) | RD(TMP_REG2)));
+
+		if (type & SLJIT_32)
+			return emit_op_mem(compiler, WORD_SIZE, TMP_REG2, mem, memw, TMP_REG1);
+
+		FAIL_IF(update_mem_addr(compiler, &mem, &memw, 0xfff - 4));
+		mem |= SLJIT_MEM;
+
+		FAIL_IF(emit_op_mem(compiler, WORD_SIZE, TMP_REG2, mem, memw, TMP_REG1));
+		FAIL_IF(push_inst(compiler, VMOV | (1 << 20) | VN(freg) | 0x80 | RD(TMP_REG2)));
+		return emit_op_mem(compiler, WORD_SIZE, TMP_REG2, mem, memw + 4, TMP_REG1);
+	}
+
+	if (type & SLJIT_32) {
+		FAIL_IF(emit_op_mem(compiler, WORD_SIZE | LOAD_DATA, TMP_REG2, mem, memw, TMP_REG1));
+		return push_inst(compiler, VMOV | VN(freg) | RD(TMP_REG2));
+	}
+
+	FAIL_IF(update_mem_addr(compiler, &mem, &memw, 0xfff - 4));
+	mem |= SLJIT_MEM;
+
+	FAIL_IF(emit_op_mem(compiler, WORD_SIZE | LOAD_DATA, TMP_REG2, mem, memw, TMP_REG1));
+	FAIL_IF(emit_op_mem(compiler, WORD_SIZE | LOAD_DATA, TMP_REG1, mem, memw + 4, TMP_REG1));
+	return push_inst(compiler, VMOV2 | VM(freg) | RD(TMP_REG2) | RN(TMP_REG1));
+#endif /* SLJIT_CONFIG_ARM_V5 */
+}
+
+#undef FPU_LOAD
+
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_const* sljit_emit_const(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw init_value)
 {
 	struct sljit_const *const_;
 	sljit_s32 dst_r;
 
 	CHECK_ERROR_PTR();
 	CHECK_PTR(check_sljit_emit_const(compiler, dst, dstw, init_value));
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeARM_64.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeARM_64.c`

 * *Files 3% similar despite different names*

```diff
@@ -82,41 +82,45 @@
 #define BRK 0xd4200000
 #define CBZ 0xb4000000
 #define CLZ 0xdac01000
 #define CSEL 0x9a800000
 #define CSINC 0x9a800400
 #define EOR 0xca000000
 #define EORI 0xd2000000
+#define EXTR 0x93c00000
 #define FABS 0x1e60c000
 #define FADD 0x1e602800
 #define FCMP 0x1e602000
 #define FCVT 0x1e224000
 #define FCVTZS 0x9e780000
 #define FDIV 0x1e601800
 #define FMOV 0x1e604000
 #define FMUL 0x1e600800
 #define FNEG 0x1e614000
 #define FSUB 0x1e603800
 #define LDRI 0xf9400000
 #define LDRI_F64 0xfd400000
+#define LDRI_POST 0xf8400400
 #define LDP 0xa9400000
 #define LDP_F64 0x6d400000
 #define LDP_POST 0xa8c00000
 #define LDR_PRE 0xf8400c00
 #define LSLV 0x9ac02000
 #define LSRV 0x9ac02400
 #define MADD 0x9b000000
 #define MOVK 0xf2800000
 #define MOVN 0x92800000
 #define MOVZ 0xd2800000
 #define NOP 0xd503201f
 #define ORN 0xaa200000
 #define ORR 0xaa000000
 #define ORRI 0xb2000000
+#define RBIT 0xdac00000
 #define RET 0xd65f0000
+#define RORV 0x9ac02c00
 #define SBC 0xda000000
 #define SBFM 0x93000000
 #define SCVTF 0x9e620000
 #define SDIV 0x9ac00c00
 #define SMADDL 0x9b200000
 #define SMULH 0x9b403c00
 #define STP 0xa9000000
@@ -133,16 +137,14 @@
 #define SUB 0xcb000000
 #define SUBI 0xd1000000
 #define SUBS 0xeb000000
 #define UBFM 0xd3000000
 #define UDIV 0x9ac00800
 #define UMULH 0x9bc03c00
 
-/* dest_reg is the absolute name of the register
-   Useful for reordering instructions in the delay slot. */
 static sljit_s32 push_inst(struct sljit_compiler *compiler, sljit_ins ins)
 {
 	sljit_ins *ptr = (sljit_ins*)ensure_buf(compiler, sizeof(sljit_ins));
 	FAIL_IF(!ptr);
 	*ptr = ins;
 	compiler->size++;
 	return SLJIT_SUCCESS;
@@ -292,16 +294,16 @@
 					SLJIT_ASSERT(put_label->label);
 					put_label->addr = (sljit_uw)(code_ptr - 3);
 					code_ptr -= put_label_get_length(put_label, (sljit_uw)(SLJIT_ADD_EXEC_OFFSET(code, executable_offset) + put_label->label->size));
 					put_label = put_label->next;
 				}
 				next_addr = compute_next_addr(label, jump, const_, put_label);
 			}
-			code_ptr ++;
-			word_count ++;
+			code_ptr++;
+			word_count++;
 		} while (buf_ptr < buf_end);
 
 		buf = buf->next;
 	} while (buf);
 
 	if (label && label->size == word_count) {
 		label->addr = (sljit_uw)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
@@ -387,14 +389,16 @@
 		return SLJIT_IS_FPU_AVAILABLE;
 #else
 		/* Available by default. */
 		return 1;
 #endif
 
 	case SLJIT_HAS_CLZ:
+	case SLJIT_HAS_CTZ:
+	case SLJIT_HAS_ROT:
 	case SLJIT_HAS_CMOV:
 	case SLJIT_HAS_PREFETCH:
 		return 1;
 
 	default:
 		return 0;
 	}
@@ -627,14 +631,15 @@
 	if (flags & (ARG1_IMM | ARG2_IMM)) {
 		reg = (sljit_s32)((flags & ARG2_IMM) ? arg1 : arg2);
 		imm = (flags & ARG2_IMM) ? arg2 : arg1;
 
 		switch (op) {
 		case SLJIT_MUL:
 		case SLJIT_CLZ:
+		case SLJIT_CTZ:
 		case SLJIT_ADDC:
 		case SLJIT_SUBC:
 			/* No form with immediate operand (except imm 0, which
 			is represented by a ZERO register). */
 			break;
 		case SLJIT_MOV:
 			SLJIT_ASSERT(!(flags & SET_FLAGS) && (flags & ARG2_IMM) && arg1 == TMP_REG1);
@@ -697,44 +702,58 @@
 			if (op == SLJIT_OR)
 				inst_bits |= ORRI;
 			else
 				inst_bits |= EORI;
 			FAIL_IF(push_inst(compiler, (inst_bits ^ inv_bits) | RD(dst) | RN(reg)));
 			goto set_flags;
 		case SLJIT_SHL:
+		case SLJIT_MSHL:
 			if (flags & ARG1_IMM)
 				break;
+
 			if (flags & INT_OP) {
 				imm &= 0x1f;
-				FAIL_IF(push_inst(compiler, (UBFM ^ inv_bits) | RD(dst) | RN(arg1)
-					| (((sljit_ins)-imm & 0x1f) << 16) | ((31 - (sljit_ins)imm) << 10)));
-			}
-			else {
+				inst_bits = (((sljit_ins)-imm & 0x1f) << 16) | ((31 - (sljit_ins)imm) << 10);
+			} else {
 				imm &= 0x3f;
-				FAIL_IF(push_inst(compiler, (UBFM ^ inv_bits) | RD(dst) | RN(arg1) | (1 << 22)
-					| (((sljit_ins)-imm & 0x3f) << 16) | ((63 - (sljit_ins)imm) << 10)));
+				inst_bits = ((sljit_ins)1 << 22) | (((sljit_ins)-imm & 0x3f) << 16) | ((63 - (sljit_ins)imm) << 10);
 			}
+
+			FAIL_IF(push_inst(compiler, (UBFM ^ inv_bits) | RD(dst) | RN(arg1) | inst_bits));
 			goto set_flags;
 		case SLJIT_LSHR:
+		case SLJIT_MLSHR:
 		case SLJIT_ASHR:
+		case SLJIT_MASHR:
 			if (flags & ARG1_IMM)
 				break;
-			if (op == SLJIT_ASHR)
+
+			if (op >= SLJIT_ASHR)
 				inv_bits |= 1 << 30;
+
 			if (flags & INT_OP) {
 				imm &= 0x1f;
-				FAIL_IF(push_inst(compiler, (UBFM ^ inv_bits) | RD(dst) | RN(arg1)
-					| ((sljit_ins)imm << 16) | (31 << 10)));
-			}
-			else {
+				inst_bits = ((sljit_ins)imm << 16) | (31 << 10);
+			} else {
 				imm &= 0x3f;
-				FAIL_IF(push_inst(compiler, (UBFM ^ inv_bits) | RD(dst) | RN(arg1)
-					| (1 << 22) | ((sljit_ins)imm << 16) | (63 << 10)));
+				inst_bits = ((sljit_ins)1 << 22) | ((sljit_ins)imm << 16) | (63 << 10);
 			}
+
+			FAIL_IF(push_inst(compiler, (UBFM ^ inv_bits) | RD(dst) | RN(arg1) | inst_bits));
 			goto set_flags;
+		case SLJIT_ROTL:
+		case SLJIT_ROTR:
+			if (flags & ARG1_IMM)
+				break;
+
+			if (op == SLJIT_ROTL)
+				imm = -imm;
+
+			imm &= (flags & INT_OP) ? 0x1f : 0x3f;
+			return push_inst(compiler, (EXTR ^ (inv_bits | (inv_bits >> 9))) | RD(dst) | RN(arg1) | RM(arg1) | ((sljit_ins)imm << 10));
 		default:
 			SLJIT_UNREACHABLE();
 			break;
 		}
 
 		if (flags & ARG2_IMM) {
 			if (arg2 == 0)
@@ -792,14 +811,18 @@
 	case SLJIT_NOT:
 		SLJIT_ASSERT(arg1 == TMP_REG1);
 		FAIL_IF(push_inst(compiler, (ORN ^ inv_bits) | RD(dst) | RN(TMP_ZERO) | RM(arg2)));
 		break; /* Set flags. */
 	case SLJIT_CLZ:
 		SLJIT_ASSERT(arg1 == TMP_REG1);
 		return push_inst(compiler, (CLZ ^ inv_bits) | RD(dst) | RN(arg2));
+	case SLJIT_CTZ:
+		SLJIT_ASSERT(arg1 == TMP_REG1);
+		FAIL_IF(push_inst(compiler, (RBIT ^ inv_bits) | RD(dst) | RN(arg2)));
+		return push_inst(compiler, (CLZ ^ inv_bits) | RD(dst) | RN(dst));
 	case SLJIT_ADD:
 		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_ADD;
 		CHECK_FLAGS(1 << 29);
 		return push_inst(compiler, (ADD ^ inv_bits) | RD(dst) | RN(arg1) | RM(arg2));
 	case SLJIT_ADDC:
 		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_ADD;
 		CHECK_FLAGS(1 << 29);
@@ -830,22 +853,31 @@
 	case SLJIT_OR:
 		FAIL_IF(push_inst(compiler, (ORR ^ inv_bits) | RD(dst) | RN(arg1) | RM(arg2)));
 		break; /* Set flags. */
 	case SLJIT_XOR:
 		FAIL_IF(push_inst(compiler, (EOR ^ inv_bits) | RD(dst) | RN(arg1) | RM(arg2)));
 		break; /* Set flags. */
 	case SLJIT_SHL:
+	case SLJIT_MSHL:
 		FAIL_IF(push_inst(compiler, (LSLV ^ inv_bits) | RD(dst) | RN(arg1) | RM(arg2)));
 		break; /* Set flags. */
 	case SLJIT_LSHR:
+	case SLJIT_MLSHR:
 		FAIL_IF(push_inst(compiler, (LSRV ^ inv_bits) | RD(dst) | RN(arg1) | RM(arg2)));
 		break; /* Set flags. */
 	case SLJIT_ASHR:
+	case SLJIT_MASHR:
 		FAIL_IF(push_inst(compiler, (ASRV ^ inv_bits) | RD(dst) | RN(arg1) | RM(arg2)));
 		break; /* Set flags. */
+	case SLJIT_ROTL:
+		FAIL_IF(push_inst(compiler, (SUB ^ inv_bits) | RD(TMP_REG2) | RN(TMP_ZERO) | RM(arg2)));
+		arg2 = TMP_REG2;
+		/* fallthrough */
+	case SLJIT_ROTR:
+		return push_inst(compiler, (RORV ^ inv_bits) | RD(dst) | RN(arg1) | RM(arg2));
 	default:
 		SLJIT_UNREACHABLE();
 		return SLJIT_SUCCESS;
 	}
 
 set_flags:
 	if (flags & SET_FLAGS)
@@ -891,51 +923,67 @@
 		FAIL_IF(load_immediate(compiler, tmp_reg, argw & ~(0xfff << shift)));
 
 		argw = (argw >> shift) & 0xfff;
 
 		return push_inst(compiler, STRBI | type | RT(reg) | RN(tmp_reg) | ((sljit_ins)argw << 10));
 	}
 
-	if (argw >= 0 && (argw & ((1 << shift) - 1)) == 0) {
-		if ((argw >> shift) <= 0xfff)
-			return push_inst(compiler, STRBI | type | RT(reg) | RN(arg) | ((sljit_ins)argw << (10 - shift)));
+	if ((argw & ((1 << shift) - 1)) == 0) {
+		if (argw >= 0) {
+			if ((argw >> shift) <= 0xfff)
+				return push_inst(compiler, STRBI | type | RT(reg) | RN(arg) | ((sljit_ins)argw << (10 - shift)));
 
-		if (argw <= 0xffffff) {
-			FAIL_IF(push_inst(compiler, ADDI | (1 << 22) | RD(tmp_reg) | RN(arg) | (((sljit_ins)argw >> 12) << 10)));
+			if (argw <= 0xffffff) {
+				FAIL_IF(push_inst(compiler, ADDI | (1 << 22) | RD(tmp_reg) | RN(arg) | (((sljit_ins)argw >> 12) << 10)));
 
-			argw = ((argw & 0xfff) >> shift);
+				argw = ((argw & 0xfff) >> shift);
+				return push_inst(compiler, STRBI | type | RT(reg) | RN(tmp_reg) | ((sljit_ins)argw << 10));
+			}
+		} else if (argw < -256 && argw >= -0xfff000) {
+			FAIL_IF(push_inst(compiler, SUBI | (1 << 22) | RD(tmp_reg) | RN(arg) | (((sljit_ins)(-argw + 0xfff) >> 12) << 10)));
+			argw = ((0x1000 + argw) & 0xfff) >> shift;
 			return push_inst(compiler, STRBI | type | RT(reg) | RN(tmp_reg) | ((sljit_ins)argw << 10));
 		}
 	}
 
-	if (argw <= 255 && argw >= -256)
+	if (argw <= 0xff && argw >= -0x100)
 		return push_inst(compiler, STURBI | type | RT(reg) | RN(arg) | (((sljit_ins)argw & 0x1ff) << 12));
 
+	if (argw >= 0) {
+		if (argw <= 0xfff0ff && ((argw + 0x100) & 0xfff) <= 0x1ff) {
+			FAIL_IF(push_inst(compiler, ADDI | (1 << 22) | RD(tmp_reg) | RN(arg) | (((sljit_ins)argw >> 12) << 10)));
+			return push_inst(compiler, STURBI | type | RT(reg) | RN(tmp_reg) | (((sljit_ins)argw & 0x1ff) << 12));
+		}
+	} else if (argw >= -0xfff100 && ((-argw + 0xff) & 0xfff) <= 0x1ff) {
+		FAIL_IF(push_inst(compiler, SUBI | (1 << 22) | RD(tmp_reg) | RN(arg) | (((sljit_ins)-argw >> 12) << 10)));
+		return push_inst(compiler, STURBI | type | RT(reg) | RN(tmp_reg) | (((sljit_ins)argw & 0x1ff) << 12));
+	}
+
 	FAIL_IF(load_immediate(compiler, tmp_reg, argw));
 
 	return push_inst(compiler, STRB | type | RT(reg) | RN(arg) | RM(tmp_reg));
 }
 
 /* --------------------------------------------------------------------- */
 /*  Entry, exit                                                          */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_enter(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
 	sljit_s32 prev, fprev, saved_regs_size, i, tmp;
-	sljit_s32 word_arg_count = 0;
+	sljit_s32 saved_arg_count = SLJIT_KEPT_SAVEDS_COUNT(options);
 	sljit_ins offs;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
-	saved_regs_size = GET_SAVED_REGISTERS_SIZE(scratches, saveds, 2);
+	saved_regs_size = GET_SAVED_REGISTERS_SIZE(scratches, saveds - saved_arg_count, 2);
 	saved_regs_size += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, SSIZE_OF(f64));
 
 	local_size = (local_size + saved_regs_size + 0xf) & ~0xf;
 	compiler->local_size = local_size;
 
 	if (local_size <= 512) {
 		FAIL_IF(push_inst(compiler, STP_PRE | RT(TMP_FP) | RT2(TMP_LR)
@@ -950,15 +998,15 @@
 		local_size -= saved_regs_size;
 		SLJIT_ASSERT(local_size > 0);
 	}
 
 	prev = -1;
 
 	tmp = SLJIT_S0 - saveds;
-	for (i = SLJIT_S0; i > tmp; i--) {
+	for (i = SLJIT_S0 - saved_arg_count; i > tmp; i--) {
 		if (prev == -1) {
 			prev = i;
 			continue;
 		}
 		FAIL_IF(push_inst(compiler, STP | RT(prev) | RT2(i) | RN(SLJIT_SP) | offs));
 		offs -= (sljit_ins)2 << 15;
 		prev = -1;
@@ -999,31 +1047,35 @@
 
 	if (fprev != -1)
 		FAIL_IF(push_inst(compiler, STRI_F64 | VT(fprev) | RN(SLJIT_SP) | (offs >> 5) | (1 << 10)));
 
 	if (prev != -1)
 		FAIL_IF(push_inst(compiler, STRI | RT(prev) | RN(SLJIT_SP) | (offs >> 5) | ((fprev == -1) ? (1 << 10) : 0)));
 
-	arg_types >>= SLJIT_ARG_SHIFT;
 
 #ifdef _WIN32
 	if (local_size > 4096)
 		FAIL_IF(push_inst(compiler, SUBI | RD(SLJIT_SP) | RN(SLJIT_SP) | (1 << 10) | (1 << 22)));
 #endif /* _WIN32 */
 
-	tmp = 0;
-	while (arg_types > 0) {
-		if ((arg_types & SLJIT_ARG_MASK) < SLJIT_ARG_TYPE_F64) {
-			if (!(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG)) {
-				FAIL_IF(push_inst(compiler, ORR | RD(SLJIT_S0 - tmp) | RN(TMP_ZERO) | RM(SLJIT_R0 + word_arg_count)));
+	if (!(options & SLJIT_ENTER_REG_ARG)) {
+		arg_types >>= SLJIT_ARG_SHIFT;
+		saved_arg_count = 0;
+		tmp = SLJIT_R0;
+
+		while (arg_types) {
+			if ((arg_types & SLJIT_ARG_MASK) < SLJIT_ARG_TYPE_F64) {
+				if (!(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG)) {
+					FAIL_IF(push_inst(compiler, ORR | RD(SLJIT_S0 - saved_arg_count) | RN(TMP_ZERO) | RM(tmp)));
+					saved_arg_count++;
+				}
 				tmp++;
 			}
-			word_arg_count++;
+			arg_types >>= SLJIT_ARG_SHIFT;
 		}
-		arg_types >>= SLJIT_ARG_SHIFT;
 	}
 
 #ifdef _WIN32
 	if (local_size > 4096) {
 		if (local_size < 4 * 4096) {
 			/* No need for a loop. */
 
@@ -1096,34 +1148,42 @@
 {
 	sljit_s32 saved_regs_size;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
-	saved_regs_size = GET_SAVED_REGISTERS_SIZE(scratches, saveds, 2);
+	saved_regs_size = GET_SAVED_REGISTERS_SIZE(scratches, saveds - SLJIT_KEPT_SAVEDS_COUNT(options), 2);
 	saved_regs_size += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, SSIZE_OF(f64));
 
 	compiler->local_size = (local_size + saved_regs_size + 0xf) & ~0xf;
 	return SLJIT_SUCCESS;
 }
 
-static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler)
+static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler, sljit_s32 is_return_to)
 {
 	sljit_s32 local_size, prev, fprev, i, tmp;
 	sljit_ins offs;
 
 	local_size = compiler->local_size;
 
-	if (local_size > 512 && local_size <= 512 + 496) {
-		FAIL_IF(push_inst(compiler, LDP_POST | RT(TMP_FP) | RT2(TMP_LR)
-			| RN(SLJIT_SP) | ((sljit_ins)(local_size - 512) << (15 - 3))));
-		local_size = 512;
-	} else
-		FAIL_IF(push_inst(compiler, LDP | RT(TMP_FP) | RT2(TMP_LR) | RN(SLJIT_SP)));
+	if (!is_return_to) {
+		if (local_size > 512 && local_size <= 512 + 496) {
+			FAIL_IF(push_inst(compiler, LDP_POST | RT(TMP_FP) | RT2(TMP_LR)
+				| RN(SLJIT_SP) | ((sljit_ins)(local_size - 512) << (15 - 3))));
+			local_size = 512;
+		} else
+			FAIL_IF(push_inst(compiler, LDP | RT(TMP_FP) | RT2(TMP_LR) | RN(SLJIT_SP)));
+	} else {
+		if (local_size > 512 && local_size <= 512 + 248) {
+			FAIL_IF(push_inst(compiler, LDRI_POST | RT(TMP_FP) | RN(SLJIT_SP) | ((sljit_ins)(local_size - 512) << 12)));
+			local_size = 512;
+		} else
+			FAIL_IF(push_inst(compiler, LDRI | RT(TMP_FP) | RN(SLJIT_SP) | 0));
+	}
 
 	if (local_size > 512) {
 		local_size -= 512;
 		if (local_size > 0xfff) {
 			FAIL_IF(push_inst(compiler, ADDI | RD(SLJIT_SP) | RN(SLJIT_SP)
 				| (((sljit_ins)local_size >> 12) << 10) | (1 << 22)));
 			local_size &= 0xfff;
@@ -1133,15 +1193,15 @@
 		local_size = 512;
 	}
 
 	offs = (sljit_ins)(local_size - 2 * SSIZE_OF(sw)) << (15 - 3);
 	prev = -1;
 
 	tmp = SLJIT_S0 - compiler->saveds;
-	for (i = SLJIT_S0; i > tmp; i--) {
+	for (i = SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options); i > tmp; i--) {
 		if (prev == -1) {
 			prev = i;
 			continue;
 		}
 		FAIL_IF(push_inst(compiler, LDP | RT(prev) | RT2(i) | RN(SLJIT_SP) | offs));
 		offs -= (sljit_ins)2 << 15;
 		prev = -1;
@@ -1191,19 +1251,42 @@
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_void(struct sljit_compiler *compiler)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_return_void(compiler));
 
-	FAIL_IF(emit_stack_frame_release(compiler));
+	FAIL_IF(emit_stack_frame_release(compiler, 0));
 
 	return push_inst(compiler, RET | RN(TMP_LR));
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_to(struct sljit_compiler *compiler,
+	sljit_s32 src, sljit_sw srcw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_return_to(compiler, src, srcw));
+
+	if (src & SLJIT_MEM) {
+		ADJUST_LOCAL_OFFSET(src, srcw);
+		FAIL_IF(emit_op_mem(compiler, WORD_SIZE, TMP_REG1, src, srcw, TMP_REG1));
+		src = TMP_REG1;
+		srcw = 0;
+	} else if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
+		FAIL_IF(push_inst(compiler, ORR | RD(TMP_REG1) | RN(TMP_ZERO) | RM(src)));
+		src = TMP_REG1;
+		srcw = 0;
+	}
+
+	FAIL_IF(emit_stack_frame_release(compiler, 1));
+
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_ijump(compiler, SLJIT_JUMP, src, srcw);
+}
+
 /* --------------------------------------------------------------------- */
 /*  Operators                                                            */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op0(struct sljit_compiler *compiler, sljit_s32 op)
 {
 	sljit_ins inv_bits = (op & SLJIT_32) ? W_OP : 0;
@@ -1388,21 +1471,92 @@
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2u(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op2(compiler, op, 1, 0, 0, src1, src1w, src2, src2w));
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_op2(compiler, op, TMP_REG1, 0, src1, src1w, src2, src2w);
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_shift_into(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 src_dst,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+	sljit_ins inv_bits, imm;
+	sljit_s32 is_left;
+	sljit_sw mask;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_shift_into(compiler, op, src_dst, src1, src1w, src2, src2w));
+
+	is_left = (GET_OPCODE(op) == SLJIT_SHL || GET_OPCODE(op) == SLJIT_MSHL);
+
+	if (src_dst == src1) {
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_op2(compiler, (is_left ? SLJIT_ROTL : SLJIT_ROTR) | (op & SLJIT_32), src_dst, 0, src_dst, 0, src2, src2w);
+	}
+
+	ADJUST_LOCAL_OFFSET(src1, src1w);
+	ADJUST_LOCAL_OFFSET(src2, src2w);
+
+	inv_bits = (op & SLJIT_32) ? W_OP : 0;
+	mask = inv_bits ? 0x1f : 0x3f;
+
+	if (src2 & SLJIT_IMM) {
+		src2w &= mask;
+
+		if (src2w == 0)
+			return SLJIT_SUCCESS;
+	} else if (src2 & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, inv_bits ? INT_SIZE : WORD_SIZE, TMP_REG2, src2, src2w, TMP_REG2));
+		src2 = TMP_REG2;
+	}
+
+	if (src1 & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, inv_bits ? INT_SIZE : WORD_SIZE, TMP_REG1, src1, src1w, TMP_REG1));
+		src1 = TMP_REG1;
+	} else if (src1 & SLJIT_IMM) {
+		FAIL_IF(load_immediate(compiler, TMP_REG1, src1w));
+		src1 = TMP_REG1;
+	}
+
+	if (src2 & SLJIT_IMM) {
+		if (is_left)
+			src2w = (src2w ^ mask) + 1;
+
+		return push_inst(compiler, (EXTR ^ (inv_bits | (inv_bits >> 9))) | RD(src_dst)
+			| RN(is_left ? src_dst : src1) | RM(is_left ? src1 : src_dst) | ((sljit_ins)src2w << 10));
+	}
+
+	FAIL_IF(push_inst(compiler, ((is_left ? LSLV : LSRV) ^ inv_bits) | RD(src_dst) | RN(src_dst) | RM(src2)));
+
+	if (!(op & SLJIT_SHIFT_INTO_NON_ZERO)) {
+		/* Shift left/right by 1. */
+		if (is_left)
+			imm = (sljit_ins)(inv_bits ? ((1 << 16) | (31 << 10)) : ((1 << 16) | (63 << 10) | (1 << 22)));
+		else
+			imm = (sljit_ins)(inv_bits ? ((31 << 16) | (30 << 10)) : ((63 << 16) | (62 << 10) | (1 << 22)));
+
+		FAIL_IF(push_inst(compiler, (UBFM ^ inv_bits) | RD(TMP_REG1) | RN(src1) | imm));
+
+		/* Set imm to mask. */
+		imm = (sljit_ins)(inv_bits ? (4 << 10) : ((5 << 10) | (1 << 22)));
+		FAIL_IF(push_inst(compiler, (EORI ^ inv_bits) | RD(TMP_REG2) | RN(src2) | imm));
+
+		src1 = TMP_REG1;
+	} else
+		FAIL_IF(push_inst(compiler, (SUB ^ inv_bits) | RD(TMP_REG2) | RN(TMP_ZERO) | RM(src2)));
+
+	FAIL_IF(push_inst(compiler, ((is_left ? LSRV : LSLV) ^ inv_bits) | RD(TMP_REG1) | RN(src1) | RM(TMP_REG2)));
+	return push_inst(compiler, (ORR ^ inv_bits) | RD(src_dst) | RN(src_dst) | RM(TMP_REG1));
+}
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_src(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src, sljit_sw srcw)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_src(compiler, op, src, srcw));
 	ADJUST_LOCAL_OFFSET(src, srcw);
 
@@ -1546,18 +1700,17 @@
 	if (GET_OPCODE(op) == SLJIT_CONV_F64_FROM_S32)
 		inv_bits |= W_OP;
 
 	if (src & SLJIT_MEM) {
 		emit_op_mem(compiler, ((GET_OPCODE(op) == SLJIT_CONV_F64_FROM_S32) ? INT_SIZE : WORD_SIZE), TMP_REG1, src, srcw, TMP_REG1);
 		src = TMP_REG1;
 	} else if (src & SLJIT_IMM) {
-#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
 		if (GET_OPCODE(op) == SLJIT_CONV_F64_FROM_S32)
 			srcw = (sljit_s32)srcw;
-#endif
+
 		FAIL_IF(load_immediate(compiler, TMP_REG1, srcw));
 		src = TMP_REG1;
 	}
 
 	FAIL_IF(push_inst(compiler, (SCVTF ^ inv_bits) | VD(dst_r) | RN(src)));
 
 	if (dst & SLJIT_MEM)
@@ -1695,75 +1848,91 @@
 /*  Conditional instructions                                             */
 /* --------------------------------------------------------------------- */
 
 static sljit_ins get_cc(struct sljit_compiler *compiler, sljit_s32 type)
 {
 	switch (type) {
 	case SLJIT_EQUAL:
-	case SLJIT_EQUAL_F64:
+	case SLJIT_F_EQUAL:
+	case SLJIT_ORDERED_EQUAL:
+	case SLJIT_UNORDERED_OR_EQUAL: /* Not supported. */
 		return 0x1;
 
 	case SLJIT_NOT_EQUAL:
-	case SLJIT_NOT_EQUAL_F64:
+	case SLJIT_F_NOT_EQUAL:
+	case SLJIT_UNORDERED_OR_NOT_EQUAL:
+	case SLJIT_ORDERED_NOT_EQUAL: /* Not supported. */
 		return 0x0;
 
 	case SLJIT_CARRY:
 		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_ADD)
 			return 0x3;
 		/* fallthrough */
 
 	case SLJIT_LESS:
-	case SLJIT_LESS_F64:
 		return 0x2;
 
 	case SLJIT_NOT_CARRY:
 		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_ADD)
 			return 0x2;
 		/* fallthrough */
 
 	case SLJIT_GREATER_EQUAL:
-	case SLJIT_GREATER_EQUAL_F64:
 		return 0x3;
 
 	case SLJIT_GREATER:
-	case SLJIT_GREATER_F64:
+	case SLJIT_UNORDERED_OR_GREATER:
 		return 0x9;
 
 	case SLJIT_LESS_EQUAL:
-	case SLJIT_LESS_EQUAL_F64:
+	case SLJIT_F_LESS_EQUAL:
+	case SLJIT_ORDERED_LESS_EQUAL:
 		return 0x8;
 
 	case SLJIT_SIG_LESS:
+	case SLJIT_UNORDERED_OR_LESS:
 		return 0xa;
 
 	case SLJIT_SIG_GREATER_EQUAL:
+	case SLJIT_F_GREATER_EQUAL:
+	case SLJIT_ORDERED_GREATER_EQUAL:
 		return 0xb;
 
 	case SLJIT_SIG_GREATER:
+	case SLJIT_F_GREATER:
+	case SLJIT_ORDERED_GREATER:
 		return 0xd;
 
 	case SLJIT_SIG_LESS_EQUAL:
+	case SLJIT_UNORDERED_OR_LESS_EQUAL:
 		return 0xc;
 
 	case SLJIT_OVERFLOW:
 		if (!(compiler->status_flags_state & (SLJIT_CURRENT_FLAGS_ADD | SLJIT_CURRENT_FLAGS_SUB)))
 			return 0x0;
 		/* fallthrough */
 
-	case SLJIT_UNORDERED_F64:
+	case SLJIT_UNORDERED:
 		return 0x7;
 
 	case SLJIT_NOT_OVERFLOW:
 		if (!(compiler->status_flags_state & (SLJIT_CURRENT_FLAGS_ADD | SLJIT_CURRENT_FLAGS_SUB)))
 			return 0x1;
 		/* fallthrough */
 
-	case SLJIT_ORDERED_F64:
+	case SLJIT_ORDERED:
 		return 0x6;
 
+	case SLJIT_F_LESS:
+	case SLJIT_ORDERED_LESS:
+		return 0x5;
+
+	case SLJIT_UNORDERED_OR_GREATER_EQUAL:
+		return 0x4;
+
 	default:
 		SLJIT_UNREACHABLE();
 		return 0xe;
 	}
 }
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_label* sljit_emit_label(struct sljit_compiler *compiler)
@@ -1812,23 +1981,19 @@
 	sljit_s32 arg_types)
 {
 	SLJIT_UNUSED_ARG(arg_types);
 	CHECK_ERROR_PTR();
 	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
 
 	if (type & SLJIT_CALL_RETURN) {
-		PTR_FAIL_IF(emit_stack_frame_release(compiler));
+		PTR_FAIL_IF(emit_stack_frame_release(compiler, 0));
 		type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
 	}
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
-
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_jump(compiler, type);
 }
 
 static SLJIT_INLINE struct sljit_jump* emit_cmp_to0(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 src, sljit_sw srcw)
 {
 	struct sljit_jump *jump;
@@ -1865,18 +2030,18 @@
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_ijump(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 src, sljit_sw srcw)
 {
 	struct sljit_jump *jump;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_ijump(compiler, type, src, srcw));
-	ADJUST_LOCAL_OFFSET(src, srcw);
 
 	if (!(src & SLJIT_IMM)) {
 		if (src & SLJIT_MEM) {
+			ADJUST_LOCAL_OFFSET(src, srcw);
 			FAIL_IF(emit_op_mem(compiler, WORD_SIZE, TMP_REG1, src, srcw, TMP_REG1));
 			src = TMP_REG1;
 		}
 		return push_inst(compiler, ((type >= SLJIT_FAST_CALL) ? BLR : BR) | RN(src));
 	}
 
 	/* These jumps are converted to jump/call instructions when possible. */
@@ -1893,51 +2058,47 @@
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_icall(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 arg_types,
 	sljit_s32 src, sljit_sw srcw)
 {
 	SLJIT_UNUSED_ARG(arg_types);
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_icall(compiler, type, arg_types, src, srcw));
-	ADJUST_LOCAL_OFFSET(src, srcw);
 
 	if (src & SLJIT_MEM) {
+		ADJUST_LOCAL_OFFSET(src, srcw);
 		FAIL_IF(emit_op_mem(compiler, WORD_SIZE, TMP_REG1, src, srcw, TMP_REG1));
 		src = TMP_REG1;
 	}
 
 	if (type & SLJIT_CALL_RETURN) {
-		if (src >= SLJIT_FIRST_SAVED_REG && src <= SLJIT_S0) {
+		if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
 			FAIL_IF(push_inst(compiler, ORR | RD(TMP_REG1) | RN(TMP_ZERO) | RM(src)));
 			src = TMP_REG1;
 		}
 
-		FAIL_IF(emit_stack_frame_release(compiler));
+		FAIL_IF(emit_stack_frame_release(compiler, 0));
 		type = SLJIT_JUMP;
 	}
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
-
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_ijump(compiler, type, src, srcw);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_flags(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 type)
 {
 	sljit_s32 dst_r, src_r, flags, mem_flags;
 	sljit_ins cc;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_flags(compiler, op, dst, dstw, type));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 
-	cc = get_cc(compiler, type & 0xff);
+	cc = get_cc(compiler, type);
 	dst_r = FAST_IS_REG(dst) ? dst : TMP_REG1;
 
 	if (GET_OPCODE(op) < SLJIT_ADD) {
 		FAIL_IF(push_inst(compiler, CSINC | (cc << 12) | RD(dst_r) | RN(TMP_ZERO) | RM(TMP_ZERO)));
 
 		if (dst_r == TMP_REG1) {
 			mem_flags = (GET_OPCODE(op) == SLJIT_MOV ? WORD_SIZE : INT_SIZE) | STORE;
@@ -1970,43 +2131,113 @@
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_cmov(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 dst_reg,
 	sljit_s32 src, sljit_sw srcw)
 {
-	sljit_ins inv_bits = (dst_reg & SLJIT_32) ? W_OP : 0;
+	sljit_ins inv_bits = (type & SLJIT_32) ? W_OP : 0;
 	sljit_ins cc;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_cmov(compiler, type, dst_reg, src, srcw));
 
 	if (SLJIT_UNLIKELY(src & SLJIT_IMM)) {
-		if (dst_reg & SLJIT_32)
+		if (type & SLJIT_32)
 			srcw = (sljit_s32)srcw;
 		FAIL_IF(load_immediate(compiler, TMP_REG1, srcw));
 		src = TMP_REG1;
 		srcw = 0;
 	}
 
-	cc = get_cc(compiler, type & 0xff);
-	dst_reg &= ~SLJIT_32;
+	cc = get_cc(compiler, type & ~SLJIT_32);
 
 	return push_inst(compiler, (CSEL ^ inv_bits) | (cc << 12) | RD(dst_reg) | RN(dst_reg) | RM(src));
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 reg,
 	sljit_s32 mem, sljit_sw memw)
 {
-	sljit_u32 sign = 0, inst;
+	sljit_u32 inst;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_mem(compiler, type, reg, mem, memw));
 
+	if (!(reg & REG_PAIR_MASK))
+		return sljit_emit_mem_unaligned(compiler, type, reg, mem, memw);
+
+	ADJUST_LOCAL_OFFSET(mem, memw);
+
+	if (!(mem & REG_MASK)) {
+		FAIL_IF(load_immediate(compiler, TMP_REG1, memw & ~0x1f8));
+
+		mem = SLJIT_MEM1(TMP_REG1);
+		memw &= 0x1f8;
+	} else if (mem & OFFS_REG_MASK) {
+		FAIL_IF(push_inst(compiler, ADD | RD(TMP_REG1) | RN(mem & REG_MASK) | RM(OFFS_REG(mem)) | ((sljit_ins)(memw & 0x3) << 10)));
+
+		mem = SLJIT_MEM1(TMP_REG1);
+		memw = 0;
+	} else if ((memw & 0x7) != 0 || memw > 0x1f8 || memw < -0x200) {
+		inst = ADDI;
+
+		if (memw < 0) {
+			/* Remains negative for integer min. */
+			memw = -memw;
+			inst = SUBI;
+		} else if ((memw & 0x7) == 0 && memw <= 0x7ff0) {
+			if (!(type & SLJIT_MEM_STORE) && (mem & REG_MASK) == REG_PAIR_FIRST(reg)) {
+				FAIL_IF(push_inst(compiler, LDRI | RD(REG_PAIR_SECOND(reg)) | RN(mem & REG_MASK) | ((sljit_ins)memw << 7)));
+				return push_inst(compiler, LDRI | RD(REG_PAIR_FIRST(reg)) | RN(mem & REG_MASK) | ((sljit_ins)(memw + 0x8) << 7));
+			}
+
+			inst = (type & SLJIT_MEM_STORE) ? STRI : LDRI;
+
+			FAIL_IF(push_inst(compiler, inst | RD(REG_PAIR_FIRST(reg)) | RN(mem & REG_MASK) | ((sljit_ins)memw << 7)));
+			return push_inst(compiler, inst | RD(REG_PAIR_SECOND(reg)) | RN(mem & REG_MASK) | ((sljit_ins)(memw + 0x8) << 7));
+		}
+
+		if ((sljit_uw)memw <= 0xfff) {
+			FAIL_IF(push_inst(compiler, inst | RD(TMP_REG1) | RN(mem & REG_MASK) | ((sljit_ins)memw << 10)));
+			memw = 0;
+		} else if ((sljit_uw)memw <= 0xffffff) {
+			FAIL_IF(push_inst(compiler, inst | (1 << 22) | RD(TMP_REG1) | RN(mem & REG_MASK) | (((sljit_ins)memw >> 12) << 10)));
+
+			if ((memw & 0xe07) != 0) {
+				FAIL_IF(push_inst(compiler, inst | RD(TMP_REG1) | RN(TMP_REG1) | (((sljit_ins)memw & 0xfff) << 10)));
+				memw = 0;
+			} else {
+				memw &= 0xfff;
+			}
+		} else {
+			FAIL_IF(load_immediate(compiler, TMP_REG1, memw));
+			FAIL_IF(push_inst(compiler, (inst == ADDI ? ADD : SUB) | RD(TMP_REG1) | RN(mem & REG_MASK) | RM(TMP_REG1)));
+			memw = 0;
+		}
+
+		mem = SLJIT_MEM1(TMP_REG1);
+
+		if (inst == SUBI)
+			memw = -memw;
+	}
+
+	SLJIT_ASSERT((memw & 0x7) == 0 && memw <= 0x1f8 && memw >= -0x200);
+	return push_inst(compiler, ((type & SLJIT_MEM_STORE) ? STP : LDP) | RT(REG_PAIR_FIRST(reg)) | RT2(REG_PAIR_SECOND(reg)) | RN(mem & REG_MASK) | (sljit_ins)((memw & 0x3f8) << 12));
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem_update(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	sljit_u32 sign = 0, inst;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_mem_update(compiler, type, reg, mem, memw));
+
 	if ((mem & OFFS_REG_MASK) || (memw > 255 || memw < -256))
 		return SLJIT_ERR_UNSUPPORTED;
 
 	if (type & SLJIT_MEM_SUPP)
 		return SLJIT_SUCCESS;
 
 	switch (type & 0xff) {
@@ -2038,28 +2269,28 @@
 		inst = STURBI | (MEM_SIZE_SHIFT(WORD_SIZE) << 30) | 0x400;
 		break;
 	}
 
 	if (!(type & SLJIT_MEM_STORE))
 		inst |= sign ? 0x00800000 : 0x00400000;
 
-	if (type & SLJIT_MEM_PRE)
+	if (!(type & SLJIT_MEM_POST))
 		inst |= 0x800;
 
 	return push_inst(compiler, inst | RT(reg) | RN(mem & REG_MASK) | (sljit_ins)((memw & 0x1ff) << 12));
 }
 
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem(struct sljit_compiler *compiler, sljit_s32 type,
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem_update(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 freg,
 	sljit_s32 mem, sljit_sw memw)
 {
 	sljit_u32 inst;
 
 	CHECK_ERROR();
-	CHECK(check_sljit_emit_fmem(compiler, type, freg, mem, memw));
+	CHECK(check_sljit_emit_fmem_update(compiler, type, freg, mem, memw));
 
 	if ((mem & OFFS_REG_MASK) || (memw > 255 || memw < -256))
 		return SLJIT_ERR_UNSUPPORTED;
 
 	if (type & SLJIT_MEM_SUPP)
 		return SLJIT_SUCCESS;
 
@@ -2067,15 +2298,15 @@
 
 	if (!(type & SLJIT_32))
 		inst |= 0x40000000;
 
 	if (!(type & SLJIT_MEM_STORE))
 		inst |= 0x00400000;
 
-	if (type & SLJIT_MEM_PRE)
+	if (!(type & SLJIT_MEM_POST))
 		inst |= 0x800;
 
 	return push_inst(compiler, inst | VT(freg) | RN(mem & REG_MASK) | (sljit_ins)((memw & 0x1ff) << 12));
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_local_base(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw offset)
 {
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeARM_T2_32.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeARM_T2_32.c`

 * *Files 11% similar despite different names*

```diff
@@ -96,15 +96,14 @@
 #define ADCI		0xf1400000
 #define ADCS		0x4140
 #define ADC_W		0xeb400000
 #define ADD		0x4400
 #define ADDS		0x1800
 #define ADDSI3		0x1c00
 #define ADDSI8		0x3000
-#define ADD_W		0xeb000000
 #define ADDWI		0xf2000000
 #define ADD_SP		0x4485
 #define ADD_SP_I	0xb000
 #define ADD_W		0xeb000000
 #define ADD_WI		0xf1000000
 #define ANDI		0xf0000000
 #define ANDS		0x4000
@@ -127,14 +126,15 @@
 #define CMP_W		0xebb00f00
 #define EORI		0xf0800000
 #define EORS		0x4040
 #define EOR_W		0xea800000
 #define IT		0xbf00
 #define LDR_SP		0x9800
 #define LDR		0xf8d00000
+#define LDRD		0xe9500000
 #define LDRI		0xf8500800
 #define LSLS		0x4080
 #define LSLSI		0x0000
 #define LSL_W		0xfa00f000
 #define LSL_WI		0xea4f0000
 #define LSRS		0x40c0
 #define LSRSI		0x0800
@@ -156,21 +156,26 @@
 #define ORRI		0xf0400000
 #define ORRS		0x4300
 #define ORR_W		0xea400000
 #define POP		0xbc00
 #define POP_W		0xe8bd0000
 #define PUSH		0xb400
 #define PUSH_W		0xe92d0000
+#define RBIT		0xfa90f0a0
+#define RORS		0x41c0
+#define ROR_W		0xfa60f000
+#define ROR_WI		0xea4f0030
 #define RSB_WI		0xf1c00000
 #define RSBSI		0x4240
 #define SBCI		0xf1600000
 #define SBCS		0x4180
 #define SBC_W		0xeb600000
 #define SDIV		0xfb90f0f0
 #define SMULL		0xfb800000
+#define STRD		0xe9400000
 #define STR_SP		0x9000
 #define SUBS		0x1a00
 #define SUBSI3		0x1e00
 #define SUBSI8		0x3800
 #define SUB_W		0xeba00000
 #define SUBWI		0xf2a00000
 #define SUB_SP_I	0xb080
@@ -430,16 +435,16 @@
 				if (put_label && put_label->addr == half_count) {
 					SLJIT_ASSERT(put_label->label);
 					put_label->addr = (sljit_uw)code_ptr;
 					put_label = put_label->next;
 				}
 				next_addr = compute_next_addr(label, jump, const_, put_label);
 			}
-			code_ptr ++;
-			half_count ++;
+			code_ptr++;
+			half_count++;
 		} while (buf_ptr < buf_end);
 
 		buf = buf->next;
 	} while (buf);
 
 	if (label && label->size == half_count) {
 		label->addr = ((sljit_uw)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset)) | 0x1;
@@ -487,14 +492,16 @@
 		return SLJIT_IS_FPU_AVAILABLE;
 #else
 		/* Available by default. */
 		return 1;
 #endif
 
 	case SLJIT_HAS_CLZ:
+	case SLJIT_HAS_CTZ:
+	case SLJIT_HAS_ROT:
 	case SLJIT_HAS_CMOV:
 	case SLJIT_HAS_PREFETCH:
 		return 1;
 
 	default:
 		return 0;
 	}
@@ -588,68 +595,69 @@
 
 static sljit_s32 emit_op_imm(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 dst, sljit_uw arg1, sljit_uw arg2)
 {
 	/* dst must be register, TMP_REG1
 	   arg1 must be register, imm
 	   arg2 must be register, imm */
 	sljit_s32 reg;
-	sljit_uw imm, nimm;
+	sljit_uw imm, imm2;
 
 	if (SLJIT_UNLIKELY((flags & (ARG1_IMM | ARG2_IMM)) == (ARG1_IMM | ARG2_IMM))) {
 		/* Both are immediates, no temporaries are used. */
 		flags &= ~ARG1_IMM;
 		FAIL_IF(load_immediate(compiler, TMP_REG1, arg1));
 		arg1 = TMP_REG1;
 	}
 
 	if (flags & (ARG1_IMM | ARG2_IMM)) {
 		reg = (sljit_s32)((flags & ARG2_IMM) ? arg1 : arg2);
 		imm = (flags & ARG2_IMM) ? arg2 : arg1;
 
 		switch (flags & 0xffff) {
 		case SLJIT_CLZ:
+		case SLJIT_CTZ:
 		case SLJIT_MUL:
 			/* No form with immediate operand. */
 			break;
 		case SLJIT_MOV:
 			SLJIT_ASSERT(!(flags & SET_FLAGS) && (flags & ARG2_IMM) && arg1 == TMP_REG2);
 			return load_immediate(compiler, dst, imm);
 		case SLJIT_NOT:
 			if (!(flags & SET_FLAGS))
 				return load_immediate(compiler, dst, ~imm);
 			/* Since the flags should be set, we just fallback to the register mode.
 			   Although some clever things could be done here, "NOT IMM" does not worth the efforts. */
 			break;
 		case SLJIT_ADD:
 			compiler->status_flags_state = SLJIT_CURRENT_FLAGS_ADD;
-			nimm = NEGATE(imm);
+			imm2 = NEGATE(imm);
 			if (IS_2_LO_REGS(reg, dst)) {
 				if (imm <= 0x7)
 					return push_inst16(compiler, ADDSI3 | IMM3(imm) | RD3(dst) | RN3(reg));
-				if (nimm <= 0x7)
-					return push_inst16(compiler, SUBSI3 | IMM3(nimm) | RD3(dst) | RN3(reg));
+				if (imm2 <= 0x7)
+					return push_inst16(compiler, SUBSI3 | IMM3(imm2) | RD3(dst) | RN3(reg));
 				if (reg == dst) {
 					if (imm <= 0xff)
 						return push_inst16(compiler, ADDSI8 | IMM8(imm) | RDN3(dst));
-					if (nimm <= 0xff)
-						return push_inst16(compiler, SUBSI8 | IMM8(nimm) | RDN3(dst));
+					if (imm2 <= 0xff)
+						return push_inst16(compiler, SUBSI8 | IMM8(imm2) | RDN3(dst));
 				}
 			}
 			if (!(flags & SET_FLAGS)) {
 				if (imm <= 0xfff)
 					return push_inst32(compiler, ADDWI | RD4(dst) | RN4(reg) | IMM12(imm));
-				if (nimm <= 0xfff)
-					return push_inst32(compiler, SUBWI | RD4(dst) | RN4(reg) | IMM12(nimm));
+				if (imm2 <= 0xfff)
+					return push_inst32(compiler, SUBWI | RD4(dst) | RN4(reg) | IMM12(imm2));
 			}
-			nimm = get_imm(imm);
-			if (nimm != INVALID_IMM)
-				return push_inst32(compiler, ADD_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | nimm);
-			nimm = get_imm(NEGATE(imm));
-			if (nimm != INVALID_IMM)
-				return push_inst32(compiler, SUB_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | nimm);
+			imm2 = get_imm(imm);
+			if (imm2 != INVALID_IMM)
+				return push_inst32(compiler, ADD_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm2);
+			imm = get_imm(NEGATE(imm));
+			if (imm != INVALID_IMM)
+				return push_inst32(compiler, SUB_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm);
 			break;
 		case SLJIT_ADDC:
 			compiler->status_flags_state = SLJIT_CURRENT_FLAGS_ADD;
 			imm = get_imm(imm);
 			if (imm != INVALID_IMM)
 				return push_inst32(compiler, ADCI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm);
 			break;
@@ -662,103 +670,118 @@
 				if (imm != INVALID_IMM)
 					return push_inst32(compiler, RSB_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm);
 				break;
 			}
 			if (flags & UNUSED_RETURN) {
 				if (imm <= 0xff && reg_map[reg] <= 7)
 					return push_inst16(compiler, CMPI | IMM8(imm) | RDN3(reg));
-				nimm = get_imm(imm);
-				if (nimm != INVALID_IMM)
-					return push_inst32(compiler, CMPI_W | RN4(reg) | nimm);
-				nimm = get_imm(NEGATE(imm));
-				if (nimm != INVALID_IMM)
-					return push_inst32(compiler, CMNI_W | RN4(reg) | nimm);
+				imm2 = get_imm(imm);
+				if (imm2 != INVALID_IMM)
+					return push_inst32(compiler, CMPI_W | RN4(reg) | imm2);
+				imm = get_imm(NEGATE(imm));
+				if (imm != INVALID_IMM)
+					return push_inst32(compiler, CMNI_W | RN4(reg) | imm);
 				break;
 			}
-			nimm = NEGATE(imm);
+			imm2 = NEGATE(imm);
 			if (IS_2_LO_REGS(reg, dst)) {
 				if (imm <= 0x7)
 					return push_inst16(compiler, SUBSI3 | IMM3(imm) | RD3(dst) | RN3(reg));
-				if (nimm <= 0x7)
-					return push_inst16(compiler, ADDSI3 | IMM3(nimm) | RD3(dst) | RN3(reg));
+				if (imm2 <= 0x7)
+					return push_inst16(compiler, ADDSI3 | IMM3(imm2) | RD3(dst) | RN3(reg));
 				if (reg == dst) {
 					if (imm <= 0xff)
 						return push_inst16(compiler, SUBSI8 | IMM8(imm) | RDN3(dst));
-					if (nimm <= 0xff)
-						return push_inst16(compiler, ADDSI8 | IMM8(nimm) | RDN3(dst));
+					if (imm2 <= 0xff)
+						return push_inst16(compiler, ADDSI8 | IMM8(imm2) | RDN3(dst));
 				}
 			}
 			if (!(flags & SET_FLAGS)) {
 				if (imm <= 0xfff)
 					return push_inst32(compiler, SUBWI | RD4(dst) | RN4(reg) | IMM12(imm));
-				if (nimm <= 0xfff)
-					return push_inst32(compiler, ADDWI | RD4(dst) | RN4(reg) | IMM12(nimm));
+				if (imm2 <= 0xfff)
+					return push_inst32(compiler, ADDWI | RD4(dst) | RN4(reg) | IMM12(imm2));
 			}
-			nimm = get_imm(imm);
-			if (nimm != INVALID_IMM)
-				return push_inst32(compiler, SUB_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | nimm);
-			nimm = get_imm(NEGATE(imm));
-			if (nimm != INVALID_IMM)
-				return push_inst32(compiler, ADD_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | nimm);
+			imm2 = get_imm(imm);
+			if (imm2 != INVALID_IMM)
+				return push_inst32(compiler, SUB_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm2);
+			imm = get_imm(NEGATE(imm));
+			if (imm != INVALID_IMM)
+				return push_inst32(compiler, ADD_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm);
 			break;
 		case SLJIT_SUBC:
 			compiler->status_flags_state = SLJIT_CURRENT_FLAGS_SUB;
 			if (flags & ARG1_IMM)
 				break;
 			imm = get_imm(imm);
 			if (imm != INVALID_IMM)
 				return push_inst32(compiler, SBCI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm);
 			break;
 		case SLJIT_AND:
-			nimm = get_imm(imm);
-			if (nimm != INVALID_IMM)
-				return push_inst32(compiler, ((flags & UNUSED_RETURN) ? TSTI : ANDI) | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | nimm);
+			imm2 = get_imm(imm);
+			if (imm2 != INVALID_IMM)
+				return push_inst32(compiler, ((flags & UNUSED_RETURN) ? TSTI : ANDI) | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm2);
 			imm = get_imm(~imm);
 			if (imm != INVALID_IMM)
 				return push_inst32(compiler, BICI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm);
 			break;
 		case SLJIT_OR:
-			nimm = get_imm(imm);
-			if (nimm != INVALID_IMM)
-				return push_inst32(compiler, ORRI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | nimm);
+			imm2 = get_imm(imm);
+			if (imm2 != INVALID_IMM)
+				return push_inst32(compiler, ORRI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm2);
 			imm = get_imm(~imm);
 			if (imm != INVALID_IMM)
 				return push_inst32(compiler, ORNI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm);
 			break;
 		case SLJIT_XOR:
 			imm = get_imm(imm);
 			if (imm != INVALID_IMM)
 				return push_inst32(compiler, EORI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | imm);
 			break;
 		case SLJIT_SHL:
+		case SLJIT_MSHL:
 		case SLJIT_LSHR:
+		case SLJIT_MLSHR:
 		case SLJIT_ASHR:
+		case SLJIT_MASHR:
+		case SLJIT_ROTL:
+		case SLJIT_ROTR:
 			if (flags & ARG1_IMM)
 				break;
 			imm &= 0x1f;
+
 			if (imm == 0) {
 				if (!(flags & SET_FLAGS))
 					return push_inst16(compiler, MOV | SET_REGS44(dst, reg));
 				if (IS_2_LO_REGS(dst, reg))
 					return push_inst16(compiler, MOVS | RD3(dst) | RN3(reg));
 				return push_inst32(compiler, MOV_W | SET_FLAGS | RD4(dst) | RM4(reg));
 			}
+
 			switch (flags & 0xffff) {
 			case SLJIT_SHL:
+			case SLJIT_MSHL:
 				if (IS_2_LO_REGS(dst, reg))
 					return push_inst16(compiler, LSLSI | RD3(dst) | RN3(reg) | (imm << 6));
 				return push_inst32(compiler, LSL_WI | (flags & SET_FLAGS) | RD4(dst) | RM4(reg) | IMM5(imm));
 			case SLJIT_LSHR:
+			case SLJIT_MLSHR:
 				if (IS_2_LO_REGS(dst, reg))
 					return push_inst16(compiler, LSRSI | RD3(dst) | RN3(reg) | (imm << 6));
 				return push_inst32(compiler, LSR_WI | (flags & SET_FLAGS) | RD4(dst) | RM4(reg) | IMM5(imm));
-			default: /* SLJIT_ASHR */
+			case SLJIT_ASHR:
+			case SLJIT_MASHR:
 				if (IS_2_LO_REGS(dst, reg))
 					return push_inst16(compiler, ASRSI | RD3(dst) | RN3(reg) | (imm << 6));
 				return push_inst32(compiler, ASR_WI | (flags & SET_FLAGS) | RD4(dst) | RM4(reg) | IMM5(imm));
+			case SLJIT_ROTL:
+				imm = (imm ^ 0x1f) + 1;
+				/* fallthrough */
+			default: /* SLJIT_ROTR */
+				return push_inst32(compiler, ROR_WI | RD4(dst) | RM4(reg) | IMM5(imm));
 			}
 		default:
 			SLJIT_UNREACHABLE();
 			break;
 		}
 
 		if (flags & ARG2_IMM) {
@@ -809,16 +832,19 @@
 	case SLJIT_NOT:
 		SLJIT_ASSERT(arg1 == TMP_REG2);
 		if (IS_2_LO_REGS(dst, arg2))
 			return push_inst16(compiler, MVNS | RD3(dst) | RN3(arg2));
 		return push_inst32(compiler, MVN_W | (flags & SET_FLAGS) | RD4(dst) | RM4(arg2));
 	case SLJIT_CLZ:
 		SLJIT_ASSERT(arg1 == TMP_REG2);
-		FAIL_IF(push_inst32(compiler, CLZ | RN4(arg2) | RD4(dst) | RM4(arg2)));
-		return SLJIT_SUCCESS;
+		return push_inst32(compiler, CLZ | RN4(arg2) | RD4(dst) | RM4(arg2));
+	case SLJIT_CTZ:
+		SLJIT_ASSERT(arg1 == TMP_REG2);
+		FAIL_IF(push_inst32(compiler, RBIT | RN4(arg2) | RD4(dst) | RM4(arg2)));
+		return push_inst32(compiler, CLZ | RN4(dst) | RD4(dst) | RM4(dst));
 	case SLJIT_ADD:
 		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_ADD;
 		if (IS_3_LO_REGS(dst, arg1, arg2))
 			return push_inst16(compiler, ADDS | RD3(dst) | RN3(arg1) | RM3(arg2));
 		if (dst == (sljit_s32)arg1 && !(flags & SET_FLAGS))
 			return push_inst16(compiler, ADD | SET_REGS44(dst, arg2));
 		return push_inst32(compiler, ADD_W | (flags & SET_FLAGS) | RD4(dst) | RN4(arg1) | RM4(arg2));
@@ -860,42 +886,62 @@
 		if (dst == (sljit_s32)arg1 && IS_2_LO_REGS(dst, arg2))
 			return push_inst16(compiler, ORRS | RD3(dst) | RN3(arg2));
 		return push_inst32(compiler, ORR_W | (flags & SET_FLAGS) | RD4(dst) | RN4(arg1) | RM4(arg2));
 	case SLJIT_XOR:
 		if (dst == (sljit_s32)arg1 && IS_2_LO_REGS(dst, arg2))
 			return push_inst16(compiler, EORS | RD3(dst) | RN3(arg2));
 		return push_inst32(compiler, EOR_W | (flags & SET_FLAGS) | RD4(dst) | RN4(arg1) | RM4(arg2));
+	case SLJIT_MSHL:
+		FAIL_IF(push_inst32(compiler, ANDI | RD4(TMP_REG2) | RN4(arg2) | 0x1f));
+		arg2 = TMP_REG2;
+		/* fallthrough */
 	case SLJIT_SHL:
 		if (dst == (sljit_s32)arg1 && IS_2_LO_REGS(dst, arg2))
 			return push_inst16(compiler, LSLS | RD3(dst) | RN3(arg2));
 		return push_inst32(compiler, LSL_W | (flags & SET_FLAGS) | RD4(dst) | RN4(arg1) | RM4(arg2));
+	case SLJIT_MLSHR:
+		FAIL_IF(push_inst32(compiler, ANDI | RD4(TMP_REG2) | RN4(arg2) | 0x1f));
+		arg2 = TMP_REG2;
+		/* fallthrough */
 	case SLJIT_LSHR:
 		if (dst == (sljit_s32)arg1 && IS_2_LO_REGS(dst, arg2))
 			return push_inst16(compiler, LSRS | RD3(dst) | RN3(arg2));
 		return push_inst32(compiler, LSR_W | (flags & SET_FLAGS) | RD4(dst) | RN4(arg1) | RM4(arg2));
+	case SLJIT_MASHR:
+		FAIL_IF(push_inst32(compiler, ANDI | RD4(TMP_REG2) | RN4(arg2) | 0x1f));
+		arg2 = TMP_REG2;
+		/* fallthrough */
 	case SLJIT_ASHR:
 		if (dst == (sljit_s32)arg1 && IS_2_LO_REGS(dst, arg2))
 			return push_inst16(compiler, ASRS | RD3(dst) | RN3(arg2));
 		return push_inst32(compiler, ASR_W | (flags & SET_FLAGS) | RD4(dst) | RN4(arg1) | RM4(arg2));
+	case SLJIT_ROTL:
+		FAIL_IF(push_inst32(compiler, RSB_WI | RD4(TMP_REG2) | RN4(arg2) | 0));
+		arg2 = TMP_REG2;
+		/* fallthrough */
+	case SLJIT_ROTR:
+		if (dst == (sljit_s32)arg1 && IS_2_LO_REGS(dst, arg2))
+			return push_inst16(compiler, RORS | RD3(dst) | RN3(arg2));
+		return push_inst32(compiler, ROR_W | RD4(dst) | RN4(arg1) | RM4(arg2));
 	}
 
 	SLJIT_UNREACHABLE();
 	return SLJIT_SUCCESS;
 }
 
 #define STORE		0x01
 #define SIGNED		0x02
 
 #define WORD_SIZE	0x00
 #define BYTE_SIZE	0x04
 #define HALF_SIZE	0x08
 #define PRELOAD		0x0c
 
-#define IS_WORD_SIZE(flags)		(!(flags & (BYTE_SIZE | HALF_SIZE)))
-#define OFFSET_CHECK(imm, shift)	(!(argw & ~(imm << shift)))
+#define IS_WORD_SIZE(flags)		(!((flags) & (BYTE_SIZE | HALF_SIZE)))
+#define ALIGN_CHECK(argw, imm, shift)	(!((argw) & ~((imm) << (shift))))
 
 /*
   1st letter:
   w = word
   b = byte
   h = half
 
@@ -986,81 +1032,88 @@
 	return SLJIT_ERR_UNSUPPORTED;
 }
 
 static SLJIT_INLINE sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg,
 	sljit_s32 arg, sljit_sw argw, sljit_s32 tmp_reg)
 {
 	sljit_s32 other_r;
-	sljit_uw tmp;
+	sljit_uw imm, tmp;
 
 	SLJIT_ASSERT(arg & SLJIT_MEM);
-	SLJIT_ASSERT((arg & REG_MASK) != tmp_reg);
-	arg &= ~SLJIT_MEM;
+	SLJIT_ASSERT((arg & REG_MASK) != tmp_reg || (arg == SLJIT_MEM1(tmp_reg) && argw >= -0xff && argw <= 0xfff));
 
 	if (SLJIT_UNLIKELY(!(arg & REG_MASK))) {
-		tmp = get_imm((sljit_uw)argw & ~(sljit_uw)0xfff);
-		if (tmp != INVALID_IMM) {
-			FAIL_IF(push_inst32(compiler, MOV_WI | RD4(tmp_reg) | tmp));
+		imm = get_imm((sljit_uw)argw & ~(sljit_uw)0xfff);
+		if (imm != INVALID_IMM) {
+			FAIL_IF(push_inst32(compiler, MOV_WI | RD4(tmp_reg) | imm));
 			return push_inst32(compiler, sljit_mem32[flags] | MEM_IMM12 | RT4(reg) | RN4(tmp_reg) | (argw & 0xfff));
 		}
 
 		FAIL_IF(load_immediate(compiler, tmp_reg, (sljit_uw)argw));
 		if (IS_2_LO_REGS(reg, tmp_reg) && sljit_mem16_imm5[flags])
 			return push_inst16(compiler, sljit_mem16_imm5[flags] | RD3(reg) | RN3(tmp_reg));
 		return push_inst32(compiler, sljit_mem32[flags] | MEM_IMM12 | RT4(reg) | RN4(tmp_reg));
 	}
 
 	if (SLJIT_UNLIKELY(arg & OFFS_REG_MASK)) {
 		argw &= 0x3;
 		other_r = OFFS_REG(arg);
-		arg &= 0xf;
+		arg &= REG_MASK;
 
 		if (!argw && IS_3_LO_REGS(reg, arg, other_r))
 			return push_inst16(compiler, sljit_mem16[flags] | RD3(reg) | RN3(arg) | RM3(other_r));
 		return push_inst32(compiler, sljit_mem32[flags] | RT4(reg) | RN4(arg) | RM4(other_r) | ((sljit_ins)argw << 4));
 	}
 
+	arg &= REG_MASK;
+
 	if (argw > 0xfff) {
-		tmp = get_imm((sljit_uw)argw & ~(sljit_uw)0xfff);
-		if (tmp != INVALID_IMM) {
-			push_inst32(compiler, ADD_WI | RD4(tmp_reg) | RN4(arg) | tmp);
+		imm = get_imm((sljit_uw)(argw & ~0xfff));
+		if (imm != INVALID_IMM) {
+			push_inst32(compiler, ADD_WI | RD4(tmp_reg) | RN4(arg) | imm);
 			arg = tmp_reg;
 			argw = argw & 0xfff;
 		}
 	}
 	else if (argw < -0xff) {
-		tmp = get_imm((sljit_uw)-argw & ~(sljit_uw)0xff);
-		if (tmp != INVALID_IMM) {
-			push_inst32(compiler, SUB_WI | RD4(tmp_reg) | RN4(arg) | tmp);
+		tmp = (sljit_uw)((-argw + 0xfff) & ~0xfff);
+		SLJIT_ASSERT(tmp >= (sljit_uw)-argw);
+		imm = get_imm(tmp);
+
+		if (imm != INVALID_IMM) {
+			push_inst32(compiler, SUB_WI | RD4(tmp_reg) | RN4(arg) | imm);
 			arg = tmp_reg;
-			argw = -(-argw & 0xff);
+			argw += (sljit_sw)tmp;
+
+			SLJIT_ASSERT(argw >= 0 && argw <= 0xfff);
 		}
 	}
 
+	/* 16 bit instruction forms. */
 	if (IS_2_LO_REGS(reg, arg) && sljit_mem16_imm5[flags]) {
 		tmp = 3;
 		if (IS_WORD_SIZE(flags)) {
-			if (OFFSET_CHECK(0x1f, 2))
+			if (ALIGN_CHECK(argw, 0x1f, 2))
 				tmp = 2;
 		}
 		else if (flags & BYTE_SIZE)
 		{
-			if (OFFSET_CHECK(0x1f, 0))
+			if (ALIGN_CHECK(argw, 0x1f, 0))
 				tmp = 0;
 		}
 		else {
 			SLJIT_ASSERT(flags & HALF_SIZE);
-			if (OFFSET_CHECK(0x1f, 1))
+			if (ALIGN_CHECK(argw, 0x1f, 1))
 				tmp = 1;
 		}
 
 		if (tmp < 3)
 			return push_inst16(compiler, sljit_mem16_imm5[flags] | RD3(reg) | RN3(arg) | ((sljit_ins)argw << (6 - tmp)));
 	}
-	else if (SLJIT_UNLIKELY(arg == SLJIT_SP) && IS_WORD_SIZE(flags) && OFFSET_CHECK(0xff, 2) && reg_map[reg] <= 7) {
+	else if (SLJIT_UNLIKELY(arg == SLJIT_SP) && IS_WORD_SIZE(flags) && ALIGN_CHECK(argw, 0xff, 2) && reg_map[reg] <= 7) {
 		/* SP based immediate. */
 		return push_inst16(compiler, STR_SP | (sljit_ins)((flags & STORE) ? 0 : 0x800) | RDN3(reg) | ((sljit_ins)argw >> 2));
 	}
 
 	if (argw >= 0 && argw <= 0xfff)
 		return push_inst32(compiler, sljit_mem32[flags] | MEM_IMM12 | RT4(reg) | RN4(arg) | (sljit_ins)argw);
 	else if (argw < 0 && argw >= -0xff)
@@ -1070,23 +1123,27 @@
 
 	FAIL_IF(load_immediate(compiler, tmp_reg, (sljit_uw)argw));
 	if (IS_3_LO_REGS(reg, arg, tmp_reg))
 		return push_inst16(compiler, sljit_mem16[flags] | RD3(reg) | RN3(arg) | RM3(tmp_reg));
 	return push_inst32(compiler, sljit_mem32[flags] | RT4(reg) | RN4(arg) | RM4(tmp_reg));
 }
 
+#undef ALIGN_CHECK
+#undef IS_WORD_SIZE
+
 /* --------------------------------------------------------------------- */
 /*  Entry, exit                                                          */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_enter(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
-	sljit_s32 size, i, tmp, word_arg_count, saved_arg_count;
+	sljit_s32 size, i, tmp, word_arg_count;
+	sljit_s32 saved_arg_count = SLJIT_KEPT_SAVEDS_COUNT(options);
 	sljit_uw offset;
 	sljit_uw imm = 0;
 #ifdef __SOFTFP__
 	sljit_u32 float_arg_count;
 #else
 	sljit_u32 old_offset, f32_offset;
 	sljit_u32 remap[3];
@@ -1094,27 +1151,27 @@
 #endif
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
 	tmp = SLJIT_S0 - saveds;
-	for (i = SLJIT_S0; i > tmp; i--)
+	for (i = SLJIT_S0 - saved_arg_count; i > tmp; i--)
 		imm |= (sljit_uw)1 << reg_map[i];
 
 	for (i = scratches; i >= SLJIT_FIRST_SAVED_REG; i--)
 		imm |= (sljit_uw)1 << reg_map[i];
 
 	/* At least two registers must be set for PUSH_W and one for PUSH instruction. */
 	FAIL_IF((imm & 0xff00)
 		? push_inst32(compiler, PUSH_W | (1 << 14) | imm)
 		: push_inst16(compiler, PUSH | (1 << 8) | imm));
 
 	/* Stack must be aligned to 8 bytes: (LR, R4) */
-	size = GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1);
+	size = GET_SAVED_REGISTERS_SIZE(scratches, saveds - saved_arg_count, 1);
 
 	if (fsaveds > 0 || fscratches >= SLJIT_FIRST_SAVED_FLOAT_REG) {
 		if ((size & SSIZE_OF(sw)) != 0) {
 			FAIL_IF(push_inst16(compiler, SUB_SP_I | (sizeof(sljit_sw) >> 2)));
 			size += SSIZE_OF(sw);
 		}
 
@@ -1127,14 +1184,17 @@
 				FAIL_IF(push_inst32(compiler, VPUSH | DD4(fscratches) | ((sljit_uw)(fscratches - (SLJIT_FIRST_SAVED_FLOAT_REG - 1)) << 1)));
 		}
 	}
 
 	local_size = ((size + local_size + 0x7) & ~0x7) - size;
 	compiler->local_size = local_size;
 
+	if (options & SLJIT_ENTER_REG_ARG)
+		arg_types = 0;
+
 	arg_types >>= SLJIT_ARG_SHIFT;
 	word_arg_count = 0;
 	saved_arg_count = 0;
 #ifdef __SOFTFP__
 	SLJIT_COMPILE_ASSERT(SLJIT_FR0 == 1, float_register_index_start);
 
 	offset = 0;
@@ -1169,21 +1229,22 @@
 				tmp = SLJIT_S0 - saved_arg_count;
 				saved_arg_count++;
 			} else if (word_arg_count - 1 != (sljit_s32)(offset >> 2))
 				tmp = word_arg_count;
 			else
 				break;
 
-			SLJIT_ASSERT(reg_map[tmp] <= 7);
-
 			if (offset < 4 * sizeof(sljit_sw))
-				FAIL_IF(push_inst16(compiler, MOV | RD3(tmp) | (offset << 1)));
-			else
+				FAIL_IF(push_inst16(compiler, MOV | ((sljit_ins)reg_map[tmp] & 0x7) | (((sljit_ins)reg_map[tmp] & 0x8) << 4) | (offset << 1)));
+			else if (reg_map[tmp] <= 7)
 				FAIL_IF(push_inst16(compiler, LDR_SP | RDN3(tmp)
 					| ((offset + (sljit_uw)size - 4 * sizeof(sljit_sw)) >> 2)));
+			else
+				FAIL_IF(push_inst32(compiler, LDR | RT4(tmp) | RN4(SLJIT_SP)
+					| ((offset + (sljit_uw)size - 4 * sizeof(sljit_sw)))));
 			break;
 		}
 
 		offset += sizeof(sljit_sw);
 		arg_types >>= SLJIT_ARG_SHIFT;
 	}
 
@@ -1289,15 +1350,15 @@
 {
 	sljit_s32 size;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
-	size = GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1);
+	size = GET_SAVED_REGISTERS_SIZE(scratches, saveds - SLJIT_KEPT_SAVEDS_COUNT(options), 1);
 
 	if ((size & SSIZE_OF(sw)) != 0 && (fsaveds > 0 || fscratches >= SLJIT_FIRST_SAVED_FLOAT_REG))
 		size += SSIZE_OF(sw);
 
 	compiler->local_size = ((size + local_size + 0x7) & ~0x7) - size;
 	return SLJIT_SUCCESS;
 }
@@ -1321,16 +1382,17 @@
 	FAIL_IF(load_immediate(compiler, TMP_REG2, imm));
 	return push_inst16(compiler, ADD_SP | RN3(TMP_REG2));
 }
 
 static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler, sljit_s32 frame_size)
 {
 	sljit_s32 local_size, fscratches, fsaveds, i, tmp;
+	sljit_s32 restored_reg = 0;
 	sljit_s32 lr_dst = TMP_PC;
-	sljit_uw reg_list;
+	sljit_uw reg_list = 0;
 
 	SLJIT_ASSERT(reg_map[TMP_REG2] == 14 && frame_size <= 128);
 
 	local_size = compiler->local_size;
 	fscratches = compiler->fscratches;
 	fsaveds = compiler->fsaveds;
 
@@ -1349,94 +1411,158 @@
 
 		local_size = GET_SAVED_REGISTERS_SIZE(compiler->scratches, compiler->saveds, 1) & 0x7;
 	}
 
 	if (frame_size < 0) {
 		lr_dst = TMP_REG2;
 		frame_size = 0;
-	} else if (frame_size > 0)
+	} else if (frame_size > 0) {
+		SLJIT_ASSERT(frame_size == 1 || (frame_size & 0x7) == 0);
 		lr_dst = 0;
+		frame_size &= ~0x7;
+	}
 
-	reg_list = 0;
 	tmp = SLJIT_S0 - compiler->saveds;
-	for (i = SLJIT_S0; i > tmp; i--)
-		reg_list |= (sljit_uw)1 << reg_map[i];
+	i = SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options);
+	if (tmp < i) {
+		restored_reg = i;
+		do {
+			reg_list |= (sljit_uw)1 << reg_map[i];
+		} while (--i > tmp);
+	}
 
-	for (i = compiler->scratches; i >= SLJIT_FIRST_SAVED_REG; i--)
-		reg_list |= (sljit_uw)1 << reg_map[i];
+	i = compiler->scratches;
+	if (i >= SLJIT_FIRST_SAVED_REG) {
+		restored_reg = i;
+		do {
+			reg_list |= (sljit_uw)1 << reg_map[i];
+		} while (--i >= SLJIT_FIRST_SAVED_REG);
+	}
+
+	if (lr_dst == TMP_REG2 && reg_list == 0) {
+		reg_list |= (sljit_uw)1 << reg_map[TMP_REG2];
+		restored_reg = TMP_REG2;
+		lr_dst = 0;
+	}
 
 	if (lr_dst == 0 && (reg_list & (reg_list - 1)) == 0) {
 		/* The local_size does not include the saved registers. */
-		local_size += SSIZE_OF(sw);
+		tmp = 0;
+		if (reg_list != 0) {
+			tmp = 2;
+			if (local_size <= 0xfff) {
+				if (local_size == 0) {
+					SLJIT_ASSERT(restored_reg != TMP_REG2);
+					if (frame_size == 0)
+						return push_inst32(compiler, LDRI | RT4(restored_reg) | RN4(SLJIT_SP) | 0x308);
+					if (frame_size > 2 * SSIZE_OF(sw))
+						return push_inst32(compiler, LDRI | RT4(restored_reg) | RN4(SLJIT_SP) | 0x100 | (sljit_ins)(frame_size - (2 * SSIZE_OF(sw))));
+				}
+
+				if (reg_map[restored_reg] <= 7 && local_size <= 0x3fc)
+					FAIL_IF(push_inst16(compiler, STR_SP | 0x800 | RDN3(restored_reg) | (sljit_ins)(local_size >> 2)));
+				else
+					FAIL_IF(push_inst32(compiler, LDR | RT4(restored_reg) | RN4(SLJIT_SP) | (sljit_ins)local_size));
+				tmp = 1;
+			} else if (frame_size == 0) {
+				frame_size = (restored_reg == TMP_REG2) ? SSIZE_OF(sw) : 2 * SSIZE_OF(sw);
+				tmp = 3;
+			}
+
+			/* Place for the saved register. */
+			if (restored_reg != TMP_REG2)
+				local_size += SSIZE_OF(sw);
+		}
 
-		if (reg_list != 0)
-			local_size += SSIZE_OF(sw);
+		/* Place for the lr register. */
+		local_size += SSIZE_OF(sw);
 
 		if (frame_size > local_size)
-			FAIL_IF(push_inst16(compiler, SUB_SP_I | ((sljit_uw)(frame_size - local_size) >> 2)));
+			FAIL_IF(push_inst16(compiler, SUB_SP_I | ((sljit_ins)(frame_size - local_size) >> 2)));
 		else if (frame_size < local_size)
 			FAIL_IF(emit_add_sp(compiler, (sljit_uw)(local_size - frame_size)));
 
-		if (reg_list == 0)
+		if (tmp <= 1)
 			return SLJIT_SUCCESS;
 
-		if (compiler->saveds > 0) {
-			SLJIT_ASSERT(reg_list == ((sljit_uw)1 << reg_map[SLJIT_S0]));
-			lr_dst = SLJIT_S0;
-		} else {
-			SLJIT_ASSERT(reg_list == ((sljit_uw)1 << reg_map[SLJIT_FIRST_SAVED_REG]));
-			lr_dst = SLJIT_FIRST_SAVED_REG;
-		}
+		if (tmp == 2) {
+			frame_size -= SSIZE_OF(sw);
+			if (restored_reg != TMP_REG2)
+				frame_size -= SSIZE_OF(sw);
 
-		frame_size -= 2 * SSIZE_OF(sw);
+			if (reg_map[restored_reg] <= 7)
+				return push_inst16(compiler, STR_SP | 0x800 | RDN3(restored_reg) | (sljit_ins)(frame_size >> 2));
 
-		if (reg_map[lr_dst] <= 7)
-			return push_inst16(compiler, STR_SP | 0x800 | RDN3(lr_dst) | (sljit_uw)(frame_size >> 2));
+			return push_inst32(compiler, LDR | RT4(restored_reg) | RN4(SLJIT_SP) | (sljit_ins)frame_size);
+		}
 
-		return push_inst32(compiler, LDR | RT4(lr_dst) | RN4(SLJIT_SP) | (sljit_uw)frame_size);
+		tmp = (restored_reg == TMP_REG2) ? 0x304 : 0x308;
+		return push_inst32(compiler, LDRI | RT4(restored_reg) | RN4(SLJIT_SP) | (sljit_ins)tmp);
 	}
 
 	if (local_size > 0)
 		FAIL_IF(emit_add_sp(compiler, (sljit_uw)local_size));
 
 	if (!(reg_list & 0xff00) && lr_dst != TMP_REG2) {
 		if (lr_dst == TMP_PC)
 			reg_list |= 1u << 8;
 
 		/* At least one register must be set for POP instruction. */
 		SLJIT_ASSERT(reg_list != 0);
 
 		FAIL_IF(push_inst16(compiler, POP | reg_list));
 	} else {
-		if (lr_dst != 0) {
-			if (reg_list == 0)
-				return push_inst32(compiler, 0xf85d0b04 | RT4(lr_dst));
-
+		if (lr_dst != 0)
 			reg_list |= (sljit_uw)1 << reg_map[lr_dst];
-		}
 
 		/* At least two registers must be set for POP_W instruction. */
 		SLJIT_ASSERT((reg_list & (reg_list - 1)) != 0);
 
 		FAIL_IF(push_inst32(compiler, POP_W | reg_list));
 	}
 
 	if (frame_size > 0)
-		return push_inst16(compiler, SUB_SP_I | (((sljit_uw)frame_size - sizeof(sljit_sw)) >> 2));
-	return SLJIT_SUCCESS;
+		return push_inst16(compiler, SUB_SP_I | (((sljit_ins)frame_size - sizeof(sljit_sw)) >> 2));
+
+	if (lr_dst != 0)
+		return SLJIT_SUCCESS;
+
+	return push_inst16(compiler, ADD_SP_I | 1);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_void(struct sljit_compiler *compiler)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_return_void(compiler));
 
 	return emit_stack_frame_release(compiler, 0);
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_to(struct sljit_compiler *compiler,
+	sljit_s32 src, sljit_sw srcw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_return_to(compiler, src, srcw));
+
+	if (src & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, WORD_SIZE, TMP_REG1, src, srcw, TMP_REG1));
+		src = TMP_REG1;
+		srcw = 0;
+	} else if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
+		FAIL_IF(push_inst16(compiler, MOV | SET_REGS44(TMP_REG1, src)));
+		src = TMP_REG1;
+		srcw = 0;
+	}
+
+	FAIL_IF(emit_stack_frame_release(compiler, 1));
+
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_ijump(compiler, SLJIT_JUMP, src, srcw);
+}
+
 /* --------------------------------------------------------------------- */
 /*  Operators                                                            */
 /* --------------------------------------------------------------------- */
 
 #if !(defined __ARM_FEATURE_IDIV) && !(defined __ARM_ARCH_EXT_IDIV__)
 
 #ifdef __cplusplus
@@ -1681,21 +1807,83 @@
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2u(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op2(compiler, op, 1, 0, 0, src1, src1w, src2, src2w));
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_op2(compiler, op, TMP_REG1, 0, src1, src1w, src2, src2w);
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_shift_into(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 src_dst,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+	sljit_s32 is_left;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_shift_into(compiler, op, src_dst, src1, src1w, src2, src2w));
+
+	op = GET_OPCODE(op);
+	is_left = (op == SLJIT_SHL || op == SLJIT_MSHL);
+
+	if (src_dst == src1) {
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_op2(compiler, is_left ? SLJIT_ROTL : SLJIT_ROTR, src_dst, 0, src_dst, 0, src2, src2w);
+	}
+
+	ADJUST_LOCAL_OFFSET(src1, src1w);
+	ADJUST_LOCAL_OFFSET(src2, src2w);
+
+	if (src2 & SLJIT_IMM) {
+		src2w &= 0x1f;
+
+		if (src2w == 0)
+			return SLJIT_SUCCESS;
+	} else if (src2 & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, WORD_SIZE, TMP_REG2, src2, src2w, TMP_REG2));
+		src2 = TMP_REG2;
+	}
+
+	if (src1 & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, WORD_SIZE, TMP_REG1, src1, src1w, TMP_REG1));
+		src1 = TMP_REG1;
+	} else if (src1 & SLJIT_IMM) {
+		FAIL_IF(load_immediate(compiler, TMP_REG1, (sljit_uw)src1w));
+		src1 = TMP_REG1;
+	}
+
+	if (src2 & SLJIT_IMM) {
+		if (reg_map[src_dst] <= 7)
+			FAIL_IF(push_inst16(compiler, (is_left ? LSLSI : LSRSI) | RD3(src_dst) | RN3(src_dst) | ((sljit_ins)src2w << 6)));
+		else
+			FAIL_IF(push_inst32(compiler, (is_left ? LSL_WI : LSR_WI) | RD4(src_dst) | RM4(src_dst) | IMM5(src2w)));
+
+		src2w = (src2w ^ 0x1f) + 1;
+		return push_inst32(compiler, ORR_W | RD4(src_dst) | RN4(src_dst) | RM4(src1) | (is_left ? 0x10 : 0x0) | IMM5(src2w));
+	}
+
+	if (op == SLJIT_MSHL || op == SLJIT_MLSHR) {
+		FAIL_IF(push_inst32(compiler, ANDI | RD4(TMP_REG2) | RN4(src2) | 0x1f));
+		src2 = TMP_REG2;
+	}
+
+	if (IS_2_LO_REGS(src_dst, src2))
+		FAIL_IF(push_inst16(compiler, (is_left ? LSLS : LSRS) | RD3(src_dst) | RN3(src2)));
+	else
+		FAIL_IF(push_inst32(compiler, (is_left ? LSL_W : LSR_W) | RD4(src_dst) | RN4(src_dst) | RM4(src2)));
+
+	FAIL_IF(push_inst32(compiler, (is_left ? LSR_WI : LSL_WI) | RD4(TMP_REG1) | RM4(src1) | (1 << 6)));
+	FAIL_IF(push_inst32(compiler, EORI | RD4(TMP_REG2) | RN4(src2) | 0x1f));
+	FAIL_IF(push_inst32(compiler, (is_left ? LSR_W : LSL_W) | RD4(TMP_REG1) | RN4(TMP_REG1) | RM4(TMP_REG2)));
+	return push_inst32(compiler, ORR_W | RD4(src_dst) | RN4(src_dst) | RM4(TMP_REG1));
+}
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_src(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src, sljit_sw srcw)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_src(compiler, op, src, srcw));
 	ADJUST_LOCAL_OFFSET(src, srcw);
 
@@ -1951,16 +2139,14 @@
 	}
 
 	if (!(dst & SLJIT_MEM))
 		return SLJIT_SUCCESS;
 	return emit_fop_mem(compiler, (op & SLJIT_32), TMP_FREG1, dst, dstw);
 }
 
-#undef FPU_LOAD
-
 /* --------------------------------------------------------------------- */
 /*  Other instructions                                                   */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw)
 {
 	CHECK_ERROR();
@@ -1980,75 +2166,91 @@
 /*  Conditional instructions                                             */
 /* --------------------------------------------------------------------- */
 
 static sljit_uw get_cc(struct sljit_compiler *compiler, sljit_s32 type)
 {
 	switch (type) {
 	case SLJIT_EQUAL:
-	case SLJIT_EQUAL_F64:
+	case SLJIT_F_EQUAL:
+	case SLJIT_ORDERED_EQUAL:
+	case SLJIT_UNORDERED_OR_EQUAL: /* Not supported. */
 		return 0x0;
 
 	case SLJIT_NOT_EQUAL:
-	case SLJIT_NOT_EQUAL_F64:
+	case SLJIT_F_NOT_EQUAL:
+	case SLJIT_UNORDERED_OR_NOT_EQUAL:
+	case SLJIT_ORDERED_NOT_EQUAL: /* Not supported. */
 		return 0x1;
 
 	case SLJIT_CARRY:
 		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_ADD)
 			return 0x2;
 		/* fallthrough */
 
 	case SLJIT_LESS:
-	case SLJIT_LESS_F64:
 		return 0x3;
 
 	case SLJIT_NOT_CARRY:
 		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_ADD)
 			return 0x3;
 		/* fallthrough */
 
 	case SLJIT_GREATER_EQUAL:
-	case SLJIT_GREATER_EQUAL_F64:
 		return 0x2;
 
 	case SLJIT_GREATER:
-	case SLJIT_GREATER_F64:
+	case SLJIT_UNORDERED_OR_GREATER:
 		return 0x8;
 
 	case SLJIT_LESS_EQUAL:
-	case SLJIT_LESS_EQUAL_F64:
+	case SLJIT_F_LESS_EQUAL:
+	case SLJIT_ORDERED_LESS_EQUAL:
 		return 0x9;
 
 	case SLJIT_SIG_LESS:
+	case SLJIT_UNORDERED_OR_LESS:
 		return 0xb;
 
 	case SLJIT_SIG_GREATER_EQUAL:
+	case SLJIT_F_GREATER_EQUAL:
+	case SLJIT_ORDERED_GREATER_EQUAL:
 		return 0xa;
 
 	case SLJIT_SIG_GREATER:
+	case SLJIT_F_GREATER:
+	case SLJIT_ORDERED_GREATER:
 		return 0xc;
 
 	case SLJIT_SIG_LESS_EQUAL:
+	case SLJIT_UNORDERED_OR_LESS_EQUAL:
 		return 0xd;
 
 	case SLJIT_OVERFLOW:
 		if (!(compiler->status_flags_state & (SLJIT_CURRENT_FLAGS_ADD | SLJIT_CURRENT_FLAGS_SUB)))
 			return 0x1;
 		/* fallthrough */
 
-	case SLJIT_UNORDERED_F64:
+	case SLJIT_UNORDERED:
 		return 0x6;
 
 	case SLJIT_NOT_OVERFLOW:
 		if (!(compiler->status_flags_state & (SLJIT_CURRENT_FLAGS_ADD | SLJIT_CURRENT_FLAGS_SUB)))
 			return 0x0;
 		/* fallthrough */
 
-	case SLJIT_ORDERED_F64:
+	case SLJIT_ORDERED:
 		return 0x7;
 
+	case SLJIT_F_LESS:
+	case SLJIT_ORDERED_LESS:
+		return 0x4;
+
+	case SLJIT_UNORDERED_OR_GREATER_EQUAL:
+		return 0x5;
+
 	default: /* SLJIT_JUMP */
 		SLJIT_UNREACHABLE();
 		return 0xe;
 	}
 }
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_label* sljit_emit_label(struct sljit_compiler *compiler)
@@ -2285,60 +2487,57 @@
 	sljit_u32 extra_space = (sljit_u32)type;
 #endif
 
 	CHECK_ERROR_PTR();
 	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
 
 #ifdef __SOFTFP__
-	PTR_FAIL_IF(softfloat_call_with_args(compiler, arg_types, NULL, &extra_space));
-	SLJIT_ASSERT((extra_space & 0x7) == 0);
-
-	if ((type & SLJIT_CALL_RETURN) && extra_space == 0)
-		type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
-
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
-
-	jump = sljit_emit_jump(compiler, type);
-	PTR_FAIL_IF(jump == NULL);
-
-	if (extra_space > 0) {
-		if (type & SLJIT_CALL_RETURN)
-			PTR_FAIL_IF(push_inst32(compiler, LDR | RT4(TMP_REG2)
-				| RN4(SLJIT_SP) | (extra_space - sizeof(sljit_sw))));
-
-		PTR_FAIL_IF(push_inst16(compiler, ADD_SP_I | (extra_space >> 2)));
-
-		if (type & SLJIT_CALL_RETURN) {
-			PTR_FAIL_IF(push_inst16(compiler, BX | RN3(TMP_REG2)));
-			return jump;
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG) {
+		PTR_FAIL_IF(softfloat_call_with_args(compiler, arg_types, NULL, &extra_space));
+		SLJIT_ASSERT((extra_space & 0x7) == 0);
+
+		if ((type & SLJIT_CALL_RETURN) && extra_space == 0)
+			type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
+
+		SLJIT_SKIP_CHECKS(compiler);
+		jump = sljit_emit_jump(compiler, type);
+		PTR_FAIL_IF(jump == NULL);
+
+		if (extra_space > 0) {
+			if (type & SLJIT_CALL_RETURN)
+				PTR_FAIL_IF(push_inst32(compiler, LDR | RT4(TMP_REG2)
+					| RN4(SLJIT_SP) | (extra_space - sizeof(sljit_sw))));
+
+			PTR_FAIL_IF(push_inst16(compiler, ADD_SP_I | (extra_space >> 2)));
+
+			if (type & SLJIT_CALL_RETURN) {
+				PTR_FAIL_IF(push_inst16(compiler, BX | RN3(TMP_REG2)));
+				return jump;
+			}
 		}
+
+		SLJIT_ASSERT(!(type & SLJIT_CALL_RETURN));
+		PTR_FAIL_IF(softfloat_post_call_with_args(compiler, arg_types));
+		return jump;
 	}
+#endif /* __SOFTFP__ */
 
-	SLJIT_ASSERT(!(type & SLJIT_CALL_RETURN));
-	PTR_FAIL_IF(softfloat_post_call_with_args(compiler, arg_types));
-	return jump;
-#else
 	if (type & SLJIT_CALL_RETURN) {
 		/* ldmia sp!, {..., lr} */
 		PTR_FAIL_IF(emit_stack_frame_release(compiler, -1));
 		type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
 	}
 
-	PTR_FAIL_IF(hardfloat_call_with_args(compiler, arg_types));
-
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+#ifndef __SOFTFP__
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG)
+		PTR_FAIL_IF(hardfloat_call_with_args(compiler, arg_types));
+#endif /* !__SOFTFP__ */
 
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_jump(compiler, type);
-#endif
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_ijump(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 src, sljit_sw srcw)
 {
 	struct sljit_jump *jump;
 
 	CHECK_ERROR();
@@ -2381,77 +2580,101 @@
 	CHECK(check_sljit_emit_icall(compiler, type, arg_types, src, srcw));
 
 	if (src & SLJIT_MEM) {
 		FAIL_IF(emit_op_mem(compiler, WORD_SIZE, TMP_REG1, src, srcw, TMP_REG1));
 		src = TMP_REG1;
 	}
 
-	if ((type & SLJIT_CALL_RETURN) && (src >= SLJIT_FIRST_SAVED_REG && src <= SLJIT_S0)) {
+	if ((type & SLJIT_CALL_RETURN) && (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options)))) {
 		FAIL_IF(push_inst16(compiler, MOV | SET_REGS44(TMP_REG1, src)));
 		src = TMP_REG1;
 	}
 
 #ifdef __SOFTFP__
-	FAIL_IF(softfloat_call_with_args(compiler, arg_types, &src, &extra_space));
-	SLJIT_ASSERT((extra_space & 0x7) == 0);
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG) {
+		FAIL_IF(softfloat_call_with_args(compiler, arg_types, &src, &extra_space));
+		SLJIT_ASSERT((extra_space & 0x7) == 0);
 
-	if ((type & SLJIT_CALL_RETURN) && extra_space == 0)
-		type = SLJIT_JUMP;
+		if ((type & SLJIT_CALL_RETURN) && extra_space == 0)
+			type = SLJIT_JUMP;
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+		SLJIT_SKIP_CHECKS(compiler);
+		FAIL_IF(sljit_emit_ijump(compiler, type, src, srcw));
 
-	FAIL_IF(sljit_emit_ijump(compiler, type, src, srcw));
+		if (extra_space > 0) {
+			if (type & SLJIT_CALL_RETURN)
+				FAIL_IF(push_inst32(compiler, LDR | RT4(TMP_REG2)
+					| RN4(SLJIT_SP) | (extra_space - sizeof(sljit_sw))));
 
-	if (extra_space > 0) {
-		if (type & SLJIT_CALL_RETURN)
-			FAIL_IF(push_inst32(compiler, LDR | RT4(TMP_REG2)
-				| RN4(SLJIT_SP) | (extra_space - sizeof(sljit_sw))));
+			FAIL_IF(push_inst16(compiler, ADD_SP_I | (extra_space >> 2)));
 
-		FAIL_IF(push_inst16(compiler, ADD_SP_I | (extra_space >> 2)));
+			if (type & SLJIT_CALL_RETURN)
+				return push_inst16(compiler, BX | RN3(TMP_REG2));
+		}
 
-		if (type & SLJIT_CALL_RETURN)
-			return push_inst16(compiler, BX | RN3(TMP_REG2));
+		SLJIT_ASSERT(!(type & SLJIT_CALL_RETURN));
+		return softfloat_post_call_with_args(compiler, arg_types);
 	}
+#endif /* __SOFTFP__ */
 
-	SLJIT_ASSERT(!(type & SLJIT_CALL_RETURN));
-	return softfloat_post_call_with_args(compiler, arg_types);
-#else /* !__SOFTFP__ */
 	if (type & SLJIT_CALL_RETURN) {
 		/* ldmia sp!, {..., lr} */
 		FAIL_IF(emit_stack_frame_release(compiler, -1));
 		type = SLJIT_JUMP;
 	}
 
-	FAIL_IF(hardfloat_call_with_args(compiler, arg_types));
-
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+#ifndef __SOFTFP__
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG)
+		FAIL_IF(hardfloat_call_with_args(compiler, arg_types));
+#endif /* !__SOFTFP__ */
 
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_ijump(compiler, type, src, srcw);
-#endif /* __SOFTFP__ */
 }
 
+#ifdef __SOFTFP__
+
+static SLJIT_INLINE sljit_s32 emit_fmov_before_return(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 src, sljit_sw srcw)
+{
+	if (compiler->options & SLJIT_ENTER_REG_ARG) {
+		if (src == SLJIT_FR0)
+			return SLJIT_SUCCESS;
+
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_fop1(compiler, op, SLJIT_RETURN_FREG, 0, src, srcw);
+	}
+
+	if (FAST_IS_REG(src)) {
+		if (op & SLJIT_32)
+			return push_inst32(compiler, VMOV | (1 << 20) | DN4(src) | RT4(SLJIT_R0));
+		return push_inst32(compiler, VMOV2 | (1 << 20) | DM4(src) | RT4(SLJIT_R0) | RN4(SLJIT_R1));
+	}
+
+	SLJIT_SKIP_CHECKS(compiler);
+
+	if (op & SLJIT_32)
+		return sljit_emit_op1(compiler, SLJIT_MOV, SLJIT_R0, 0, src, srcw);
+	return sljit_emit_mem(compiler, SLJIT_MOV, SLJIT_REG_PAIR(SLJIT_R0, SLJIT_R1), src, srcw);
+}
+
+#endif /* __SOFTFP__ */
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_flags(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 type)
 {
 	sljit_s32 dst_r, flags = GET_ALL_FLAGS(op);
 	sljit_ins cc;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_flags(compiler, op, dst, dstw, type));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 
 	op = GET_OPCODE(op);
-	cc = get_cc(compiler, type & 0xff);
+	cc = get_cc(compiler, type);
 	dst_r = FAST_IS_REG(dst) ? dst : TMP_REG1;
 
 	if (op < SLJIT_ADD) {
 		FAIL_IF(push_inst16(compiler, IT | (cc << 4) | (((cc & 0x1) ^ 0x1) << 3) | 0x4));
 		if (reg_map[dst_r] > 7) {
 			FAIL_IF(push_inst32(compiler, MOV_WI | RD4(dst_r) | 1));
 			FAIL_IF(push_inst32(compiler, MOV_WI | RD4(dst_r) | 0));
@@ -2493,17 +2716,15 @@
 	sljit_s32 src, sljit_sw srcw)
 {
 	sljit_uw cc, tmp;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_cmov(compiler, type, dst_reg, src, srcw));
 
-	dst_reg &= ~SLJIT_32;
-
-	cc = get_cc(compiler, type & 0xff);
+	cc = get_cc(compiler, type & ~SLJIT_32);
 
 	if (!(src & SLJIT_IMM)) {
 		FAIL_IF(push_inst16(compiler, IT | (cc << 4) | 0x8));
 		return push_inst16(compiler, MOV | SET_REGS44(dst_reg, src));
 	}
 
 	tmp = (sljit_uw) srcw;
@@ -2537,19 +2758,194 @@
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 reg,
 	sljit_s32 mem, sljit_sw memw)
 {
 	sljit_s32 flags;
-	sljit_ins inst;
+	sljit_uw imm, tmp;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_mem(compiler, type, reg, mem, memw));
 
+	if (!(reg & REG_PAIR_MASK))
+		return sljit_emit_mem_unaligned(compiler, type, reg, mem, memw);
+
+	if (type & (SLJIT_MEM_UNALIGNED | SLJIT_MEM_UNALIGNED_16 | SLJIT_MEM_UNALIGNED_32)) {
+		if ((mem & REG_MASK) == 0) {
+			if ((memw & 0xfff) >= (0x1000 - SSIZE_OF(sw))) {
+				imm = get_imm((sljit_uw)((memw + 0x1000) & ~0xfff));
+
+				if (imm != INVALID_IMM)
+					memw = (memw & 0xfff) - 0x1000;
+			} else {
+				imm = get_imm((sljit_uw)(memw & ~0xfff));
+
+				if (imm != INVALID_IMM)
+					memw &= 0xff;
+			}
+
+			if (imm == INVALID_IMM) {
+				FAIL_IF(load_immediate(compiler, TMP_REG1, (sljit_uw)memw));
+				memw = 0;
+			} else
+				FAIL_IF(push_inst32(compiler, MOV_WI | RD4(TMP_REG1) | imm));
+
+			mem = SLJIT_MEM1(TMP_REG1);
+		} else if (mem & OFFS_REG_MASK) {
+			FAIL_IF(push_inst32(compiler, ADD_W | RD4(TMP_REG1) | RN4(mem & REG_MASK) | RM4(OFFS_REG(mem)) | ((sljit_uw)(memw & 0x3) << 6)));
+			memw = 0;
+			mem = SLJIT_MEM1(TMP_REG1);
+		} else if (memw < -0xff) {
+			/* Zero value can be included in the first case. */
+			if ((-memw & 0xfff) <= SSIZE_OF(sw))
+				tmp = (sljit_uw)((-memw + 0x7ff) & ~0x7ff);
+			else
+				tmp = (sljit_uw)((-memw + 0xfff) & ~0xfff);
+
+			SLJIT_ASSERT(tmp >= (sljit_uw)-memw);
+			imm = get_imm(tmp);
+
+			if (imm != INVALID_IMM) {
+				FAIL_IF(push_inst32(compiler, SUB_WI | RD4(TMP_REG1) | RN4(mem & REG_MASK) | imm));
+				memw += (sljit_sw)tmp;
+				SLJIT_ASSERT(memw >= 0 && memw <= 0xfff - SSIZE_OF(sw));
+			} else {
+				FAIL_IF(load_immediate(compiler, TMP_REG1, (sljit_uw)memw));
+				FAIL_IF(push_inst16(compiler, ADD | SET_REGS44(TMP_REG1, mem & REG_MASK)));
+				memw = 0;
+			}
+
+			mem = SLJIT_MEM1(TMP_REG1);
+		} else if (memw >= (0x1000 - SSIZE_OF(sw))) {
+			if ((memw & 0xfff) >= (0x1000 - SSIZE_OF(sw))) {
+				imm = get_imm((sljit_uw)((memw + 0x1000) & ~0xfff));
+
+				if (imm != INVALID_IMM)
+					memw = (memw & 0xfff) - 0x1000;
+			} else {
+				imm = get_imm((sljit_uw)(memw & ~0xfff));
+
+				if (imm != INVALID_IMM)
+					memw &= 0xfff;
+			}
+
+			if (imm != INVALID_IMM) {
+				SLJIT_ASSERT(memw >= -0xff && memw <= 0xfff);
+				FAIL_IF(push_inst32(compiler, ADD_WI | RD4(TMP_REG1) | RN4(mem & REG_MASK) | imm));
+			} else {
+				FAIL_IF(load_immediate(compiler, TMP_REG1, (sljit_uw)memw));
+				FAIL_IF(push_inst16(compiler, ADD | SET_REGS44(TMP_REG1, mem & REG_MASK)));
+				memw = 0;
+			}
+
+			mem = SLJIT_MEM1(TMP_REG1);
+		}
+
+		flags = WORD_SIZE;
+
+		SLJIT_ASSERT(memw <= 0xfff - SSIZE_OF(sw) && memw >= -0xff);
+
+		if (type & SLJIT_MEM_STORE) {
+			flags |= STORE;
+		} else if (REG_PAIR_FIRST(reg) == (mem & REG_MASK)) {
+			FAIL_IF(emit_op_mem(compiler, WORD_SIZE, REG_PAIR_SECOND(reg), mem, memw + SSIZE_OF(sw), TMP_REG2));
+			return emit_op_mem(compiler, WORD_SIZE, REG_PAIR_FIRST(reg), mem, memw, TMP_REG2);
+		}
+
+		FAIL_IF(emit_op_mem(compiler, flags, REG_PAIR_FIRST(reg), mem, memw, TMP_REG2));
+		return emit_op_mem(compiler, flags, REG_PAIR_SECOND(reg), mem, memw + SSIZE_OF(sw), TMP_REG2);
+	}
+
+	flags = 1 << 23;
+
+	if ((mem & REG_MASK) == 0) {
+		tmp = (sljit_uw)(memw & 0x7fc);
+		imm = get_imm((sljit_uw)((memw + (tmp <= 0x400 ? 0 : 0x400)) & ~0x3fc));
+
+		if (imm == INVALID_IMM) {
+			FAIL_IF(load_immediate(compiler, TMP_REG1, (sljit_uw)memw));
+			memw = 0;
+		} else {
+			FAIL_IF(push_inst32(compiler, MOV_WI | RD4(TMP_REG1) | imm));
+			memw = (memw & 0x3fc) >> 2;
+
+			if (tmp > 0x400) {
+				memw = 0x100 - memw;
+				flags = 0;
+			}
+
+			SLJIT_ASSERT(memw >= 0 && memw <= 0xff);
+		}
+
+		mem = SLJIT_MEM1(TMP_REG1);
+	} else if (mem & OFFS_REG_MASK) {
+		FAIL_IF(push_inst32(compiler, ADD_W | RD4(TMP_REG1) | RN4(mem & REG_MASK) | RM4(OFFS_REG(mem)) | ((sljit_uw)(memw & 0x3) << 6)));
+		memw = 0;
+		mem = SLJIT_MEM1(TMP_REG1);
+	} else if (memw < 0) {
+		if ((-memw & ~0x3fc) == 0) {
+			flags = 0;
+			memw = -memw >> 2;
+		} else {
+			tmp = (sljit_uw)(-memw & 0x7fc);
+			imm = get_imm((sljit_uw)((-memw + (tmp <= 0x400 ? 0 : 0x400)) & ~0x3fc));
+
+			if (imm != INVALID_IMM) {
+				FAIL_IF(push_inst32(compiler, SUB_WI | RD4(TMP_REG1) | RN4(mem & REG_MASK) | imm));
+				memw = (-memw & 0x3fc) >> 2;
+
+				if (tmp <= 0x400)
+					flags = 0;
+				else
+					memw = 0x100 - memw;
+			} else {
+				FAIL_IF(load_immediate(compiler, TMP_REG1, (sljit_uw)memw));
+				FAIL_IF(push_inst16(compiler, ADD | SET_REGS44(TMP_REG1, mem & REG_MASK)));
+				memw = 0;
+			}
+
+			mem = SLJIT_MEM1(TMP_REG1);
+		}
+	} else if ((memw & ~0x3fc) != 0) {
+		tmp = (sljit_uw)(memw & 0x7fc);
+		imm = get_imm((sljit_uw)((memw + (tmp <= 0x400 ? 0 : 0x400)) & ~0x3fc));
+
+		if (imm != INVALID_IMM) {
+			FAIL_IF(push_inst32(compiler, ADD_WI | RD4(TMP_REG1) | RN4(mem & REG_MASK) | imm));
+			memw = (memw & 0x3fc) >> 2;
+
+			if (tmp > 0x400) {
+				memw = 0x100 - memw;
+				flags = 0;
+			}
+		} else {
+			FAIL_IF(load_immediate(compiler, TMP_REG1, (sljit_uw)memw));
+			FAIL_IF(push_inst16(compiler, ADD | SET_REGS44(TMP_REG1, mem & REG_MASK)));
+			memw = 0;
+		}
+
+		mem = SLJIT_MEM1(TMP_REG1);
+	} else
+		memw >>= 2;
+
+	SLJIT_ASSERT(memw >= 0 && memw <= 0xff);
+	return push_inst32(compiler, ((type & SLJIT_MEM_STORE) ? STRD : LDRD) | (sljit_ins)flags | RN4(mem & REG_MASK) | RT4(REG_PAIR_FIRST(reg)) | RD4(REG_PAIR_SECOND(reg)) | (sljit_ins)memw);
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem_update(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	sljit_s32 flags;
+	sljit_ins inst;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_mem_update(compiler, type, reg, mem, memw));
+
 	if ((mem & OFFS_REG_MASK) || (memw > 255 || memw < -255))
 		return SLJIT_ERR_UNSUPPORTED;
 
 	if (type & SLJIT_MEM_SUPP)
 		return SLJIT_SUCCESS;
 
 	switch (type & 0xff) {
@@ -2579,25 +2975,125 @@
 	}
 
 	if (type & SLJIT_MEM_STORE)
 		flags |= STORE;
 
 	inst = sljit_mem32[flags] | 0x900;
 
-	if (type & SLJIT_MEM_PRE)
+	if (!(type & SLJIT_MEM_POST))
 		inst |= 0x400;
 
 	if (memw >= 0)
 		inst |= 0x200;
 	else
 		memw = -memw;
 
 	return push_inst32(compiler, inst | RT4(reg) | RN4(mem & REG_MASK) | (sljit_ins)memw);
 }
 
+static sljit_s32 update_mem_addr(struct sljit_compiler *compiler, sljit_s32 *mem, sljit_sw *memw, sljit_s32 max_offset)
+{
+	sljit_s32 arg = *mem;
+	sljit_sw argw = *memw;
+	sljit_uw imm;
+
+	*mem = TMP_REG1;
+
+	if (SLJIT_UNLIKELY(arg & OFFS_REG_MASK)) {
+		*memw = 0;
+		return push_inst32(compiler, ADD_W | RD4(TMP_REG1) | RN4(arg & REG_MASK) | RM4(OFFS_REG(arg)) | ((sljit_uw)(argw & 0x3) << 6));
+	}
+
+	arg &= REG_MASK;
+
+	if (arg) {
+		if (argw <= max_offset && argw >= -0xff) {
+			*mem = arg;
+			return SLJIT_SUCCESS;
+		}
+
+		if (argw < 0) {
+			imm = get_imm((sljit_uw)(-argw & ~0xff));
+
+			if (imm) {
+				*memw = -(-argw & 0xff);
+				return push_inst32(compiler, SUB_WI | RD4(TMP_REG1) | RN4(arg) | imm);
+			}
+		} else if ((argw & 0xfff) <= max_offset) {
+			imm = get_imm((sljit_uw)(argw & ~0xfff));
+
+			if (imm) {
+				*memw = argw & 0xfff;
+				return push_inst32(compiler, ADD_WI | RD4(TMP_REG1) | RN4(arg) | imm);
+			}
+		} else {
+			imm = get_imm((sljit_uw)((argw | 0xfff) + 1));
+
+			if (imm) {
+				*memw = (argw & 0xfff) - 0x1000;
+				return push_inst32(compiler, ADD_WI | RD4(TMP_REG1) | RN4(arg) | imm);
+			}
+		}
+	}
+
+	imm = (sljit_uw)(argw & ~0xfff);
+
+	if ((argw & 0xfff) > max_offset) {
+		imm += 0x1000;
+		*memw = (argw & 0xfff) - 0x1000;
+	} else
+		*memw = argw & 0xfff;
+
+	FAIL_IF(load_immediate(compiler, TMP_REG1, imm));
+
+	if (arg == 0)
+		return SLJIT_SUCCESS;
+
+	return push_inst16(compiler, ADD | SET_REGS44(TMP_REG1, arg));
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 freg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_fmem(compiler, type, freg, mem, memw));
+
+	if (type & SLJIT_MEM_UNALIGNED_32)
+		return emit_fop_mem(compiler, ((type ^ SLJIT_32) & SLJIT_32) | ((type & SLJIT_MEM_STORE) ? 0 : FPU_LOAD), freg, mem, memw);
+
+	if (type & SLJIT_MEM_STORE) {
+		FAIL_IF(push_inst32(compiler, VMOV | (1 << 20) | DN4(freg) | RT4(TMP_REG2)));
+
+		if (type & SLJIT_32)
+			return emit_op_mem(compiler, WORD_SIZE | STORE, TMP_REG2, mem, memw, TMP_REG1);
+
+		FAIL_IF(update_mem_addr(compiler, &mem, &memw, 0xfff - 4));
+		mem |= SLJIT_MEM;
+
+		FAIL_IF(emit_op_mem(compiler, WORD_SIZE | STORE, TMP_REG2, mem, memw, TMP_REG1));
+		FAIL_IF(push_inst32(compiler, VMOV | (1 << 20) | DN4(freg) | 0x80 | RT4(TMP_REG2)));
+		return emit_op_mem(compiler, WORD_SIZE | STORE, TMP_REG2, mem, memw + 4, TMP_REG1);
+	}
+
+	if (type & SLJIT_32) {
+		FAIL_IF(emit_op_mem(compiler, WORD_SIZE, TMP_REG2, mem, memw, TMP_REG1));
+		return push_inst32(compiler, VMOV | DN4(freg) | RT4(TMP_REG2));
+	}
+
+	FAIL_IF(update_mem_addr(compiler, &mem, &memw, 0xfff - 4));
+	mem |= SLJIT_MEM;
+
+	FAIL_IF(emit_op_mem(compiler, WORD_SIZE, TMP_REG2, mem, memw, TMP_REG1));
+	FAIL_IF(emit_op_mem(compiler, WORD_SIZE, TMP_REG1, mem, memw + 4, TMP_REG1));
+	return push_inst32(compiler, VMOV2 | DM4(freg) | RT4(TMP_REG2) | RN4(TMP_REG1));
+}
+
+#undef FPU_LOAD
+
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_const* sljit_emit_const(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw init_value)
 {
 	struct sljit_const *const_;
 	sljit_s32 dst_r;
 
 	CHECK_ERROR_PTR();
 	CHECK_PTR(check_sljit_emit_const(compiler, dst, dstw, init_value));
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeMIPS_common.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativePPC_common.c`

 * *Files 17% similar despite different names*

```diff
@@ -20,492 +20,390 @@
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/* Latest MIPS architecture. */
-
-#ifndef __mips_hard_float
-/* Disable automatic detection, covers both -msoft-float and -mno-float */
-#undef SLJIT_IS_FPU_AVAILABLE
-#define SLJIT_IS_FPU_AVAILABLE 0
-#endif
-
 SLJIT_API_FUNC_ATTRIBUTE const char* sljit_get_platform_name(void)
 {
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-	return "MIPS32-R6" SLJIT_CPUINFO;
-#else /* !SLJIT_CONFIG_MIPS_32 */
-	return "MIPS64-R6" SLJIT_CPUINFO;
-#endif /* SLJIT_CONFIG_MIPS_32 */
-
-#elif (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1)
+	return "PowerPC" SLJIT_CPUINFO;
+}
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-	return "MIPS32-R1" SLJIT_CPUINFO;
-#else /* !SLJIT_CONFIG_MIPS_32 */
-	return "MIPS64-R1" SLJIT_CPUINFO;
-#endif /* SLJIT_CONFIG_MIPS_32 */
+/* Length of an instruction word.
+   Both for ppc-32 and ppc-64. */
+typedef sljit_u32 sljit_ins;
 
-#else /* SLJIT_MIPS_REV < 1 */
-	return "MIPS III" SLJIT_CPUINFO;
-#endif /* SLJIT_MIPS_REV >= 6 */
+#if ((defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) && (defined _AIX)) \
+	|| (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#define SLJIT_PPC_STACK_FRAME_V2 1
+#endif
+
+#ifdef _AIX
+#include <sys/cache.h>
+#endif
+
+#if (defined _CALL_ELF && _CALL_ELF == 2)
+#define SLJIT_PASS_ENTRY_ADDR_TO_CALL 1
+#endif
+
+#if (defined SLJIT_CACHE_FLUSH_OWN_IMPL && SLJIT_CACHE_FLUSH_OWN_IMPL)
+
+static void ppc_cache_flush(sljit_ins *from, sljit_ins *to)
+{
+#ifdef _AIX
+	_sync_cache_range((caddr_t)from, (int)((size_t)to - (size_t)from));
+#elif defined(__GNUC__) || (defined(__IBM_GCC_ASM) && __IBM_GCC_ASM)
+#	if defined(_ARCH_PWR) || defined(_ARCH_PWR2)
+	/* Cache flush for POWER architecture. */
+	while (from < to) {
+		__asm__ volatile (
+			"clf 0, %0\n"
+			"dcs\n"
+			: : "r"(from)
+		);
+		from++;
+	}
+	__asm__ volatile ( "ics" );
+#	elif defined(_ARCH_COM) && !defined(_ARCH_PPC)
+#	error "Cache flush is not implemented for PowerPC/POWER common mode."
+#	else
+	/* Cache flush for PowerPC architecture. */
+	while (from < to) {
+		__asm__ volatile (
+			"dcbf 0, %0\n"
+			"sync\n"
+			"icbi 0, %0\n"
+			: : "r"(from)
+		);
+		from++;
+	}
+	__asm__ volatile ( "isync" );
+#	endif
+#	ifdef __xlc__
+#	warning "This file may fail to compile if -qfuncsect is used"
+#	endif
+#elif defined(__xlc__)
+#error "Please enable GCC syntax for inline assembly statements with -qasm=gcc"
+#else
+#error "This platform requires a cache flush implementation."
+#endif /* _AIX */
 }
 
-/* Length of an instruction word
-   Both for mips-32 and mips-64 */
-typedef sljit_u32 sljit_ins;
+#endif /* (defined SLJIT_CACHE_FLUSH_OWN_IMPL && SLJIT_CACHE_FLUSH_OWN_IMPL) */
 
 #define TMP_REG1	(SLJIT_NUMBER_OF_REGISTERS + 2)
 #define TMP_REG2	(SLJIT_NUMBER_OF_REGISTERS + 3)
-#define TMP_REG3	(SLJIT_NUMBER_OF_REGISTERS + 4)
+#define TMP_ZERO	(SLJIT_NUMBER_OF_REGISTERS + 4)
 
-/* For position independent code, t9 must contain the function address. */
-#define PIC_ADDR_REG	TMP_REG2
-
-/* Floating point status register. */
-#define FCSR_REG	31
-/* Return address register. */
-#define RETURN_ADDR_REG	31
-
-/* Flags are kept in volatile registers. */
-#define EQUAL_FLAG	3
-#define OTHER_FLAG	1
+#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL)
+#define TMP_CALL_REG	(SLJIT_NUMBER_OF_REGISTERS + 5)
+#else
+#define TMP_CALL_REG	TMP_REG2
+#endif
 
 #define TMP_FREG1	(SLJIT_NUMBER_OF_FLOAT_REGISTERS + 1)
 #define TMP_FREG2	(SLJIT_NUMBER_OF_FLOAT_REGISTERS + 2)
-#define TMP_FREG3	(SLJIT_NUMBER_OF_FLOAT_REGISTERS + 3)
 
-static const sljit_u8 reg_map[SLJIT_NUMBER_OF_REGISTERS + 5] = {
-	0, 2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 24, 23, 22, 21, 20, 19, 18, 17, 16, 29, 4, 25, 31
+static const sljit_u8 reg_map[SLJIT_NUMBER_OF_REGISTERS + 7] = {
+	0, 3, 4, 5, 6, 7, 8, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 1, 9, 10, 31, 12
 };
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-
-static const sljit_u8 freg_map[SLJIT_NUMBER_OF_FLOAT_REGISTERS + 4] = {
-	0, 0, 14, 2, 4, 6, 8, 18, 30, 28, 26, 24, 22, 20, 12, 10, 16
+static const sljit_u8 freg_map[SLJIT_NUMBER_OF_FLOAT_REGISTERS + 3] = {
+	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 0, 13
 };
 
-#else
-
-static const sljit_u8 freg_map[SLJIT_NUMBER_OF_FLOAT_REGISTERS + 4] = {
-	0, 0, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 1, 2, 3, 4, 5, 6, 7, 8, 9, 31, 30, 29, 28, 27, 26, 25, 24, 12, 11, 10
-};
-
-#endif
-
 /* --------------------------------------------------------------------- */
 /*  Instrucion forms                                                     */
 /* --------------------------------------------------------------------- */
-
+#define D(d)		((sljit_ins)reg_map[d] << 21)
 #define S(s)		((sljit_ins)reg_map[s] << 21)
-#define T(t)		((sljit_ins)reg_map[t] << 16)
-#define D(d)		((sljit_ins)reg_map[d] << 11)
-#define FT(t)		((sljit_ins)freg_map[t] << 16)
-#define FS(s)		((sljit_ins)freg_map[s] << 11)
-#define FD(d)		((sljit_ins)freg_map[d] << 6)
-/* Absolute registers. */
-#define SA(s)		((sljit_ins)(s) << 21)
-#define TA(t)		((sljit_ins)(t) << 16)
-#define DA(d)		((sljit_ins)(d) << 11)
+#define A(a)		((sljit_ins)reg_map[a] << 16)
+#define B(b)		((sljit_ins)reg_map[b] << 11)
+#define C(c)		((sljit_ins)reg_map[c] << 6)
+#define FD(fd)		((sljit_ins)freg_map[fd] << 21)
+#define FS(fs)		((sljit_ins)freg_map[fs] << 21)
+#define FA(fa)		((sljit_ins)freg_map[fa] << 16)
+#define FB(fb)		((sljit_ins)freg_map[fb] << 11)
+#define FC(fc)		((sljit_ins)freg_map[fc] << 6)
 #define IMM(imm)	((sljit_ins)(imm) & 0xffff)
-#define SH_IMM(imm)	((sljit_ins)(imm) << 6)
+#define CRD(d)		((sljit_ins)(d) << 21)
 
-#define DR(dr)		(reg_map[dr])
-#define FR(dr)		(freg_map[dr])
+/* Instruction bit sections.
+   OE and Rc flag (see ALT_SET_FLAGS). */
+#define OE(flags)	((flags) & ALT_SET_FLAGS)
+/* Rc flag (see ALT_SET_FLAGS). */
+#define RC(flags)	(((flags) & ALT_SET_FLAGS) >> 10)
 #define HI(opcode)	((sljit_ins)(opcode) << 26)
-#define LO(opcode)	((sljit_ins)(opcode))
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-/* CMP.cond.fmt */
-/* S = (20 << 21) D = (21 << 21) */
-#define CMP_FMT_S	(20 << 21)
-#endif /* SLJIT_MIPS_REV >= 6 */
-/* S = (16 << 21) D = (17 << 21) */
-#define FMT_S		(16 << 21)
-#define FMT_D		(17 << 21)
-
-#define ABS_S		(HI(17) | FMT_S | LO(5))
-#define ADD_S		(HI(17) | FMT_S | LO(0))
-#define ADDIU		(HI(9))
-#define ADDU		(HI(0) | LO(33))
-#define AND		(HI(0) | LO(36))
-#define ANDI		(HI(12))
-#define B		(HI(4))
-#define BAL		(HI(1) | (17 << 16))
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-#define BC1EQZ		(HI(17) | (9 << 21) | FT(TMP_FREG3))
-#define BC1NEZ		(HI(17) | (13 << 21) | FT(TMP_FREG3))
-#else /* SLJIT_MIPS_REV < 6 */
-#define BC1F		(HI(17) | (8 << 21))
-#define BC1T		(HI(17) | (8 << 21) | (1 << 16))
-#endif /* SLJIT_MIPS_REV >= 6 */
-#define BEQ		(HI(4))
-#define BGEZ		(HI(1) | (1 << 16))
-#define BGTZ		(HI(7))
-#define BLEZ		(HI(6))
-#define BLTZ		(HI(1) | (0 << 16))
-#define BNE		(HI(5))
-#define BREAK		(HI(0) | LO(13))
-#define CFC1		(HI(17) | (2 << 21))
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-#define C_UEQ_S		(HI(17) | CMP_FMT_S | LO(3))
-#define C_ULE_S		(HI(17) | CMP_FMT_S | LO(7))
-#define C_ULT_S		(HI(17) | CMP_FMT_S | LO(5))
-#define C_UN_S		(HI(17) | CMP_FMT_S | LO(1))
-#define C_FD		(FD(TMP_FREG3))
-#else /* SLJIT_MIPS_REV < 6 */
-#define C_UEQ_S		(HI(17) | FMT_S | LO(51))
-#define C_ULE_S		(HI(17) | FMT_S | LO(55))
-#define C_ULT_S		(HI(17) | FMT_S | LO(53))
-#define C_UN_S		(HI(17) | FMT_S | LO(49))
-#define C_FD		(0)
-#endif /* SLJIT_MIPS_REV >= 6 */
-#define CVT_S_S		(HI(17) | FMT_S | LO(32))
-#define DADDIU		(HI(25))
-#define DADDU		(HI(0) | LO(45))
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-#define DDIV		(HI(0) | (2 << 6) | LO(30))
-#define DDIVU		(HI(0) | (2 << 6) | LO(31))
-#define DMOD		(HI(0) | (3 << 6) | LO(30))
-#define DMODU		(HI(0) | (3 << 6) | LO(31))
-#define DIV		(HI(0) | (2 << 6) | LO(26))
-#define DIVU		(HI(0) | (2 << 6) | LO(27))
-#define DMUH		(HI(0) | (3 << 6) | LO(28))
-#define DMUHU		(HI(0) | (3 << 6) | LO(29))
-#define DMUL		(HI(0) | (2 << 6) | LO(28))
-#define DMULU		(HI(0) | (2 << 6) | LO(29))
-#else /* SLJIT_MIPS_REV < 6 */
-#define DDIV		(HI(0) | LO(30))
-#define DDIVU		(HI(0) | LO(31))
-#define DIV		(HI(0) | LO(26))
-#define DIVU		(HI(0) | LO(27))
-#define DMULT		(HI(0) | LO(28))
-#define DMULTU		(HI(0) | LO(29))
-#endif /* SLJIT_MIPS_REV >= 6 */
-#define DIV_S		(HI(17) | FMT_S | LO(3))
-#define DINSU		(HI(31) | LO(6))
-#define DSLL		(HI(0) | LO(56))
-#define DSLL32		(HI(0) | LO(60))
-#define DSLLV		(HI(0) | LO(20))
-#define DSRA		(HI(0) | LO(59))
-#define DSRA32		(HI(0) | LO(63))
-#define DSRAV		(HI(0) | LO(23))
-#define DSRL		(HI(0) | LO(58))
-#define DSRL32		(HI(0) | LO(62))
-#define DSRLV		(HI(0) | LO(22))
-#define DSUBU		(HI(0) | LO(47))
-#define J		(HI(2))
-#define JAL		(HI(3))
-#define JALR		(HI(0) | LO(9))
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-#define JR		(HI(0) | LO(9))
-#else /* SLJIT_MIPS_REV < 6 */
-#define JR		(HI(0) | LO(8))
-#endif /* SLJIT_MIPS_REV >= 6 */
-#define LD		(HI(55))
-#define LDC1		(HI(53))
-#define LUI		(HI(15))
-#define LW		(HI(35))
-#define LWC1		(HI(49))
-#define MFC1		(HI(17))
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-#define MOD		(HI(0) | (3 << 6) | LO(26))
-#define MODU		(HI(0) | (3 << 6) | LO(27))
-#else /* SLJIT_MIPS_REV < 6 */
-#define MFHI		(HI(0) | LO(16))
-#define MFLO		(HI(0) | LO(18))
-#endif /* SLJIT_MIPS_REV >= 6 */
-#define MOV_S		(HI(17) | FMT_S | LO(6))
-#define MTC1		(HI(17) | (4 << 21))
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-#define MUH		(HI(0) | (3 << 6) | LO(24))
-#define MUHU		(HI(0) | (3 << 6) | LO(25))
-#define MUL		(HI(0) | (2 << 6) | LO(24))
-#define MULU		(HI(0) | (2 << 6) | LO(25))
-#else /* SLJIT_MIPS_REV < 6 */
-#define MULT		(HI(0) | LO(24))
-#define MULTU		(HI(0) | LO(25))
-#endif /* SLJIT_MIPS_REV >= 6 */
-#define MUL_S		(HI(17) | FMT_S | LO(2))
-#define NEG_S		(HI(17) | FMT_S | LO(7))
-#define NOP		(HI(0) | LO(0))
-#define NOR		(HI(0) | LO(39))
-#define OR		(HI(0) | LO(37))
-#define ORI		(HI(13))
-#define SD		(HI(63))
-#define SDC1		(HI(61))
-#define SLT		(HI(0) | LO(42))
-#define SLTI		(HI(10))
-#define SLTIU		(HI(11))
-#define SLTU		(HI(0) | LO(43))
-#define SLL		(HI(0) | LO(0))
-#define SLLV		(HI(0) | LO(4))
-#define SRL		(HI(0) | LO(2))
-#define SRLV		(HI(0) | LO(6))
-#define SRA		(HI(0) | LO(3))
-#define SRAV		(HI(0) | LO(7))
-#define SUB_S		(HI(17) | FMT_S | LO(1))
-#define SUBU		(HI(0) | LO(35))
-#define SW		(HI(43))
-#define SWC1		(HI(57))
-#define TRUNC_W_S	(HI(17) | FMT_S | LO(13))
-#define XOR		(HI(0) | LO(38))
-#define XORI		(HI(14))
-
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1)
-#define CLZ		(HI(28) | LO(32))
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-#define DCLZ		(LO(18))
-#else /* SLJIT_MIPS_REV < 6 */
-#define DCLZ		(HI(28) | LO(36))
-#define MOVF		(HI(0) | (0 << 16) | LO(1))
-#define MOVN		(HI(0) | LO(11))
-#define MOVT		(HI(0) | (1 << 16) | LO(1))
-#define MOVZ		(HI(0) | LO(10))
-#define MUL		(HI(28) | LO(2))
-#endif /* SLJIT_MIPS_REV >= 6 */
-#define PREF		(HI(51))
-#define PREFX		(HI(19) | LO(15))
-#define SEB		(HI(31) | (16 << 6) | LO(32))
-#define SEH		(HI(31) | (24 << 6) | LO(32))
-#endif /* SLJIT_MIPS_REV >= 1 */
-
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-#define ADDU_W		ADDU
-#define ADDIU_W		ADDIU
-#define SLL_W		SLL
-#define SUBU_W		SUBU
-#else
-#define ADDU_W		DADDU
-#define ADDIU_W		DADDIU
-#define SLL_W		DSLL
-#define SUBU_W		DSUBU
-#endif
+#define LO(opcode)	((sljit_ins)(opcode) << 1)
+
+#define ADD		(HI(31) | LO(266))
+#define ADDC		(HI(31) | LO(10))
+#define ADDE		(HI(31) | LO(138))
+#define ADDI		(HI(14))
+#define ADDIC		(HI(13))
+#define ADDIS		(HI(15))
+#define ADDME		(HI(31) | LO(234))
+#define AND		(HI(31) | LO(28))
+#define ANDI		(HI(28))
+#define ANDIS		(HI(29))
+#define Bx		(HI(18))
+#define BCx		(HI(16))
+#define BCCTR		(HI(19) | LO(528) | (3 << 11))
+#define BLR		(HI(19) | LO(16) | (0x14 << 21))
+#define CNTLZD		(HI(31) | LO(58))
+#define CNTLZW		(HI(31) | LO(26))
+#define CMP		(HI(31) | LO(0))
+#define CMPI		(HI(11))
+#define CMPL		(HI(31) | LO(32))
+#define CMPLI		(HI(10))
+#define CROR		(HI(19) | LO(449))
+#define DCBT		(HI(31) | LO(278))
+#define DIVD		(HI(31) | LO(489))
+#define DIVDU		(HI(31) | LO(457))
+#define DIVW		(HI(31) | LO(491))
+#define DIVWU		(HI(31) | LO(459))
+#define EXTSB		(HI(31) | LO(954))
+#define EXTSH		(HI(31) | LO(922))
+#define EXTSW		(HI(31) | LO(986))
+#define FABS		(HI(63) | LO(264))
+#define FADD		(HI(63) | LO(21))
+#define FADDS		(HI(59) | LO(21))
+#define FCFID		(HI(63) | LO(846))
+#define FCMPU		(HI(63) | LO(0))
+#define FCTIDZ		(HI(63) | LO(815))
+#define FCTIWZ		(HI(63) | LO(15))
+#define FDIV		(HI(63) | LO(18))
+#define FDIVS		(HI(59) | LO(18))
+#define FMR		(HI(63) | LO(72))
+#define FMUL		(HI(63) | LO(25))
+#define FMULS		(HI(59) | LO(25))
+#define FNEG		(HI(63) | LO(40))
+#define FRSP		(HI(63) | LO(12))
+#define FSUB		(HI(63) | LO(20))
+#define FSUBS		(HI(59) | LO(20))
+#define LD		(HI(58) | 0)
+#define LFD		(HI(50))
+#define LWZ		(HI(32))
+#define MFCR		(HI(31) | LO(19))
+#define MFLR		(HI(31) | LO(339) | 0x80000)
+#define MFXER		(HI(31) | LO(339) | 0x10000)
+#define MTCTR		(HI(31) | LO(467) | 0x90000)
+#define MTLR		(HI(31) | LO(467) | 0x80000)
+#define MTXER		(HI(31) | LO(467) | 0x10000)
+#define MULHD		(HI(31) | LO(73))
+#define MULHDU		(HI(31) | LO(9))
+#define MULHW		(HI(31) | LO(75))
+#define MULHWU		(HI(31) | LO(11))
+#define MULLD		(HI(31) | LO(233))
+#define MULLI		(HI(7))
+#define MULLW		(HI(31) | LO(235))
+#define NEG		(HI(31) | LO(104))
+#define NOP		(HI(24))
+#define NOR		(HI(31) | LO(124))
+#define OR		(HI(31) | LO(444))
+#define ORI		(HI(24))
+#define ORIS		(HI(25))
+#define RLDCL		(HI(30) | LO(8))
+#define RLDICL		(HI(30) | LO(0 << 1))
+#define RLDICR		(HI(30) | LO(1 << 1))
+#define RLDIMI		(HI(30) | LO(3 << 1))
+#define RLWIMI		(HI(20))
+#define RLWINM		(HI(21))
+#define RLWNM		(HI(23))
+#define SLD		(HI(31) | LO(27))
+#define SLW		(HI(31) | LO(24))
+#define SRAD		(HI(31) | LO(794))
+#define SRADI		(HI(31) | LO(413 << 1))
+#define SRAW		(HI(31) | LO(792))
+#define SRAWI		(HI(31) | LO(824))
+#define SRD		(HI(31) | LO(539))
+#define SRW		(HI(31) | LO(536))
+#define STD		(HI(62) | 0)
+#define STDU		(HI(62) | 1)
+#define STDUX		(HI(31) | LO(181))
+#define STFD		(HI(54))
+#define STFIWX		(HI(31) | LO(983))
+#define STW		(HI(36))
+#define STWU		(HI(37))
+#define STWUX		(HI(31) | LO(183))
+#define SUBF		(HI(31) | LO(40))
+#define SUBFC		(HI(31) | LO(8))
+#define SUBFE		(HI(31) | LO(136))
+#define SUBFIC		(HI(8))
+#define XOR		(HI(31) | LO(316))
+#define XORI		(HI(26))
+#define XORIS		(HI(27))
 
 #define SIMM_MAX	(0x7fff)
 #define SIMM_MIN	(-0x8000)
 #define UIMM_MAX	(0xffff)
 
-/* dest_reg is the absolute name of the register
-   Useful for reordering instructions in the delay slot. */
-static sljit_s32 push_inst(struct sljit_compiler *compiler, sljit_ins ins, sljit_s32 delay_slot)
+/* Shift helpers. */
+#define RLWI_SH(sh) ((sljit_ins)(sh) << 11)
+#define RLWI_MBE(mb, me) (((sljit_ins)(mb) << 6) | ((sljit_ins)(me) << 1))
+#define RLDI_SH(sh) ((((sljit_ins)(sh) & 0x1f) << 11) | (((sljit_ins)(sh) & 0x20) >> 4))
+#define RLDI_MB(mb) ((((sljit_ins)(mb) & 0x1f) << 6) | ((sljit_ins)(mb) & 0x20))
+#define RLDI_ME(me) RLDI_MB(me)
+
+#define SLWI(shift) (RLWINM | RLWI_SH(shift) | RLWI_MBE(0, 31 - (shift)))
+#define SLDI(shift) (RLDICR | RLDI_SH(shift) | RLDI_ME(63 - (shift)))
+/* shift > 0 */
+#define SRWI(shift) (RLWINM | RLWI_SH(32 - (shift)) | RLWI_MBE((shift), 31))
+#define SRDI(shift) (RLDICL | RLDI_SH(64 - (shift)) | RLDI_MB(shift))
+
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
+#define SLWI_W(shift) SLWI(shift)
+#else /* !SLJIT_CONFIG_PPC_32 */
+#define SLWI_W(shift) SLDI(shift)
+#endif /* SLJIT_CONFIG_PPC_32 */
+
+#if (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
+SLJIT_API_FUNC_ATTRIBUTE void sljit_set_function_context(void** func_ptr, struct sljit_function_context* context, sljit_uw addr, void* func)
+{
+	sljit_uw* ptrs;
+
+	if (func_ptr)
+		*func_ptr = (void*)context;
+
+	ptrs = (sljit_uw*)func;
+	context->addr = addr ? addr : ptrs[0];
+	context->r2 = ptrs[1];
+	context->r11 = ptrs[2];
+}
+#endif
+
+static sljit_s32 push_inst(struct sljit_compiler *compiler, sljit_ins ins)
 {
 	sljit_ins *ptr = (sljit_ins*)ensure_buf(compiler, sizeof(sljit_ins));
-	SLJIT_ASSERT(delay_slot == MOVABLE_INS || delay_slot >= UNMOVABLE_INS
-		|| (sljit_ins)delay_slot == ((ins >> 11) & 0x1f)
-		|| (sljit_ins)delay_slot == ((ins >> 16) & 0x1f));
 	FAIL_IF(!ptr);
 	*ptr = ins;
 	compiler->size++;
-	compiler->delay_slot = delay_slot;
 	return SLJIT_SUCCESS;
 }
 
-static SLJIT_INLINE sljit_ins invert_branch(sljit_uw flags)
-{
-	if (flags & IS_BIT26_COND)
-		return (1 << 26);
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-	if (flags & IS_BIT23_COND)
-		return (1 << 23);
-#endif /* SLJIT_MIPS_REV >= 6 */
-	return (1 << 16);
-}
-
-static SLJIT_INLINE sljit_ins* detect_jump_type(struct sljit_jump *jump, sljit_ins *code_ptr, sljit_ins *code, sljit_sw executable_offset)
+static SLJIT_INLINE sljit_s32 detect_jump_type(struct sljit_jump *jump, sljit_ins *code_ptr, sljit_ins *code, sljit_sw executable_offset)
 {
 	sljit_sw diff;
 	sljit_uw target_addr;
-	sljit_ins *inst;
-	sljit_ins saved_inst;
+	sljit_uw extra_jump_flags;
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
+#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL) && (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
 	if (jump->flags & (SLJIT_REWRITABLE_JUMP | IS_CALL))
-		return code_ptr;
+		return 0;
 #else
 	if (jump->flags & SLJIT_REWRITABLE_JUMP)
-		return code_ptr;
+		return 0;
 #endif
 
 	if (jump->flags & JUMP_ADDR)
 		target_addr = jump->u.target;
 	else {
 		SLJIT_ASSERT(jump->flags & JUMP_LABEL);
 		target_addr = (sljit_uw)(code + jump->u.label->size) + (sljit_uw)executable_offset;
 	}
 
-	inst = (sljit_ins *)jump->addr;
-	if (jump->flags & IS_COND)
-		inst--;
-
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
+#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL) && (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
 	if (jump->flags & IS_CALL)
 		goto keep_address;
 #endif
 
-	/* B instructions. */
-	if (jump->flags & IS_MOVABLE) {
-		diff = ((sljit_sw)target_addr - (sljit_sw)inst - executable_offset) >> 2;
-		if (diff <= SIMM_MAX && diff >= SIMM_MIN) {
-			jump->flags |= PATCH_B;
+	diff = ((sljit_sw)target_addr - (sljit_sw)(code_ptr) - executable_offset) & ~0x3l;
 
-			if (!(jump->flags & IS_COND)) {
-				inst[0] = inst[-1];
-				inst[-1] = (jump->flags & IS_JAL) ? BAL : B;
-				jump->addr -= sizeof(sljit_ins);
-				return inst;
-			}
-			saved_inst = inst[0];
-			inst[0] = inst[-1];
-			inst[-1] = saved_inst ^ invert_branch(jump->flags);
-			jump->addr -= 2 * sizeof(sljit_ins);
-			return inst;
-		}
-	}
-	else {
-		diff = ((sljit_sw)target_addr - (sljit_sw)(inst + 1) - executable_offset) >> 2;
-		if (diff <= SIMM_MAX && diff >= SIMM_MIN) {
+	extra_jump_flags = 0;
+	if (jump->flags & IS_COND) {
+		if (diff <= 0x7fff && diff >= -0x8000) {
 			jump->flags |= PATCH_B;
-
-			if (!(jump->flags & IS_COND)) {
-				inst[0] = (jump->flags & IS_JAL) ? BAL : B;
-				inst[1] = NOP;
-				return inst + 1;
-			}
-			inst[0] ^= invert_branch(jump->flags);
-			inst[1] = NOP;
-			jump->addr -= sizeof(sljit_ins);
-			return inst + 1;
+			return 1;
 		}
+		if (target_addr <= 0xffff) {
+			jump->flags |= PATCH_B | PATCH_ABS_B;
+			return 1;
+		}
+		extra_jump_flags = REMOVE_COND;
+
+		diff -= SSIZE_OF(ins);
 	}
 
-	if (jump->flags & IS_COND) {
-		if ((jump->flags & IS_MOVABLE) && (target_addr & ~(sljit_uw)0xfffffff) == ((jump->addr + 2 * sizeof(sljit_ins)) & ~(sljit_uw)0xfffffff)) {
-			jump->flags |= PATCH_J;
-			saved_inst = inst[0];
-			inst[0] = inst[-1];
-			inst[-1] = (saved_inst & 0xffff0000) | 3;
-			inst[1] = J;
-			inst[2] = NOP;
-			return inst + 2;
-		}
-		else if ((target_addr & ~(sljit_uw)0xfffffff) == ((jump->addr + 3 * sizeof(sljit_ins)) & ~(sljit_uw)0xfffffff)) {
-			jump->flags |= PATCH_J;
-			inst[0] = (inst[0] & 0xffff0000) | 3;
-			inst[1] = NOP;
-			inst[2] = J;
-			inst[3] = NOP;
-			jump->addr += sizeof(sljit_ins);
-			return inst + 3;
-		}
+	if (diff <= 0x01ffffff && diff >= -0x02000000) {
+		jump->flags |= PATCH_B | extra_jump_flags;
+		return 1;
 	}
-	else {
-		/* J instuctions. */
-		if ((jump->flags & IS_MOVABLE) && (target_addr & ~(sljit_uw)0xfffffff) == (jump->addr & ~(sljit_uw)0xfffffff)) {
-			jump->flags |= PATCH_J;
-			inst[0] = inst[-1];
-			inst[-1] = (jump->flags & IS_JAL) ? JAL : J;
-			jump->addr -= sizeof(sljit_ins);
-			return inst;
-		}
 
-		if ((target_addr & ~(sljit_uw)0xfffffff) == ((jump->addr + sizeof(sljit_ins)) & ~(sljit_uw)0xfffffff)) {
-			jump->flags |= PATCH_J;
-			inst[0] = (jump->flags & IS_JAL) ? JAL : J;
-			inst[1] = NOP;
-			return inst + 1;
-		}
+	if (target_addr <= 0x03ffffff) {
+		jump->flags |= PATCH_B | PATCH_ABS_B | extra_jump_flags;
+		return 1;
 	}
 
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL)
 keep_address:
+#endif
 	if (target_addr <= 0x7fffffff) {
 		jump->flags |= PATCH_ABS32;
-		if (jump->flags & IS_COND) {
-			inst[0] -= 4;
-			inst++;
-		}
-		inst[2] = inst[6];
-		inst[3] = inst[7];
-		return inst + 3;
+		return 1;
 	}
+
 	if (target_addr <= 0x7fffffffffffl) {
 		jump->flags |= PATCH_ABS48;
-		if (jump->flags & IS_COND) {
-			inst[0] -= 2;
-			inst++;
-		}
-		inst[4] = inst[6];
-		inst[5] = inst[7];
-		return inst + 5;
+		return 1;
 	}
 #endif
 
-	return code_ptr;
+	return 0;
 }
 
-#ifdef __GNUC__
-static __attribute__ ((noinline)) void sljit_cache_flush(void* code, void* code_ptr)
-{
-	SLJIT_CACHE_FLUSH(code, code_ptr);
-}
-#endif
-
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
 
 static SLJIT_INLINE sljit_sw put_label_get_length(struct sljit_put_label *put_label, sljit_uw max_label)
 {
-	if (max_label < 0x80000000l) {
+	if (max_label < 0x100000000l) {
 		put_label->flags = 0;
 		return 1;
 	}
 
-	if (max_label < 0x800000000000l) {
+	if (max_label < 0x1000000000000l) {
 		put_label->flags = 1;
 		return 3;
 	}
 
 	put_label->flags = 2;
-	return 5;
+	return 4;
 }
 
 static SLJIT_INLINE void put_label_set(struct sljit_put_label *put_label)
 {
 	sljit_uw addr = put_label->label->addr;
 	sljit_ins *inst = (sljit_ins *)put_label->addr;
 	sljit_u32 reg = *inst;
 
 	if (put_label->flags == 0) {
-		SLJIT_ASSERT(addr < 0x80000000l);
-		inst[0] = LUI | T(reg) | IMM(addr >> 16);
-	}
-	else if (put_label->flags == 1) {
-		SLJIT_ASSERT(addr < 0x800000000000l);
-		inst[0] = LUI | T(reg) | IMM(addr >> 32);
-		inst[1] = ORI | S(reg) | T(reg) | IMM((addr >> 16) & 0xffff);
-		inst[2] = DSLL | T(reg) | D(reg) | SH_IMM(16);
-		inst += 2;
+		SLJIT_ASSERT(addr < 0x100000000l);
+		inst[0] = ORIS | S(TMP_ZERO) | A(reg) | IMM(addr >> 16);
 	}
 	else {
-		inst[0] = LUI | T(reg) | IMM(addr >> 48);
-		inst[1] = ORI | S(reg) | T(reg) | IMM((addr >> 32) & 0xffff);
-		inst[2] = DSLL | T(reg) | D(reg) | SH_IMM(16);
-		inst[3] = ORI | S(reg) | T(reg) | IMM((addr >> 16) & 0xffff);
-		inst[4] = DSLL | T(reg) | D(reg) | SH_IMM(16);
-		inst += 4;
+		if (put_label->flags == 1) {
+			SLJIT_ASSERT(addr < 0x1000000000000l);
+			inst[0] = ORI | S(TMP_ZERO) | A(reg) | IMM(addr >> 32);
+		}
+		else {
+			inst[0] = ORIS | S(TMP_ZERO) | A(reg) | IMM(addr >> 48);
+			inst[1] = ORI | S(reg) | A(reg) | IMM((addr >> 32) & 0xffff);
+			inst++;
+		}
+
+		inst[1] = SLDI(32) | S(reg) | A(reg);
+		inst[2] = ORIS | S(reg) | A(reg) | IMM((addr >> 16) & 0xffff);
+		inst += 2;
 	}
 
-	inst[1] = ORI | S(reg) | T(reg) | IMM(addr & 0xffff);
+	inst[1] = ORI | S(reg) | A(reg) | IMM(addr & 0xffff);
 }
 
-#endif
+#endif /* SLJIT_CONFIG_PPC_64 */
 
 SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compiler)
 {
 	struct sljit_memory_fragment *buf;
 	sljit_ins *code;
 	sljit_ins *code_ptr;
 	sljit_ins *buf_ptr;
@@ -520,14 +418,21 @@
 	struct sljit_const *const_;
 	struct sljit_put_label *put_label;
 
 	CHECK_ERROR_PTR();
 	CHECK_PTR(check_sljit_generate_code(compiler));
 	reverse_buf(compiler);
 
+#if (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	compiler->size += (compiler->size & 0x1) + (sizeof(struct sljit_function_context) / sizeof(sljit_ins));
+#else
+	compiler->size += (sizeof(struct sljit_function_context) / sizeof(sljit_ins));
+#endif
+#endif
 	code = (sljit_ins*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_ins), compiler->exec_allocator_data);
 	PTR_FAIL_WITH_EXEC_IF(code);
 	buf = compiler->buf;
 
 	code_ptr = code;
 	word_count = 0;
 	next_addr = 0;
@@ -547,1439 +452,1739 @@
 				SLJIT_ASSERT(!label || label->size >= word_count);
 				SLJIT_ASSERT(!jump || jump->addr >= word_count);
 				SLJIT_ASSERT(!const_ || const_->addr >= word_count);
 				SLJIT_ASSERT(!put_label || put_label->addr >= word_count);
 
 				/* These structures are ordered by their address. */
 				if (label && label->size == word_count) {
+					/* Just recording the address. */
 					label->addr = (sljit_uw)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
 					label->size = (sljit_uw)(code_ptr - code);
 					label = label->next;
 				}
 				if (jump && jump->addr == word_count) {
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
 					jump->addr = (sljit_uw)(code_ptr - 3);
 #else
-					jump->addr = (sljit_uw)(code_ptr - 7);
+					jump->addr = (sljit_uw)(code_ptr - 6);
 #endif
-					code_ptr = detect_jump_type(jump, code_ptr, code, executable_offset);
+					if (detect_jump_type(jump, code_ptr, code, executable_offset)) {
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
+						code_ptr[-3] = code_ptr[0];
+						code_ptr -= 3;
+#else
+						if (jump->flags & PATCH_ABS32) {
+							code_ptr -= 3;
+							code_ptr[-1] = code_ptr[2];
+							code_ptr[0] = code_ptr[3];
+						}
+						else if (jump->flags & PATCH_ABS48) {
+							code_ptr--;
+							code_ptr[-1] = code_ptr[0];
+							code_ptr[0] = code_ptr[1];
+							/* rldicr rX,rX,32,31 -> rX,rX,16,47 */
+							SLJIT_ASSERT((code_ptr[-3] & 0xfc00ffff) == 0x780007c6);
+							code_ptr[-3] ^= 0x8422;
+							/* oris -> ori */
+							code_ptr[-2] ^= 0x4000000;
+						}
+						else {
+							code_ptr[-6] = code_ptr[0];
+							code_ptr -= 6;
+						}
+#endif
+						if (jump->flags & REMOVE_COND) {
+							code_ptr[0] = BCx | (2 << 2) | ((code_ptr[0] ^ (8 << 21)) & 0x03ff0001);
+							code_ptr++;
+							jump->addr += sizeof(sljit_ins);
+							code_ptr[0] = Bx;
+							jump->flags -= IS_COND;
+						}
+					}
 					jump = jump->next;
 				}
 				if (const_ && const_->addr == word_count) {
 					const_->addr = (sljit_uw)code_ptr;
 					const_ = const_->next;
 				}
 				if (put_label && put_label->addr == word_count) {
 					SLJIT_ASSERT(put_label->label);
 					put_label->addr = (sljit_uw)code_ptr;
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
 					code_ptr += put_label_get_length(put_label, (sljit_uw)(SLJIT_ADD_EXEC_OFFSET(code, executable_offset) + put_label->label->size));
-					word_count += 5;
+					word_count += 4;
 #endif
 					put_label = put_label->next;
 				}
 				next_addr = compute_next_addr(label, jump, const_, put_label);
 			}
-			code_ptr ++;
-			word_count ++;
+			code_ptr++;
+			word_count++;
 		} while (buf_ptr < buf_end);
 
 		buf = buf->next;
 	} while (buf);
 
 	if (label && label->size == word_count) {
-		label->addr = (sljit_uw)code_ptr;
+		label->addr = (sljit_uw)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
 		label->size = (sljit_uw)(code_ptr - code);
 		label = label->next;
 	}
 
 	SLJIT_ASSERT(!label);
 	SLJIT_ASSERT(!jump);
 	SLJIT_ASSERT(!const_);
 	SLJIT_ASSERT(!put_label);
+
+#if (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
+	SLJIT_ASSERT(code_ptr - code <= (sljit_sw)(compiler->size - (sizeof(struct sljit_function_context) / sizeof(sljit_ins))));
+#else
 	SLJIT_ASSERT(code_ptr - code <= (sljit_sw)compiler->size);
+#endif
 
 	jump = compiler->jumps;
 	while (jump) {
 		do {
 			addr = (jump->flags & JUMP_LABEL) ? jump->u.label->addr : jump->u.target;
 			buf_ptr = (sljit_ins *)jump->addr;
 
 			if (jump->flags & PATCH_B) {
-				addr = (sljit_uw)((sljit_sw)(addr - (sljit_uw)SLJIT_ADD_EXEC_OFFSET(buf_ptr, executable_offset) - sizeof(sljit_ins)) >> 2);
-				SLJIT_ASSERT((sljit_sw)addr <= SIMM_MAX && (sljit_sw)addr >= SIMM_MIN);
-				buf_ptr[0] = (buf_ptr[0] & 0xffff0000) | ((sljit_ins)addr & 0xffff);
-				break;
-			}
-			if (jump->flags & PATCH_J) {
-				SLJIT_ASSERT((addr & ~(sljit_uw)0xfffffff)
-					== (((sljit_uw)SLJIT_ADD_EXEC_OFFSET(buf_ptr, executable_offset) + sizeof(sljit_ins)) & ~(sljit_uw)0xfffffff));
-				buf_ptr[0] |= (sljit_ins)(addr >> 2) & 0x03ffffff;
+				if (jump->flags & IS_COND) {
+					if (!(jump->flags & PATCH_ABS_B)) {
+						addr -= (sljit_uw)SLJIT_ADD_EXEC_OFFSET(buf_ptr, executable_offset);
+						SLJIT_ASSERT((sljit_sw)addr <= 0x7fff && (sljit_sw)addr >= -0x8000);
+						*buf_ptr = BCx | ((sljit_ins)addr & 0xfffc) | ((*buf_ptr) & 0x03ff0001);
+					}
+					else {
+						SLJIT_ASSERT(addr <= 0xffff);
+						*buf_ptr = BCx | ((sljit_ins)addr & 0xfffc) | 0x2 | ((*buf_ptr) & 0x03ff0001);
+					}
+				}
+				else {
+					if (!(jump->flags & PATCH_ABS_B)) {
+						addr -= (sljit_uw)SLJIT_ADD_EXEC_OFFSET(buf_ptr, executable_offset);
+						SLJIT_ASSERT((sljit_sw)addr <= 0x01ffffff && (sljit_sw)addr >= -0x02000000);
+						*buf_ptr = Bx | ((sljit_ins)addr & 0x03fffffc) | ((*buf_ptr) & 0x1);
+					}
+					else {
+						SLJIT_ASSERT(addr <= 0x03ffffff);
+						*buf_ptr = Bx | ((sljit_ins)addr & 0x03fffffc) | 0x2 | ((*buf_ptr) & 0x1);
+					}
+				}
 				break;
 			}
 
 			/* Set the fields of immediate loads. */
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
 			SLJIT_ASSERT(((buf_ptr[0] | buf_ptr[1]) & 0xffff) == 0);
 			buf_ptr[0] |= (sljit_ins)(addr >> 16) & 0xffff;
 			buf_ptr[1] |= (sljit_ins)addr & 0xffff;
 #else
 			if (jump->flags & PATCH_ABS32) {
 				SLJIT_ASSERT(addr <= 0x7fffffff);
 				SLJIT_ASSERT(((buf_ptr[0] | buf_ptr[1]) & 0xffff) == 0);
 				buf_ptr[0] |= (sljit_ins)(addr >> 16) & 0xffff;
 				buf_ptr[1] |= (sljit_ins)addr & 0xffff;
 				break;
 			}
 
 			if (jump->flags & PATCH_ABS48) {
-				SLJIT_ASSERT(addr <= 0x7fffffffffffl);
+				SLJIT_ASSERT(addr <= 0x7fffffffffff);
 				SLJIT_ASSERT(((buf_ptr[0] | buf_ptr[1] | buf_ptr[3]) & 0xffff) == 0);
 				buf_ptr[0] |= (sljit_ins)(addr >> 32) & 0xffff;
 				buf_ptr[1] |= (sljit_ins)(addr >> 16) & 0xffff;
 				buf_ptr[3] |= (sljit_ins)addr & 0xffff;
 				break;
 			}
 
-			SLJIT_ASSERT(((buf_ptr[0] | buf_ptr[1] | buf_ptr[3] | buf_ptr[5]) & 0xffff) == 0);
+			SLJIT_ASSERT(((buf_ptr[0] | buf_ptr[1] | buf_ptr[3] | buf_ptr[4]) & 0xffff) == 0);
 			buf_ptr[0] |= (sljit_ins)(addr >> 48) & 0xffff;
 			buf_ptr[1] |= (sljit_ins)(addr >> 32) & 0xffff;
 			buf_ptr[3] |= (sljit_ins)(addr >> 16) & 0xffff;
-			buf_ptr[5] |= (sljit_ins)addr & 0xffff;
+			buf_ptr[4] |= (sljit_ins)addr & 0xffff;
 #endif
 		} while (0);
 		jump = jump->next;
 	}
 
 	put_label = compiler->put_labels;
 	while (put_label) {
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
 		addr = put_label->label->addr;
 		buf_ptr = (sljit_ins *)put_label->addr;
 
-		SLJIT_ASSERT((buf_ptr[0] & 0xffe00000) == LUI && (buf_ptr[1] & 0xfc000000) == ORI);
+		SLJIT_ASSERT((buf_ptr[0] & 0xfc1f0000) == ADDIS && (buf_ptr[1] & 0xfc000000) == ORI);
 		buf_ptr[0] |= (addr >> 16) & 0xffff;
 		buf_ptr[1] |= addr & 0xffff;
 #else
 		put_label_set(put_label);
 #endif
 		put_label = put_label->next;
 	}
 
 	compiler->error = SLJIT_ERR_COMPILED;
 	compiler->executable_offset = executable_offset;
 	compiler->executable_size = (sljit_uw)(code_ptr - code) * sizeof(sljit_ins);
 
 	code = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(code, executable_offset);
+
+#if (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	if (((sljit_sw)code_ptr) & 0x4)
+		code_ptr++;
+#endif
+	sljit_set_function_context(NULL, (struct sljit_function_context*)code_ptr, (sljit_uw)code, (void*)sljit_generate_code);
+#endif
+
 	code_ptr = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
 
-#ifndef __GNUC__
 	SLJIT_CACHE_FLUSH(code, code_ptr);
-#else
-	/* GCC workaround for invalid code generation with -O2. */
-	sljit_cache_flush(code, code_ptr);
-#endif
 	SLJIT_UPDATE_WX_FLAGS(code, code_ptr, 1);
+
+#if (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
+	return code_ptr;
+#else
 	return code;
+#endif
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_has_cpu_feature(sljit_s32 feature_type)
 {
-#if defined(__GNUC__) && !defined(SLJIT_IS_FPU_AVAILABLE)
-	sljit_sw fir = 0;
-#endif /* __GNUC__ && !SLJIT_IS_FPU_AVAILABLE */
-
 	switch (feature_type) {
 	case SLJIT_HAS_FPU:
 #ifdef SLJIT_IS_FPU_AVAILABLE
 		return SLJIT_IS_FPU_AVAILABLE;
-#elif defined(__GNUC__)
-		__asm__ ("cfc1 %0, $0" : "=r"(fir));
-		return (fir >> 22) & 0x1;
 #else
-#error "FIR check is not implemented for this architecture"
-#endif
-	case SLJIT_HAS_ZERO_REGISTER:
+		/* Available by default. */
 		return 1;
+#endif
 
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1)
+	/* A saved register is set to a zero value. */
+	case SLJIT_HAS_ZERO_REGISTER:
 	case SLJIT_HAS_CLZ:
-	case SLJIT_HAS_CMOV:
+	case SLJIT_HAS_ROT:
 	case SLJIT_HAS_PREFETCH:
 		return 1;
-#endif /* SLJIT_MIPS_REV >= 1 */
+
+	case SLJIT_HAS_CTZ:
+		return 2;
 
 	default:
 		return 0;
 	}
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_cmp_info(sljit_s32 type)
+{
+	return (type >= SLJIT_UNORDERED && type <= SLJIT_ORDERED_LESS_EQUAL);
+}
+
 /* --------------------------------------------------------------------- */
 /*  Entry, exit                                                          */
 /* --------------------------------------------------------------------- */
 
+/* inp_flags: */
+
 /* Creates an index in data_transfer_insts array. */
 #define LOAD_DATA	0x01
+#define INDEXED		0x02
+#define SIGNED_DATA	0x04
+
 #define WORD_DATA	0x00
-#define BYTE_DATA	0x02
-#define HALF_DATA	0x04
-#define INT_DATA	0x06
-#define SIGNED_DATA	0x08
+#define BYTE_DATA	0x08
+#define HALF_DATA	0x10
+#define INT_DATA	0x18
 /* Separates integer and floating point registers */
-#define GPR_REG		0x0f
-#define DOUBLE_DATA	0x10
-#define SINGLE_DATA	0x12
-
-#define MEM_MASK	0x1f
-
-#define ARG_TEST	0x00020
-#define ALT_KEEP_CACHE	0x00040
-#define CUMULATIVE_OP	0x00080
-#define LOGICAL_OP	0x00100
-#define IMM_OP		0x00200
-#define MOVE_OP		0x00400
-#define SRC2_IMM	0x00800
-
-#define UNUSED_DEST	0x01000
-#define REG_DEST	0x02000
-#define REG1_SOURCE	0x04000
-#define REG2_SOURCE	0x08000
-#define SLOW_SRC1	0x10000
-#define SLOW_SRC2	0x20000
-#define SLOW_DEST	0x40000
-
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-#define STACK_STORE	SW
-#define STACK_LOAD	LW
+#define GPR_REG		0x1f
+#define DOUBLE_DATA	0x20
+
+#define MEM_MASK	0x7f
+
+/* Other inp_flags. */
+
+/* Integer opertion and set flags -> requires exts on 64 bit systems. */
+#define ALT_SIGN_EXT	0x000100
+/* This flag affects the RC() and OERC() macros. */
+#define ALT_SET_FLAGS	0x000400
+#define ALT_FORM1	0x001000
+#define ALT_FORM2	0x002000
+#define ALT_FORM3	0x004000
+#define ALT_FORM4	0x008000
+#define ALT_FORM5	0x010000
+
+/* Source and destination is register. */
+#define REG_DEST	0x000001
+#define REG1_SOURCE	0x000002
+#define REG2_SOURCE	0x000004
+/*
+ALT_SIGN_EXT		0x000100
+ALT_SET_FLAGS		0x000200
+ALT_FORM1		0x001000
+...
+ALT_FORM5		0x010000 */
+
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
+#include "sljitNativePPC_32.c"
 #else
-#define STACK_STORE	SD
-#define STACK_LOAD	LD
+#include "sljitNativePPC_64.c"
 #endif
 
-static sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg_ar, sljit_s32 arg, sljit_sw argw);
-static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler, sljit_s32 frame_size, sljit_ins *ins_ptr);
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
+#define STACK_STORE	STW
+#define STACK_LOAD	LWZ
+#else
+#define STACK_STORE	STD
+#define STACK_LOAD	LD
+#endif
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-#include "sljitNativeMIPS_32.c"
+#if (defined SLJIT_PPC_STACK_FRAME_V2 && SLJIT_PPC_STACK_FRAME_V2)
+#define LR_SAVE_OFFSET		2 * SSIZE_OF(sw)
 #else
-#include "sljitNativeMIPS_64.c"
+#define LR_SAVE_OFFSET		SSIZE_OF(sw)
 #endif
 
+#define STACK_MAX_DISTANCE	(0x8000 - SSIZE_OF(sw) - LR_SAVE_OFFSET)
+
+static sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 inp_flags, sljit_s32 reg,
+	sljit_s32 arg, sljit_sw argw, sljit_s32 tmp_reg);
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_enter(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
-	sljit_ins base;
-	sljit_s32 i, tmp, offset;
-	sljit_s32 arg_count, word_arg_count, saved_arg_count, float_arg_count;
+	sljit_s32 i, tmp, base, offset;
+	sljit_s32 word_arg_count = 0;
+	sljit_s32 saved_arg_count = SLJIT_KEPT_SAVEDS_COUNT(options);
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	sljit_s32 arg_count = 0;
+#endif
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
-	local_size += GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1);
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-	if (fsaveds > 0 || fscratches >= SLJIT_FIRST_SAVED_FLOAT_REG) {
-		if ((local_size & SSIZE_OF(sw)) != 0)
-			local_size += SSIZE_OF(sw);
-		local_size += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
-	}
+	local_size += GET_SAVED_REGISTERS_SIZE(scratches, saveds - saved_arg_count, 0)
+		+ GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
+
+	if (!(options & SLJIT_ENTER_REG_ARG))
+		local_size += SSIZE_OF(sw);
 
 	local_size = (local_size + SLJIT_LOCALS_OFFSET + 15) & ~0xf;
-#else
-	local_size += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
-	local_size = (local_size + SLJIT_LOCALS_OFFSET + 31) & ~0x1f;
-#endif
 	compiler->local_size = local_size;
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-	tmp = arg_types >> SLJIT_ARG_SHIFT;
-	arg_count = 0;
-	offset = 0;
-
-	while (tmp) {
-		offset = arg_count;
-		if ((tmp & SLJIT_ARG_MASK) == SLJIT_ARG_TYPE_F64) {
-			if ((arg_count & 0x1) != 0)
-				arg_count++;
-			arg_count++;
-		}
+	FAIL_IF(push_inst(compiler, MFLR | D(0)));
 
-		arg_count++;
-		tmp >>= SLJIT_ARG_SHIFT;
-	}
+	base = SLJIT_SP;
+	offset = local_size;
 
-	compiler->args_size = (sljit_uw)arg_count << 2;
-	offset = (offset >= 4) ? (offset << 2) : 0;
-#else /* !SLJIT_CONFIG_MIPS_32 */
-	offset = 0;
-#endif /* SLJIT_CONFIG_MIPS_32 */
-
-	if (local_size + offset <= -SIMM_MIN) {
-		/* Frequent case. */
-		FAIL_IF(push_inst(compiler, ADDIU_W | S(SLJIT_SP) | T(SLJIT_SP) | IMM(-local_size), DR(SLJIT_SP)));
-		base = S(SLJIT_SP);
-		offset = local_size - SSIZE_OF(sw);
+	if (local_size <= STACK_MAX_DISTANCE) {
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
+		FAIL_IF(push_inst(compiler, STWU | S(SLJIT_SP) | A(SLJIT_SP) | IMM(-local_size)));
+#else
+		FAIL_IF(push_inst(compiler, STDU | S(SLJIT_SP) | A(SLJIT_SP) | IMM(-local_size)));
+#endif
 	} else {
-		FAIL_IF(load_immediate(compiler, DR(OTHER_FLAG), local_size));
-		FAIL_IF(push_inst(compiler, ADDU_W | S(SLJIT_SP) | TA(0) | D(TMP_REG2), DR(TMP_REG2)));
-		FAIL_IF(push_inst(compiler, SUBU_W | S(SLJIT_SP) | T(OTHER_FLAG) | D(SLJIT_SP), DR(SLJIT_SP)));
-		base = S(TMP_REG2);
-		offset = -SSIZE_OF(sw);
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-		local_size = 0;
+		base = TMP_REG1;
+		FAIL_IF(push_inst(compiler, OR | S(SLJIT_SP) | A(TMP_REG1) | B(SLJIT_SP)));
+		FAIL_IF(load_immediate(compiler, TMP_REG2, -local_size));
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
+		FAIL_IF(push_inst(compiler, STWUX | S(SLJIT_SP) | A(SLJIT_SP) | B(TMP_REG2)));
+#else
+		FAIL_IF(push_inst(compiler, STDUX | S(SLJIT_SP) | A(SLJIT_SP) | B(TMP_REG2)));
 #endif
+		local_size = 0;
+		offset = 0;
 	}
 
-	FAIL_IF(push_inst(compiler, STACK_STORE | base | TA(RETURN_ADDR_REG) | IMM(offset), MOVABLE_INS));
+	tmp = SLJIT_FS0 - fsaveds;
+	for (i = SLJIT_FS0; i > tmp; i--) {
+		offset -= SSIZE_OF(f64);
+		FAIL_IF(push_inst(compiler, STFD | FS(i) | A(base) | IMM(offset)));
+	}
+
+	for (i = fscratches; i >= SLJIT_FIRST_SAVED_FLOAT_REG; i--) {
+		offset -= SSIZE_OF(f64);
+		FAIL_IF(push_inst(compiler, STFD | FS(i) | A(base) | IMM(offset)));
+	}
+
+	if (!(options & SLJIT_ENTER_REG_ARG)) {
+		offset -= SSIZE_OF(sw);
+		FAIL_IF(push_inst(compiler, STACK_STORE | S(TMP_ZERO) | A(base) | IMM(offset)));
+	}
 
 	tmp = SLJIT_S0 - saveds;
-	for (i = SLJIT_S0; i > tmp; i--) {
+	for (i = SLJIT_S0 - saved_arg_count; i > tmp; i--) {
 		offset -= SSIZE_OF(sw);
-		FAIL_IF(push_inst(compiler, STACK_STORE | base | T(i) | IMM(offset), MOVABLE_INS));
+		FAIL_IF(push_inst(compiler, STACK_STORE | S(i) | A(base) | IMM(offset)));
 	}
 
 	for (i = scratches; i >= SLJIT_FIRST_SAVED_REG; i--) {
 		offset -= SSIZE_OF(sw);
-		FAIL_IF(push_inst(compiler, STACK_STORE | base | T(i) | IMM(offset), MOVABLE_INS));
+		FAIL_IF(push_inst(compiler, STACK_STORE | S(i) | A(base) | IMM(offset)));
 	}
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-	/* This alignment is valid because offset is not used after storing FPU regs. */
-	if ((offset & SSIZE_OF(sw)) != 0)
-		offset -= SSIZE_OF(sw);
-#endif
+	FAIL_IF(push_inst(compiler, STACK_STORE | S(0) | A(base) | IMM(local_size + LR_SAVE_OFFSET)));
 
-	tmp = SLJIT_FS0 - fsaveds;
-	for (i = SLJIT_FS0; i > tmp; i--) {
-		offset -= SSIZE_OF(f64);
-		FAIL_IF(push_inst(compiler, SDC1 | base | FT(i) | IMM(offset), MOVABLE_INS));
-	}
+	if (options & SLJIT_ENTER_REG_ARG)
+		return SLJIT_SUCCESS;
 
-	for (i = fscratches; i >= SLJIT_FIRST_SAVED_FLOAT_REG; i--) {
-		offset -= SSIZE_OF(f64);
-		FAIL_IF(push_inst(compiler, SDC1 | base | FT(i) | IMM(offset), MOVABLE_INS));
-	}
+	FAIL_IF(push_inst(compiler, ADDI | D(TMP_ZERO) | A(0) | 0));
 
 	arg_types >>= SLJIT_ARG_SHIFT;
-	arg_count = 0;
-	word_arg_count = 0;
 	saved_arg_count = 0;
-	float_arg_count = 0;
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-	/* The first maximum two floating point arguments are passed in floating point
-	   registers if no integer argument precedes them. The first 16 byte data is
-	   passed in four integer registers, the rest is placed onto the stack.
-	   The floating point registers are also part of the first 16 byte data, so
-	   their corresponding integer registers are not used when they are present. */
-
-	while (arg_types) {
-		switch (arg_types & SLJIT_ARG_MASK) {
-		case SLJIT_ARG_TYPE_F64:
-			float_arg_count++;
-			if ((arg_count & 0x1) != 0)
-				arg_count++;
-
-			if (word_arg_count == 0 && float_arg_count <= 2) {
-				if (float_arg_count == 1)
-					FAIL_IF(push_inst(compiler, MOV_S | FMT_D | FS(TMP_FREG1) | FD(SLJIT_FR0), MOVABLE_INS));
-			} else if (arg_count < 4) {
-				FAIL_IF(push_inst(compiler, MTC1 | TA(4 + arg_count) | FS(float_arg_count), MOVABLE_INS));
-				FAIL_IF(push_inst(compiler, MTC1 | TA(5 + arg_count) | FS(float_arg_count) | (1 << 11), MOVABLE_INS));
-			} else
-				FAIL_IF(push_inst(compiler, LDC1 | base | FT(float_arg_count) | IMM(local_size + (arg_count << 2)), MOVABLE_INS));
-			arg_count++;
-			break;
-		case SLJIT_ARG_TYPE_F32:
-			float_arg_count++;
-
-			if (word_arg_count == 0 && float_arg_count <= 2) {
-				if (float_arg_count == 1)
-					FAIL_IF(push_inst(compiler, MOV_S | FMT_S | FS(TMP_FREG1) | FD(SLJIT_FR0), MOVABLE_INS));
-			} else if (arg_count < 4)
-				FAIL_IF(push_inst(compiler, MTC1 | TA(4 + arg_count) | FS(float_arg_count), MOVABLE_INS));
-			else
-				FAIL_IF(push_inst(compiler, LWC1 | base | FT(float_arg_count) | IMM(local_size + (arg_count << 2)), MOVABLE_INS));
-			break;
-		default:
-			word_arg_count++;
+	while (arg_types > 0) {
+		if ((arg_types & SLJIT_ARG_MASK) < SLJIT_ARG_TYPE_F64) {
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+			do {
+				if (!(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG)) {
+					tmp = SLJIT_S0 - saved_arg_count;
+					saved_arg_count++;
+				} else if (arg_count != word_arg_count)
+					tmp = SLJIT_R0 + word_arg_count;
+				else
+					break;
 
+				FAIL_IF(push_inst(compiler, OR | S(SLJIT_R0 + arg_count) | A(tmp) | B(SLJIT_R0 + arg_count)));
+			} while (0);
+#else
 			if (!(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG)) {
-				tmp = SLJIT_S0 - saved_arg_count;
+				FAIL_IF(push_inst(compiler, OR | S(SLJIT_R0 + word_arg_count) | A(SLJIT_S0 - saved_arg_count) | B(SLJIT_R0 + word_arg_count)));
 				saved_arg_count++;
-			} else if (word_arg_count != arg_count + 1 || arg_count == 0)
-				tmp = word_arg_count;
-			else
-				break;
-
-			if (arg_count < 4)
-				FAIL_IF(push_inst(compiler, ADDU_W | SA(4 + arg_count) | TA(0) | D(tmp), DR(tmp)));
-			else
-				FAIL_IF(push_inst(compiler, LW | base | T(tmp) | IMM(local_size + (arg_count << 2)), DR(tmp)));
-			break;
+			}
+#endif
+			word_arg_count++;
 		}
-		arg_count++;
-		arg_types >>= SLJIT_ARG_SHIFT;
-	}
 
-	SLJIT_ASSERT(compiler->args_size == (sljit_uw)arg_count << 2);
-#else /* !SLJIT_CONFIG_MIPS_32 */
-	while (arg_types) {
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
 		arg_count++;
-		switch (arg_types & SLJIT_ARG_MASK) {
-		case SLJIT_ARG_TYPE_F64:
-			float_arg_count++;
-			if (arg_count != float_arg_count)
-				FAIL_IF(push_inst(compiler, MOV_S | FMT_D | FS(arg_count) | FD(float_arg_count), MOVABLE_INS));
-			else if (arg_count == 1)
-				FAIL_IF(push_inst(compiler, MOV_S | FMT_D | FS(TMP_FREG1) | FD(SLJIT_FR0), MOVABLE_INS));
-			break;
-		case SLJIT_ARG_TYPE_F32:
-			float_arg_count++;
-			if (arg_count != float_arg_count)
-				FAIL_IF(push_inst(compiler, MOV_S | FMT_S | FS(arg_count) | FD(float_arg_count), MOVABLE_INS));
-			else if (arg_count == 1)
-				FAIL_IF(push_inst(compiler, MOV_S | FMT_S | FS(TMP_FREG1) | FD(SLJIT_FR0), MOVABLE_INS));
-			break;
-		default:
-			word_arg_count++;
-
-			if (!(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG)) {
-				tmp = SLJIT_S0 - saved_arg_count;
-				saved_arg_count++;
-			} else if (word_arg_count != arg_count || word_arg_count <= 1)
-				tmp = word_arg_count;
-			else
-				break;
-
-			FAIL_IF(push_inst(compiler, ADDU_W | SA(3 + arg_count) | TA(0) | D(tmp), DR(tmp)));
-			break;
-		}
+#endif
 		arg_types >>= SLJIT_ARG_SHIFT;
 	}
-#endif /* SLJIT_CONFIG_MIPS_32 */
 
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_set_context(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
-	local_size += GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1);
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-	if (fsaveds > 0 || fscratches >= SLJIT_FIRST_SAVED_FLOAT_REG) {
-		if ((local_size & SSIZE_OF(sw)) != 0)
-			local_size += SSIZE_OF(sw);
-		local_size += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
-	}
+	local_size += GET_SAVED_REGISTERS_SIZE(scratches, saveds - SLJIT_KEPT_SAVEDS_COUNT(options), 0)
+		+ GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
+
+	if (!(options & SLJIT_ENTER_REG_ARG))
+		local_size += SSIZE_OF(sw);
 
 	compiler->local_size = (local_size + SLJIT_LOCALS_OFFSET + 15) & ~0xf;
-#else
-	local_size += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
-	compiler->local_size = (local_size + SLJIT_LOCALS_OFFSET + 31) & ~0x1f;
-#endif
 	return SLJIT_SUCCESS;
 }
 
-static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler, sljit_s32 frame_size, sljit_ins *ins_ptr)
+static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler, sljit_s32 is_return_to)
 {
-	sljit_s32 local_size, i, tmp, offset;
-	sljit_s32 scratches = compiler->scratches;
-	sljit_s32 saveds = compiler->saveds;
-	sljit_s32 fsaveds = compiler->fsaveds;
-	sljit_s32 fscratches = compiler->fscratches;
-
-	local_size = compiler->local_size;
+	sljit_s32 i, tmp, base, offset;
+	sljit_s32 local_size = compiler->local_size;
 
-	tmp = GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1);
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-	if (fsaveds > 0 || fscratches >= SLJIT_FIRST_SAVED_FLOAT_REG) {
-		if ((tmp & SSIZE_OF(sw)) != 0)
-			tmp += SSIZE_OF(sw);
-		tmp += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
+	base = SLJIT_SP;
+	if (local_size > STACK_MAX_DISTANCE) {
+		base = TMP_REG1;
+		if (local_size > 2 * STACK_MAX_DISTANCE + LR_SAVE_OFFSET) {
+			FAIL_IF(push_inst(compiler, STACK_LOAD | D(base) | A(SLJIT_SP) | IMM(0)));
+			local_size = 0;
+		} else {
+			FAIL_IF(push_inst(compiler, ADDI | D(TMP_REG1) | A(SLJIT_SP) | IMM(local_size - STACK_MAX_DISTANCE)));
+			local_size = STACK_MAX_DISTANCE;
+		}
 	}
-#else
-	tmp += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
-#endif
 
-	if (local_size <= SIMM_MAX) {
-		if (local_size < frame_size) {
-			FAIL_IF(push_inst(compiler, ADDIU_W | S(SLJIT_SP) | T(SLJIT_SP) | IMM(local_size - frame_size), DR(SLJIT_SP)));
-			local_size = frame_size;
-		}
-	} else {
-		if (tmp < frame_size)
-			tmp = frame_size;
+	offset = local_size;
+	if (!is_return_to)
+		FAIL_IF(push_inst(compiler, STACK_LOAD | S(0) | A(base) | IMM(offset + LR_SAVE_OFFSET)));
 
-		FAIL_IF(load_immediate(compiler, DR(TMP_REG1), local_size - tmp));
-		FAIL_IF(push_inst(compiler, ADDU_W | S(SLJIT_SP) | T(TMP_REG1) | D(SLJIT_SP), DR(SLJIT_SP)));
-		local_size = tmp;
+	tmp = SLJIT_FS0 - compiler->fsaveds;
+	for (i = SLJIT_FS0; i > tmp; i--) {
+		offset -= SSIZE_OF(f64);
+		FAIL_IF(push_inst(compiler, LFD | FS(i) | A(base) | IMM(offset)));
 	}
 
-	SLJIT_ASSERT(local_size >= frame_size);
-
-	offset = local_size - SSIZE_OF(sw);
-	if (frame_size == 0)
-		FAIL_IF(push_inst(compiler, STACK_LOAD | S(SLJIT_SP) | TA(RETURN_ADDR_REG) | IMM(offset), RETURN_ADDR_REG));
+	for (i = compiler->fscratches; i >= SLJIT_FIRST_SAVED_FLOAT_REG; i--) {
+		offset -= SSIZE_OF(f64);
+		FAIL_IF(push_inst(compiler, LFD | FS(i) | A(base) | IMM(offset)));
+	}
 
-	tmp = SLJIT_S0 - saveds;
-	for (i = SLJIT_S0; i > tmp; i--) {
+	if (!(compiler->options & SLJIT_ENTER_REG_ARG)) {
 		offset -= SSIZE_OF(sw);
-		FAIL_IF(push_inst(compiler, STACK_LOAD | S(SLJIT_SP) | T(i) | IMM(offset), MOVABLE_INS));
+		FAIL_IF(push_inst(compiler, STACK_LOAD | S(TMP_ZERO) | A(base) | IMM(offset)));
 	}
 
-	for (i = scratches; i >= SLJIT_FIRST_SAVED_REG; i--) {
+	tmp = SLJIT_S0 - compiler->saveds;
+	for (i = SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options); i > tmp; i--) {
 		offset -= SSIZE_OF(sw);
-		FAIL_IF(push_inst(compiler, STACK_LOAD | S(SLJIT_SP) | T(i) | IMM(offset), MOVABLE_INS));
+		FAIL_IF(push_inst(compiler, STACK_LOAD | S(i) | A(base) | IMM(offset)));
 	}
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-	/* This alignment is valid because offset is not used after storing FPU regs. */
-	if ((offset & SSIZE_OF(sw)) != 0)
+	for (i = compiler->scratches; i >= SLJIT_FIRST_SAVED_REG; i--) {
 		offset -= SSIZE_OF(sw);
-#endif
-
-	tmp = SLJIT_FS0 - fsaveds;
-	for (i = SLJIT_FS0; i > tmp; i--) {
-		offset -= SSIZE_OF(f64);
-		FAIL_IF(push_inst(compiler, LDC1 | S(SLJIT_SP) | FT(i) | IMM(offset), MOVABLE_INS));
+		FAIL_IF(push_inst(compiler, STACK_LOAD | S(i) | A(base) | IMM(offset)));
 	}
 
-	for (i = fscratches; i >= SLJIT_FIRST_SAVED_FLOAT_REG; i--) {
-		offset -= SSIZE_OF(f64);
-		FAIL_IF(push_inst(compiler, LDC1 | S(SLJIT_SP) | FT(i) | IMM(offset), MOVABLE_INS));
-	}
+	if (!is_return_to)
+		push_inst(compiler, MTLR | S(0));
 
-	if (local_size > frame_size)
-		*ins_ptr = ADDIU_W | S(SLJIT_SP) | T(SLJIT_SP) | IMM(local_size - frame_size);
-	else
-		*ins_ptr = NOP;
+	if (local_size > 0)
+		return push_inst(compiler, ADDI | D(SLJIT_SP) | A(base) | IMM(local_size));
 
-	return SLJIT_SUCCESS;
+	SLJIT_ASSERT(base == TMP_REG1);
+	return push_inst(compiler, OR | S(base) | A(SLJIT_SP) | B(base));
 }
 
+#undef STACK_STORE
+#undef STACK_LOAD
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_void(struct sljit_compiler *compiler)
 {
-	sljit_ins ins;
-
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_return_void(compiler));
 
-	emit_stack_frame_release(compiler, 0, &ins);
-
-	FAIL_IF(push_inst(compiler, JR | SA(RETURN_ADDR_REG), UNMOVABLE_INS));
-	return push_inst(compiler, ins, UNMOVABLE_INS);
+	FAIL_IF(emit_stack_frame_release(compiler, 0));
+	return push_inst(compiler, BLR);
 }
 
-#undef STACK_STORE
-#undef STACK_LOAD
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_to(struct sljit_compiler *compiler,
+	sljit_s32 src, sljit_sw srcw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_return_to(compiler, src, srcw));
+
+	if (src & SLJIT_MEM) {
+		ADJUST_LOCAL_OFFSET(src, srcw);
+		FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, TMP_CALL_REG, src, srcw, TMP_CALL_REG));
+		src = TMP_CALL_REG;
+		srcw = 0;
+	} else if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
+		FAIL_IF(push_inst(compiler, OR | S(src) | A(TMP_CALL_REG) | B(src)));
+		src = TMP_CALL_REG;
+		srcw = 0;
+	}
+
+	FAIL_IF(emit_stack_frame_release(compiler, 1));
+
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_ijump(compiler, SLJIT_JUMP, src, srcw);
+}
 
 /* --------------------------------------------------------------------- */
 /*  Operators                                                            */
 /* --------------------------------------------------------------------- */
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
+/* s/l - store/load (1 bit)
+   i/x - immediate/indexed form
+   u/s - signed/unsigned (1 bit)
+   w/b/h/i - word/byte/half/int allowed (2 bit)
+
+   Some opcodes are repeated (e.g. store signed / unsigned byte is the same instruction). */
+
+/* 64 bit only: [reg+imm] must be aligned to 4 bytes. */
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#define INT_ALIGNED	0x10000
+#endif
+
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
 #define ARCH_32_64(a, b)	a
+#define INST_CODE_AND_DST(inst, flags, reg) \
+	((sljit_ins)(inst) | (sljit_ins)(((flags) & MEM_MASK) <= GPR_REG ? D(reg) : FD(reg)))
 #else
 #define ARCH_32_64(a, b)	b
+#define INST_CODE_AND_DST(inst, flags, reg) \
+	(((sljit_ins)(inst) & ~(sljit_ins)INT_ALIGNED) | (sljit_ins)(((flags) & MEM_MASK) <= GPR_REG ? D(reg) : FD(reg)))
 #endif
 
-static const sljit_ins data_transfer_insts[16 + 4] = {
-/* u w s */ ARCH_32_64(HI(43) /* sw */, HI(63) /* sd */),
-/* u w l */ ARCH_32_64(HI(35) /* lw */, HI(55) /* ld */),
-/* u b s */ HI(40) /* sb */,
-/* u b l */ HI(36) /* lbu */,
-/* u h s */ HI(41) /* sh */,
-/* u h l */ HI(37) /* lhu */,
-/* u i s */ HI(43) /* sw */,
-/* u i l */ ARCH_32_64(HI(35) /* lw */, HI(39) /* lwu */),
-
-/* s w s */ ARCH_32_64(HI(43) /* sw */, HI(63) /* sd */),
-/* s w l */ ARCH_32_64(HI(35) /* lw */, HI(55) /* ld */),
-/* s b s */ HI(40) /* sb */,
-/* s b l */ HI(32) /* lb */,
-/* s h s */ HI(41) /* sh */,
-/* s h l */ HI(33) /* lh */,
-/* s i s */ HI(43) /* sw */,
-/* s i l */ HI(35) /* lw */,
-
-/* d   s */ HI(61) /* sdc1 */,
-/* d   l */ HI(53) /* ldc1 */,
-/* s   s */ HI(57) /* swc1 */,
-/* s   l */ HI(49) /* lwc1 */,
-};
+static const sljit_ins data_transfer_insts[64 + 16] = {
 
-#undef ARCH_32_64
+/* -------- Integer -------- */
 
-/* reg_ar is an absoulute register! */
+/* Word. */
 
-/* Can perform an operation using at most 1 instruction. */
-static sljit_s32 getput_arg_fast(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg_ar, sljit_s32 arg, sljit_sw argw)
-{
-	SLJIT_ASSERT(arg & SLJIT_MEM);
+/* w u i s */ ARCH_32_64(HI(36) /* stw */, HI(62) | INT_ALIGNED | 0x0 /* std */),
+/* w u i l */ ARCH_32_64(HI(32) /* lwz */, HI(58) | INT_ALIGNED | 0x0 /* ld */),
+/* w u x s */ ARCH_32_64(HI(31) | LO(151) /* stwx */, HI(31) | LO(149) /* stdx */),
+/* w u x l */ ARCH_32_64(HI(31) | LO(23) /* lwzx */, HI(31) | LO(21) /* ldx */),
 
-	if (!(arg & OFFS_REG_MASK) && argw <= SIMM_MAX && argw >= SIMM_MIN) {
-		/* Works for both absoulte and relative addresses. */
-		if (SLJIT_UNLIKELY(flags & ARG_TEST))
-			return 1;
-		FAIL_IF(push_inst(compiler, data_transfer_insts[flags & MEM_MASK] | S(arg & REG_MASK)
-			| TA(reg_ar) | IMM(argw), ((flags & MEM_MASK) <= GPR_REG && (flags & LOAD_DATA)) ? reg_ar : MOVABLE_INS));
-		return -1;
-	}
-	return 0;
-}
+/* w s i s */ ARCH_32_64(HI(36) /* stw */, HI(62) | INT_ALIGNED | 0x0 /* std */),
+/* w s i l */ ARCH_32_64(HI(32) /* lwz */, HI(58) | INT_ALIGNED | 0x0 /* ld */),
+/* w s x s */ ARCH_32_64(HI(31) | LO(151) /* stwx */, HI(31) | LO(149) /* stdx */),
+/* w s x l */ ARCH_32_64(HI(31) | LO(23) /* lwzx */, HI(31) | LO(21) /* ldx */),
 
-/* See getput_arg below.
-   Note: can_cache is called only for binary operators. Those
-   operators always uses word arguments without write back. */
-static sljit_s32 can_cache(sljit_s32 arg, sljit_sw argw, sljit_s32 next_arg, sljit_sw next_argw)
-{
-	SLJIT_ASSERT((arg & SLJIT_MEM) && (next_arg & SLJIT_MEM));
+/* Byte. */
 
-	/* Simple operation except for updates. */
-	if (arg & OFFS_REG_MASK) {
-		argw &= 0x3;
-		next_argw &= 0x3;
-		if (argw && argw == next_argw && (arg == next_arg || (arg & OFFS_REG_MASK) == (next_arg & OFFS_REG_MASK)))
-			return 1;
-		return 0;
-	}
+/* b u i s */ HI(38) /* stb */,
+/* b u i l */ HI(34) /* lbz */,
+/* b u x s */ HI(31) | LO(215) /* stbx */,
+/* b u x l */ HI(31) | LO(87) /* lbzx */,
 
-	if (arg == next_arg) {
-		if (((next_argw - argw) <= SIMM_MAX && (next_argw - argw) >= SIMM_MIN))
-			return 1;
-		return 0;
-	}
+/* b s i s */ HI(38) /* stb */,
+/* b s i l */ HI(34) /* lbz */ /* EXTS_REQ */,
+/* b s x s */ HI(31) | LO(215) /* stbx */,
+/* b s x l */ HI(31) | LO(87) /* lbzx */ /* EXTS_REQ */,
 
-	return 0;
-}
+/* Half. */
 
-/* Emit the necessary instructions. See can_cache above. */
-static sljit_s32 getput_arg(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg_ar, sljit_s32 arg, sljit_sw argw, sljit_s32 next_arg, sljit_sw next_argw)
-{
-	sljit_s32 tmp_ar, base, delay_slot;
+/* h u i s */ HI(44) /* sth */,
+/* h u i l */ HI(40) /* lhz */,
+/* h u x s */ HI(31) | LO(407) /* sthx */,
+/* h u x l */ HI(31) | LO(279) /* lhzx */,
 
-	SLJIT_ASSERT(arg & SLJIT_MEM);
-	if (!(next_arg & SLJIT_MEM)) {
-		next_arg = 0;
-		next_argw = 0;
-	}
+/* h s i s */ HI(44) /* sth */,
+/* h s i l */ HI(42) /* lha */,
+/* h s x s */ HI(31) | LO(407) /* sthx */,
+/* h s x l */ HI(31) | LO(343) /* lhax */,
 
-	if ((flags & MEM_MASK) <= GPR_REG && (flags & LOAD_DATA)) {
-		tmp_ar = reg_ar;
-		delay_slot = reg_ar;
-	}
-	else {
-		tmp_ar = DR(TMP_REG1);
-		delay_slot = MOVABLE_INS;
-	}
-	base = arg & REG_MASK;
+/* Int. */
 
-	if (SLJIT_UNLIKELY(arg & OFFS_REG_MASK)) {
-		argw &= 0x3;
+/* i u i s */ HI(36) /* stw */,
+/* i u i l */ HI(32) /* lwz */,
+/* i u x s */ HI(31) | LO(151) /* stwx */,
+/* i u x l */ HI(31) | LO(23) /* lwzx */,
 
-		/* Using the cache. */
-		if (argw == compiler->cache_argw) {
-			if (arg == compiler->cache_arg)
-				return push_inst(compiler, data_transfer_insts[flags & MEM_MASK] | S(TMP_REG3) | TA(reg_ar), delay_slot);
-
-			if ((SLJIT_MEM | (arg & OFFS_REG_MASK)) == compiler->cache_arg) {
-				if (arg == next_arg && argw == (next_argw & 0x3)) {
-					compiler->cache_arg = arg;
-					compiler->cache_argw = argw;
-					FAIL_IF(push_inst(compiler, ADDU_W | S(base) | T(TMP_REG3) | D(TMP_REG3), DR(TMP_REG3)));
-					return push_inst(compiler, data_transfer_insts[flags & MEM_MASK] | S(TMP_REG3) | TA(reg_ar), delay_slot);
-				}
-				FAIL_IF(push_inst(compiler, ADDU_W | S(base) | T(TMP_REG3) | DA(tmp_ar), tmp_ar));
-				return push_inst(compiler, data_transfer_insts[flags & MEM_MASK] | SA(tmp_ar) | TA(reg_ar), delay_slot);
-			}
-		}
+/* i s i s */ HI(36) /* stw */,
+/* i s i l */ ARCH_32_64(HI(32) /* lwz */, HI(58) | INT_ALIGNED | 0x2 /* lwa */),
+/* i s x s */ HI(31) | LO(151) /* stwx */,
+/* i s x l */ ARCH_32_64(HI(31) | LO(23) /* lwzx */, HI(31) | LO(341) /* lwax */),
 
-		if (SLJIT_UNLIKELY(argw)) {
-			compiler->cache_arg = SLJIT_MEM | (arg & OFFS_REG_MASK);
-			compiler->cache_argw = argw;
-			FAIL_IF(push_inst(compiler, SLL_W | T(OFFS_REG(arg)) | D(TMP_REG3) | SH_IMM(argw), DR(TMP_REG3)));
-		}
+/* -------- Floating point -------- */
 
-		if (arg == next_arg && argw == (next_argw & 0x3)) {
-			compiler->cache_arg = arg;
-			compiler->cache_argw = argw;
-			FAIL_IF(push_inst(compiler, ADDU_W | S(base) | T(!argw ? OFFS_REG(arg) : TMP_REG3) | D(TMP_REG3), DR(TMP_REG3)));
-			tmp_ar = DR(TMP_REG3);
-		}
-		else
-			FAIL_IF(push_inst(compiler, ADDU_W | S(base) | T(!argw ? OFFS_REG(arg) : TMP_REG3) | DA(tmp_ar), tmp_ar));
-		return push_inst(compiler, data_transfer_insts[flags & MEM_MASK] | SA(tmp_ar) | TA(reg_ar), delay_slot);
-	}
+/* d   i s */ HI(54) /* stfd */,
+/* d   i l */ HI(50) /* lfd */,
+/* d   x s */ HI(31) | LO(727) /* stfdx */,
+/* d   x l */ HI(31) | LO(599) /* lfdx */,
 
-	if (compiler->cache_arg == arg && argw - compiler->cache_argw <= SIMM_MAX && argw - compiler->cache_argw >= SIMM_MIN) {
-		if (argw != compiler->cache_argw) {
-			FAIL_IF(push_inst(compiler, ADDIU_W | S(TMP_REG3) | T(TMP_REG3) | IMM(argw - compiler->cache_argw), DR(TMP_REG3)));
-			compiler->cache_argw = argw;
-		}
-		return push_inst(compiler, data_transfer_insts[flags & MEM_MASK] | S(TMP_REG3) | TA(reg_ar), delay_slot);
-	}
+/* s   i s */ HI(52) /* stfs */,
+/* s   i l */ HI(48) /* lfs */,
+/* s   x s */ HI(31) | LO(663) /* stfsx */,
+/* s   x l */ HI(31) | LO(535) /* lfsx */,
+};
 
-	if (compiler->cache_arg == SLJIT_MEM && argw - compiler->cache_argw <= SIMM_MAX && argw - compiler->cache_argw >= SIMM_MIN) {
-		if (argw != compiler->cache_argw)
-			FAIL_IF(push_inst(compiler, ADDIU_W | S(TMP_REG3) | T(TMP_REG3) | IMM(argw - compiler->cache_argw), DR(TMP_REG3)));
-	}
-	else {
-		compiler->cache_arg = SLJIT_MEM;
-		FAIL_IF(load_immediate(compiler, DR(TMP_REG3), argw));
-	}
-	compiler->cache_argw = argw;
+static const sljit_ins updated_data_transfer_insts[64] = {
 
-	if (!base)
-		return push_inst(compiler, data_transfer_insts[flags & MEM_MASK] | S(TMP_REG3) | TA(reg_ar), delay_slot);
+/* -------- Integer -------- */
 
-	if (arg == next_arg && next_argw - argw <= SIMM_MAX && next_argw - argw >= SIMM_MIN) {
-		compiler->cache_arg = arg;
-		FAIL_IF(push_inst(compiler, ADDU_W | S(TMP_REG3) | T(base) | D(TMP_REG3), DR(TMP_REG3)));
-		return push_inst(compiler, data_transfer_insts[flags & MEM_MASK] | S(TMP_REG3) | TA(reg_ar), delay_slot);
-	}
+/* Word. */
 
-	FAIL_IF(push_inst(compiler, ADDU_W | S(TMP_REG3) | T(base) | DA(tmp_ar), tmp_ar));
-	return push_inst(compiler, data_transfer_insts[flags & MEM_MASK] | SA(tmp_ar) | TA(reg_ar), delay_slot);
-}
+/* w u i s */ ARCH_32_64(HI(37) /* stwu */, HI(62) | INT_ALIGNED | 0x1 /* stdu */),
+/* w u i l */ ARCH_32_64(HI(33) /* lwzu */, HI(58) | INT_ALIGNED | 0x1 /* ldu */),
+/* w u x s */ ARCH_32_64(HI(31) | LO(183) /* stwux */, HI(31) | LO(181) /* stdux */),
+/* w u x l */ ARCH_32_64(HI(31) | LO(55) /* lwzux */, HI(31) | LO(53) /* ldux */),
 
-static sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg_ar, sljit_s32 arg, sljit_sw argw)
-{
-	sljit_s32 tmp_ar, base, delay_slot;
+/* w s i s */ ARCH_32_64(HI(37) /* stwu */, HI(62) | INT_ALIGNED | 0x1 /* stdu */),
+/* w s i l */ ARCH_32_64(HI(33) /* lwzu */, HI(58) | INT_ALIGNED | 0x1 /* ldu */),
+/* w s x s */ ARCH_32_64(HI(31) | LO(183) /* stwux */, HI(31) | LO(181) /* stdux */),
+/* w s x l */ ARCH_32_64(HI(31) | LO(55) /* lwzux */, HI(31) | LO(53) /* ldux */),
 
-	if (getput_arg_fast(compiler, flags, reg_ar, arg, argw))
-		return compiler->error;
+/* Byte. */
 
-	if ((flags & MEM_MASK) <= GPR_REG && (flags & LOAD_DATA)) {
-		tmp_ar = reg_ar;
-		delay_slot = reg_ar;
-	}
-	else {
-		tmp_ar = DR(TMP_REG1);
-		delay_slot = MOVABLE_INS;
-	}
-	base = arg & REG_MASK;
+/* b u i s */ HI(39) /* stbu */,
+/* b u i l */ HI(35) /* lbzu */,
+/* b u x s */ HI(31) | LO(247) /* stbux */,
+/* b u x l */ HI(31) | LO(119) /* lbzux */,
+
+/* b s i s */ HI(39) /* stbu */,
+/* b s i l */ 0 /* no such instruction */,
+/* b s x s */ HI(31) | LO(247) /* stbux */,
+/* b s x l */ 0 /* no such instruction */,
+
+/* Half. */
+
+/* h u i s */ HI(45) /* sthu */,
+/* h u i l */ HI(41) /* lhzu */,
+/* h u x s */ HI(31) | LO(439) /* sthux */,
+/* h u x l */ HI(31) | LO(311) /* lhzux */,
+
+/* h s i s */ HI(45) /* sthu */,
+/* h s i l */ HI(43) /* lhau */,
+/* h s x s */ HI(31) | LO(439) /* sthux */,
+/* h s x l */ HI(31) | LO(375) /* lhaux */,
+
+/* Int. */
+
+/* i u i s */ HI(37) /* stwu */,
+/* i u i l */ HI(33) /* lwzu */,
+/* i u x s */ HI(31) | LO(183) /* stwux */,
+/* i u x l */ HI(31) | LO(55) /* lwzux */,
+
+/* i s i s */ HI(37) /* stwu */,
+/* i s i l */ ARCH_32_64(HI(33) /* lwzu */, 0 /* no such instruction */),
+/* i s x s */ HI(31) | LO(183) /* stwux */,
+/* i s x l */ ARCH_32_64(HI(31) | LO(55) /* lwzux */, HI(31) | LO(373) /* lwaux */),
+
+/* -------- Floating point -------- */
+
+/* d   i s */ HI(55) /* stfdu */,
+/* d   i l */ HI(51) /* lfdu */,
+/* d   x s */ HI(31) | LO(759) /* stfdux */,
+/* d   x l */ HI(31) | LO(631) /* lfdux */,
+
+/* s   i s */ HI(53) /* stfsu */,
+/* s   i l */ HI(49) /* lfsu */,
+/* s   x s */ HI(31) | LO(695) /* stfsux */,
+/* s   x l */ HI(31) | LO(567) /* lfsux */,
+};
+
+#undef ARCH_32_64
+
+/* Simple cases, (no caching is required). */
+static sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 inp_flags, sljit_s32 reg,
+	sljit_s32 arg, sljit_sw argw, sljit_s32 tmp_reg)
+{
+	sljit_ins inst;
+	sljit_s32 offs_reg;
+
+	/* Should work when (arg & REG_MASK) == 0. */
+	SLJIT_ASSERT(A(0) == 0);
+	SLJIT_ASSERT(arg & SLJIT_MEM);
 
 	if (SLJIT_UNLIKELY(arg & OFFS_REG_MASK)) {
 		argw &= 0x3;
+		offs_reg = OFFS_REG(arg);
 
-		if (SLJIT_UNLIKELY(argw)) {
-			FAIL_IF(push_inst(compiler, SLL_W | T(OFFS_REG(arg)) | DA(tmp_ar) | SH_IMM(argw), tmp_ar));
-			FAIL_IF(push_inst(compiler, ADDU_W | S(base) | TA(tmp_ar) | DA(tmp_ar), tmp_ar));
+		if (argw != 0) {
+			FAIL_IF(push_inst(compiler, SLWI_W(argw) | S(OFFS_REG(arg)) | A(tmp_reg)));
+			offs_reg = tmp_reg;
 		}
-		else
-			FAIL_IF(push_inst(compiler, ADDU_W | S(base) | T(OFFS_REG(arg)) | DA(tmp_ar), tmp_ar));
-		return push_inst(compiler, data_transfer_insts[flags & MEM_MASK] | SA(tmp_ar) | TA(reg_ar), delay_slot);
+
+		inst = data_transfer_insts[(inp_flags | INDEXED) & MEM_MASK];
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+		SLJIT_ASSERT(!(inst & INT_ALIGNED));
+#endif /* SLJIT_CONFIG_PPC_64 */
+
+		return push_inst(compiler, INST_CODE_AND_DST(inst, inp_flags, reg) | A(arg & REG_MASK) | B(offs_reg));
 	}
 
-	FAIL_IF(load_immediate(compiler, tmp_ar, argw));
+	inst = data_transfer_insts[inp_flags & MEM_MASK];
+	arg &= REG_MASK;
 
-	if (base != 0)
-		FAIL_IF(push_inst(compiler, ADDU_W | S(base) | TA(tmp_ar) | DA(tmp_ar), tmp_ar));
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	if ((inst & INT_ALIGNED) && (argw & 0x3) != 0) {
+		FAIL_IF(load_immediate(compiler, tmp_reg, argw));
 
-	return push_inst(compiler, data_transfer_insts[flags & MEM_MASK] | SA(tmp_ar) | TA(reg_ar), delay_slot);
-}
+		inst = data_transfer_insts[(inp_flags | INDEXED) & MEM_MASK];
+		return push_inst(compiler, INST_CODE_AND_DST(inst, inp_flags, reg) | A(arg) | B(tmp_reg));
+	}
+#endif /* SLJIT_CONFIG_PPC_64 */
 
-static SLJIT_INLINE sljit_s32 emit_op_mem2(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg, sljit_s32 arg1, sljit_sw arg1w, sljit_s32 arg2, sljit_sw arg2w)
-{
-	if (getput_arg_fast(compiler, flags, reg, arg1, arg1w))
-		return compiler->error;
-	return getput_arg(compiler, flags, reg, arg1, arg1w, arg2, arg2w);
+	if (argw <= SIMM_MAX && argw >= SIMM_MIN)
+		return push_inst(compiler, INST_CODE_AND_DST(inst, inp_flags, reg) | A(arg) | IMM(argw));
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	if (argw <= 0x7fff7fffl && argw >= -0x80000000l) {
+#endif /* SLJIT_CONFIG_PPC_64 */
+		FAIL_IF(push_inst(compiler, ADDIS | D(tmp_reg) | A(arg) | IMM((argw + 0x8000) >> 16)));
+		return push_inst(compiler, INST_CODE_AND_DST(inst, inp_flags, reg) | A(tmp_reg) | IMM(argw));
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	}
+
+	FAIL_IF(load_immediate(compiler, tmp_reg, argw));
+
+	inst = data_transfer_insts[(inp_flags | INDEXED) & MEM_MASK];
+	return push_inst(compiler, INST_CODE_AND_DST(inst, inp_flags, reg) | A(arg) | B(tmp_reg));
+#endif /* SLJIT_CONFIG_PPC_64 */
 }
 
-static sljit_s32 emit_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 flags,
+static sljit_s32 emit_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 input_flags,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 	/* arg1 goes to TMP_REG1 or src reg
 	   arg2 goes to TMP_REG2, imm or src reg
-	   TMP_REG3 can be used for caching
-	   result goes to TMP_REG2, so put result can use TMP_REG1 and TMP_REG3. */
+	   result goes to TMP_REG2, so put result can use TMP_REG1. */
 	sljit_s32 dst_r = TMP_REG2;
 	sljit_s32 src1_r;
-	sljit_sw src2_r = 0;
+	sljit_s32 src2_r;
 	sljit_s32 sugg_src2_r = TMP_REG2;
+	sljit_s32 flags = input_flags & (ALT_FORM1 | ALT_FORM2 | ALT_FORM3 | ALT_FORM4 | ALT_FORM5 | ALT_SIGN_EXT | ALT_SET_FLAGS);
 
-	if (!(flags & ALT_KEEP_CACHE)) {
-		compiler->cache_arg = 0;
-		compiler->cache_argw = 0;
-	}
-
-	if (dst == TMP_REG2) {
-		SLJIT_ASSERT(HAS_FLAGS(op));
-		flags |= UNUSED_DEST;
-	}
-	else if (FAST_IS_REG(dst)) {
+	/* Destination check. */
+	if (FAST_IS_REG(dst)) {
 		dst_r = dst;
+		/* The REG_DEST is only used by SLJIT_MOV operations, although
+		 * it is set for op2 operations with unset destination. */
 		flags |= REG_DEST;
-		if (flags & MOVE_OP)
-			sugg_src2_r = dst_r;
-	}
-	else if ((dst & SLJIT_MEM) && !getput_arg_fast(compiler, flags | ARG_TEST, DR(TMP_REG1), dst, dstw))
-		flags |= SLOW_DEST;
 
-	if (flags & IMM_OP) {
-		if ((src2 & SLJIT_IMM) && src2w) {
-			if ((!(flags & LOGICAL_OP) && (src2w <= SIMM_MAX && src2w >= SIMM_MIN))
-				|| ((flags & LOGICAL_OP) && !(src2w & ~UIMM_MAX))) {
-				flags |= SRC2_IMM;
-				src2_r = src2w;
-			}
-		}
-		if (!(flags & SRC2_IMM) && (flags & CUMULATIVE_OP) && (src1 & SLJIT_IMM) && src1w) {
-			if ((!(flags & LOGICAL_OP) && (src1w <= SIMM_MAX && src1w >= SIMM_MIN))
-				|| ((flags & LOGICAL_OP) && !(src1w & ~UIMM_MAX))) {
-				flags |= SRC2_IMM;
-				src2_r = src1w;
-
-				/* And swap arguments. */
-				src1 = src2;
-				src1w = src2w;
-				src2 = SLJIT_IMM;
-				/* src2w = src2_r unneeded. */
-			}
-		}
+		if (op >= SLJIT_MOV && op <= SLJIT_MOV_P)
+			sugg_src2_r = dst_r;
 	}
 
 	/* Source 1. */
 	if (FAST_IS_REG(src1)) {
 		src1_r = src1;
 		flags |= REG1_SOURCE;
 	}
 	else if (src1 & SLJIT_IMM) {
-		if (src1w) {
-			FAIL_IF(load_immediate(compiler, DR(TMP_REG1), src1w));
+		src1_r = TMP_ZERO;
+		if (src1w != 0) {
+			FAIL_IF(load_immediate(compiler, TMP_REG1, src1w));
 			src1_r = TMP_REG1;
 		}
-		else
-			src1_r = 0;
 	}
 	else {
-		if (getput_arg_fast(compiler, flags | LOAD_DATA, DR(TMP_REG1), src1, src1w))
-			FAIL_IF(compiler->error);
-		else
-			flags |= SLOW_SRC1;
+		FAIL_IF(emit_op_mem(compiler, input_flags | LOAD_DATA, TMP_REG1, src1, src1w, TMP_REG1));
 		src1_r = TMP_REG1;
 	}
 
 	/* Source 2. */
 	if (FAST_IS_REG(src2)) {
 		src2_r = src2;
 		flags |= REG2_SOURCE;
-		if ((flags & (REG_DEST | MOVE_OP)) == MOVE_OP)
-			dst_r = (sljit_s32)src2_r;
+
+		if (!(flags & REG_DEST) && op >= SLJIT_MOV && op <= SLJIT_MOV_P)
+			dst_r = src2_r;
 	}
 	else if (src2 & SLJIT_IMM) {
-		if (!(flags & SRC2_IMM)) {
-			if (src2w) {
-				FAIL_IF(load_immediate(compiler, DR(sugg_src2_r), src2w));
-				src2_r = sugg_src2_r;
-			}
-			else {
-				src2_r = 0;
-				if (flags & MOVE_OP) {
-					if (dst & SLJIT_MEM)
-						dst_r = 0;
-					else
-						op = SLJIT_MOV;
-				}
-			}
+		src2_r = TMP_ZERO;
+		if (src2w != 0) {
+			FAIL_IF(load_immediate(compiler, sugg_src2_r, src2w));
+			src2_r = sugg_src2_r;
 		}
 	}
 	else {
-		if (getput_arg_fast(compiler, flags | LOAD_DATA, DR(sugg_src2_r), src2, src2w))
-			FAIL_IF(compiler->error);
-		else
-			flags |= SLOW_SRC2;
+		FAIL_IF(emit_op_mem(compiler, input_flags | LOAD_DATA, sugg_src2_r, src2, src2w, TMP_REG2));
 		src2_r = sugg_src2_r;
 	}
 
-	if ((flags & (SLOW_SRC1 | SLOW_SRC2)) == (SLOW_SRC1 | SLOW_SRC2)) {
-		SLJIT_ASSERT(src2_r == TMP_REG2);
-		if (!can_cache(src1, src1w, src2, src2w) && can_cache(src1, src1w, dst, dstw)) {
-			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, DR(TMP_REG2), src2, src2w, src1, src1w));
-			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, DR(TMP_REG1), src1, src1w, dst, dstw));
-		}
-		else {
-			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, DR(TMP_REG1), src1, src1w, src2, src2w));
-			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, DR(TMP_REG2), src2, src2w, dst, dstw));
-		}
-	}
-	else if (flags & SLOW_SRC1)
-		FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, DR(TMP_REG1), src1, src1w, dst, dstw));
-	else if (flags & SLOW_SRC2)
-		FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, DR(sugg_src2_r), src2, src2w, dst, dstw));
-
 	FAIL_IF(emit_single_op(compiler, op, flags, dst_r, src1_r, src2_r));
 
-	if (dst & SLJIT_MEM) {
-		if (!(flags & SLOW_DEST)) {
-			getput_arg_fast(compiler, flags, DR(dst_r), dst, dstw);
-			return compiler->error;
-		}
-		return getput_arg(compiler, flags, DR(dst_r), dst, dstw, 0, 0);
-	}
+	if (!(dst & SLJIT_MEM))
+		return SLJIT_SUCCESS;
 
-	return SLJIT_SUCCESS;
+	return emit_op_mem(compiler, input_flags, dst_r, dst, dstw, TMP_REG1);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op0(struct sljit_compiler *compiler, sljit_s32 op)
 {
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
 	sljit_s32 int_op = op & SLJIT_32;
 #endif
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op0(compiler, op));
 
 	op = GET_OPCODE(op);
 	switch (op) {
 	case SLJIT_BREAKPOINT:
-		return push_inst(compiler, BREAK, UNMOVABLE_INS);
 	case SLJIT_NOP:
-		return push_inst(compiler, NOP, UNMOVABLE_INS);
+		return push_inst(compiler, NOP);
 	case SLJIT_LMUL_UW:
 	case SLJIT_LMUL_SW:
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
-		FAIL_IF(push_inst(compiler, (op == SLJIT_LMUL_UW ? DMULU : DMUL) | S(SLJIT_R0) | T(SLJIT_R1) | D(TMP_REG3), DR(TMP_REG3)));
-		FAIL_IF(push_inst(compiler, (op == SLJIT_LMUL_UW ? DMUHU : DMUH) | S(SLJIT_R0) | T(SLJIT_R1) | D(TMP_REG1), DR(TMP_REG1)));
-#else /* !SLJIT_CONFIG_MIPS_64 */
-		FAIL_IF(push_inst(compiler, (op == SLJIT_LMUL_UW ? MULU : MUL) | S(SLJIT_R0) | T(SLJIT_R1) | D(TMP_REG3), DR(TMP_REG3)));
-		FAIL_IF(push_inst(compiler, (op == SLJIT_LMUL_UW ? MUHU : MUH) | S(SLJIT_R0) | T(SLJIT_R1) | D(TMP_REG1), DR(TMP_REG1)));
-#endif /* SLJIT_CONFIG_MIPS_64 */
-		FAIL_IF(push_inst(compiler, ADDU_W | S(TMP_REG3) | TA(0) | D(SLJIT_R0), DR(SLJIT_R0)));
-		return push_inst(compiler, ADDU_W | S(TMP_REG1) | TA(0) | D(SLJIT_R1), DR(SLJIT_R1));
-#else /* SLJIT_MIPS_REV < 6 */
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
-		FAIL_IF(push_inst(compiler, (op == SLJIT_LMUL_UW ? DMULTU : DMULT) | S(SLJIT_R0) | T(SLJIT_R1), MOVABLE_INS));
-#else /* !SLJIT_CONFIG_MIPS_64 */
-		FAIL_IF(push_inst(compiler, (op == SLJIT_LMUL_UW ? MULTU : MULT) | S(SLJIT_R0) | T(SLJIT_R1), MOVABLE_INS));
-#endif /* SLJIT_CONFIG_MIPS_64 */
-		FAIL_IF(push_inst(compiler, MFLO | D(SLJIT_R0), DR(SLJIT_R0)));
-		return push_inst(compiler, MFHI | D(SLJIT_R1), DR(SLJIT_R1));
-#endif /* SLJIT_MIPS_REV >= 6 */
+		FAIL_IF(push_inst(compiler, OR | S(SLJIT_R0) | A(TMP_REG1) | B(SLJIT_R0)));
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+		FAIL_IF(push_inst(compiler, MULLD | D(SLJIT_R0) | A(TMP_REG1) | B(SLJIT_R1)));
+		return push_inst(compiler, (op == SLJIT_LMUL_UW ? MULHDU : MULHD) | D(SLJIT_R1) | A(TMP_REG1) | B(SLJIT_R1));
+#else
+		FAIL_IF(push_inst(compiler, MULLW | D(SLJIT_R0) | A(TMP_REG1) | B(SLJIT_R1)));
+		return push_inst(compiler, (op == SLJIT_LMUL_UW ? MULHWU : MULHW) | D(SLJIT_R1) | A(TMP_REG1) | B(SLJIT_R1));
+#endif
 	case SLJIT_DIVMOD_UW:
 	case SLJIT_DIVMOD_SW:
+		FAIL_IF(push_inst(compiler, OR | S(SLJIT_R0) | A(TMP_REG1) | B(SLJIT_R0)));
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+		FAIL_IF(push_inst(compiler, (int_op ? (op == SLJIT_DIVMOD_UW ? DIVWU : DIVW) : (op == SLJIT_DIVMOD_UW ? DIVDU : DIVD)) | D(SLJIT_R0) | A(SLJIT_R0) | B(SLJIT_R1)));
+		FAIL_IF(push_inst(compiler, (int_op ? MULLW : MULLD) | D(SLJIT_R1) | A(SLJIT_R0) | B(SLJIT_R1)));
+#else
+		FAIL_IF(push_inst(compiler, (op == SLJIT_DIVMOD_UW ? DIVWU : DIVW) | D(SLJIT_R0) | A(SLJIT_R0) | B(SLJIT_R1)));
+		FAIL_IF(push_inst(compiler, MULLW | D(SLJIT_R1) | A(SLJIT_R0) | B(SLJIT_R1)));
+#endif
+		return push_inst(compiler, SUBF | D(SLJIT_R1) | A(SLJIT_R1) | B(TMP_REG1));
 	case SLJIT_DIV_UW:
 	case SLJIT_DIV_SW:
-		SLJIT_COMPILE_ASSERT((SLJIT_DIVMOD_UW & 0x2) == 0 && SLJIT_DIV_UW - 0x2 == SLJIT_DIVMOD_UW, bad_div_opcode_assignments);
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
-		if (int_op) {
-			FAIL_IF(push_inst(compiler, ((op | 0x2) == SLJIT_DIV_UW ? DIVU : DIV) | S(SLJIT_R0) | T(SLJIT_R1) | D(TMP_REG3), DR(TMP_REG3)));
-			FAIL_IF(push_inst(compiler, ((op | 0x2) == SLJIT_DIV_UW ? MODU : MOD) | S(SLJIT_R0) | T(SLJIT_R1) | D(TMP_REG1), DR(TMP_REG1)));
-		}
-		else {
-			FAIL_IF(push_inst(compiler, ((op | 0x2) == SLJIT_DIV_UW ? DDIVU : DDIV) | S(SLJIT_R0) | T(SLJIT_R1) | D(TMP_REG3), DR(TMP_REG3)));
-			FAIL_IF(push_inst(compiler, ((op | 0x2) == SLJIT_DIV_UW ? DMODU : DMOD) | S(SLJIT_R0) | T(SLJIT_R1) | D(TMP_REG1), DR(TMP_REG1)));
-		}
-#else /* !SLJIT_CONFIG_MIPS_64 */
-		FAIL_IF(push_inst(compiler, ((op | 0x2) == SLJIT_DIV_UW ? DIVU : DIV) | S(SLJIT_R0) | T(SLJIT_R1) | D(TMP_REG3), DR(TMP_REG3)));
-		FAIL_IF(push_inst(compiler, ((op | 0x2) == SLJIT_DIV_UW ? MODU : MOD) | S(SLJIT_R0) | T(SLJIT_R1) | D(TMP_REG1), DR(TMP_REG1)));
-#endif /* SLJIT_CONFIG_MIPS_64 */
-		FAIL_IF(push_inst(compiler, ADDU_W | S(TMP_REG3) | TA(0) | D(SLJIT_R0), DR(SLJIT_R0)));
-		return (op >= SLJIT_DIV_UW) ? SLJIT_SUCCESS : push_inst(compiler, ADDU_W | S(TMP_REG1) | TA(0) | D(SLJIT_R1), DR(SLJIT_R1));
-#else /* SLJIT_MIPS_REV < 6 */
-#if !(defined SLJIT_MIPS_REV)
-		FAIL_IF(push_inst(compiler, NOP, UNMOVABLE_INS));
-		FAIL_IF(push_inst(compiler, NOP, UNMOVABLE_INS));
-#endif /* !SLJIT_MIPS_REV */
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
-		if (int_op)
-			FAIL_IF(push_inst(compiler, ((op | 0x2) == SLJIT_DIV_UW ? DIVU : DIV) | S(SLJIT_R0) | T(SLJIT_R1), MOVABLE_INS));
-		else
-			FAIL_IF(push_inst(compiler, ((op | 0x2) == SLJIT_DIV_UW ? DDIVU : DDIV) | S(SLJIT_R0) | T(SLJIT_R1), MOVABLE_INS));
-#else /* !SLJIT_CONFIG_MIPS_64 */
-		FAIL_IF(push_inst(compiler, ((op | 0x2) == SLJIT_DIV_UW ? DIVU : DIV) | S(SLJIT_R0) | T(SLJIT_R1), MOVABLE_INS));
-#endif /* SLJIT_CONFIG_MIPS_64 */
-		FAIL_IF(push_inst(compiler, MFLO | D(SLJIT_R0), DR(SLJIT_R0)));
-		return (op >= SLJIT_DIV_UW) ? SLJIT_SUCCESS : push_inst(compiler, MFHI | D(SLJIT_R1), DR(SLJIT_R1));
-#endif /* SLJIT_MIPS_REV >= 6 */
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+		return push_inst(compiler, (int_op ? (op == SLJIT_DIV_UW ? DIVWU : DIVW) : (op == SLJIT_DIV_UW ? DIVDU : DIVD)) | D(SLJIT_R0) | A(SLJIT_R0) | B(SLJIT_R1));
+#else
+		return push_inst(compiler, (op == SLJIT_DIV_UW ? DIVWU : DIVW) | D(SLJIT_R0) | A(SLJIT_R0) | B(SLJIT_R1));
+#endif
 	case SLJIT_ENDBR:
 	case SLJIT_SKIP_FRAMES_BEFORE_RETURN:
 		return SLJIT_SUCCESS;
 	}
 
 	return SLJIT_SUCCESS;
 }
 
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1)
 static sljit_s32 emit_prefetch(struct sljit_compiler *compiler,
         sljit_s32 src, sljit_sw srcw)
 {
 	if (!(src & OFFS_REG_MASK)) {
-		if (srcw <= SIMM_MAX && srcw >= SIMM_MIN)
-			return push_inst(compiler, PREF | S(src & REG_MASK) | IMM(srcw), MOVABLE_INS);
+		if (srcw == 0 && (src & REG_MASK))
+			return push_inst(compiler, DCBT | A(0) | B(src & REG_MASK));
 
-		FAIL_IF(load_immediate(compiler, DR(TMP_REG1), srcw));
-		return push_inst(compiler, PREFX | S(src & REG_MASK) | T(TMP_REG1), MOVABLE_INS);
+		FAIL_IF(load_immediate(compiler, TMP_REG1, srcw));
+		/* Works with SLJIT_MEM0() case as well. */
+		return push_inst(compiler, DCBT | A(src & REG_MASK) | B(TMP_REG1));
 	}
 
 	srcw &= 0x3;
 
-	if (SLJIT_UNLIKELY(srcw != 0)) {
-		FAIL_IF(push_inst(compiler, SLL_W | T(OFFS_REG(src)) | D(TMP_REG1) | SH_IMM(srcw), DR(TMP_REG1)));
-		return push_inst(compiler, PREFX | S(src & REG_MASK) | T(TMP_REG1), MOVABLE_INS);
-	}
+	if (srcw == 0)
+		return push_inst(compiler, DCBT | A(src & REG_MASK) | B(OFFS_REG(src)));
 
-	return push_inst(compiler, PREFX | S(src & REG_MASK) | T(OFFS_REG(src)), MOVABLE_INS);
+	FAIL_IF(push_inst(compiler, SLWI_W(srcw) | S(OFFS_REG(src)) | A(TMP_REG1)));
+	return push_inst(compiler, DCBT | A(src & REG_MASK) | B(TMP_REG1));
 }
-#endif /* SLJIT_MIPS_REV >= 1 */
+
+#define EMIT_MOV(type, type_flags, type_cast) \
+	emit_op(compiler, (src & SLJIT_IMM) ? SLJIT_MOV : type, flags | (type_flags), dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? type_cast srcw : srcw)
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op1(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src, sljit_sw srcw)
 {
-	sljit_s32 flags = 0;
+	sljit_s32 flags = HAS_FLAGS(op) ? ALT_SET_FLAGS : 0;
+	sljit_s32 op_flags = GET_ALL_FLAGS(op);
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op1(compiler, op, dst, dstw, src, srcw));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 	ADJUST_LOCAL_OFFSET(src, srcw);
 
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
-	if (op & SLJIT_32)
-		flags = INT_DATA | SIGNED_DATA;
+	op = GET_OPCODE(op);
+
+	if (GET_FLAG_TYPE(op_flags) == SLJIT_OVERFLOW)
+		FAIL_IF(push_inst(compiler, MTXER | S(TMP_ZERO)));
+
+	if (op < SLJIT_NOT && FAST_IS_REG(src) && src == dst) {
+		if (!TYPE_CAST_NEEDED(op))
+			return SLJIT_SUCCESS;
+	}
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	if (op_flags & SLJIT_32) {
+		if (op < SLJIT_NOT) {
+			if (src & SLJIT_MEM) {
+				if (op == SLJIT_MOV_S32)
+					op = SLJIT_MOV_U32;
+			}
+			else if (src & SLJIT_IMM) {
+				if (op == SLJIT_MOV_U32)
+					op = SLJIT_MOV_S32;
+			}
+		}
+		else {
+			/* Most operations expect sign extended arguments. */
+			flags |= INT_DATA | SIGNED_DATA;
+			if (HAS_FLAGS(op_flags))
+				flags |= ALT_SIGN_EXT;
+		}
+	}
 #endif
 
-	switch (GET_OPCODE(op)) {
+	switch (op) {
 	case SLJIT_MOV:
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
 	case SLJIT_MOV_U32:
 	case SLJIT_MOV_S32:
 	case SLJIT_MOV32:
 #endif
 	case SLJIT_MOV_P:
-		return emit_op(compiler, SLJIT_MOV, WORD_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, srcw);
+		return emit_op(compiler, SLJIT_MOV, flags | WORD_DATA, dst, dstw, TMP_REG1, 0, src, srcw);
 
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
 	case SLJIT_MOV_U32:
-		return emit_op(compiler, SLJIT_MOV_U32, INT_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_u32)srcw : srcw);
+		return EMIT_MOV(SLJIT_MOV_U32, INT_DATA, (sljit_u32));
 
 	case SLJIT_MOV_S32:
 	case SLJIT_MOV32:
-		return emit_op(compiler, SLJIT_MOV_S32, INT_DATA | SIGNED_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_s32)srcw : srcw);
+		return EMIT_MOV(SLJIT_MOV_S32, INT_DATA | SIGNED_DATA, (sljit_s32));
 #endif
 
 	case SLJIT_MOV_U8:
-		return emit_op(compiler, op, BYTE_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_u8)srcw : srcw);
+		return EMIT_MOV(SLJIT_MOV_U8, BYTE_DATA, (sljit_u8));
 
 	case SLJIT_MOV_S8:
-		return emit_op(compiler, op, BYTE_DATA | SIGNED_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_s8)srcw : srcw);
+		return EMIT_MOV(SLJIT_MOV_S8, BYTE_DATA | SIGNED_DATA, (sljit_s8));
 
 	case SLJIT_MOV_U16:
-		return emit_op(compiler, op, HALF_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_u16)srcw : srcw);
+		return EMIT_MOV(SLJIT_MOV_U16, HALF_DATA, (sljit_u16));
 
 	case SLJIT_MOV_S16:
-		return emit_op(compiler, op, HALF_DATA | SIGNED_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_s16)srcw : srcw);
+		return EMIT_MOV(SLJIT_MOV_S16, HALF_DATA | SIGNED_DATA, (sljit_s16));
 
 	case SLJIT_NOT:
-		return emit_op(compiler, op, flags, dst, dstw, TMP_REG1, 0, src, srcw);
+		return emit_op(compiler, SLJIT_NOT, flags, dst, dstw, TMP_REG1, 0, src, srcw);
 
 	case SLJIT_CLZ:
+	case SLJIT_CTZ:
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+		return emit_op(compiler, op, flags | (!(op_flags & SLJIT_32) ? 0 : ALT_FORM1), dst, dstw, TMP_REG1, 0, src, srcw);
+#else
 		return emit_op(compiler, op, flags, dst, dstw, TMP_REG1, 0, src, srcw);
+#endif
 	}
 
-	SLJIT_UNREACHABLE();
 	return SLJIT_SUCCESS;
 }
 
+#undef EMIT_MOV
+
+#define TEST_SL_IMM(src, srcw) \
+	(((src) & SLJIT_IMM) && (srcw) <= SIMM_MAX && (srcw) >= SIMM_MIN)
+
+#define TEST_UL_IMM(src, srcw) \
+	(((src) & SLJIT_IMM) && !((srcw) & ~0xffff))
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#define TEST_SH_IMM(src, srcw) \
+	(((src) & SLJIT_IMM) && !((srcw) & 0xffff) && (srcw) <= 0x7fffffffl && (srcw) >= -0x80000000l)
+#else
+#define TEST_SH_IMM(src, srcw) \
+	(((src) & SLJIT_IMM) && !((srcw) & 0xffff))
+#endif
+
+#define TEST_UH_IMM(src, srcw) \
+	(((src) & SLJIT_IMM) && !((srcw) & ~(sljit_sw)0xffff0000))
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#define TEST_ADD_IMM(src, srcw) \
+	(((src) & SLJIT_IMM) && (srcw) <= 0x7fff7fffl && (srcw) >= -0x80000000l)
+#else
+#define TEST_ADD_IMM(src, srcw) \
+	((src) & SLJIT_IMM)
+#endif
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#define TEST_UI_IMM(src, srcw) \
+	(((src) & SLJIT_IMM) && !((srcw) & ~0xffffffff))
+#else
+#define TEST_UI_IMM(src, srcw) \
+	((src) & SLJIT_IMM)
+#endif
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#define TEST_ADD_FORM1(op) \
+	(GET_FLAG_TYPE(op) == SLJIT_OVERFLOW \
+		|| (op & (SLJIT_32 | SLJIT_SET_Z | VARIABLE_FLAG_MASK)) == (SLJIT_32 | SLJIT_SET_Z | SLJIT_SET_CARRY))
+#define TEST_SUB_FORM2(op) \
+	((GET_FLAG_TYPE(op) >= SLJIT_SIG_LESS && GET_FLAG_TYPE(op) <= SLJIT_SIG_LESS_EQUAL) \
+		|| (op & (SLJIT_32 | SLJIT_SET_Z | VARIABLE_FLAG_MASK)) == (SLJIT_32 | SLJIT_SET_Z))
+#define TEST_SUB_FORM3(op) \
+	(GET_FLAG_TYPE(op) == SLJIT_OVERFLOW \
+		|| (op & (SLJIT_32 | SLJIT_SET_Z)) == (SLJIT_32 | SLJIT_SET_Z))
+#else
+#define TEST_ADD_FORM1(op) \
+	(GET_FLAG_TYPE(op) == SLJIT_OVERFLOW)
+#define TEST_SUB_FORM2(op) \
+	(GET_FLAG_TYPE(op) >= SLJIT_SIG_LESS && GET_FLAG_TYPE(op) <= SLJIT_SIG_LESS_EQUAL)
+#define TEST_SUB_FORM3(op) \
+	(GET_FLAG_TYPE(op) == SLJIT_OVERFLOW)
+#endif
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
-	sljit_s32 flags = 0;
+	sljit_s32 flags = HAS_FLAGS(op) ? ALT_SET_FLAGS : 0;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op2(compiler, op, 0, dst, dstw, src1, src1w, src2, src2w));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 	ADJUST_LOCAL_OFFSET(src1, src1w);
 	ADJUST_LOCAL_OFFSET(src2, src2w);
 
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
 	if (op & SLJIT_32) {
+		/* Most operations expect sign extended arguments. */
 		flags |= INT_DATA | SIGNED_DATA;
 		if (src1 & SLJIT_IMM)
-			src1w = (sljit_s32)src1w;
+			src1w = (sljit_s32)(src1w);
 		if (src2 & SLJIT_IMM)
-			src2w = (sljit_s32)src2w;
+			src2w = (sljit_s32)(src2w);
+		if (HAS_FLAGS(op))
+			flags |= ALT_SIGN_EXT;
 	}
 #endif
+	if (GET_FLAG_TYPE(op) == SLJIT_OVERFLOW)
+		FAIL_IF(push_inst(compiler, MTXER | S(TMP_ZERO)));
 
 	switch (GET_OPCODE(op)) {
 	case SLJIT_ADD:
+		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_ADD;
+
+		if (TEST_ADD_FORM1(op))
+			return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM1, dst, dstw, src1, src1w, src2, src2w);
+
+		if (!HAS_FLAGS(op) && ((src1 | src2) & SLJIT_IMM)) {
+			if (TEST_SL_IMM(src2, src2w)) {
+				compiler->imm = (sljit_ins)src2w & 0xffff;
+				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			if (TEST_SL_IMM(src1, src1w)) {
+				compiler->imm = (sljit_ins)src1w & 0xffff;
+				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2, dst, dstw, src2, src2w, TMP_REG2, 0);
+			}
+			if (TEST_SH_IMM(src2, src2w)) {
+				compiler->imm = (sljit_ins)(src2w >> 16) & 0xffff;
+				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2 | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			if (TEST_SH_IMM(src1, src1w)) {
+				compiler->imm = (sljit_ins)(src1w >> 16) & 0xffff;
+				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2 | ALT_FORM3, dst, dstw, src2, src2w, TMP_REG2, 0);
+			}
+			/* Range between -1 and -32768 is covered above. */
+			if (TEST_ADD_IMM(src2, src2w)) {
+				compiler->imm = (sljit_ins)src2w & 0xffffffff;
+				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2 | ALT_FORM4, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			if (TEST_ADD_IMM(src1, src1w)) {
+				compiler->imm = (sljit_ins)src1w & 0xffffffff;
+				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2 | ALT_FORM4, dst, dstw, src2, src2w, TMP_REG2, 0);
+			}
+		}
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+		if ((op & (SLJIT_32 | SLJIT_SET_Z)) == (SLJIT_32 | SLJIT_SET_Z)) {
+			if (TEST_SL_IMM(src2, src2w)) {
+				compiler->imm = (sljit_ins)src2w & 0xffff;
+				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM4 | ALT_FORM5, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			if (TEST_SL_IMM(src1, src1w)) {
+				compiler->imm = (sljit_ins)src1w & 0xffff;
+				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM4 | ALT_FORM5, dst, dstw, src2, src2w, TMP_REG2, 0);
+			}
+			return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM4, dst, dstw, src1, src1w, src2, src2w);
+		}
+#endif
+		if (HAS_FLAGS(op)) {
+			if (TEST_SL_IMM(src2, src2w)) {
+				compiler->imm = (sljit_ins)src2w & 0xffff;
+				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			if (TEST_SL_IMM(src1, src1w)) {
+				compiler->imm = (sljit_ins)src1w & 0xffff;
+				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM3, dst, dstw, src2, src2w, TMP_REG2, 0);
+			}
+		}
+		return emit_op(compiler, SLJIT_ADD, flags | ((GET_FLAG_TYPE(op) == GET_FLAG_TYPE(SLJIT_SET_CARRY)) ? ALT_FORM5 : 0), dst, dstw, src1, src1w, src2, src2w);
+
 	case SLJIT_ADDC:
 		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_ADD;
-		return emit_op(compiler, op, flags | CUMULATIVE_OP | IMM_OP, dst, dstw, src1, src1w, src2, src2w);
+		return emit_op(compiler, SLJIT_ADDC, flags, dst, dstw, src1, src1w, src2, src2w);
 
 	case SLJIT_SUB:
+		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_SUB;
+
+		if (GET_FLAG_TYPE(op) >= SLJIT_LESS && GET_FLAG_TYPE(op) <= SLJIT_LESS_EQUAL) {
+			if (dst == TMP_REG2) {
+				if (TEST_UL_IMM(src2, src2w)) {
+					compiler->imm = (sljit_ins)src2w & 0xffff;
+					return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM1 | ALT_FORM2, dst, dstw, src1, src1w, TMP_REG2, 0);
+				}
+				return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM1, dst, dstw, src1, src1w, src2, src2w);
+			}
+
+			if ((src2 & SLJIT_IMM) && src2w >= 0 && src2w <= (SIMM_MAX + 1)) {
+				compiler->imm = (sljit_ins)src2w;
+				return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM1 | ALT_FORM2 | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM1 | ALT_FORM3, dst, dstw, src1, src1w, src2, src2w);
+		}
+
+		if (dst == TMP_REG2 && GET_FLAG_TYPE(op) <= SLJIT_SIG_LESS_EQUAL) {
+			if (TEST_SL_IMM(src2, src2w)) {
+				compiler->imm = (sljit_ins)src2w & 0xffff;
+				return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM2 | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM2, dst, dstw, src1, src1w, src2, src2w);
+		}
+
+		if (TEST_SUB_FORM2(op)) {
+			if ((src2 & SLJIT_IMM) && src2w >= -SIMM_MAX && src2w <= SIMM_MAX) {
+				compiler->imm = (sljit_ins)src2w & 0xffff;
+				return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM2 | ALT_FORM3 | ALT_FORM4, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM2 | ALT_FORM4, dst, dstw, src1, src1w, src2, src2w);
+		}
+
+		if (TEST_SUB_FORM3(op))
+			return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM3, dst, dstw, src1, src1w, src2, src2w);
+
+		if (TEST_SL_IMM(src2, -src2w)) {
+			compiler->imm = (sljit_ins)(-src2w) & 0xffff;
+			return emit_op(compiler, SLJIT_ADD, flags | (!HAS_FLAGS(op) ? ALT_FORM2 : ALT_FORM3), dst, dstw, src1, src1w, TMP_REG2, 0);
+		}
+
+		if (TEST_SL_IMM(src1, src1w) && !(op & SLJIT_SET_Z)) {
+			compiler->imm = (sljit_ins)src1w & 0xffff;
+			return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM4, dst, dstw, src2, src2w, TMP_REG2, 0);
+		}
+
+		if (!HAS_FLAGS(op)) {
+			if (TEST_SH_IMM(src2, -src2w)) {
+				compiler->imm = (sljit_ins)((-src2w) >> 16) & 0xffff;
+				return emit_op(compiler, SLJIT_ADD, flags |  ALT_FORM2 | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			/* Range between -1 and -32768 is covered above. */
+			if (TEST_ADD_IMM(src2, -src2w)) {
+				compiler->imm = (sljit_ins)-src2w;
+				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2 | ALT_FORM4, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+		}
+
+		/* We know ALT_SIGN_EXT is set if it is an SLJIT_32 on 64 bit systems. */
+		return emit_op(compiler, SLJIT_SUB, flags | ((GET_FLAG_TYPE(op) == GET_FLAG_TYPE(SLJIT_SET_CARRY)) ? ALT_FORM5 : 0), dst, dstw, src1, src1w, src2, src2w);
+
 	case SLJIT_SUBC:
 		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_SUB;
-		return emit_op(compiler, op, flags | IMM_OP, dst, dstw, src1, src1w, src2, src2w);
+		return emit_op(compiler, SLJIT_SUBC, flags, dst, dstw, src1, src1w, src2, src2w);
 
 	case SLJIT_MUL:
-		compiler->status_flags_state = 0;
-		return emit_op(compiler, op, flags | CUMULATIVE_OP, dst, dstw, src1, src1w, src2, src2w);
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+		if (op & SLJIT_32)
+			flags |= ALT_FORM2;
+#endif
+		if (!HAS_FLAGS(op)) {
+			if (TEST_SL_IMM(src2, src2w)) {
+				compiler->imm = (sljit_ins)src2w & 0xffff;
+				return emit_op(compiler, SLJIT_MUL, flags | ALT_FORM1, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			if (TEST_SL_IMM(src1, src1w)) {
+				compiler->imm = (sljit_ins)src1w & 0xffff;
+				return emit_op(compiler, SLJIT_MUL, flags | ALT_FORM1, dst, dstw, src2, src2w, TMP_REG2, 0);
+			}
+		}
+		else
+			FAIL_IF(push_inst(compiler, MTXER | S(TMP_ZERO)));
+		return emit_op(compiler, SLJIT_MUL, flags, dst, dstw, src1, src1w, src2, src2w);
 
 	case SLJIT_AND:
 	case SLJIT_OR:
 	case SLJIT_XOR:
-		return emit_op(compiler, op, flags | CUMULATIVE_OP | LOGICAL_OP | IMM_OP, dst, dstw, src1, src1w, src2, src2w);
+		/* Commutative unsigned operations. */
+		if (!HAS_FLAGS(op) || GET_OPCODE(op) == SLJIT_AND) {
+			if (TEST_UL_IMM(src2, src2w)) {
+				compiler->imm = (sljit_ins)src2w;
+				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM1, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			if (TEST_UL_IMM(src1, src1w)) {
+				compiler->imm = (sljit_ins)src1w;
+				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM1, dst, dstw, src2, src2w, TMP_REG2, 0);
+			}
+			if (TEST_UH_IMM(src2, src2w)) {
+				compiler->imm = (sljit_ins)(src2w >> 16) & 0xffff;
+				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM2, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			if (TEST_UH_IMM(src1, src1w)) {
+				compiler->imm = (sljit_ins)(src1w >> 16) & 0xffff;
+				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM2, dst, dstw, src2, src2w, TMP_REG2, 0);
+			}
+		}
+		if (!HAS_FLAGS(op) && GET_OPCODE(op) != SLJIT_AND) {
+			/* Unlike or and xor, the and resets unwanted bits as well. */
+			if (TEST_UI_IMM(src2, src2w)) {
+				compiler->imm = (sljit_ins)src2w;
+				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
+			}
+			if (TEST_UI_IMM(src1, src1w)) {
+				compiler->imm = (sljit_ins)src1w;
+				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM3, dst, dstw, src2, src2w, TMP_REG2, 0);
+			}
+		}
+		return emit_op(compiler, GET_OPCODE(op), flags, dst, dstw, src1, src1w, src2, src2w);
 
 	case SLJIT_SHL:
+	case SLJIT_MSHL:
 	case SLJIT_LSHR:
+	case SLJIT_MLSHR:
 	case SLJIT_ASHR:
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-		if (src2 & SLJIT_IMM)
-			src2w &= 0x1f;
-#else
+	case SLJIT_MASHR:
+	case SLJIT_ROTL:
+	case SLJIT_ROTR:
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+		if (op & SLJIT_32)
+			flags |= ALT_FORM2;
+#endif
 		if (src2 & SLJIT_IMM) {
-			if (op & SLJIT_32)
-				src2w &= 0x1f;
-			else
-				src2w &= 0x3f;
+			compiler->imm = (sljit_ins)src2w;
+			return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM1, dst, dstw, src1, src1w, TMP_REG2, 0);
 		}
-#endif
-		return emit_op(compiler, op, flags | IMM_OP, dst, dstw, src1, src1w, src2, src2w);
+		return emit_op(compiler, GET_OPCODE(op), flags, dst, dstw, src1, src1w, src2, src2w);
 	}
 
-	SLJIT_UNREACHABLE();
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2u(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op2(compiler, op, 1, 0, 0, src1, src1w, src2, src2w));
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_op2(compiler, op, TMP_REG2, 0, src1, src1w, src2, src2w);
 }
 
+#undef TEST_ADD_FORM1
+#undef TEST_SUB_FORM2
+#undef TEST_SUB_FORM3
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_shift_into(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 src_dst,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+	sljit_s32 is_right;
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	sljit_s32 inp_flags = ((op & SLJIT_32) ? INT_DATA : WORD_DATA) | LOAD_DATA;
+	sljit_sw bit_length = (op & SLJIT_32) ? 32 : 64;
+#else /* !SLJIT_CONFIG_PPC_64 */
+	sljit_s32 inp_flags = WORD_DATA | LOAD_DATA;
+	sljit_sw bit_length = 32;
+#endif /* SLJIT_CONFIG_PPC_64 */
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_shift_into(compiler, op, src_dst, src1, src1w, src2, src2w));
+
+	is_right = (GET_OPCODE(op) == SLJIT_LSHR || GET_OPCODE(op) == SLJIT_MLSHR);
+
+	if (src_dst == src1) {
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_op2(compiler, (is_right ? SLJIT_ROTR : SLJIT_ROTL) | (op & SLJIT_32), src_dst, 0, src_dst, 0, src2, src2w);
+	}
+
+	ADJUST_LOCAL_OFFSET(src1, src1w);
+	ADJUST_LOCAL_OFFSET(src2, src2w);
+
+	if (src2 & SLJIT_IMM) {
+		src2w &= bit_length - 1;
+
+		if (src2w == 0)
+			return SLJIT_SUCCESS;
+	} else if (src2 & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, inp_flags, TMP_REG2, src2, src2w, TMP_REG2));
+		src2 = TMP_REG2;
+	}
+
+	if (src1 & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, inp_flags, TMP_REG1, src1, src1w, TMP_REG1));
+		src1 = TMP_REG1;
+	} else if (src1 & SLJIT_IMM) {
+		FAIL_IF(load_immediate(compiler, TMP_REG1, src1w));
+		src1 = TMP_REG1;
+	}
+
+	if (src2 & SLJIT_IMM) {
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+		if (!(op & SLJIT_32)) {
+			if (is_right) {
+				FAIL_IF(push_inst(compiler, SRDI(src2w) | S(src_dst) | A(src_dst)));
+				return push_inst(compiler, RLDIMI | S(src1) | A(src_dst) | RLDI_SH(64 - src2w) | RLDI_MB(0));
+			}
+
+			FAIL_IF(push_inst(compiler, SLDI(src2w) | S(src_dst) | A(src_dst)));
+			/* Computes SRDI(64 - src2w). */
+			FAIL_IF(push_inst(compiler, RLDICL | S(src1) | A(TMP_REG1) | RLDI_SH(src2w) | RLDI_MB(64 - src2w)));
+			return push_inst(compiler, OR | S(src_dst) | A(src_dst) | B(TMP_REG1));
+		}
+#endif /* SLJIT_CONFIG_PPC_64 */
+
+		if (is_right) {
+			FAIL_IF(push_inst(compiler, SRWI(src2w) | S(src_dst) | A(src_dst)));
+			return push_inst(compiler, RLWIMI | S(src1) | A(src_dst) | RLWI_SH(32 - src2w) | RLWI_MBE(0, src2w - 1));
+		}
+
+		FAIL_IF(push_inst(compiler, SLWI(src2w) | S(src_dst) | A(src_dst)));
+		return push_inst(compiler, RLWIMI | S(src1) | A(src_dst) | RLWI_SH(src2w) | RLWI_MBE(32 - src2w, 31));
+	}
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	if (!(op & SLJIT_32)) {
+		if (GET_OPCODE(op) == SLJIT_MSHL || GET_OPCODE(op) == SLJIT_MLSHR) {
+			FAIL_IF(push_inst(compiler, ANDI | S(src2) | A(TMP_REG2) | 0x3f));
+			src2 = TMP_REG2;
+		}
+
+		FAIL_IF(push_inst(compiler, (is_right ? SRD : SLD) | S(src_dst) | A(src_dst) | B(src2)));
+		FAIL_IF(push_inst(compiler, (is_right ? SLDI(1) : SRDI(1)) | S(src1) | A(TMP_REG1)));
+		FAIL_IF(push_inst(compiler, XORI | S(src2) | A(TMP_REG2) | 0x3f));
+		FAIL_IF(push_inst(compiler, (is_right ? SLD : SRD) | S(TMP_REG1) | A(TMP_REG1) | B(TMP_REG2)));
+		return push_inst(compiler, OR | S(src_dst) | A(src_dst) | B(TMP_REG1));
+	}
+#endif /* SLJIT_CONFIG_PPC_64 */
+
+	if (GET_OPCODE(op) == SLJIT_MSHL || GET_OPCODE(op) == SLJIT_MLSHR) {
+		FAIL_IF(push_inst(compiler, ANDI | S(src2) | A(TMP_REG2) | 0x1f));
+		src2 = TMP_REG2;
+	}
+
+	FAIL_IF(push_inst(compiler, (is_right ? SRW : SLW) | S(src_dst) | A(src_dst) | B(src2)));
+	FAIL_IF(push_inst(compiler, (is_right ? SLWI(1) : SRWI(1)) | S(src1) | A(TMP_REG1)));
+	FAIL_IF(push_inst(compiler, XORI | S(src2) | A(TMP_REG2) | 0x1f));
+	FAIL_IF(push_inst(compiler, (is_right ? SLW : SRW) | S(TMP_REG1) | A(TMP_REG1) | B(TMP_REG2)));
+	return push_inst(compiler, OR | S(src_dst) | A(src_dst) | B(TMP_REG1));
+}
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_src(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src, sljit_sw srcw)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_src(compiler, op, src, srcw));
 	ADJUST_LOCAL_OFFSET(src, srcw);
 
 	switch (op) {
 	case SLJIT_FAST_RETURN:
 		if (FAST_IS_REG(src))
-			FAIL_IF(push_inst(compiler, ADDU_W | S(src) | TA(0) | DA(RETURN_ADDR_REG), RETURN_ADDR_REG));
-		else
-			FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, RETURN_ADDR_REG, src, srcw));
+			FAIL_IF(push_inst(compiler, MTLR | S(src)));
+		else {
+			FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, TMP_REG2, src, srcw, TMP_REG2));
+			FAIL_IF(push_inst(compiler, MTLR | S(TMP_REG2)));
+		}
 
-		FAIL_IF(push_inst(compiler, JR | SA(RETURN_ADDR_REG), UNMOVABLE_INS));
-		return push_inst(compiler, NOP, UNMOVABLE_INS);
+		return push_inst(compiler, BLR);
 	case SLJIT_SKIP_FRAMES_BEFORE_FAST_RETURN:
 		return SLJIT_SUCCESS;
 	case SLJIT_PREFETCH_L1:
 	case SLJIT_PREFETCH_L2:
 	case SLJIT_PREFETCH_L3:
 	case SLJIT_PREFETCH_ONCE:
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1)
 		return emit_prefetch(compiler, src, srcw);
-#else /* SLJIT_MIPS_REV < 1 */
-		return SLJIT_SUCCESS;
-#endif /* SLJIT_MIPS_REV >= 1 */
 	}
 
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_register_index(sljit_s32 reg)
 {
 	CHECK_REG_INDEX(check_sljit_get_register_index(reg));
 	return reg_map[reg];
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_float_register_index(sljit_s32 reg)
 {
 	CHECK_REG_INDEX(check_sljit_get_float_register_index(reg));
-	return FR(reg);
+	return freg_map[reg];
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_custom(struct sljit_compiler *compiler,
 	void *instruction, sljit_u32 size)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_custom(compiler, instruction, size));
 
-	return push_inst(compiler, *(sljit_ins*)instruction, UNMOVABLE_INS);
+	return push_inst(compiler, *(sljit_ins*)instruction);
 }
 
 /* --------------------------------------------------------------------- */
 /*  Floating point operators                                             */
 /* --------------------------------------------------------------------- */
 
-#define FLOAT_DATA(op) (DOUBLE_DATA | ((op & SLJIT_32) >> 7))
-#define FMT(op) ((((sljit_ins)op & SLJIT_32) ^ SLJIT_32) << (21 - 8))
+#define FLOAT_DATA(op) (DOUBLE_DATA | ((op & SLJIT_32) >> 6))
+#define SELECT_FOP(op, single, double) ((sljit_ins)((op & SLJIT_32) ? single : double))
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#define FLOAT_TMP_MEM_OFFSET (6 * sizeof(sljit_sw))
+#else
+#define FLOAT_TMP_MEM_OFFSET (2 * sizeof(sljit_sw))
+
+#if (defined SLJIT_LITTLE_ENDIAN && SLJIT_LITTLE_ENDIAN)
+#define FLOAT_TMP_MEM_OFFSET_LOW (2 * sizeof(sljit_sw))
+#define FLOAT_TMP_MEM_OFFSET_HI (3 * sizeof(sljit_sw))
+#else
+#define FLOAT_TMP_MEM_OFFSET_LOW (3 * sizeof(sljit_sw))
+#define FLOAT_TMP_MEM_OFFSET_HI (2 * sizeof(sljit_sw))
+#endif
+
+#endif /* SLJIT_CONFIG_PPC_64 */
 
 static SLJIT_INLINE sljit_s32 sljit_emit_fop1_conv_sw_from_f64(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src, sljit_sw srcw)
 {
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-#	define flags (sljit_u32)0
-#else
-	sljit_u32 flags = ((sljit_u32)(GET_OPCODE(op) == SLJIT_CONV_SW_FROM_F64)) << 21;
-#endif
-
 	if (src & SLJIT_MEM) {
-		FAIL_IF(emit_op_mem2(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(TMP_FREG1), src, srcw, dst, dstw));
+		/* We can ignore the temporary data store on the stack from caching point of view. */
+		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src, srcw, TMP_REG1));
 		src = TMP_FREG1;
 	}
 
-	FAIL_IF(push_inst(compiler, (TRUNC_W_S ^ (flags >> 19)) | FMT(op) | FS(src) | FD(TMP_FREG1), MOVABLE_INS));
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	op = GET_OPCODE(op);
+	FAIL_IF(push_inst(compiler, (op == SLJIT_CONV_S32_FROM_F64 ? FCTIWZ : FCTIDZ) | FD(TMP_FREG1) | FB(src)));
 
-	if (FAST_IS_REG(dst))
-		return push_inst(compiler, MFC1 | flags | T(dst) | FS(TMP_FREG1), MOVABLE_INS);
+	if (op == SLJIT_CONV_SW_FROM_F64) {
+		if (FAST_IS_REG(dst)) {
+			FAIL_IF(emit_op_mem(compiler, DOUBLE_DATA, TMP_FREG1, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1));
+			return emit_op_mem(compiler, WORD_DATA | LOAD_DATA, dst, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1);
+		}
+		return emit_op_mem(compiler, DOUBLE_DATA, TMP_FREG1, dst, dstw, TMP_REG1);
+	}
+#else
+	FAIL_IF(push_inst(compiler, FCTIWZ | FD(TMP_FREG1) | FB(src)));
+#endif
 
-	/* Store the integer value from a VFP register. */
-	return emit_op_mem2(compiler, flags ? DOUBLE_DATA : SINGLE_DATA, FR(TMP_FREG1), dst, dstw, 0, 0);
+	if (FAST_IS_REG(dst)) {
+		FAIL_IF(load_immediate(compiler, TMP_REG1, FLOAT_TMP_MEM_OFFSET));
+		FAIL_IF(push_inst(compiler, STFIWX | FS(TMP_FREG1) | A(SLJIT_SP) | B(TMP_REG1)));
+		return emit_op_mem(compiler, INT_DATA | LOAD_DATA, dst, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1);
+	}
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-#	undef is_long
-#endif
+	SLJIT_ASSERT(dst & SLJIT_MEM);
+
+	if (dst & OFFS_REG_MASK) {
+		dstw &= 0x3;
+		if (dstw) {
+			FAIL_IF(push_inst(compiler, SLWI_W(dstw) | S(OFFS_REG(dst)) | A(TMP_REG1)));
+			dstw = TMP_REG1;
+		}
+		else
+			dstw = OFFS_REG(dst);
+	}
+	else {
+		if ((dst & REG_MASK) && !dstw) {
+			dstw = dst & REG_MASK;
+			dst = 0;
+		}
+		else {
+			/* This works regardless we have SLJIT_MEM1 or SLJIT_MEM0. */
+			FAIL_IF(load_immediate(compiler, TMP_REG1, dstw));
+			dstw = TMP_REG1;
+		}
+	}
+
+	return push_inst(compiler, STFIWX | FS(TMP_FREG1) | A(dst & REG_MASK) | B(dstw));
 }
 
 static SLJIT_INLINE sljit_s32 sljit_emit_fop1_conv_f64_from_sw(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src, sljit_sw srcw)
 {
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-#	define flags (sljit_u32)0
-#else
-	sljit_u32 flags = ((sljit_u32)(GET_OPCODE(op) == SLJIT_CONV_F64_FROM_SW)) << 21;
-#endif
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
 
 	sljit_s32 dst_r = FAST_IS_REG(dst) ? dst : TMP_FREG1;
 
-	if (FAST_IS_REG(src))
-		FAIL_IF(push_inst(compiler, MTC1 | flags | T(src) | FS(TMP_FREG1), MOVABLE_INS));
-	else if (src & SLJIT_MEM) {
-		/* Load the integer value into a VFP register. */
-		FAIL_IF(emit_op_mem2(compiler, ((flags) ? DOUBLE_DATA : SINGLE_DATA) | LOAD_DATA, FR(TMP_FREG1), src, srcw, dst, dstw));
-	}
-	else {
-#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+	if (src & SLJIT_IMM) {
 		if (GET_OPCODE(op) == SLJIT_CONV_F64_FROM_S32)
 			srcw = (sljit_s32)srcw;
-#endif
-		FAIL_IF(load_immediate(compiler, DR(TMP_REG1), srcw));
-		FAIL_IF(push_inst(compiler, MTC1 | flags | T(TMP_REG1) | FS(TMP_FREG1), MOVABLE_INS));
+
+		FAIL_IF(load_immediate(compiler, TMP_REG1, srcw));
+		src = TMP_REG1;
+	}
+	else if (GET_OPCODE(op) == SLJIT_CONV_F64_FROM_S32) {
+		if (FAST_IS_REG(src))
+			FAIL_IF(push_inst(compiler, EXTSW | S(src) | A(TMP_REG1)));
+		else
+			FAIL_IF(emit_op_mem(compiler, INT_DATA | SIGNED_DATA | LOAD_DATA, TMP_REG1, src, srcw, TMP_REG1));
+		src = TMP_REG1;
+	}
+
+	if (FAST_IS_REG(src)) {
+		FAIL_IF(emit_op_mem(compiler, WORD_DATA, src, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1));
+		FAIL_IF(emit_op_mem(compiler, DOUBLE_DATA | LOAD_DATA, TMP_FREG1, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1));
+	}
+	else
+		FAIL_IF(emit_op_mem(compiler, DOUBLE_DATA | LOAD_DATA, TMP_FREG1, src, srcw, TMP_REG1));
+
+	FAIL_IF(push_inst(compiler, FCFID | FD(dst_r) | FB(TMP_FREG1)));
+
+	if (dst & SLJIT_MEM)
+		return emit_op_mem(compiler, FLOAT_DATA(op), TMP_FREG1, dst, dstw, TMP_REG1);
+	if (op & SLJIT_32)
+		return push_inst(compiler, FRSP | FD(dst_r) | FB(dst_r));
+	return SLJIT_SUCCESS;
+
+#else
+
+	sljit_s32 dst_r = FAST_IS_REG(dst) ? dst : TMP_FREG1;
+	sljit_s32 invert_sign = 1;
+
+	if (src & SLJIT_IMM) {
+		FAIL_IF(load_immediate(compiler, TMP_REG1, srcw ^ (sljit_sw)0x80000000));
+		src = TMP_REG1;
+		invert_sign = 0;
 	}
+	else if (!FAST_IS_REG(src)) {
+		FAIL_IF(emit_op_mem(compiler, WORD_DATA | SIGNED_DATA | LOAD_DATA, TMP_REG1, src, srcw, TMP_REG1));
+		src = TMP_REG1;
+	}
+
+	/* First, a special double floating point value is constructed: (2^53 + (input xor (2^31)))
+	   The double precision format has exactly 53 bit precision, so the lower 32 bit represents
+	   the lower 32 bit of such value. The result of xor 2^31 is the same as adding 0x80000000
+	   to the input, which shifts it into the 0 - 0xffffffff range. To get the converted floating
+	   point value, we need to subtract 2^53 + 2^31 from the constructed value. */
+	FAIL_IF(push_inst(compiler, ADDIS | D(TMP_REG2) | A(0) | 0x4330));
+	if (invert_sign)
+		FAIL_IF(push_inst(compiler, XORIS | S(src) | A(TMP_REG1) | 0x8000));
+	FAIL_IF(emit_op_mem(compiler, WORD_DATA, TMP_REG2, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET_HI, TMP_REG1));
+	FAIL_IF(emit_op_mem(compiler, WORD_DATA, TMP_REG1, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET_LOW, TMP_REG2));
+	FAIL_IF(push_inst(compiler, ADDIS | D(TMP_REG1) | A(0) | 0x8000));
+	FAIL_IF(emit_op_mem(compiler, DOUBLE_DATA | LOAD_DATA, TMP_FREG1, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1));
+	FAIL_IF(emit_op_mem(compiler, WORD_DATA, TMP_REG1, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET_LOW, TMP_REG2));
+	FAIL_IF(emit_op_mem(compiler, DOUBLE_DATA | LOAD_DATA, TMP_FREG2, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1));
 
-	FAIL_IF(push_inst(compiler, CVT_S_S | flags | (4 << 21) | ((((sljit_ins)op & SLJIT_32) ^ SLJIT_32) >> 8) | FS(TMP_FREG1) | FD(dst_r), MOVABLE_INS));
+	FAIL_IF(push_inst(compiler, FSUB | FD(dst_r) | FA(TMP_FREG1) | FB(TMP_FREG2)));
 
 	if (dst & SLJIT_MEM)
-		return emit_op_mem2(compiler, FLOAT_DATA(op), FR(TMP_FREG1), dst, dstw, 0, 0);
+		return emit_op_mem(compiler, FLOAT_DATA(op), TMP_FREG1, dst, dstw, TMP_REG1);
+	if (op & SLJIT_32)
+		return push_inst(compiler, FRSP | FD(dst_r) | FB(dst_r));
 	return SLJIT_SUCCESS;
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-#	undef flags
 #endif
 }
 
 static SLJIT_INLINE sljit_s32 sljit_emit_fop1_cmp(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
-	sljit_ins inst;
-
 	if (src1 & SLJIT_MEM) {
-		FAIL_IF(emit_op_mem2(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(TMP_FREG1), src1, src1w, src2, src2w));
+		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src1, src1w, TMP_REG1));
 		src1 = TMP_FREG1;
 	}
 
 	if (src2 & SLJIT_MEM) {
-		FAIL_IF(emit_op_mem2(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(TMP_FREG2), src2, src2w, 0, 0));
+		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG2, src2, src2w, TMP_REG2));
 		src2 = TMP_FREG2;
 	}
 
+	FAIL_IF(push_inst(compiler, FCMPU | CRD(4) | FA(src1) | FB(src2)));
+
 	switch (GET_FLAG_TYPE(op)) {
-	case SLJIT_EQUAL_F64:
-	case SLJIT_NOT_EQUAL_F64:
-		inst = C_UEQ_S;
-		break;
-	case SLJIT_LESS_F64:
-	case SLJIT_GREATER_EQUAL_F64:
-		inst = C_ULT_S;
-		break;
-	case SLJIT_GREATER_F64:
-	case SLJIT_LESS_EQUAL_F64:
-		inst = C_ULE_S;
-		break;
-	default:
-		SLJIT_ASSERT(GET_FLAG_TYPE(op) == SLJIT_UNORDERED_F64 || GET_FLAG_TYPE(op) == SLJIT_ORDERED_F64);
-		inst = C_UN_S;
-		break;
+	case SLJIT_UNORDERED_OR_EQUAL:
+	case SLJIT_ORDERED_NOT_EQUAL:
+		return push_inst(compiler, CROR | ((4 + 2) << 21) | ((4 + 2) << 16) | ((4 + 3) << 11));
+	case SLJIT_UNORDERED_OR_LESS:
+	case SLJIT_ORDERED_GREATER_EQUAL:
+		return push_inst(compiler, CROR | ((4 + 0) << 21) | ((4 + 0) << 16) | ((4 + 3) << 11));
+	case SLJIT_UNORDERED_OR_GREATER:
+	case SLJIT_ORDERED_LESS_EQUAL:
+		return push_inst(compiler, CROR | ((4 + 1) << 21) | ((4 + 1) << 16) | ((4 + 3) << 11));
 	}
-	return push_inst(compiler, inst | FMT(op) | FT(src2) | FS(src1) | C_FD, UNMOVABLE_INS);
+
+	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fop1(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src, sljit_sw srcw)
 {
 	sljit_s32 dst_r;
 
 	CHECK_ERROR();
-	compiler->cache_arg = 0;
-	compiler->cache_argw = 0;
 
-	SLJIT_COMPILE_ASSERT((SLJIT_32 == 0x100) && !(DOUBLE_DATA & 0x2), float_transfer_bit_error);
+	SLJIT_COMPILE_ASSERT((SLJIT_32 == 0x100) && !(DOUBLE_DATA & 0x4), float_transfer_bit_error);
 	SELECT_FOP1_OPERATION_WITH_CHECKS(compiler, op, dst, dstw, src, srcw);
 
 	if (GET_OPCODE(op) == SLJIT_CONV_F64_FROM_F32)
 		op ^= SLJIT_32;
 
 	dst_r = FAST_IS_REG(dst) ? dst : TMP_FREG1;
 
 	if (src & SLJIT_MEM) {
-		FAIL_IF(emit_op_mem2(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(dst_r), src, srcw, dst, dstw));
+		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, dst_r, src, srcw, TMP_REG1));
 		src = dst_r;
 	}
 
 	switch (GET_OPCODE(op)) {
+	case SLJIT_CONV_F64_FROM_F32:
+		op ^= SLJIT_32;
+		if (op & SLJIT_32) {
+			FAIL_IF(push_inst(compiler, FRSP | FD(dst_r) | FB(src)));
+			break;
+		}
+		/* Fall through. */
 	case SLJIT_MOV_F64:
 		if (src != dst_r) {
 			if (dst_r != TMP_FREG1)
-				FAIL_IF(push_inst(compiler, MOV_S | FMT(op) | FS(src) | FD(dst_r), MOVABLE_INS));
+				FAIL_IF(push_inst(compiler, FMR | FD(dst_r) | FB(src)));
 			else
 				dst_r = src;
 		}
 		break;
 	case SLJIT_NEG_F64:
-		FAIL_IF(push_inst(compiler, NEG_S | FMT(op) | FS(src) | FD(dst_r), MOVABLE_INS));
+		FAIL_IF(push_inst(compiler, FNEG | FD(dst_r) | FB(src)));
 		break;
 	case SLJIT_ABS_F64:
-		FAIL_IF(push_inst(compiler, ABS_S | FMT(op) | FS(src) | FD(dst_r), MOVABLE_INS));
-		break;
-	case SLJIT_CONV_F64_FROM_F32:
-		FAIL_IF(push_inst(compiler, CVT_S_S | (sljit_ins)((op & SLJIT_32) ? 1 : (1 << 21)) | FS(src) | FD(dst_r), MOVABLE_INS));
-		op ^= SLJIT_32;
+		FAIL_IF(push_inst(compiler, FABS | FD(dst_r) | FB(src)));
 		break;
 	}
 
 	if (dst & SLJIT_MEM)
-		return emit_op_mem2(compiler, FLOAT_DATA(op), FR(dst_r), dst, dstw, 0, 0);
+		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op), dst_r, dst, dstw, TMP_REG1));
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fop2(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
-	sljit_s32 dst_r, flags = 0;
+	sljit_s32 dst_r;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_fop2(compiler, op, dst, dstw, src1, src1w, src2, src2w));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 	ADJUST_LOCAL_OFFSET(src1, src1w);
 	ADJUST_LOCAL_OFFSET(src2, src2w);
 
-	compiler->cache_arg = 0;
-	compiler->cache_argw = 0;
-
 	dst_r = FAST_IS_REG(dst) ? dst : TMP_FREG2;
 
 	if (src1 & SLJIT_MEM) {
-		if (getput_arg_fast(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(TMP_FREG1), src1, src1w)) {
-			FAIL_IF(compiler->error);
-			src1 = TMP_FREG1;
-		} else
-			flags |= SLOW_SRC1;
+		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src1, src1w, TMP_REG1));
+		src1 = TMP_FREG1;
 	}
 
 	if (src2 & SLJIT_MEM) {
-		if (getput_arg_fast(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(TMP_FREG2), src2, src2w)) {
-			FAIL_IF(compiler->error);
-			src2 = TMP_FREG2;
-		} else
-			flags |= SLOW_SRC2;
-	}
-
-	if ((flags & (SLOW_SRC1 | SLOW_SRC2)) == (SLOW_SRC1 | SLOW_SRC2)) {
-		if (!can_cache(src1, src1w, src2, src2w) && can_cache(src1, src1w, dst, dstw)) {
-			FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(TMP_FREG2), src2, src2w, src1, src1w));
-			FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(TMP_FREG1), src1, src1w, dst, dstw));
-		}
-		else {
-			FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(TMP_FREG1), src1, src1w, src2, src2w));
-			FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(TMP_FREG2), src2, src2w, dst, dstw));
-		}
-	}
-	else if (flags & SLOW_SRC1)
-		FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(TMP_FREG1), src1, src1w, dst, dstw));
-	else if (flags & SLOW_SRC2)
-		FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, FR(TMP_FREG2), src2, src2w, dst, dstw));
-
-	if (flags & SLOW_SRC1)
-		src1 = TMP_FREG1;
-	if (flags & SLOW_SRC2)
+		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG2, src2, src2w, TMP_REG2));
 		src2 = TMP_FREG2;
+	}
 
 	switch (GET_OPCODE(op)) {
 	case SLJIT_ADD_F64:
-		FAIL_IF(push_inst(compiler, ADD_S | FMT(op) | FT(src2) | FS(src1) | FD(dst_r), MOVABLE_INS));
+		FAIL_IF(push_inst(compiler, SELECT_FOP(op, FADDS, FADD) | FD(dst_r) | FA(src1) | FB(src2)));
 		break;
 
 	case SLJIT_SUB_F64:
-		FAIL_IF(push_inst(compiler, SUB_S | FMT(op) | FT(src2) | FS(src1) | FD(dst_r), MOVABLE_INS));
+		FAIL_IF(push_inst(compiler, SELECT_FOP(op, FSUBS, FSUB) | FD(dst_r) | FA(src1) | FB(src2)));
 		break;
 
 	case SLJIT_MUL_F64:
-		FAIL_IF(push_inst(compiler, MUL_S | FMT(op) | FT(src2) | FS(src1) | FD(dst_r), MOVABLE_INS));
+		FAIL_IF(push_inst(compiler, SELECT_FOP(op, FMULS, FMUL) | FD(dst_r) | FA(src1) | FC(src2) /* FMUL use FC as src2 */));
 		break;
 
 	case SLJIT_DIV_F64:
-		FAIL_IF(push_inst(compiler, DIV_S | FMT(op) | FT(src2) | FS(src1) | FD(dst_r), MOVABLE_INS));
+		FAIL_IF(push_inst(compiler, SELECT_FOP(op, FDIVS, FDIV) | FD(dst_r) | FA(src1) | FB(src2)));
 		break;
 	}
 
-	if (dst_r == TMP_FREG2)
-		FAIL_IF(emit_op_mem2(compiler, FLOAT_DATA(op), FR(TMP_FREG2), dst, dstw, 0, 0));
+	if (dst & SLJIT_MEM)
+		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op), TMP_FREG2, dst, dstw, TMP_REG1));
 
 	return SLJIT_SUCCESS;
 }
 
+#undef SELECT_FOP
+
 /* --------------------------------------------------------------------- */
 /*  Other instructions                                                   */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_fast_enter(compiler, dst, dstw));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 
 	if (FAST_IS_REG(dst))
-		return push_inst(compiler, ADDU_W | SA(RETURN_ADDR_REG) | TA(0) | D(dst), UNMOVABLE_INS);
+		return push_inst(compiler, MFLR | D(dst));
 
 	/* Memory. */
-	FAIL_IF(emit_op_mem(compiler, WORD_DATA, RETURN_ADDR_REG, dst, dstw));
-	compiler->delay_slot = UNMOVABLE_INS;
-	return SLJIT_SUCCESS;
+	FAIL_IF(push_inst(compiler, MFLR | D(TMP_REG2)));
+	return emit_op(compiler, SLJIT_MOV, WORD_DATA, dst, dstw, TMP_REG1, 0, TMP_REG2, 0);
 }
 
 /* --------------------------------------------------------------------- */
 /*  Conditional instructions                                             */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_label* sljit_emit_label(struct sljit_compiler *compiler)
@@ -1991,477 +2196,608 @@
 
 	if (compiler->last_label && compiler->last_label->size == compiler->size)
 		return compiler->last_label;
 
 	label = (struct sljit_label*)ensure_abuf(compiler, sizeof(struct sljit_label));
 	PTR_FAIL_IF(!label);
 	set_label(label, compiler);
-	compiler->delay_slot = UNMOVABLE_INS;
 	return label;
 }
 
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-#define JUMP_LENGTH	4
-#else
-#define JUMP_LENGTH	8
-#endif
-
-#define BR_Z(src) \
-	inst = BEQ | SA(src) | TA(0) | JUMP_LENGTH; \
-	flags = IS_BIT26_COND; \
-	delay_check = src;
-
-#define BR_NZ(src) \
-	inst = BNE | SA(src) | TA(0) | JUMP_LENGTH; \
-	flags = IS_BIT26_COND; \
-	delay_check = src;
-
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-
-#define BR_T() \
-	inst = BC1NEZ; \
-	flags = IS_BIT23_COND; \
-	delay_check = FCSR_FCC;
-#define BR_F() \
-	inst = BC1EQZ; \
-	flags = IS_BIT23_COND; \
-	delay_check = FCSR_FCC;
-
-#else /* SLJIT_MIPS_REV < 6 */
-
-#define BR_T() \
-	inst = BC1T | JUMP_LENGTH; \
-	flags = IS_BIT16_COND; \
-	delay_check = FCSR_FCC;
-#define BR_F() \
-	inst = BC1F | JUMP_LENGTH; \
-	flags = IS_BIT16_COND; \
-	delay_check = FCSR_FCC;
-
-#endif /* SLJIT_MIPS_REV >= 6 */
-
-SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_jump(struct sljit_compiler *compiler, sljit_s32 type)
+static sljit_ins get_bo_bi_flags(struct sljit_compiler *compiler, sljit_s32 type)
 {
-	struct sljit_jump *jump;
-	sljit_ins inst;
-	sljit_u32 flags = 0;
-	sljit_s32 delay_check = UNMOVABLE_INS;
+	switch (type) {
+	case SLJIT_NOT_CARRY:
+		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_SUB)
+			return (4 << 21) | (2 << 16);
+		/* fallthrough */
 
-	CHECK_ERROR_PTR();
-	CHECK_PTR(check_sljit_emit_jump(compiler, type));
+	case SLJIT_EQUAL:
+		return (12 << 21) | (2 << 16);
 
-	jump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));
-	PTR_FAIL_IF(!jump);
-	set_jump(jump, compiler, type & SLJIT_REWRITABLE_JUMP);
-	type &= 0xff;
+	case SLJIT_CARRY:
+		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_SUB)
+			return (12 << 21) | (2 << 16);
+		/* fallthrough */
 
-	switch (type) {
-	case SLJIT_EQUAL:
-		BR_NZ(EQUAL_FLAG);
-		break;
 	case SLJIT_NOT_EQUAL:
-		BR_Z(EQUAL_FLAG);
-		break;
+		return (4 << 21) | (2 << 16);
+
 	case SLJIT_LESS:
-	case SLJIT_GREATER:
 	case SLJIT_SIG_LESS:
-	case SLJIT_SIG_GREATER:
-	case SLJIT_OVERFLOW:
-	case SLJIT_CARRY:
-		BR_Z(OTHER_FLAG);
-		break;
+		return (12 << 21) | (0 << 16);
+
 	case SLJIT_GREATER_EQUAL:
-	case SLJIT_LESS_EQUAL:
 	case SLJIT_SIG_GREATER_EQUAL:
+		return (4 << 21) | (0 << 16);
+
+	case SLJIT_GREATER:
+	case SLJIT_SIG_GREATER:
+		return (12 << 21) | (1 << 16);
+
+	case SLJIT_LESS_EQUAL:
 	case SLJIT_SIG_LESS_EQUAL:
-	case SLJIT_NOT_OVERFLOW:
-	case SLJIT_NOT_CARRY:
-		BR_NZ(OTHER_FLAG);
-		break;
-	case SLJIT_NOT_EQUAL_F64:
-	case SLJIT_GREATER_EQUAL_F64:
-	case SLJIT_GREATER_F64:
-	case SLJIT_ORDERED_F64:
-		BR_T();
-		break;
-	case SLJIT_EQUAL_F64:
-	case SLJIT_LESS_F64:
-	case SLJIT_LESS_EQUAL_F64:
-	case SLJIT_UNORDERED_F64:
-		BR_F();
-		break;
-	default:
-		/* Not conditional branch. */
-		inst = 0;
-		break;
-	}
+		return (4 << 21) | (1 << 16);
 
-	jump->flags |= flags;
-	if (compiler->delay_slot == MOVABLE_INS || (compiler->delay_slot != UNMOVABLE_INS && compiler->delay_slot != delay_check))
-		jump->flags |= IS_MOVABLE;
+	case SLJIT_OVERFLOW:
+		return (12 << 21) | (3 << 16);
 
-	if (inst)
-		PTR_FAIL_IF(push_inst(compiler, inst, UNMOVABLE_INS));
+	case SLJIT_NOT_OVERFLOW:
+		return (4 << 21) | (3 << 16);
 
-	PTR_FAIL_IF(emit_const(compiler, TMP_REG2, 0));
+	case SLJIT_F_LESS:
+	case SLJIT_ORDERED_LESS:
+	case SLJIT_UNORDERED_OR_LESS:
+		return (12 << 21) | ((4 + 0) << 16);
+
+	case SLJIT_F_GREATER_EQUAL:
+	case SLJIT_ORDERED_GREATER_EQUAL:
+	case SLJIT_UNORDERED_OR_GREATER_EQUAL:
+		return (4 << 21) | ((4 + 0) << 16);
+
+	case SLJIT_F_GREATER:
+	case SLJIT_ORDERED_GREATER:
+	case SLJIT_UNORDERED_OR_GREATER:
+		return (12 << 21) | ((4 + 1) << 16);
+
+	case SLJIT_F_LESS_EQUAL:
+	case SLJIT_ORDERED_LESS_EQUAL:
+	case SLJIT_UNORDERED_OR_LESS_EQUAL:
+		return (4 << 21) | ((4 + 1) << 16);
+
+	case SLJIT_F_EQUAL:
+	case SLJIT_ORDERED_EQUAL:
+	case SLJIT_UNORDERED_OR_EQUAL:
+		return (12 << 21) | ((4 + 2) << 16);
+
+	case SLJIT_F_NOT_EQUAL:
+	case SLJIT_ORDERED_NOT_EQUAL:
+	case SLJIT_UNORDERED_OR_NOT_EQUAL:
+		return (4 << 21) | ((4 + 2) << 16);
 
-	if (type <= SLJIT_JUMP)
-		PTR_FAIL_IF(push_inst(compiler, JR | S(TMP_REG2), UNMOVABLE_INS));
-	else {
-		jump->flags |= IS_JAL;
-		PTR_FAIL_IF(push_inst(compiler, JALR | S(TMP_REG2) | DA(RETURN_ADDR_REG), UNMOVABLE_INS));
-	}
+	case SLJIT_UNORDERED:
+		return (12 << 21) | ((4 + 3) << 16);
 
-	jump->addr = compiler->size;
-	PTR_FAIL_IF(push_inst(compiler, NOP, UNMOVABLE_INS));
-	return jump;
-}
+	case SLJIT_ORDERED:
+		return (4 << 21) | ((4 + 3) << 16);
 
-#define RESOLVE_IMM1() \
-	if (src1 & SLJIT_IMM) { \
-		if (src1w) { \
-			PTR_FAIL_IF(load_immediate(compiler, DR(TMP_REG1), src1w)); \
-			src1 = TMP_REG1; \
-		} \
-		else \
-			src1 = 0; \
-	}
-
-#define RESOLVE_IMM2() \
-	if (src2 & SLJIT_IMM) { \
-		if (src2w) { \
-			PTR_FAIL_IF(load_immediate(compiler, DR(TMP_REG2), src2w)); \
-			src2 = TMP_REG2; \
-		} \
-		else \
-			src2 = 0; \
+	default:
+		SLJIT_ASSERT(type >= SLJIT_JUMP && type <= SLJIT_CALL_REG_ARG);
+		return (20 << 21);
 	}
+}
 
-SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_cmp(struct sljit_compiler *compiler, sljit_s32 type,
-	sljit_s32 src1, sljit_sw src1w,
-	sljit_s32 src2, sljit_sw src2w)
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_jump(struct sljit_compiler *compiler, sljit_s32 type)
 {
 	struct sljit_jump *jump;
-	sljit_s32 flags;
-	sljit_ins inst;
+	sljit_ins bo_bi_flags;
 
 	CHECK_ERROR_PTR();
-	CHECK_PTR(check_sljit_emit_cmp(compiler, type, src1, src1w, src2, src2w));
-	ADJUST_LOCAL_OFFSET(src1, src1w);
-	ADJUST_LOCAL_OFFSET(src2, src2w);
+	CHECK_PTR(check_sljit_emit_jump(compiler, type));
 
-	compiler->cache_arg = 0;
-	compiler->cache_argw = 0;
-	flags = ((type & SLJIT_32) ? INT_DATA : WORD_DATA) | LOAD_DATA;
-	if (src1 & SLJIT_MEM) {
-		PTR_FAIL_IF(emit_op_mem2(compiler, flags, DR(TMP_REG1), src1, src1w, src2, src2w));
-		src1 = TMP_REG1;
-	}
-	if (src2 & SLJIT_MEM) {
-		PTR_FAIL_IF(emit_op_mem2(compiler, flags, DR(TMP_REG2), src2, src2w, 0, 0));
-		src2 = TMP_REG2;
-	}
+	bo_bi_flags = get_bo_bi_flags(compiler, type & 0xff);
+	if (!bo_bi_flags)
+		return NULL;
 
 	jump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));
 	PTR_FAIL_IF(!jump);
-	set_jump(jump, compiler, type & SLJIT_REWRITABLE_JUMP);
+	set_jump(jump, compiler, (sljit_u32)type & SLJIT_REWRITABLE_JUMP);
 	type &= 0xff;
 
-	if (type <= SLJIT_NOT_EQUAL) {
-		RESOLVE_IMM1();
-		RESOLVE_IMM2();
-		jump->flags |= IS_BIT26_COND;
-		if (compiler->delay_slot == MOVABLE_INS || (compiler->delay_slot != UNMOVABLE_INS && compiler->delay_slot != DR(src1) && compiler->delay_slot != DR(src2)))
-			jump->flags |= IS_MOVABLE;
-		PTR_FAIL_IF(push_inst(compiler, (type == SLJIT_EQUAL ? BNE : BEQ) | S(src1) | T(src2) | JUMP_LENGTH, UNMOVABLE_INS));
-	}
-	else if (type >= SLJIT_SIG_LESS && (((src1 & SLJIT_IMM) && (src1w == 0)) || ((src2 & SLJIT_IMM) && (src2w == 0)))) {
-		inst = NOP;
-		if ((src1 & SLJIT_IMM) && (src1w == 0)) {
-			RESOLVE_IMM2();
-			switch (type) {
-			case SLJIT_SIG_LESS:
-				inst = BLEZ;
-				jump->flags |= IS_BIT26_COND;
-				break;
-			case SLJIT_SIG_GREATER_EQUAL:
-				inst = BGTZ;
-				jump->flags |= IS_BIT26_COND;
-				break;
-			case SLJIT_SIG_GREATER:
-				inst = BGEZ;
-				jump->flags |= IS_BIT16_COND;
-				break;
-			case SLJIT_SIG_LESS_EQUAL:
-				inst = BLTZ;
-				jump->flags |= IS_BIT16_COND;
-				break;
-			}
-			src1 = src2;
-		}
-		else {
-			RESOLVE_IMM1();
-			switch (type) {
-			case SLJIT_SIG_LESS:
-				inst = BGEZ;
-				jump->flags |= IS_BIT16_COND;
-				break;
-			case SLJIT_SIG_GREATER_EQUAL:
-				inst = BLTZ;
-				jump->flags |= IS_BIT16_COND;
-				break;
-			case SLJIT_SIG_GREATER:
-				inst = BLEZ;
-				jump->flags |= IS_BIT26_COND;
-				break;
-			case SLJIT_SIG_LESS_EQUAL:
-				inst = BGTZ;
-				jump->flags |= IS_BIT26_COND;
-				break;
-			}
-		}
-		PTR_FAIL_IF(push_inst(compiler, inst | S(src1) | JUMP_LENGTH, UNMOVABLE_INS));
-	}
-	else {
-		if (type == SLJIT_LESS || type == SLJIT_GREATER_EQUAL || type == SLJIT_SIG_LESS || type == SLJIT_SIG_GREATER_EQUAL) {
-			RESOLVE_IMM1();
-			if ((src2 & SLJIT_IMM) && src2w <= SIMM_MAX && src2w >= SIMM_MIN)
-				PTR_FAIL_IF(push_inst(compiler, (type <= SLJIT_LESS_EQUAL ? SLTIU : SLTI) | S(src1) | T(TMP_REG1) | IMM(src2w), DR(TMP_REG1)));
-			else {
-				RESOLVE_IMM2();
-				PTR_FAIL_IF(push_inst(compiler, (type <= SLJIT_LESS_EQUAL ? SLTU : SLT) | S(src1) | T(src2) | D(TMP_REG1), DR(TMP_REG1)));
-			}
-			type = (type == SLJIT_LESS || type == SLJIT_SIG_LESS) ? SLJIT_NOT_EQUAL : SLJIT_EQUAL;
-		}
-		else {
-			RESOLVE_IMM2();
-			if ((src1 & SLJIT_IMM) && src1w <= SIMM_MAX && src1w >= SIMM_MIN)
-				PTR_FAIL_IF(push_inst(compiler, (type <= SLJIT_LESS_EQUAL ? SLTIU : SLTI) | S(src2) | T(TMP_REG1) | IMM(src1w), DR(TMP_REG1)));
-			else {
-				RESOLVE_IMM1();
-				PTR_FAIL_IF(push_inst(compiler, (type <= SLJIT_LESS_EQUAL ? SLTU : SLT) | S(src2) | T(src1) | D(TMP_REG1), DR(TMP_REG1)));
-			}
-			type = (type == SLJIT_GREATER || type == SLJIT_SIG_GREATER) ? SLJIT_NOT_EQUAL : SLJIT_EQUAL;
-		}
+	if (type == SLJIT_CARRY || type == SLJIT_NOT_CARRY)
+		PTR_FAIL_IF(push_inst(compiler, ADDE | RC(ALT_SET_FLAGS) | D(TMP_REG1) | A(TMP_ZERO) | B(TMP_ZERO)));
 
-		jump->flags |= IS_BIT26_COND;
-		PTR_FAIL_IF(push_inst(compiler, (type == SLJIT_EQUAL ? BNE : BEQ) | S(TMP_REG1) | TA(0) | JUMP_LENGTH, UNMOVABLE_INS));
-	}
+	/* In PPC, we don't need to touch the arguments. */
+	if (type < SLJIT_JUMP)
+		jump->flags |= IS_COND;
+#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL)
+	if (type >= SLJIT_CALL)
+		jump->flags |= IS_CALL;
+#endif
 
-	PTR_FAIL_IF(emit_const(compiler, TMP_REG2, 0));
-	PTR_FAIL_IF(push_inst(compiler, JR | S(TMP_REG2), UNMOVABLE_INS));
+	PTR_FAIL_IF(emit_const(compiler, TMP_CALL_REG, 0));
+	PTR_FAIL_IF(push_inst(compiler, MTCTR | S(TMP_CALL_REG)));
 	jump->addr = compiler->size;
-	PTR_FAIL_IF(push_inst(compiler, NOP, UNMOVABLE_INS));
+	PTR_FAIL_IF(push_inst(compiler, BCCTR | bo_bi_flags | (type >= SLJIT_FAST_CALL ? 1 : 0)));
 	return jump;
 }
 
-#undef RESOLVE_IMM1
-#undef RESOLVE_IMM2
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 arg_types)
+{
+	CHECK_ERROR_PTR();
+	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG)
+		PTR_FAIL_IF(call_with_args(compiler, arg_types, NULL));
+#endif
 
-#undef JUMP_LENGTH
-#undef BR_Z
-#undef BR_NZ
-#undef BR_T
-#undef BR_F
+	if (type & SLJIT_CALL_RETURN) {
+		PTR_FAIL_IF(emit_stack_frame_release(compiler, 0));
+		type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
+	}
 
-#undef FLOAT_DATA
-#undef FMT
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_jump(compiler, type);
+}
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_ijump(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 src, sljit_sw srcw)
 {
 	struct sljit_jump *jump = NULL;
+	sljit_s32 src_r;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_ijump(compiler, type, src, srcw));
-	ADJUST_LOCAL_OFFSET(src, srcw);
 
-	if (src & SLJIT_IMM) {
+	if (FAST_IS_REG(src)) {
+#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL)
+		if (type >= SLJIT_CALL && src != TMP_CALL_REG) {
+			FAIL_IF(push_inst(compiler, OR | S(src) | A(TMP_CALL_REG) | B(src)));
+			src_r = TMP_CALL_REG;
+		}
+		else
+			src_r = src;
+#else /* SLJIT_PASS_ENTRY_ADDR_TO_CALL */
+		src_r = src;
+#endif /* SLJIT_PASS_ENTRY_ADDR_TO_CALL */
+	} else if (src & SLJIT_IMM) {
+		/* These jumps are converted to jump/call instructions when possible. */
 		jump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));
 		FAIL_IF(!jump);
-		set_jump(jump, compiler, JUMP_ADDR | ((type >= SLJIT_FAST_CALL) ? IS_JAL : 0));
+		set_jump(jump, compiler, JUMP_ADDR);
 		jump->u.target = (sljit_uw)srcw;
 
-		if (compiler->delay_slot != UNMOVABLE_INS)
-			jump->flags |= IS_MOVABLE;
+#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL)
+		if (type >= SLJIT_CALL)
+			jump->flags |= IS_CALL;
+#endif /* SLJIT_PASS_ENTRY_ADDR_TO_CALL */
 
-		FAIL_IF(emit_const(compiler, TMP_REG2, 0));
-		src = TMP_REG2;
-	}
-	else if (src & SLJIT_MEM) {
-		FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, DR(TMP_REG2), src, srcw));
-		src = TMP_REG2;
+		FAIL_IF(emit_const(compiler, TMP_CALL_REG, 0));
+		src_r = TMP_CALL_REG;
+	} else {
+		ADJUST_LOCAL_OFFSET(src, srcw);
+		FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, TMP_CALL_REG, src, srcw, TMP_CALL_REG));
+		src_r = TMP_CALL_REG;
 	}
 
-	FAIL_IF(push_inst(compiler, JR | S(src), UNMOVABLE_INS));
+	FAIL_IF(push_inst(compiler, MTCTR | S(src_r)));
 	if (jump)
 		jump->addr = compiler->size;
-	FAIL_IF(push_inst(compiler, NOP, UNMOVABLE_INS));
-	return SLJIT_SUCCESS;
+	return push_inst(compiler, BCCTR | (20 << 21) | (type >= SLJIT_FAST_CALL ? 1 : 0));
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_icall(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 arg_types,
+	sljit_s32 src, sljit_sw srcw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_icall(compiler, type, arg_types, src, srcw));
+
+	if (src & SLJIT_MEM) {
+		ADJUST_LOCAL_OFFSET(src, srcw);
+		FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, TMP_CALL_REG, src, srcw, TMP_CALL_REG));
+		src = TMP_CALL_REG;
+	}
+
+	if (type & SLJIT_CALL_RETURN) {
+		if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
+			FAIL_IF(push_inst(compiler, OR | S(src) | A(TMP_CALL_REG) | B(src)));
+			src = TMP_CALL_REG;
+		}
+
+		FAIL_IF(emit_stack_frame_release(compiler, 0));
+		type = SLJIT_JUMP;
+	}
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG)
+		FAIL_IF(call_with_args(compiler, arg_types, &src));
+#endif
+
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_ijump(compiler, type, src, srcw);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_flags(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 type)
 {
-	sljit_s32 src_ar, dst_ar;
+	sljit_s32 reg, invert;
+	sljit_u32 bit, from_xer;
 	sljit_s32 saved_op = op;
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
-	sljit_s32 mem_type = WORD_DATA;
+	sljit_sw saved_dstw = dstw;
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	sljit_s32 input_flags = ((op & SLJIT_32) || op == SLJIT_MOV32) ? INT_DATA : WORD_DATA;
 #else
-	sljit_s32 mem_type = ((op & SLJIT_32) || op == SLJIT_MOV32) ? (INT_DATA | SIGNED_DATA) : WORD_DATA;
+	sljit_s32 input_flags = WORD_DATA;
 #endif
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_flags(compiler, op, dst, dstw, type));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 
 	op = GET_OPCODE(op);
-	dst_ar = DR((op < SLJIT_ADD && FAST_IS_REG(dst)) ? dst : TMP_REG2);
-
-	compiler->cache_arg = 0;
-	compiler->cache_argw = 0;
+	reg = (op < SLJIT_ADD && FAST_IS_REG(dst)) ? dst : TMP_REG2;
 
 	if (op >= SLJIT_ADD && (dst & SLJIT_MEM))
-		FAIL_IF(emit_op_mem2(compiler, mem_type | LOAD_DATA, DR(TMP_REG1), dst, dstw, dst, dstw));
+		FAIL_IF(emit_op_mem(compiler, input_flags | LOAD_DATA, TMP_REG1, dst, dstw, TMP_REG1));
+
+	invert = 0;
+	bit = 0;
+	from_xer = 0;
+
+	switch (type) {
+	case SLJIT_LESS:
+	case SLJIT_SIG_LESS:
+		break;
+
+	case SLJIT_GREATER_EQUAL:
+	case SLJIT_SIG_GREATER_EQUAL:
+		invert = 1;
+		break;
+
+	case SLJIT_GREATER:
+	case SLJIT_SIG_GREATER:
+		bit = 1;
+		break;
+
+	case SLJIT_LESS_EQUAL:
+	case SLJIT_SIG_LESS_EQUAL:
+		bit = 1;
+		invert = 1;
+		break;
 
-	switch (type & 0xff) {
 	case SLJIT_EQUAL:
+		bit = 2;
+		break;
+
 	case SLJIT_NOT_EQUAL:
-		FAIL_IF(push_inst(compiler, SLTIU | SA(EQUAL_FLAG) | TA(dst_ar) | IMM(1), dst_ar));
-		src_ar = dst_ar;
+		bit = 2;
+		invert = 1;
 		break;
+
 	case SLJIT_OVERFLOW:
+		from_xer = 1;
+		bit = 1;
+		break;
+
 	case SLJIT_NOT_OVERFLOW:
-		if (compiler->status_flags_state & (SLJIT_CURRENT_FLAGS_ADD | SLJIT_CURRENT_FLAGS_SUB)) {
-			src_ar = OTHER_FLAG;
-			break;
-		}
-		FAIL_IF(push_inst(compiler, SLTIU | SA(OTHER_FLAG) | TA(dst_ar) | IMM(1), dst_ar));
-		src_ar = dst_ar;
-		type ^= 0x1; /* Flip type bit for the XORI below. */
-		break;
-	case SLJIT_GREATER_F64:
-	case SLJIT_LESS_EQUAL_F64:
-		type ^= 0x1; /* Flip type bit for the XORI below. */
-		/* fallthrough */
-	case SLJIT_EQUAL_F64:
-	case SLJIT_NOT_EQUAL_F64:
-	case SLJIT_LESS_F64:
-	case SLJIT_GREATER_EQUAL_F64:
-	case SLJIT_UNORDERED_F64:
-	case SLJIT_ORDERED_F64:
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 6)
-		FAIL_IF(push_inst(compiler, MFC1 | TA(dst_ar) | FS(TMP_FREG3), dst_ar));
-#else /* SLJIT_MIPS_REV < 6 */
-		FAIL_IF(push_inst(compiler, CFC1 | TA(dst_ar) | DA(FCSR_REG), dst_ar));
-#endif /* SLJIT_MIPS_REV >= 6 */
-		FAIL_IF(push_inst(compiler, SRL | TA(dst_ar) | DA(dst_ar) | SH_IMM(23), dst_ar));
-		FAIL_IF(push_inst(compiler, ANDI | SA(dst_ar) | TA(dst_ar) | IMM(1), dst_ar));
-		src_ar = dst_ar;
+		from_xer = 1;
+		bit = 1;
+		invert = 1;
+		break;
+
+	case SLJIT_CARRY:
+		from_xer = 1;
+		bit = 2;
+		invert = (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_SUB) != 0;
+		break;
+
+	case SLJIT_NOT_CARRY:
+		from_xer = 1;
+		bit = 2;
+		invert = (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_ADD) != 0;
+		break;
+
+	case SLJIT_F_LESS:
+	case SLJIT_ORDERED_LESS:
+	case SLJIT_UNORDERED_OR_LESS:
+		bit = 4 + 0;
+		break;
+
+	case SLJIT_F_GREATER_EQUAL:
+	case SLJIT_ORDERED_GREATER_EQUAL:
+	case SLJIT_UNORDERED_OR_GREATER_EQUAL:
+		bit = 4 + 0;
+		invert = 1;
+		break;
+
+	case SLJIT_F_GREATER:
+	case SLJIT_ORDERED_GREATER:
+	case SLJIT_UNORDERED_OR_GREATER:
+		bit = 4 + 1;
+		break;
+
+	case SLJIT_F_LESS_EQUAL:
+	case SLJIT_ORDERED_LESS_EQUAL:
+	case SLJIT_UNORDERED_OR_LESS_EQUAL:
+		bit = 4 + 1;
+		invert = 1;
+		break;
+
+	case SLJIT_F_EQUAL:
+	case SLJIT_ORDERED_EQUAL:
+	case SLJIT_UNORDERED_OR_EQUAL:
+		bit = 4 + 2;
+		break;
+
+	case SLJIT_F_NOT_EQUAL:
+	case SLJIT_ORDERED_NOT_EQUAL:
+	case SLJIT_UNORDERED_OR_NOT_EQUAL:
+		bit = 4 + 2;
+		invert = 1;
+		break;
+
+	case SLJIT_UNORDERED:
+		bit = 4 + 3;
+		break;
+
+	case SLJIT_ORDERED:
+		bit = 4 + 3;
+		invert = 1;
 		break;
 
 	default:
-		src_ar = OTHER_FLAG;
+		SLJIT_UNREACHABLE();
 		break;
 	}
 
-	if (type & 0x1) {
-		FAIL_IF(push_inst(compiler, XORI | SA(src_ar) | TA(dst_ar) | IMM(1), dst_ar));
-		src_ar = dst_ar;
-	}
+	FAIL_IF(push_inst(compiler, (from_xer ? MFXER : MFCR) | D(reg)));
+	/* Simplified mnemonics: extrwi. */
+	FAIL_IF(push_inst(compiler, RLWINM | S(reg) | A(reg) | RLWI_SH(1 + bit) | RLWI_MBE(31, 31)));
 
-	if (op < SLJIT_ADD) {
-		if (dst & SLJIT_MEM)
-			return emit_op_mem(compiler, mem_type, src_ar, dst, dstw);
+	if (invert)
+		FAIL_IF(push_inst(compiler, XORI | S(reg) | A(reg) | 0x1));
 
-		if (src_ar != dst_ar)
-			return push_inst(compiler, ADDU_W | SA(src_ar) | TA(0) | DA(dst_ar), dst_ar);
-		return SLJIT_SUCCESS;
+	if (op < SLJIT_ADD) {
+		if (!(dst & SLJIT_MEM))
+			return SLJIT_SUCCESS;
+		return emit_op_mem(compiler, input_flags, reg, dst, dstw, TMP_REG1);
 	}
 
-	/* OTHER_FLAG cannot be specified as src2 argument at the moment. */
-	if (DR(TMP_REG2) != src_ar)
-		FAIL_IF(push_inst(compiler, ADDU_W | SA(src_ar) | TA(0) | D(TMP_REG2), DR(TMP_REG2)));
-
-	mem_type |= CUMULATIVE_OP | LOGICAL_OP | IMM_OP | ALT_KEEP_CACHE;
+	SLJIT_SKIP_CHECKS(compiler);
 
 	if (dst & SLJIT_MEM)
-		return emit_op(compiler, saved_op, mem_type, dst, dstw, TMP_REG1, 0, TMP_REG2, 0);
-	return emit_op(compiler, saved_op, mem_type, dst, dstw, dst, dstw, TMP_REG2, 0);
+		return sljit_emit_op2(compiler, saved_op, dst, saved_dstw, TMP_REG1, 0, TMP_REG2, 0);
+	return sljit_emit_op2(compiler, saved_op, dst, 0, dst, 0, TMP_REG2, 0);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_cmov(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 dst_reg,
 	sljit_s32 src, sljit_sw srcw)
 {
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1 && SLJIT_MIPS_REV < 6)
-	sljit_ins ins;
-#endif /* SLJIT_MIPS_REV >= 1 && SLJIT_MIPS_REV < 6 */
-
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_cmov(compiler, type, dst_reg, src, srcw));
 
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1 && SLJIT_MIPS_REV < 6)
+	return sljit_emit_cmov_generic(compiler, type, dst_reg, src, srcw);;
+}
+
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
 
-	if (SLJIT_UNLIKELY(src & SLJIT_IMM)) {
-#if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
-		if (dst_reg & SLJIT_32)
-			srcw = (sljit_s32)srcw;
-#endif
-		FAIL_IF(load_immediate(compiler, DR(TMP_REG1), srcw));
-		src = TMP_REG1;
-		srcw = 0;
+#define EMIT_MEM_LOAD_IMM(inst, mem, memw) \
+	((sljit_s16)(memw) > SIMM_MAX - SSIZE_OF(sw))
+
+#else /* !SLJIT_CONFIG_PPC_32 */
+
+#define EMIT_MEM_LOAD_IMM(inst, mem, memw) \
+	((((inst) & INT_ALIGNED) && ((memw) & 0x3) != 0) \
+		|| ((sljit_s16)(memw) > SIMM_MAX - SSIZE_OF(sw)) \
+		|| ((memw) > 0x7fff7fffl || (memw) < -0x80000000l)) \
+
+#endif /* SLJIT_CONFIG_PPC_32 */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	sljit_ins inst;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_mem(compiler, type, reg, mem, memw));
+
+	if (!(reg & REG_PAIR_MASK))
+		return sljit_emit_mem_unaligned(compiler, type, reg, mem, memw);
+
+	ADJUST_LOCAL_OFFSET(mem, memw);
+
+	inst = data_transfer_insts[WORD_DATA | ((type & SLJIT_MEM_STORE) ? 0 : LOAD_DATA)];
+
+	if (SLJIT_UNLIKELY(mem & OFFS_REG_MASK)) {
+		memw &= 0x3;
+
+		if (memw != 0) {
+			FAIL_IF(push_inst(compiler, SLWI_W(memw) | S(OFFS_REG(mem)) | A(TMP_REG1)));
+			FAIL_IF(push_inst(compiler, ADD | D(TMP_REG1) | A(TMP_REG1) | B(mem & REG_MASK)));
+		} else
+			FAIL_IF(push_inst(compiler, ADD | D(TMP_REG1) | A(mem & REG_MASK) | B(OFFS_REG(mem))));
+
+		mem = TMP_REG1;
+		memw = 0;
+	} else {
+		if (EMIT_MEM_LOAD_IMM(inst, mem, memw)) {
+			if ((mem & REG_MASK) != 0) {
+				SLJIT_SKIP_CHECKS(compiler);
+				FAIL_IF(sljit_emit_op2(compiler, SLJIT_ADD, TMP_REG1, 0, mem & REG_MASK, 0, SLJIT_IMM, memw));
+			} else
+				FAIL_IF(load_immediate(compiler, TMP_REG1, memw));
+
+			memw = 0;
+			mem = TMP_REG1;
+		} else if (memw > SIMM_MAX || memw < SIMM_MIN) {
+			FAIL_IF(push_inst(compiler, ADDIS | D(TMP_REG1) | A(mem & REG_MASK) | IMM((memw + 0x8000) >> 16)));
+
+			memw &= 0xffff;
+			mem = TMP_REG1;
+		} else {
+			memw &= 0xffff;
+			mem &= REG_MASK;
+		}
 	}
 
-	dst_reg &= ~SLJIT_32;
+	SLJIT_ASSERT((memw >= 0 && memw <= SIMM_MAX - SSIZE_OF(sw)) || (memw >= 0x8000 && memw <= 0xffff));
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	inst &= (sljit_ins)~INT_ALIGNED;
+#endif /* SLJIT_CONFIG_PPC_64 */
+
+	if (!(type & SLJIT_MEM_STORE) && mem == REG_PAIR_FIRST(reg)) {
+		FAIL_IF(push_inst(compiler, inst | D(REG_PAIR_SECOND(reg)) | A(mem) | IMM(memw + SSIZE_OF(sw))));
+		return push_inst(compiler, inst | D(REG_PAIR_FIRST(reg)) | A(mem) | IMM(memw));
+	}
+
+	FAIL_IF(push_inst(compiler, inst | D(REG_PAIR_FIRST(reg)) | A(mem) | IMM(memw)));
+	return push_inst(compiler, inst | D(REG_PAIR_SECOND(reg)) | A(mem) | IMM(memw + SSIZE_OF(sw)));
+}
+
+#undef EMIT_MEM_LOAD_IMM
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem_update(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	sljit_s32 mem_flags;
+	sljit_ins inst;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_mem_update(compiler, type, reg, mem, memw));
+
+	if (type & SLJIT_MEM_POST)
+		return SLJIT_ERR_UNSUPPORTED;
 
 	switch (type & 0xff) {
-	case SLJIT_EQUAL:
-		ins = MOVZ | TA(EQUAL_FLAG);
+	case SLJIT_MOV:
+	case SLJIT_MOV_P:
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
+	case SLJIT_MOV_U32:
+	case SLJIT_MOV_S32:
+	case SLJIT_MOV32:
+#endif
+		mem_flags = WORD_DATA;
 		break;
-	case SLJIT_NOT_EQUAL:
-		ins = MOVN | TA(EQUAL_FLAG);
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	case SLJIT_MOV_U32:
+	case SLJIT_MOV32:
+		mem_flags = INT_DATA;
 		break;
-	case SLJIT_LESS:
-	case SLJIT_GREATER:
-	case SLJIT_SIG_LESS:
-	case SLJIT_SIG_GREATER:
-	case SLJIT_OVERFLOW:
-		ins = MOVN | TA(OTHER_FLAG);
+
+	case SLJIT_MOV_S32:
+		mem_flags = INT_DATA;
+
+		if (!(type & SLJIT_MEM_STORE) && !(type & SLJIT_32)) {
+			if (mem & OFFS_REG_MASK)
+				mem_flags |= SIGNED_DATA;
+			else
+				return SLJIT_ERR_UNSUPPORTED;
+		}
 		break;
-	case SLJIT_GREATER_EQUAL:
-	case SLJIT_LESS_EQUAL:
-	case SLJIT_SIG_GREATER_EQUAL:
-	case SLJIT_SIG_LESS_EQUAL:
-	case SLJIT_NOT_OVERFLOW:
-		ins = MOVZ | TA(OTHER_FLAG);
+#endif
+
+	case SLJIT_MOV_U8:
+	case SLJIT_MOV_S8:
+		mem_flags = BYTE_DATA;
 		break;
-	case SLJIT_EQUAL_F64:
-	case SLJIT_LESS_F64:
-	case SLJIT_LESS_EQUAL_F64:
-	case SLJIT_UNORDERED_F64:
-		ins = MOVT;
-		break;
-	case SLJIT_NOT_EQUAL_F64:
-	case SLJIT_GREATER_EQUAL_F64:
-	case SLJIT_GREATER_F64:
-	case SLJIT_ORDERED_F64:
-		ins = MOVF;
+
+	case SLJIT_MOV_U16:
+		mem_flags = HALF_DATA;
 		break;
+
+	case SLJIT_MOV_S16:
+		mem_flags = HALF_DATA | SIGNED_DATA;
+		break;
+
 	default:
-		ins = MOVZ | TA(OTHER_FLAG);
 		SLJIT_UNREACHABLE();
+		mem_flags = WORD_DATA;
 		break;
 	}
 
-	return push_inst(compiler, ins | S(src) | D(dst_reg), DR(dst_reg));
+	if (!(type & SLJIT_MEM_STORE))
+		mem_flags |= LOAD_DATA;
+
+	if (SLJIT_UNLIKELY(mem & OFFS_REG_MASK)) {
+		if (memw != 0)
+			return SLJIT_ERR_UNSUPPORTED;
 
-#else /* SLJIT_MIPS_REV < 1 || SLJIT_MIPS_REV >= 6 */
-	return sljit_emit_cmov_generic(compiler, type, dst_reg, src, srcw);
-#endif /* SLJIT_MIPS_REV >= 1 */
+		if (type & SLJIT_MEM_SUPP)
+			return SLJIT_SUCCESS;
+
+		inst = updated_data_transfer_insts[mem_flags | INDEXED];
+		FAIL_IF(push_inst(compiler, INST_CODE_AND_DST(inst, 0, reg) | A(mem & REG_MASK) | B(OFFS_REG(mem))));
+	}
+	else {
+		if (memw > SIMM_MAX || memw < SIMM_MIN)
+			return SLJIT_ERR_UNSUPPORTED;
+
+		inst = updated_data_transfer_insts[mem_flags];
+
+#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+		if ((inst & INT_ALIGNED) && (memw & 0x3) != 0)
+			return SLJIT_ERR_UNSUPPORTED;
+#endif
+
+		if (type & SLJIT_MEM_SUPP)
+			return SLJIT_SUCCESS;
+
+		FAIL_IF(push_inst(compiler, INST_CODE_AND_DST(inst, 0, reg) | A(mem & REG_MASK) | IMM(memw)));
+	}
+
+	if ((mem_flags & LOAD_DATA) && (type & 0xff) == SLJIT_MOV_S8)
+		return push_inst(compiler, EXTSB | S(reg) | A(reg));
+	return SLJIT_SUCCESS;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem_update(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 freg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	sljit_s32 mem_flags;
+	sljit_ins inst;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_fmem_update(compiler, type, freg, mem, memw));
+
+	if (type & SLJIT_MEM_POST)
+		return SLJIT_ERR_UNSUPPORTED;
+
+	if (SLJIT_UNLIKELY(mem & OFFS_REG_MASK)) {
+		if (memw != 0)
+			return SLJIT_ERR_UNSUPPORTED;
+	}
+	else {
+		if (memw > SIMM_MAX || memw < SIMM_MIN)
+			return SLJIT_ERR_UNSUPPORTED;
+	}
+
+	if (type & SLJIT_MEM_SUPP)
+		return SLJIT_SUCCESS;
+
+	mem_flags = FLOAT_DATA(type);
+
+	if (!(type & SLJIT_MEM_STORE))
+		mem_flags |= LOAD_DATA;
+
+	if (SLJIT_UNLIKELY(mem & OFFS_REG_MASK)) {
+		inst = updated_data_transfer_insts[mem_flags | INDEXED];
+		return push_inst(compiler, INST_CODE_AND_DST(inst, DOUBLE_DATA, freg) | A(mem & REG_MASK) | B(OFFS_REG(mem)));
+	}
+
+	inst = updated_data_transfer_insts[mem_flags];
+	return push_inst(compiler, INST_CODE_AND_DST(inst, DOUBLE_DATA, freg) | A(mem & REG_MASK) | IMM(memw));
 }
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_const* sljit_emit_const(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw init_value)
 {
 	struct sljit_const *const_;
 	sljit_s32 dst_r;
 
@@ -2492,19 +2828,24 @@
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 
 	put_label = (struct sljit_put_label*)ensure_abuf(compiler, sizeof(struct sljit_put_label));
 	PTR_FAIL_IF(!put_label);
 	set_put_label(put_label, compiler, 0);
 
 	dst_r = FAST_IS_REG(dst) ? dst : TMP_REG2;
-#if (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32)
+#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
 	PTR_FAIL_IF(emit_const(compiler, dst_r, 0));
 #else
-	PTR_FAIL_IF(push_inst(compiler, (sljit_ins)dst_r, UNMOVABLE_INS));
-	compiler->size += 5;
+	PTR_FAIL_IF(push_inst(compiler, (sljit_ins)dst_r));
+	compiler->size += 4;
 #endif
 
 	if (dst & SLJIT_MEM)
 		PTR_FAIL_IF(emit_op(compiler, SLJIT_MOV, WORD_DATA, dst, dstw, TMP_REG1, 0, TMP_REG2, 0));
 
 	return put_label;
 }
+
+SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
+{
+	sljit_set_jump_addr(addr, (sljit_uw)new_constant, executable_offset);
+}
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativePPC_32.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativePPC_32.c`

 * *Files 13% similar despite different names*

```diff
@@ -34,20 +34,23 @@
 	if (!(imm & ~0xffff))
 		return push_inst(compiler, ORI | S(TMP_ZERO) | A(reg) | IMM(imm));
 
 	FAIL_IF(push_inst(compiler, ADDIS | D(reg) | A(0) | IMM(imm >> 16)));
 	return (imm & 0xffff) ? push_inst(compiler, ORI | S(reg) | A(reg) | IMM(imm)) : SLJIT_SUCCESS;
 }
 
+/* Simplified mnemonics: clrlwi. */
 #define INS_CLEAR_LEFT(dst, src, from) \
-	(RLWINM | S(src) | A(dst) | ((from) << 6) | (31 << 1))
+	(RLWINM | S(src) | A(dst) | RLWI_MBE(from, 31))
 
 static SLJIT_INLINE sljit_s32 emit_single_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 flags,
 	sljit_s32 dst, sljit_s32 src1, sljit_s32 src2)
 {
+	sljit_u32 imm;
+
 	switch (op) {
 	case SLJIT_MOV:
 	case SLJIT_MOV_U32:
 	case SLJIT_MOV_S32:
 	case SLJIT_MOV_P:
 		SLJIT_ASSERT(src1 == TMP_REG1);
 		if (dst != src2)
@@ -86,33 +89,45 @@
 		SLJIT_ASSERT(src1 == TMP_REG1);
 		return push_inst(compiler, NOR | RC(flags) | S(src2) | A(dst) | B(src2));
 
 	case SLJIT_CLZ:
 		SLJIT_ASSERT(src1 == TMP_REG1);
 		return push_inst(compiler, CNTLZW | S(src2) | A(dst));
 
+	case SLJIT_CTZ:
+		SLJIT_ASSERT(src1 == TMP_REG1);
+		FAIL_IF(push_inst(compiler, NEG | D(TMP_REG1) | A(src2)));
+		FAIL_IF(push_inst(compiler, AND | S(src2) | A(dst) | B(TMP_REG1)));
+		FAIL_IF(push_inst(compiler, CNTLZW | S(dst) | A(dst)));
+		FAIL_IF(push_inst(compiler, ADDI | D(TMP_REG1) | A(dst) | IMM(-32)));
+		/* The highest bits are set, if dst < 32, zero otherwise. */
+		FAIL_IF(push_inst(compiler, SRWI(27) | S(TMP_REG1) | A(TMP_REG1)));
+		return push_inst(compiler, XOR | S(dst) | A(dst) | B(TMP_REG1));
+
 	case SLJIT_ADD:
 		if (flags & ALT_FORM1) {
 			/* Setting XER SO is not enough, CR SO is also needed. */
 			return push_inst(compiler, ADD | OE(ALT_SET_FLAGS) | RC(ALT_SET_FLAGS) | D(dst) | A(src1) | B(src2));
 		}
 
 		if (flags & ALT_FORM2) {
 			/* Flags does not set: BIN_IMM_EXTS unnecessary. */
 			SLJIT_ASSERT(src2 == TMP_REG2);
 
 			if (flags & ALT_FORM3)
 				return push_inst(compiler, ADDIS | D(dst) | A(src1) | compiler->imm);
 
+			imm = compiler->imm;
+
 			if (flags & ALT_FORM4) {
-				FAIL_IF(push_inst(compiler, ADDIS | D(dst) | A(src1) | (((compiler->imm >> 16) & 0xffff) + ((compiler->imm >> 15) & 0x1))));
+				FAIL_IF(push_inst(compiler, ADDIS | D(dst) | A(src1) | (((imm >> 16) & 0xffff) + ((imm >> 15) & 0x1))));
 				src1 = dst;
 			}
 
-			return push_inst(compiler, ADDI | D(dst) | A(src1) | (compiler->imm & 0xffff));
+			return push_inst(compiler, ADDI | D(dst) | A(src1) | (imm & 0xffff));
 		}
 		if (flags & ALT_FORM3) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
 			return push_inst(compiler, ADDIC | D(dst) | A(src1) | compiler->imm);
 		}
 		SLJIT_ASSERT(!(flags & ALT_FORM4));
 		if (!(flags & ALT_SET_FLAGS))
@@ -204,58 +219,104 @@
 		}
 		if (flags & ALT_FORM2) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
 			return push_inst(compiler, ORIS | S(src1) | A(dst) | compiler->imm);
 		}
 		if (flags & ALT_FORM3) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
-			FAIL_IF(push_inst(compiler, ORI | S(src1) | A(dst) | IMM(compiler->imm)));
-			return push_inst(compiler, ORIS | S(dst) | A(dst) | IMM(compiler->imm >> 16));
+			imm = compiler->imm;
+
+			FAIL_IF(push_inst(compiler, ORI | S(src1) | A(dst) | IMM(imm)));
+			return push_inst(compiler, ORIS | S(dst) | A(dst) | IMM(imm >> 16));
 		}
 		return push_inst(compiler, OR | RC(flags) | S(src1) | A(dst) | B(src2));
 
 	case SLJIT_XOR:
 		if (flags & ALT_FORM1) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
 			return push_inst(compiler, XORI | S(src1) | A(dst) | compiler->imm);
 		}
 		if (flags & ALT_FORM2) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
 			return push_inst(compiler, XORIS | S(src1) | A(dst) | compiler->imm);
 		}
 		if (flags & ALT_FORM3) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
-			FAIL_IF(push_inst(compiler, XORI | S(src1) | A(dst) | IMM(compiler->imm)));
-			return push_inst(compiler, XORIS | S(dst) | A(dst) | IMM(compiler->imm >> 16));
+			imm = compiler->imm;
+
+			FAIL_IF(push_inst(compiler, XORI | S(src1) | A(dst) | IMM(imm)));
+			return push_inst(compiler, XORIS | S(dst) | A(dst) | IMM(imm >> 16));
 		}
 		return push_inst(compiler, XOR | RC(flags) | S(src1) | A(dst) | B(src2));
 
 	case SLJIT_SHL:
+	case SLJIT_MSHL:
 		if (flags & ALT_FORM1) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
-			compiler->imm &= 0x1f;
-			return push_inst(compiler, RLWINM | RC(flags) | S(src1) | A(dst) | (compiler->imm << 11) | ((31 - compiler->imm) << 1));
+			imm = compiler->imm & 0x1f;
+			return push_inst(compiler, SLWI(imm) | RC(flags) | S(src1) | A(dst));
+		}
+
+		if (op == SLJIT_MSHL) {
+			FAIL_IF(push_inst(compiler, ANDI | S(src2) | A(TMP_REG2) | 0x1f));
+			src2 = TMP_REG2;
 		}
+
 		return push_inst(compiler, SLW | RC(flags) | S(src1) | A(dst) | B(src2));
 
 	case SLJIT_LSHR:
+	case SLJIT_MLSHR:
 		if (flags & ALT_FORM1) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
-			compiler->imm &= 0x1f;
-			return push_inst(compiler, RLWINM | RC(flags) | S(src1) | A(dst) | (((32 - compiler->imm) & 0x1f) << 11) | (compiler->imm << 6) | (31 << 1));
+			imm = compiler->imm & 0x1f;
+			/* Since imm can be 0, SRWI() cannot be used. */
+			return push_inst(compiler, RLWINM | RC(flags) | S(src1) | A(dst) | RLWI_SH((32 - imm) & 0x1f) | RLWI_MBE(imm, 31));
+		}
+
+		if (op == SLJIT_MLSHR) {
+			FAIL_IF(push_inst(compiler, ANDI | S(src2) | A(TMP_REG2) | 0x1f));
+			src2 = TMP_REG2;
 		}
+
 		return push_inst(compiler, SRW | RC(flags) | S(src1) | A(dst) | B(src2));
 
 	case SLJIT_ASHR:
+	case SLJIT_MASHR:
 		if (flags & ALT_FORM1) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
-			compiler->imm &= 0x1f;
-			return push_inst(compiler, SRAWI | RC(flags) | S(src1) | A(dst) | (compiler->imm << 11));
+			imm = compiler->imm & 0x1f;
+			return push_inst(compiler, SRAWI | RC(flags) | S(src1) | A(dst) | (imm << 11));
+		}
+
+		if (op == SLJIT_MASHR) {
+			FAIL_IF(push_inst(compiler, ANDI | S(src2) | A(TMP_REG2) | 0x1f));
+			src2 = TMP_REG2;
 		}
+
 		return push_inst(compiler, SRAW | RC(flags) | S(src1) | A(dst) | B(src2));
+
+	case SLJIT_ROTL:
+	case SLJIT_ROTR:
+		if (flags & ALT_FORM1) {
+			SLJIT_ASSERT(src2 == TMP_REG2);
+			imm = compiler->imm;
+
+			if (op == SLJIT_ROTR)
+				imm = (sljit_u32)(-(sljit_s32)imm);
+
+			imm &= 0x1f;
+			return push_inst(compiler, RLWINM | S(src1) | A(dst) | RLWI_SH(imm) | RLWI_MBE(0, 31));
+		}
+
+		if (op == SLJIT_ROTR) {
+			FAIL_IF(push_inst(compiler, SUBFIC | D(TMP_REG2) | A(src2) | 0));
+			src2 = TMP_REG2;
+		}
+
+		return push_inst(compiler, RLWNM | S(src1) | A(dst) | B(src2) | RLWI_MBE(0, 31));
 	}
 
 	SLJIT_UNREACHABLE();
 	return SLJIT_SUCCESS;
 }
 
 static SLJIT_INLINE sljit_s32 emit_const(struct sljit_compiler *compiler, sljit_s32 reg, sljit_sw init_value)
@@ -273,12 +334,7 @@
 	SLJIT_ASSERT((inst[0] & 0xfc1f0000) == ADDIS && (inst[1] & 0xfc000000) == ORI);
 	inst[0] = (inst[0] & 0xffff0000) | ((new_target >> 16) & 0xffff);
 	inst[1] = (inst[1] & 0xffff0000) | (new_target & 0xffff);
 	SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 1);
 	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 	SLJIT_CACHE_FLUSH(inst, inst + 2);
 }
-
-SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
-{
-	sljit_set_jump_addr(addr, (sljit_uw)new_constant, executable_offset);
-}
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativePPC_64.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativePPC_64.c`

 * *Files 10% similar despite different names*

```diff
@@ -31,16 +31,17 @@
 	__asm__ volatile ( "cntlzd %0, %1" : "=r"(dst) : "r"(src) )
 #elif defined(__xlc__)
 #error "Please enable GCC syntax for inline assembly statements"
 #else
 #error "Must implement count leading zeroes"
 #endif
 
-#define PUSH_RLDICR(reg, shift) \
-	push_inst(compiler, RLDI(reg, reg, 63 - shift, shift, 1))
+/* Computes SLDI(63 - shift). */
+#define PUSH_SLDI_NEG(reg, shift) \
+	push_inst(compiler, RLDICR | S(reg) | A(reg) | RLDI_SH(63 - shift) | RLDI_ME(shift))
 
 static sljit_s32 load_immediate(struct sljit_compiler *compiler, sljit_s32 reg, sljit_sw imm)
 {
 	sljit_uw tmp;
 	sljit_uw shift;
 	sljit_uw tmp2;
 	sljit_uw shift2;
@@ -62,64 +63,65 @@
 	SLJIT_ASSERT(shift > 0);
 	shift--;
 	tmp = ((sljit_uw)imm << shift);
 
 	if ((tmp & ~0xffff000000000000ul) == 0) {
 		FAIL_IF(push_inst(compiler, ADDI | D(reg) | A(0) | (sljit_ins)(tmp >> 48)));
 		shift += 15;
-		return PUSH_RLDICR(reg, shift);
+		return PUSH_SLDI_NEG(reg, shift);
 	}
 
 	if ((tmp & ~0xffffffff00000000ul) == 0) {
 		FAIL_IF(push_inst(compiler, ADDIS | D(reg) | A(0) | (sljit_ins)(tmp >> 48)));
 		FAIL_IF(push_inst(compiler, ORI | S(reg) | A(reg) | IMM(tmp >> 32)));
 		shift += 31;
-		return PUSH_RLDICR(reg, shift);
+		return PUSH_SLDI_NEG(reg, shift);
 	}
 
 	/* Cut out the 16 bit from immediate. */
 	shift += 15;
 	tmp2 = (sljit_uw)imm & (((sljit_uw)1 << (63 - shift)) - 1);
 
 	if (tmp2 <= 0xffff) {
 		FAIL_IF(push_inst(compiler, ADDI | D(reg) | A(0) | (sljit_ins)(tmp >> 48)));
-		FAIL_IF(PUSH_RLDICR(reg, shift));
+		FAIL_IF(PUSH_SLDI_NEG(reg, shift));
 		return push_inst(compiler, ORI | S(reg) | A(reg) | (sljit_ins)tmp2);
 	}
 
 	if (tmp2 <= 0xffffffff) {
 		FAIL_IF(push_inst(compiler, ADDI | D(reg) | A(0) | IMM(tmp >> 48)));
-		FAIL_IF(PUSH_RLDICR(reg, shift));
+		FAIL_IF(PUSH_SLDI_NEG(reg, shift));
 		FAIL_IF(push_inst(compiler, ORIS | S(reg) | A(reg) | (sljit_ins)(tmp2 >> 16)));
 		return (imm & 0xffff) ? push_inst(compiler, ORI | S(reg) | A(reg) | IMM(tmp2)) : SLJIT_SUCCESS;
 	}
 
 	ASM_SLJIT_CLZ(tmp2, shift2);
 	tmp2 <<= shift2;
 
 	if ((tmp2 & ~0xffff000000000000ul) == 0) {
 		FAIL_IF(push_inst(compiler, ADDI | D(reg) | A(0) | (sljit_ins)(tmp >> 48)));
 		shift2 += 15;
 		shift += (63 - shift2);
-		FAIL_IF(PUSH_RLDICR(reg, shift));
+		FAIL_IF(PUSH_SLDI_NEG(reg, shift));
 		FAIL_IF(push_inst(compiler, ORI | S(reg) | A(reg) | (sljit_ins)(tmp2 >> 48)));
-		return PUSH_RLDICR(reg, shift2);
+		return PUSH_SLDI_NEG(reg, shift2);
 	}
 
 	/* The general version. */
 	FAIL_IF(push_inst(compiler, ADDIS | D(reg) | A(0) | (sljit_ins)((sljit_uw)imm >> 48)));
 	FAIL_IF(push_inst(compiler, ORI | S(reg) | A(reg) | IMM(imm >> 32)));
-	FAIL_IF(PUSH_RLDICR(reg, 31));
+	FAIL_IF(PUSH_SLDI_NEG(reg, 31));
 	FAIL_IF(push_inst(compiler, ORIS | S(reg) | A(reg) | IMM(imm >> 16)));
 	return push_inst(compiler, ORI | S(reg) | A(reg) | IMM(imm));
 }
 
-/* Simplified mnemonics: clrldi. */
-#define INS_CLEAR_LEFT(dst, src, from) \
-	(RLDICL | S(src) | A(dst) | ((from) << 6) | (1 << 5))
+#undef PUSH_SLDI_NEG
+
+#define CLRLDI(dst, src, n) \
+	(RLDICL | S(src) | A(dst) | RLDI_SH(0) | RLDI_MB(n))
 
 /* Sign extension for integer operations. */
 #define UN_EXTS() \
 	if ((flags & (ALT_SIGN_EXT | REG2_SOURCE)) == (ALT_SIGN_EXT | REG2_SOURCE)) { \
 		FAIL_IF(push_inst(compiler, EXTSW | S(src2) | A(TMP_REG2))); \
 		src2 = TMP_REG2; \
 	}
@@ -141,102 +143,114 @@
 		FAIL_IF(push_inst(compiler, EXTSW | S(src1) | A(TMP_REG1))); \
 		src1 = TMP_REG1; \
 	}
 
 static SLJIT_INLINE sljit_s32 emit_single_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 flags,
 	sljit_s32 dst, sljit_s32 src1, sljit_s32 src2)
 {
+	sljit_u32 imm;
+
 	switch (op) {
 	case SLJIT_MOV:
 	case SLJIT_MOV_P:
 		SLJIT_ASSERT(src1 == TMP_REG1);
 		if (dst != src2)
 			return push_inst(compiler, OR | S(src2) | A(dst) | B(src2));
 		return SLJIT_SUCCESS;
 
 	case SLJIT_MOV_U32:
 	case SLJIT_MOV_S32:
 		SLJIT_ASSERT(src1 == TMP_REG1);
 		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
 			if (op == SLJIT_MOV_S32)
 				return push_inst(compiler, EXTSW | S(src2) | A(dst));
-			return push_inst(compiler, INS_CLEAR_LEFT(dst, src2, 0));
+			return push_inst(compiler, CLRLDI(dst, src2, 32));
 		}
 		else {
 			SLJIT_ASSERT(dst == src2);
 		}
 		return SLJIT_SUCCESS;
 
 	case SLJIT_MOV_U8:
 	case SLJIT_MOV_S8:
 		SLJIT_ASSERT(src1 == TMP_REG1);
 		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
 			if (op == SLJIT_MOV_S8)
 				return push_inst(compiler, EXTSB | S(src2) | A(dst));
-			return push_inst(compiler, INS_CLEAR_LEFT(dst, src2, 24));
+			return push_inst(compiler, CLRLDI(dst, src2, 56));
 		}
 		else if ((flags & REG_DEST) && op == SLJIT_MOV_S8)
 			return push_inst(compiler, EXTSB | S(src2) | A(dst));
 		else {
 			SLJIT_ASSERT(dst == src2);
 		}
 		return SLJIT_SUCCESS;
 
 	case SLJIT_MOV_U16:
 	case SLJIT_MOV_S16:
 		SLJIT_ASSERT(src1 == TMP_REG1);
 		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
 			if (op == SLJIT_MOV_S16)
 				return push_inst(compiler, EXTSH | S(src2) | A(dst));
-			return push_inst(compiler, INS_CLEAR_LEFT(dst, src2, 16));
+			return push_inst(compiler, CLRLDI(dst, src2, 48));
 		}
 		else {
 			SLJIT_ASSERT(dst == src2);
 		}
 		return SLJIT_SUCCESS;
 
 	case SLJIT_NOT:
 		SLJIT_ASSERT(src1 == TMP_REG1);
 		UN_EXTS();
 		return push_inst(compiler, NOR | RC(flags) | S(src2) | A(dst) | B(src2));
 
 	case SLJIT_CLZ:
 		SLJIT_ASSERT(src1 == TMP_REG1);
-		if (flags & ALT_FORM1)
-			return push_inst(compiler, CNTLZW | S(src2) | A(dst));
-		return push_inst(compiler, CNTLZD | S(src2) | A(dst));
+		return push_inst(compiler, ((flags & ALT_FORM1) ? CNTLZW : CNTLZD) | S(src2) | A(dst));
+
+	case SLJIT_CTZ:
+		SLJIT_ASSERT(src1 == TMP_REG1);
+		FAIL_IF(push_inst(compiler, NEG | D(TMP_REG1) | A(src2)));
+		FAIL_IF(push_inst(compiler, AND | S(src2) | A(dst) | B(TMP_REG1)));
+		FAIL_IF(push_inst(compiler, ((flags & ALT_FORM1) ? CNTLZW : CNTLZD) | S(dst) | A(dst)));
+		FAIL_IF(push_inst(compiler, ADDI | D(TMP_REG1) | A(dst) | IMM((flags & ALT_FORM1) ? -32 : -64)));
+		/* The highest bits are set, if dst < bit width, zero otherwise. */
+		FAIL_IF(push_inst(compiler, ((flags & ALT_FORM1) ? SRWI(27) : SRDI(58)) | S(TMP_REG1) | A(TMP_REG1)));
+		return push_inst(compiler, XOR | S(dst) | A(dst) | B(TMP_REG1));
 
 	case SLJIT_ADD:
 		if (flags & ALT_FORM1) {
 			if (flags & ALT_SIGN_EXT) {
-				FAIL_IF(push_inst(compiler, RLDI(TMP_REG1, src1, 32, 31, 1)));
+				FAIL_IF(push_inst(compiler, SLDI(32) | S(src1) | A(TMP_REG1)));
 				src1 = TMP_REG1;
-				FAIL_IF(push_inst(compiler, RLDI(TMP_REG2, src2, 32, 31, 1)));
+				FAIL_IF(push_inst(compiler, SLDI(32) | S(src2) | A(TMP_REG2)));
 				src2 = TMP_REG2;
 			}
 			/* Setting XER SO is not enough, CR SO is also needed. */
 			FAIL_IF(push_inst(compiler, ADD | OE(ALT_SET_FLAGS) | RC(ALT_SET_FLAGS) | D(dst) | A(src1) | B(src2)));
 			if (flags & ALT_SIGN_EXT)
-				return push_inst(compiler, RLDI(dst, dst, 32, 32, 0));
+				return push_inst(compiler, SRDI(32) | S(dst) | A(dst));
 			return SLJIT_SUCCESS;
 		}
 
 		if (flags & ALT_FORM2) {
 			/* Flags does not set: BIN_IMM_EXTS unnecessary. */
 			SLJIT_ASSERT(src2 == TMP_REG2);
 
 			if (flags & ALT_FORM3)
 				return push_inst(compiler, ADDIS | D(dst) | A(src1) | compiler->imm);
 
+			imm = compiler->imm;
+
 			if (flags & ALT_FORM4) {
-				FAIL_IF(push_inst(compiler, ADDIS | D(dst) | A(src1) | (((compiler->imm >> 16) & 0xffff) + ((compiler->imm >> 15) & 0x1))));
+				FAIL_IF(push_inst(compiler, ADDIS | D(dst) | A(src1) | (((imm >> 16) & 0xffff) + ((imm >> 15) & 0x1))));
 				src1 = dst;
 			}
 
-			return push_inst(compiler, ADDI | D(dst) | A(src1) | (compiler->imm & 0xffff));
+			return push_inst(compiler, ADDI | D(dst) | A(src1) | (imm & 0xffff));
 		}
 		if (flags & ALT_FORM3) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
 			BIN_IMM_EXTS();
 			return push_inst(compiler, ADDIC | D(dst) | A(src1) | compiler->imm);
 		}
 		if (flags & ALT_FORM4) {
@@ -283,31 +297,31 @@
 				return SLJIT_SUCCESS;
 			return push_inst(compiler, SUBF | D(dst) | A(src2) | B(src1));
 		}
 
 		if (flags & ALT_FORM3) {
 			if (flags & ALT_SIGN_EXT) {
 				if (src1 != TMP_ZERO) {
-					FAIL_IF(push_inst(compiler, RLDI(TMP_REG1, src1, 32, 31, 1)));
+					FAIL_IF(push_inst(compiler, SLDI(32) | S(src1) | A(TMP_REG1)));
 					src1 = TMP_REG1;
 				}
 				if (src2 != TMP_ZERO) {
-					FAIL_IF(push_inst(compiler, RLDI(TMP_REG2, src2, 32, 31, 1)));
+					FAIL_IF(push_inst(compiler, SLDI(32) | S(src2) | A(TMP_REG2)));
 					src2 = TMP_REG2;
 				}
 			}
 
 			/* Setting XER SO is not enough, CR SO is also needed. */
 			if (src1 != TMP_ZERO)
 				FAIL_IF(push_inst(compiler, SUBF | OE(ALT_SET_FLAGS) | RC(ALT_SET_FLAGS) | D(dst) | A(src2) | B(src1)));
 			else
 				FAIL_IF(push_inst(compiler, NEG | OE(ALT_SET_FLAGS) | RC(ALT_SET_FLAGS) | D(dst) | A(src2)));
 
 			if (flags & ALT_SIGN_EXT)
-				return push_inst(compiler, RLDI(dst, dst, 32, 32, 0));
+				return push_inst(compiler, SRDI(32) | S(dst) | A(dst));
 			return SLJIT_SUCCESS;
 		}
 
 		if (flags & ALT_FORM4) {
 			/* Flags does not set: BIN_IMM_EXTS unnecessary. */
 			SLJIT_ASSERT(src2 == TMP_REG2);
 			return push_inst(compiler, SUBFIC | D(dst) | A(src1) | compiler->imm);
@@ -358,70 +372,131 @@
 		}
 		if (flags & ALT_FORM2) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
 			return push_inst(compiler, ORIS | S(src1) | A(dst) | compiler->imm);
 		}
 		if (flags & ALT_FORM3) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
-			FAIL_IF(push_inst(compiler, ORI | S(src1) | A(dst) | IMM(compiler->imm)));
-			return push_inst(compiler, ORIS | S(dst) | A(dst) | IMM(compiler->imm >> 16));
+			imm = compiler->imm;
+
+			FAIL_IF(push_inst(compiler, ORI | S(src1) | A(dst) | IMM(imm)));
+			return push_inst(compiler, ORIS | S(dst) | A(dst) | IMM(imm >> 16));
 		}
 		return push_inst(compiler, OR | RC(flags) | S(src1) | A(dst) | B(src2));
 
 	case SLJIT_XOR:
 		if (flags & ALT_FORM1) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
 			return push_inst(compiler, XORI | S(src1) | A(dst) | compiler->imm);
 		}
 		if (flags & ALT_FORM2) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
 			return push_inst(compiler, XORIS | S(src1) | A(dst) | compiler->imm);
 		}
 		if (flags & ALT_FORM3) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
-			FAIL_IF(push_inst(compiler, XORI | S(src1) | A(dst) | IMM(compiler->imm)));
-			return push_inst(compiler, XORIS | S(dst) | A(dst) | IMM(compiler->imm >> 16));
+			imm = compiler->imm;
+
+			FAIL_IF(push_inst(compiler, XORI | S(src1) | A(dst) | IMM(imm)));
+			return push_inst(compiler, XORIS | S(dst) | A(dst) | IMM(imm >> 16));
 		}
 		return push_inst(compiler, XOR | RC(flags) | S(src1) | A(dst) | B(src2));
 
 	case SLJIT_SHL:
+	case SLJIT_MSHL:
 		if (flags & ALT_FORM1) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
+			imm = compiler->imm;
+
 			if (flags & ALT_FORM2) {
-				compiler->imm &= 0x1f;
-				return push_inst(compiler, RLWINM | RC(flags) | S(src1) | A(dst) | (compiler->imm << 11) | ((31 - compiler->imm) << 1));
+				imm &= 0x1f;
+				return push_inst(compiler, SLWI(imm) | RC(flags) | S(src1) | A(dst));
 			}
-			compiler->imm &= 0x3f;
-			return push_inst(compiler, RLDI(dst, src1, compiler->imm, 63 - compiler->imm, 1) | RC(flags));
+
+			imm &= 0x3f;
+			return push_inst(compiler, SLDI(imm) | RC(flags) | S(src1) | A(dst));
 		}
+
+		if (op == SLJIT_MSHL) {
+			FAIL_IF(push_inst(compiler, ANDI | S(src2) | A(TMP_REG2) | ((flags & ALT_FORM2) ? 0x1f : 0x3f)));
+			src2 = TMP_REG2;
+		}
+
 		return push_inst(compiler, ((flags & ALT_FORM2) ? SLW : SLD) | RC(flags) | S(src1) | A(dst) | B(src2));
 
 	case SLJIT_LSHR:
+	case SLJIT_MLSHR:
 		if (flags & ALT_FORM1) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
+			imm = compiler->imm;
+
 			if (flags & ALT_FORM2) {
-				compiler->imm &= 0x1f;
-				return push_inst(compiler, RLWINM | RC(flags) | S(src1) | A(dst) | (((32 - compiler->imm) & 0x1f) << 11) | (compiler->imm << 6) | (31 << 1));
+				imm &= 0x1f;
+				/* Since imm can be 0, SRWI() cannot be used. */
+				return push_inst(compiler, RLWINM | RC(flags) | S(src1) | A(dst) | RLWI_SH((32 - imm) & 0x1f) | RLWI_MBE(imm, 31));
 			}
-			compiler->imm &= 0x3f;
-			return push_inst(compiler, RLDI(dst, src1, 64 - compiler->imm, compiler->imm, 0) | RC(flags));
+
+			imm &= 0x3f;
+			/* Since imm can be 0, SRDI() cannot be used. */
+			return push_inst(compiler, RLDICL | RC(flags) | S(src1) | A(dst) | RLDI_SH((64 - imm) & 0x3f) | RLDI_MB(imm));
 		}
+
+		if (op == SLJIT_MLSHR) {
+			FAIL_IF(push_inst(compiler, ANDI | S(src2) | A(TMP_REG2) | ((flags & ALT_FORM2) ? 0x1f : 0x3f)));
+			src2 = TMP_REG2;
+		}
+
 		return push_inst(compiler, ((flags & ALT_FORM2) ? SRW : SRD) | RC(flags) | S(src1) | A(dst) | B(src2));
 
 	case SLJIT_ASHR:
+	case SLJIT_MASHR:
 		if (flags & ALT_FORM1) {
 			SLJIT_ASSERT(src2 == TMP_REG2);
+			imm = compiler->imm;
+
 			if (flags & ALT_FORM2) {
-				compiler->imm &= 0x1f;
-				return push_inst(compiler, SRAWI | RC(flags) | S(src1) | A(dst) | (compiler->imm << 11));
+				imm &= 0x1f;
+				return push_inst(compiler, SRAWI | RC(flags) | S(src1) | A(dst) | (imm << 11));
 			}
-			compiler->imm &= 0x3f;
-			return push_inst(compiler, SRADI | RC(flags) | S(src1) | A(dst) | ((compiler->imm & 0x1f) << 11) | ((compiler->imm & 0x20) >> 4));
+
+			imm &= 0x3f;
+			return push_inst(compiler, SRADI | RC(flags) | S(src1) | A(dst) | RLDI_SH(imm));
 		}
+
+		if (op == SLJIT_MASHR) {
+			FAIL_IF(push_inst(compiler, ANDI | S(src2) | A(TMP_REG2) | ((flags & ALT_FORM2) ? 0x1f : 0x3f)));
+			src2 = TMP_REG2;
+		}
+
 		return push_inst(compiler, ((flags & ALT_FORM2) ? SRAW : SRAD) | RC(flags) | S(src1) | A(dst) | B(src2));
+
+	case SLJIT_ROTL:
+	case SLJIT_ROTR:
+		if (flags & ALT_FORM1) {
+			SLJIT_ASSERT(src2 == TMP_REG2);
+			imm = compiler->imm;
+
+			if (op == SLJIT_ROTR)
+				imm = (sljit_u32)(-(sljit_s32)imm);
+
+			if (flags & ALT_FORM2) {
+				imm &= 0x1f;
+				return push_inst(compiler, RLWINM | S(src1) | A(dst) | RLWI_SH(imm) | RLWI_MBE(0, 31));
+			}
+
+			imm &= 0x3f;
+			return push_inst(compiler, RLDICL | S(src1) | A(dst) | RLDI_SH(imm));
+		}
+
+		if (op == SLJIT_ROTR) {
+			FAIL_IF(push_inst(compiler, SUBFIC | D(TMP_REG2) | A(src2) | 0));
+			src2 = TMP_REG2;
+		}
+
+		return push_inst(compiler, ((flags & ALT_FORM2) ? (RLWNM | RLWI_MBE(0, 31)) : (RLDCL | RLDI_MB(0))) | S(src1) | A(dst) | B(src2));
 	}
 
 	SLJIT_UNREACHABLE();
 	return SLJIT_SUCCESS;
 }
 
 static sljit_s32 call_with_args(struct sljit_compiler *compiler, sljit_s32 arg_types, sljit_s32 *src)
@@ -479,15 +554,15 @@
 	return SLJIT_SUCCESS;
 }
 
 static SLJIT_INLINE sljit_s32 emit_const(struct sljit_compiler *compiler, sljit_s32 reg, sljit_sw init_value)
 {
 	FAIL_IF(push_inst(compiler, ADDIS | D(reg) | A(0) | IMM(init_value >> 48)));
 	FAIL_IF(push_inst(compiler, ORI | S(reg) | A(reg) | IMM(init_value >> 32)));
-	FAIL_IF(PUSH_RLDICR(reg, 31));
+	FAIL_IF(push_inst(compiler, SLDI(32) | S(reg) | A(reg)));
 	FAIL_IF(push_inst(compiler, ORIS | S(reg) | A(reg) | IMM(init_value >> 16)));
 	return push_inst(compiler, ORI | S(reg) | A(reg) | IMM(init_value));
 }
 
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
 {
 	sljit_ins *inst = (sljit_ins*)addr;
@@ -498,12 +573,7 @@
 	inst[1] = (inst[1] & 0xffff0000u) | ((sljit_ins)(new_target >> 32) & 0xffff);
 	inst[3] = (inst[3] & 0xffff0000u) | ((sljit_ins)(new_target >> 16) & 0xffff);
 	inst[4] = (inst[4] & 0xffff0000u) | ((sljit_ins)new_target & 0xffff);
 	SLJIT_UPDATE_WX_FLAGS(inst, inst + 5, 1);
 	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 	SLJIT_CACHE_FLUSH(inst, inst + 5);
 }
-
-SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
-{
-	sljit_set_jump_addr(addr, (sljit_uw)new_constant, executable_offset);
-}
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativePPC_common.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeRISCV_common.c`

 * *Files 18% similar despite different names*

```diff
@@ -22,368 +22,357 @@
  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 SLJIT_API_FUNC_ATTRIBUTE const char* sljit_get_platform_name(void)
 {
-	return "PowerPC" SLJIT_CPUINFO;
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	return "RISC-V-32" SLJIT_CPUINFO;
+#else /* !SLJIT_CONFIG_RISCV_32 */
+	return "RISC-V-64" SLJIT_CPUINFO;
+#endif /* SLJIT_CONFIG_RISCV_32 */
 }
 
-/* Length of an instruction word.
-   Both for ppc-32 and ppc-64. */
+/* Length of an instruction word
+   Both for riscv-32 and riscv-64 */
 typedef sljit_u32 sljit_ins;
 
-#if ((defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) && (defined _AIX)) \
-	|| (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-#define SLJIT_PPC_STACK_FRAME_V2 1
-#endif
-
-#ifdef _AIX
-#include <sys/cache.h>
-#endif
-
-#if (defined _CALL_ELF && _CALL_ELF == 2)
-#define SLJIT_PASS_ENTRY_ADDR_TO_CALL 1
-#endif
-
-#if (defined SLJIT_CACHE_FLUSH_OWN_IMPL && SLJIT_CACHE_FLUSH_OWN_IMPL)
-
-static void ppc_cache_flush(sljit_ins *from, sljit_ins *to)
-{
-#ifdef _AIX
-	_sync_cache_range((caddr_t)from, (int)((size_t)to - (size_t)from));
-#elif defined(__GNUC__) || (defined(__IBM_GCC_ASM) && __IBM_GCC_ASM)
-#	if defined(_ARCH_PWR) || defined(_ARCH_PWR2)
-	/* Cache flush for POWER architecture. */
-	while (from < to) {
-		__asm__ volatile (
-			"clf 0, %0\n"
-			"dcs\n"
-			: : "r"(from)
-		);
-		from++;
-	}
-	__asm__ volatile ( "ics" );
-#	elif defined(_ARCH_COM) && !defined(_ARCH_PPC)
-#	error "Cache flush is not implemented for PowerPC/POWER common mode."
-#	else
-	/* Cache flush for PowerPC architecture. */
-	while (from < to) {
-		__asm__ volatile (
-			"dcbf 0, %0\n"
-			"sync\n"
-			"icbi 0, %0\n"
-			: : "r"(from)
-		);
-		from++;
-	}
-	__asm__ volatile ( "isync" );
-#	endif
-#	ifdef __xlc__
-#	warning "This file may fail to compile if -qfuncsect is used"
-#	endif
-#elif defined(__xlc__)
-#error "Please enable GCC syntax for inline assembly statements with -qasm=gcc"
-#else
-#error "This platform requires a cache flush implementation."
-#endif /* _AIX */
-}
-
-#endif /* (defined SLJIT_CACHE_FLUSH_OWN_IMPL && SLJIT_CACHE_FLUSH_OWN_IMPL) */
-
 #define TMP_REG1	(SLJIT_NUMBER_OF_REGISTERS + 2)
 #define TMP_REG2	(SLJIT_NUMBER_OF_REGISTERS + 3)
-#define TMP_ZERO	(SLJIT_NUMBER_OF_REGISTERS + 4)
+#define TMP_REG3	(SLJIT_NUMBER_OF_REGISTERS + 4)
+#define TMP_ZERO	0
 
-#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL)
-#define TMP_CALL_REG	(SLJIT_NUMBER_OF_REGISTERS + 5)
-#else
-#define TMP_CALL_REG	TMP_REG2
-#endif
+/* Flags are kept in volatile registers. */
+#define EQUAL_FLAG	(SLJIT_NUMBER_OF_REGISTERS + 5)
+#define RETURN_ADDR_REG	TMP_REG2
+#define OTHER_FLAG	(SLJIT_NUMBER_OF_REGISTERS + 6)
 
 #define TMP_FREG1	(SLJIT_NUMBER_OF_FLOAT_REGISTERS + 1)
 #define TMP_FREG2	(SLJIT_NUMBER_OF_FLOAT_REGISTERS + 2)
 
 static const sljit_u8 reg_map[SLJIT_NUMBER_OF_REGISTERS + 7] = {
-	0, 3, 4, 5, 6, 7, 8, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 1, 9, 10, 31, 12
+	0, 10, 11, 12, 13, 14, 15, 16, 17, 29, 30, 31, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 9, 8, 2, 6, 1, 7, 5, 28
 };
 
 static const sljit_u8 freg_map[SLJIT_NUMBER_OF_FLOAT_REGISTERS + 3] = {
-	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 0, 13
+	0, 10, 11, 12, 13, 14, 15, 16, 17, 2, 3, 4, 5, 6, 7, 28, 29, 30, 31, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 9, 8, 0, 1,
 };
 
 /* --------------------------------------------------------------------- */
 /*  Instrucion forms                                                     */
 /* --------------------------------------------------------------------- */
-#define D(d)		((sljit_ins)reg_map[d] << 21)
-#define S(s)		((sljit_ins)reg_map[s] << 21)
-#define A(a)		((sljit_ins)reg_map[a] << 16)
-#define B(b)		((sljit_ins)reg_map[b] << 11)
-#define C(c)		((sljit_ins)reg_map[c] << 6)
-#define FD(fd)		((sljit_ins)freg_map[fd] << 21)
-#define FS(fs)		((sljit_ins)freg_map[fs] << 21)
-#define FA(fa)		((sljit_ins)freg_map[fa] << 16)
-#define FB(fb)		((sljit_ins)freg_map[fb] << 11)
-#define FC(fc)		((sljit_ins)freg_map[fc] << 6)
-#define IMM(imm)	((sljit_ins)(imm) & 0xffff)
-#define CRD(d)		((sljit_ins)(d) << 21)
-
-/* Instruction bit sections.
-   OE and Rc flag (see ALT_SET_FLAGS). */
-#define OE(flags)	((flags) & ALT_SET_FLAGS)
-/* Rc flag (see ALT_SET_FLAGS). */
-#define RC(flags)	(((flags) & ALT_SET_FLAGS) >> 10)
-#define HI(opcode)	((sljit_ins)(opcode) << 26)
-#define LO(opcode)	((sljit_ins)(opcode) << 1)
-
-#define ADD		(HI(31) | LO(266))
-#define ADDC		(HI(31) | LO(10))
-#define ADDE		(HI(31) | LO(138))
-#define ADDI		(HI(14))
-#define ADDIC		(HI(13))
-#define ADDIS		(HI(15))
-#define ADDME		(HI(31) | LO(234))
-#define AND		(HI(31) | LO(28))
-#define ANDI		(HI(28))
-#define ANDIS		(HI(29))
-#define Bx		(HI(18))
-#define BCx		(HI(16))
-#define BCCTR		(HI(19) | LO(528) | (3 << 11))
-#define BLR		(HI(19) | LO(16) | (0x14 << 21))
-#define CNTLZD		(HI(31) | LO(58))
-#define CNTLZW		(HI(31) | LO(26))
-#define CMP		(HI(31) | LO(0))
-#define CMPI		(HI(11))
-#define CMPL		(HI(31) | LO(32))
-#define CMPLI		(HI(10))
-#define CROR		(HI(19) | LO(449))
-#define DCBT		(HI(31) | LO(278))
-#define DIVD		(HI(31) | LO(489))
-#define DIVDU		(HI(31) | LO(457))
-#define DIVW		(HI(31) | LO(491))
-#define DIVWU		(HI(31) | LO(459))
-#define EXTSB		(HI(31) | LO(954))
-#define EXTSH		(HI(31) | LO(922))
-#define EXTSW		(HI(31) | LO(986))
-#define FABS		(HI(63) | LO(264))
-#define FADD		(HI(63) | LO(21))
-#define FADDS		(HI(59) | LO(21))
-#define FCFID		(HI(63) | LO(846))
-#define FCMPU		(HI(63) | LO(0))
-#define FCTIDZ		(HI(63) | LO(815))
-#define FCTIWZ		(HI(63) | LO(15))
-#define FDIV		(HI(63) | LO(18))
-#define FDIVS		(HI(59) | LO(18))
-#define FMR		(HI(63) | LO(72))
-#define FMUL		(HI(63) | LO(25))
-#define FMULS		(HI(59) | LO(25))
-#define FNEG		(HI(63) | LO(40))
-#define FRSP		(HI(63) | LO(12))
-#define FSUB		(HI(63) | LO(20))
-#define FSUBS		(HI(59) | LO(20))
-#define LD		(HI(58) | 0)
-#define LFD		(HI(50))
-#define LWZ		(HI(32))
-#define MFCR		(HI(31) | LO(19))
-#define MFLR		(HI(31) | LO(339) | 0x80000)
-#define MFXER		(HI(31) | LO(339) | 0x10000)
-#define MTCTR		(HI(31) | LO(467) | 0x90000)
-#define MTLR		(HI(31) | LO(467) | 0x80000)
-#define MTXER		(HI(31) | LO(467) | 0x10000)
-#define MULHD		(HI(31) | LO(73))
-#define MULHDU		(HI(31) | LO(9))
-#define MULHW		(HI(31) | LO(75))
-#define MULHWU		(HI(31) | LO(11))
-#define MULLD		(HI(31) | LO(233))
-#define MULLI		(HI(7))
-#define MULLW		(HI(31) | LO(235))
-#define NEG		(HI(31) | LO(104))
-#define NOP		(HI(24))
-#define NOR		(HI(31) | LO(124))
-#define OR		(HI(31) | LO(444))
-#define ORI		(HI(24))
-#define ORIS		(HI(25))
-#define RLDICL		(HI(30))
-#define RLWINM		(HI(21))
-#define SLD		(HI(31) | LO(27))
-#define SLW		(HI(31) | LO(24))
-#define SRAD		(HI(31) | LO(794))
-#define SRADI		(HI(31) | LO(413 << 1))
-#define SRAW		(HI(31) | LO(792))
-#define SRAWI		(HI(31) | LO(824))
-#define SRD		(HI(31) | LO(539))
-#define SRW		(HI(31) | LO(536))
-#define STD		(HI(62) | 0)
-#define STDU		(HI(62) | 1)
-#define STDUX		(HI(31) | LO(181))
-#define STFD		(HI(54))
-#define STFIWX		(HI(31) | LO(983))
-#define STW		(HI(36))
-#define STWU		(HI(37))
-#define STWUX		(HI(31) | LO(183))
-#define SUBF		(HI(31) | LO(40))
-#define SUBFC		(HI(31) | LO(8))
-#define SUBFE		(HI(31) | LO(136))
-#define SUBFIC		(HI(8))
-#define XOR		(HI(31) | LO(316))
-#define XORI		(HI(26))
-#define XORIS		(HI(27))
-
-#define SIMM_MAX	(0x7fff)
-#define SIMM_MIN	(-0x8000)
-#define UIMM_MAX	(0xffff)
-
-#define RLDI(dst, src, sh, mb, type) \
-	(HI(30) | S(src) | A(dst) | ((sljit_ins)(type) << 2) | (((sljit_ins)(sh) & 0x1f) << 11) \
-	| (((sljit_ins)(sh) & 0x20) >> 4) | (((sljit_ins)(mb) & 0x1f) << 6) | ((sljit_ins)(mb) & 0x20))
-
-#if (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
-SLJIT_API_FUNC_ATTRIBUTE void sljit_set_function_context(void** func_ptr, struct sljit_function_context* context, sljit_uw addr, void* func)
-{
-	sljit_uw* ptrs;
-
-	if (func_ptr)
-		*func_ptr = (void*)context;
-
-	ptrs = (sljit_uw*)func;
-	context->addr = addr ? addr : ptrs[0];
-	context->r2 = ptrs[1];
-	context->r11 = ptrs[2];
-}
+
+#define RD(rd)		((sljit_ins)reg_map[rd] << 7)
+#define RS1(rs1)	((sljit_ins)reg_map[rs1] << 15)
+#define RS2(rs2)	((sljit_ins)reg_map[rs2] << 20)
+#define FRD(rd)		((sljit_ins)freg_map[rd] << 7)
+#define FRS1(rs1)	((sljit_ins)freg_map[rs1] << 15)
+#define FRS2(rs2)	((sljit_ins)freg_map[rs2] << 20)
+#define IMM_I(imm)	((sljit_ins)(imm) << 20)
+#define IMM_S(imm)	((((sljit_ins)(imm) & 0xfe0) << 20) | (((sljit_ins)(imm) & 0x1f) << 7))
+
+/* Represents funct(i) parts of the instructions. */
+#define OPC(o)		((sljit_ins)(o))
+#define F3(f)		((sljit_ins)(f) << 12)
+#define F12(f)		((sljit_ins)(f) << 20)
+#define F7(f)		((sljit_ins)(f) << 25)
+
+#define ADD		(F7(0x0) | F3(0x0) | OPC(0x33))
+#define ADDI		(F3(0x0) | OPC(0x13))
+#define AND		(F7(0x0) | F3(0x7) | OPC(0x33))
+#define ANDI		(F3(0x7) | OPC(0x13))
+#define AUIPC		(OPC(0x17))
+#define BEQ		(F3(0x0) | OPC(0x63))
+#define BNE		(F3(0x1) | OPC(0x63))
+#define BLT		(F3(0x4) | OPC(0x63))
+#define BGE		(F3(0x5) | OPC(0x63))
+#define BLTU		(F3(0x6) | OPC(0x63))
+#define BGEU		(F3(0x7) | OPC(0x63))
+#define DIV		(F7(0x1) | F3(0x4) | OPC(0x33))
+#define DIVU		(F7(0x1) | F3(0x5) | OPC(0x33))
+#define EBREAK		(F12(0x1) | F3(0x0) | OPC(0x73))
+#define FADD_S		(F7(0x0) | F3(0x7) | OPC(0x53))
+#define FDIV_S		(F7(0xc) | F3(0x7) | OPC(0x53))
+#define FEQ_S		(F7(0x50) | F3(0x2) | OPC(0x53))
+#define FLD		(F3(0x3) | OPC(0x7))
+#define FLE_S		(F7(0x50) | F3(0x0) | OPC(0x53))
+#define FLT_S		(F7(0x50) | F3(0x1) | OPC(0x53))
+#define FSD		(F3(0x3) | OPC(0x27))
+/* These conversion opcodes are partly defined. */
+#define FCVT_S_D	(F7(0x20) | OPC(0x53))
+#define FCVT_S_W	(F7(0x68) | OPC(0x53))
+#define FCVT_W_S	(F7(0x60) | F3(0x1) | OPC(0x53))
+#define FMUL_S		(F7(0x8) | F3(0x7) | OPC(0x53))
+#define FSGNJ_S		(F7(0x10) | F3(0x0) | OPC(0x53))
+#define FSGNJN_S	(F7(0x10) | F3(0x1) | OPC(0x53))
+#define FSGNJX_S	(F7(0x10) | F3(0x2) | OPC(0x53))
+#define FSUB_S		(F7(0x4) | F3(0x7) | OPC(0x53))
+#define JAL		(OPC(0x6f))
+#define JALR		(F3(0x0) | OPC(0x67))
+#define LD		(F3(0x3) | OPC(0x3))
+#define LUI		(OPC(0x37))
+#define LW		(F3(0x2) | OPC(0x3))
+#define MUL		(F7(0x1) | F3(0x0) | OPC(0x33))
+#define MULH		(F7(0x1) | F3(0x1) | OPC(0x33))
+#define MULHU		(F7(0x1) | F3(0x3) | OPC(0x33))
+#define OR		(F7(0x0) | F3(0x6) | OPC(0x33))
+#define ORI		(F3(0x6) | OPC(0x13))
+#define REM		(F7(0x1) | F3(0x6) | OPC(0x33))
+#define REMU		(F7(0x1) | F3(0x7) | OPC(0x33))
+#define SD		(F3(0x3) | OPC(0x23))
+#define SLL		(F7(0x0) | F3(0x1) | OPC(0x33))
+#define SLLI		(IMM_I(0x0) | F3(0x1) | OPC(0x13))
+#define SLT		(F7(0x0) | F3(0x2) | OPC(0x33))
+#define SLTI		(F3(0x2) | OPC(0x13))
+#define SLTU		(F7(0x0) | F3(0x3) | OPC(0x33))
+#define SLTUI		(F3(0x3) | OPC(0x13))
+#define SRL		(F7(0x0) | F3(0x5) | OPC(0x33))
+#define SRLI		(IMM_I(0x0) | F3(0x5) | OPC(0x13))
+#define SRA		(F7(0x20) | F3(0x5) | OPC(0x33))
+#define SRAI		(IMM_I(0x400) | F3(0x5) | OPC(0x13))
+#define SUB		(F7(0x20) | F3(0x0) | OPC(0x33))
+#define SW		(F3(0x2) | OPC(0x23))
+#define XOR		(F7(0x0) | F3(0x4) | OPC(0x33))
+#define XORI		(F3(0x4) | OPC(0x13))
+
+#define SIMM_MAX	(0x7ff)
+#define SIMM_MIN	(-0x800)
+#define BRANCH_MAX	(0xfff)
+#define BRANCH_MIN	(-0x1000)
+#define JUMP_MAX	(0xfffff)
+#define JUMP_MIN	(-0x100000)
+
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+#define S32_MAX		(0x7ffff7ffl)
+#define S32_MIN		(-0x80000000l)
+#define S44_MAX		(0x7fffffff7ffl)
+#define S52_MAX		(0x7ffffffffffffl)
 #endif
 
 static sljit_s32 push_inst(struct sljit_compiler *compiler, sljit_ins ins)
 {
 	sljit_ins *ptr = (sljit_ins*)ensure_buf(compiler, sizeof(sljit_ins));
 	FAIL_IF(!ptr);
 	*ptr = ins;
 	compiler->size++;
 	return SLJIT_SUCCESS;
 }
 
-static SLJIT_INLINE sljit_s32 detect_jump_type(struct sljit_jump *jump, sljit_ins *code_ptr, sljit_ins *code, sljit_sw executable_offset)
+static sljit_s32 push_imm_s_inst(struct sljit_compiler *compiler, sljit_ins ins, sljit_sw imm)
+{
+	return push_inst(compiler, ins | IMM_S(imm));
+}
+
+static SLJIT_INLINE sljit_ins* detect_jump_type(struct sljit_jump *jump, sljit_ins *code, sljit_sw executable_offset)
 {
 	sljit_sw diff;
 	sljit_uw target_addr;
-	sljit_uw extra_jump_flags;
+	sljit_ins *inst;
+
+	inst = (sljit_ins *)jump->addr;
 
-#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL) && (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-	if (jump->flags & (SLJIT_REWRITABLE_JUMP | IS_CALL))
-		return 0;
-#else
 	if (jump->flags & SLJIT_REWRITABLE_JUMP)
-		return 0;
-#endif
+		goto exit;
 
 	if (jump->flags & JUMP_ADDR)
 		target_addr = jump->u.target;
 	else {
 		SLJIT_ASSERT(jump->flags & JUMP_LABEL);
 		target_addr = (sljit_uw)(code + jump->u.label->size) + (sljit_uw)executable_offset;
 	}
 
-#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL) && (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	if (jump->flags & IS_CALL)
-		goto keep_address;
-#endif
-
-	diff = ((sljit_sw)target_addr - (sljit_sw)(code_ptr) - executable_offset) & ~0x3l;
+	diff = (sljit_sw)target_addr - (sljit_sw)inst - executable_offset;
 
-	extra_jump_flags = 0;
 	if (jump->flags & IS_COND) {
-		if (diff <= 0x7fff && diff >= -0x8000) {
+		inst--;
+		diff += SSIZE_OF(ins);
+
+		if (diff >= BRANCH_MIN && diff <= BRANCH_MAX) {
 			jump->flags |= PATCH_B;
-			return 1;
-		}
-		if (target_addr <= 0xffff) {
-			jump->flags |= PATCH_B | PATCH_ABS_B;
-			return 1;
+			inst[0] = (inst[0] & 0x1fff07f) ^ 0x1000;
+			jump->addr = (sljit_uw)inst;
+			return inst;
 		}
-		extra_jump_flags = REMOVE_COND;
 
+		inst++;
 		diff -= SSIZE_OF(ins);
 	}
 
-	if (diff <= 0x01ffffff && diff >= -0x02000000) {
-		jump->flags |= PATCH_B | extra_jump_flags;
-		return 1;
+	if (diff >= JUMP_MIN && diff <= JUMP_MAX) {
+		if (jump->flags & IS_COND) {
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+			inst[-1] -= (sljit_ins)(1 * sizeof(sljit_ins)) << 7;
+#else
+			inst[-1] -= (sljit_ins)(5 * sizeof(sljit_ins)) << 7;
+#endif
+		}
+
+		jump->flags |= PATCH_J;
+		return inst;
 	}
 
-	if (target_addr <= 0x03ffffff) {
-		jump->flags |= PATCH_B | PATCH_ABS_B | extra_jump_flags;
-		return 1;
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+	if (diff >= S32_MIN && diff <= S32_MAX) {
+		if (jump->flags & IS_COND)
+			inst[-1] -= (sljit_ins)(4 * sizeof(sljit_ins)) << 7;
+
+		jump->flags |= PATCH_REL32;
+		inst[1] = inst[0];
+		return inst + 1;
 	}
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL)
-keep_address:
-#endif
-	if (target_addr <= 0x7fffffff) {
+	if (target_addr <= (sljit_uw)S32_MAX) {
+		if (jump->flags & IS_COND)
+			inst[-1] -= (sljit_ins)(4 * sizeof(sljit_ins)) << 7;
+
 		jump->flags |= PATCH_ABS32;
-		return 1;
+		inst[1] = inst[0];
+		return inst + 1;
 	}
 
-	if (target_addr <= 0x7fffffffffffl) {
-		jump->flags |= PATCH_ABS48;
-		return 1;
+	if (target_addr <= S44_MAX) {
+		if (jump->flags & IS_COND)
+			inst[-1] -= (sljit_ins)(2 * sizeof(sljit_ins)) << 7;
+
+		jump->flags |= PATCH_ABS44;
+		inst[3] = inst[0];
+		return inst + 3;
+	}
+
+	if (target_addr <= S52_MAX) {
+		if (jump->flags & IS_COND)
+			inst[-1] -= (sljit_ins)(1 * sizeof(sljit_ins)) << 7;
+
+		jump->flags |= PATCH_ABS52;
+		inst[4] = inst[0];
+		return inst + 4;
 	}
 #endif
 
-	return 0;
+exit:
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	inst[1] = inst[0];
+	return inst + 1;
+#else
+	inst[5] = inst[0];
+	return inst + 5;
+#endif
 }
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
 
 static SLJIT_INLINE sljit_sw put_label_get_length(struct sljit_put_label *put_label, sljit_uw max_label)
 {
-	if (max_label < 0x100000000l) {
-		put_label->flags = 0;
+	if (max_label <= (sljit_uw)S32_MAX) {
+		put_label->flags = PATCH_ABS32;
 		return 1;
 	}
 
-	if (max_label < 0x1000000000000l) {
-		put_label->flags = 1;
+	if (max_label <= S44_MAX) {
+		put_label->flags = PATCH_ABS44;
 		return 3;
 	}
 
-	put_label->flags = 2;
-	return 4;
+	if (max_label <= S52_MAX) {
+		put_label->flags = PATCH_ABS52;
+		return 4;
+	}
+
+	put_label->flags = 0;
+	return 5;
 }
 
-static SLJIT_INLINE void put_label_set(struct sljit_put_label *put_label)
+#endif /* SLJIT_CONFIG_RISCV_64 */
+
+static SLJIT_INLINE void load_addr_to_reg(void *dst, sljit_u32 reg)
 {
-	sljit_uw addr = put_label->label->addr;
-	sljit_ins *inst = (sljit_ins *)put_label->addr;
-	sljit_u32 reg = *inst;
+	struct sljit_jump *jump = NULL;
+	struct sljit_put_label *put_label;
+	sljit_uw flags;
+	sljit_ins *inst;
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+	sljit_sw high;
+#endif
+	sljit_uw addr;
 
-	if (put_label->flags == 0) {
-		SLJIT_ASSERT(addr < 0x100000000l);
-		inst[0] = ORIS | S(TMP_ZERO) | A(reg) | IMM(addr >> 16);
+	if (reg != 0) {
+		jump = (struct sljit_jump*)dst;
+		flags = jump->flags;
+		inst = (sljit_ins*)jump->addr;
+		addr = (flags & JUMP_LABEL) ? jump->u.label->addr : jump->u.target;
+	} else {
+		put_label = (struct sljit_put_label*)dst;
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+		flags = put_label->flags;
+#endif
+		inst = (sljit_ins*)put_label->addr;
+		addr = put_label->label->addr;
+		reg = *inst;
 	}
-	else {
-		if (put_label->flags == 1) {
-			SLJIT_ASSERT(addr < 0x1000000000000l);
-			inst[0] = ORI | S(TMP_ZERO) | A(reg) | IMM(addr >> 32);
-		}
-		else {
-			inst[0] = ORIS | S(TMP_ZERO) | A(reg) | IMM(addr >> 48);
-			inst[1] = ORI | S(reg) | A(reg) | IMM((addr >> 32) & 0xffff);
-			inst ++;
+
+	if ((addr & 0x800) != 0)
+		addr += 0x1000;
+
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	inst[0] = LUI | RD(reg) | (sljit_ins)((sljit_sw)addr & ~0xfff);
+#else /* !SLJIT_CONFIG_RISCV_32 */
+
+	if (flags & PATCH_ABS32) {
+		SLJIT_ASSERT(addr <= S32_MAX);
+		inst[0] = LUI | RD(reg) | (sljit_ins)((sljit_sw)addr & ~0xfff);
+	} else if (flags & PATCH_ABS44) {
+		high = (sljit_sw)addr >> 12;
+		SLJIT_ASSERT((sljit_uw)high <= 0x7fffffff);
+
+		if (high > S32_MAX) {
+			SLJIT_ASSERT((high & 0x800) != 0);
+			inst[0] = LUI | RD(reg) | (sljit_ins)0x80000000u;
+			inst[1] = XORI | RD(reg) | RS1(reg) | IMM_I(high);
+		} else {
+			if ((high & 0x800) != 0)
+				high += 0x1000;
+
+			inst[0] = LUI | RD(reg) | (sljit_ins)(high & ~0xfff);
+			inst[1] = ADDI | RD(reg) | RS1(reg) | IMM_I(high);
 		}
 
-		inst[1] = RLDI(reg, reg, 32, 31, 1);
-		inst[2] = ORIS | S(reg) | A(reg) | IMM((addr >> 16) & 0xffff);
+		inst[2] = SLLI | RD(reg) | RS1(reg) | IMM_I(12);
 		inst += 2;
-	}
+	} else {
+		high = (sljit_sw)addr >> 32;
 
-	inst[1] = ORI | S(reg) | A(reg) | IMM(addr & 0xffff);
-}
+		if ((addr & 0x80000000l) != 0)
+			high = ~high;
 
-#endif
+		if ((high & 0x800) != 0)
+			high += 0x1000;
+
+		if (flags & PATCH_ABS52) {
+			SLJIT_ASSERT(addr <= S52_MAX);
+			inst[0] = LUI | RD(TMP_REG3) | (sljit_ins)(high << 12);
+		} else {
+			inst[0] = LUI | RD(TMP_REG3) | (sljit_ins)(high & ~0xfff);
+			inst[1] = ADDI | RD(TMP_REG3) | RS1(TMP_REG3) | IMM_I(high);
+			inst++;
+		}
+
+		inst[1] = LUI | RD(reg) | (sljit_ins)((sljit_sw)addr & ~0xfff);
+		inst[2] = SLLI | RD(TMP_REG3) | RS1(TMP_REG3) | IMM_I((flags & PATCH_ABS52) ? 20 : 32);
+		inst[3] = XOR | RD(reg) | RS1(reg) | RS2(TMP_REG3);
+		inst += 3;
+	}
+#endif /* !SLJIT_CONFIG_RISCV_32 */
+
+	if (jump != NULL) {
+		SLJIT_ASSERT((inst[1] & 0x707f) == JALR);
+		inst[1] = (inst[1] & 0xfffff) | IMM_I(addr);
+	} else
+		inst[1] = ADDI | RD(reg) | RS1(reg) | IMM_I(addr);
+}
 
 SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compiler)
 {
 	struct sljit_memory_fragment *buf;
 	sljit_ins *code;
 	sljit_ins *code_ptr;
 	sljit_ins *buf_ptr;
@@ -398,21 +387,14 @@
 	struct sljit_const *const_;
 	struct sljit_put_label *put_label;
 
 	CHECK_ERROR_PTR();
 	CHECK_PTR(check_sljit_generate_code(compiler));
 	reverse_buf(compiler);
 
-#if (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	compiler->size += (compiler->size & 0x1) + (sizeof(struct sljit_function_context) / sizeof(sljit_ins));
-#else
-	compiler->size += (sizeof(struct sljit_function_context) / sizeof(sljit_ins));
-#endif
-#endif
 	code = (sljit_ins*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_ins), compiler->exec_allocator_data);
 	PTR_FAIL_WITH_EXEC_IF(code);
 	buf = compiler->buf;
 
 	code_ptr = code;
 	word_count = 0;
 	next_addr = 0;
@@ -432,1276 +414,1538 @@
 				SLJIT_ASSERT(!label || label->size >= word_count);
 				SLJIT_ASSERT(!jump || jump->addr >= word_count);
 				SLJIT_ASSERT(!const_ || const_->addr >= word_count);
 				SLJIT_ASSERT(!put_label || put_label->addr >= word_count);
 
 				/* These structures are ordered by their address. */
 				if (label && label->size == word_count) {
-					/* Just recording the address. */
 					label->addr = (sljit_uw)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
 					label->size = (sljit_uw)(code_ptr - code);
 					label = label->next;
 				}
 				if (jump && jump->addr == word_count) {
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-					jump->addr = (sljit_uw)(code_ptr - 3);
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+					word_count += 1;
 #else
-					jump->addr = (sljit_uw)(code_ptr - 6);
+					word_count += 5;
 #endif
-					if (detect_jump_type(jump, code_ptr, code, executable_offset)) {
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-						code_ptr[-3] = code_ptr[0];
-						code_ptr -= 3;
-#else
-						if (jump->flags & PATCH_ABS32) {
-							code_ptr -= 3;
-							code_ptr[-1] = code_ptr[2];
-							code_ptr[0] = code_ptr[3];
-						}
-						else if (jump->flags & PATCH_ABS48) {
-							code_ptr--;
-							code_ptr[-1] = code_ptr[0];
-							code_ptr[0] = code_ptr[1];
-							/* rldicr rX,rX,32,31 -> rX,rX,16,47 */
-							SLJIT_ASSERT((code_ptr[-3] & 0xfc00ffff) == 0x780007c6);
-							code_ptr[-3] ^= 0x8422;
-							/* oris -> ori */
-							code_ptr[-2] ^= 0x4000000;
-						}
-						else {
-							code_ptr[-6] = code_ptr[0];
-							code_ptr -= 6;
-						}
-#endif
-						if (jump->flags & REMOVE_COND) {
-							code_ptr[0] = BCx | (2 << 2) | ((code_ptr[0] ^ (8 << 21)) & 0x03ff0001);
-							code_ptr++;
-							jump->addr += sizeof(sljit_ins);
-							code_ptr[0] = Bx;
-							jump->flags -= IS_COND;
-						}
-					}
+					jump->addr = (sljit_uw)code_ptr;
+					code_ptr = detect_jump_type(jump, code, executable_offset);
 					jump = jump->next;
 				}
 				if (const_ && const_->addr == word_count) {
 					const_->addr = (sljit_uw)code_ptr;
 					const_ = const_->next;
 				}
 				if (put_label && put_label->addr == word_count) {
 					SLJIT_ASSERT(put_label->label);
 					put_label->addr = (sljit_uw)code_ptr;
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+					code_ptr += 1;
+					word_count += 1;
+#else
 					code_ptr += put_label_get_length(put_label, (sljit_uw)(SLJIT_ADD_EXEC_OFFSET(code, executable_offset) + put_label->label->size));
-					word_count += 4;
+					word_count += 5;
 #endif
 					put_label = put_label->next;
 				}
 				next_addr = compute_next_addr(label, jump, const_, put_label);
 			}
-			code_ptr ++;
-			word_count ++;
+			code_ptr++;
+			word_count++;
 		} while (buf_ptr < buf_end);
 
 		buf = buf->next;
 	} while (buf);
 
 	if (label && label->size == word_count) {
-		label->addr = (sljit_uw)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
+		label->addr = (sljit_uw)code_ptr;
 		label->size = (sljit_uw)(code_ptr - code);
 		label = label->next;
 	}
 
 	SLJIT_ASSERT(!label);
 	SLJIT_ASSERT(!jump);
 	SLJIT_ASSERT(!const_);
 	SLJIT_ASSERT(!put_label);
-
-#if (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
-	SLJIT_ASSERT(code_ptr - code <= (sljit_sw)(compiler->size - (sizeof(struct sljit_function_context) / sizeof(sljit_ins))));
-#else
 	SLJIT_ASSERT(code_ptr - code <= (sljit_sw)compiler->size);
-#endif
 
 	jump = compiler->jumps;
 	while (jump) {
 		do {
+			if (!(jump->flags & (PATCH_B | PATCH_J | PATCH_REL32))) {
+				load_addr_to_reg(jump, TMP_REG1);
+				break;
+			}
+
 			addr = (jump->flags & JUMP_LABEL) ? jump->u.label->addr : jump->u.target;
 			buf_ptr = (sljit_ins *)jump->addr;
+			addr -= (sljit_uw)SLJIT_ADD_EXEC_OFFSET(buf_ptr, executable_offset);
 
 			if (jump->flags & PATCH_B) {
-				if (jump->flags & IS_COND) {
-					if (!(jump->flags & PATCH_ABS_B)) {
-						addr -= (sljit_uw)SLJIT_ADD_EXEC_OFFSET(buf_ptr, executable_offset);
-						SLJIT_ASSERT((sljit_sw)addr <= 0x7fff && (sljit_sw)addr >= -0x8000);
-						*buf_ptr = BCx | ((sljit_ins)addr & 0xfffc) | ((*buf_ptr) & 0x03ff0001);
-					}
-					else {
-						SLJIT_ASSERT(addr <= 0xffff);
-						*buf_ptr = BCx | ((sljit_ins)addr & 0xfffc) | 0x2 | ((*buf_ptr) & 0x03ff0001);
-					}
-				}
-				else {
-					if (!(jump->flags & PATCH_ABS_B)) {
-						addr -= (sljit_uw)SLJIT_ADD_EXEC_OFFSET(buf_ptr, executable_offset);
-						SLJIT_ASSERT((sljit_sw)addr <= 0x01ffffff && (sljit_sw)addr >= -0x02000000);
-						*buf_ptr = Bx | ((sljit_ins)addr & 0x03fffffc) | ((*buf_ptr) & 0x1);
-					}
-					else {
-						SLJIT_ASSERT(addr <= 0x03ffffff);
-						*buf_ptr = Bx | ((sljit_ins)addr & 0x03fffffc) | 0x2 | ((*buf_ptr) & 0x1);
-					}
-				}
-				break;
-			}
-
-			/* Set the fields of immediate loads. */
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-			SLJIT_ASSERT(((buf_ptr[0] | buf_ptr[1]) & 0xffff) == 0);
-			buf_ptr[0] |= (sljit_ins)(addr >> 16) & 0xffff;
-			buf_ptr[1] |= (sljit_ins)addr & 0xffff;
-#else
-			if (jump->flags & PATCH_ABS32) {
-				SLJIT_ASSERT(addr <= 0x7fffffff);
-				SLJIT_ASSERT(((buf_ptr[0] | buf_ptr[1]) & 0xffff) == 0);
-				buf_ptr[0] |= (sljit_ins)(addr >> 16) & 0xffff;
-				buf_ptr[1] |= (sljit_ins)addr & 0xffff;
+				SLJIT_ASSERT((sljit_sw)addr >= BRANCH_MIN && (sljit_sw)addr <= BRANCH_MAX);
+				addr = ((addr & 0x800) >> 4) | ((addr & 0x1e) << 7) | ((addr & 0x7e0) << 20) | ((addr & 0x1000) << 19);
+				buf_ptr[0] |= (sljit_ins)addr;
 				break;
 			}
 
-			if (jump->flags & PATCH_ABS48) {
-				SLJIT_ASSERT(addr <= 0x7fffffffffff);
-				SLJIT_ASSERT(((buf_ptr[0] | buf_ptr[1] | buf_ptr[3]) & 0xffff) == 0);
-				buf_ptr[0] |= (sljit_ins)(addr >> 32) & 0xffff;
-				buf_ptr[1] |= (sljit_ins)(addr >> 16) & 0xffff;
-				buf_ptr[3] |= (sljit_ins)addr & 0xffff;
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+			if (jump->flags & PATCH_REL32) {
+				SLJIT_ASSERT((sljit_sw)addr >= S32_MIN && (sljit_sw)addr <= S32_MAX);
+
+				if ((addr & 0x800) != 0)
+					addr += 0x1000;
+
+				buf_ptr[0] = AUIPC | RD(TMP_REG1) | (sljit_ins)((sljit_sw)addr & ~0xfff);
+				SLJIT_ASSERT((buf_ptr[1] & 0x707f) == JALR);
+				buf_ptr[1] |= IMM_I(addr);
 				break;
 			}
-
-			SLJIT_ASSERT(((buf_ptr[0] | buf_ptr[1] | buf_ptr[3] | buf_ptr[4]) & 0xffff) == 0);
-			buf_ptr[0] |= (sljit_ins)(addr >> 48) & 0xffff;
-			buf_ptr[1] |= (sljit_ins)(addr >> 32) & 0xffff;
-			buf_ptr[3] |= (sljit_ins)(addr >> 16) & 0xffff;
-			buf_ptr[4] |= (sljit_ins)addr & 0xffff;
 #endif
+
+			SLJIT_ASSERT((sljit_sw)addr >= JUMP_MIN && (sljit_sw)addr <= JUMP_MAX);
+			addr = (addr & 0xff000) | ((addr & 0x800) << 9) | ((addr & 0x7fe) << 20) | ((addr & 0x100000) << 11);
+			buf_ptr[0] = JAL | RD((jump->flags & IS_CALL) ? RETURN_ADDR_REG : TMP_ZERO) | (sljit_ins)addr;
 		} while (0);
 		jump = jump->next;
 	}
 
 	put_label = compiler->put_labels;
 	while (put_label) {
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-		addr = put_label->label->addr;
-		buf_ptr = (sljit_ins *)put_label->addr;
-
-		SLJIT_ASSERT((buf_ptr[0] & 0xfc1f0000) == ADDIS && (buf_ptr[1] & 0xfc000000) == ORI);
-		buf_ptr[0] |= (addr >> 16) & 0xffff;
-		buf_ptr[1] |= addr & 0xffff;
-#else
-		put_label_set(put_label);
-#endif
+		load_addr_to_reg(put_label, 0);
 		put_label = put_label->next;
 	}
 
 	compiler->error = SLJIT_ERR_COMPILED;
 	compiler->executable_offset = executable_offset;
 	compiler->executable_size = (sljit_uw)(code_ptr - code) * sizeof(sljit_ins);
 
 	code = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(code, executable_offset);
-
-#if (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	if (((sljit_sw)code_ptr) & 0x4)
-		code_ptr++;
-#endif
-	sljit_set_function_context(NULL, (struct sljit_function_context*)code_ptr, (sljit_uw)code, (void*)sljit_generate_code);
-#endif
-
 	code_ptr = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
 
 	SLJIT_CACHE_FLUSH(code, code_ptr);
 	SLJIT_UPDATE_WX_FLAGS(code, code_ptr, 1);
-
-#if (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
-	return code_ptr;
-#else
 	return code;
-#endif
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_has_cpu_feature(sljit_s32 feature_type)
 {
 	switch (feature_type) {
 	case SLJIT_HAS_FPU:
-#ifdef SLJIT_IS_FPU_AVAILABLE
-		return SLJIT_IS_FPU_AVAILABLE;
-#else
-		/* Available by default. */
-		return 1;
-#endif
-
-	/* A saved register is set to a zero value. */
 	case SLJIT_HAS_ZERO_REGISTER:
-	case SLJIT_HAS_CLZ:
-	case SLJIT_HAS_PREFETCH:
 		return 1;
-
 	default:
 		return 0;
 	}
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_cmp_info(sljit_s32 type)
+{
+	return (type >= SLJIT_ORDERED_EQUAL && type <= SLJIT_ORDERED_LESS_EQUAL);
+}
+
 /* --------------------------------------------------------------------- */
 /*  Entry, exit                                                          */
 /* --------------------------------------------------------------------- */
 
-/* inp_flags: */
-
 /* Creates an index in data_transfer_insts array. */
 #define LOAD_DATA	0x01
-#define INDEXED		0x02
-#define SIGNED_DATA	0x04
-
 #define WORD_DATA	0x00
-#define BYTE_DATA	0x08
-#define HALF_DATA	0x10
-#define INT_DATA	0x18
+#define BYTE_DATA	0x02
+#define HALF_DATA	0x04
+#define INT_DATA	0x06
+#define SIGNED_DATA	0x08
 /* Separates integer and floating point registers */
-#define GPR_REG		0x1f
-#define DOUBLE_DATA	0x20
-
-#define MEM_MASK	0x7f
-
-/* Other inp_flags. */
-
-/* Integer opertion and set flags -> requires exts on 64 bit systems. */
-#define ALT_SIGN_EXT	0x000100
-/* This flag affects the RC() and OERC() macros. */
-#define ALT_SET_FLAGS	0x000400
-#define ALT_FORM1	0x001000
-#define ALT_FORM2	0x002000
-#define ALT_FORM3	0x004000
-#define ALT_FORM4	0x008000
-#define ALT_FORM5	0x010000
-
-/* Source and destination is register. */
-#define REG_DEST	0x000001
-#define REG1_SOURCE	0x000002
-#define REG2_SOURCE	0x000004
-/*
-ALT_SIGN_EXT		0x000100
-ALT_SET_FLAGS		0x000200
-ALT_FORM1		0x001000
-...
-ALT_FORM5		0x010000 */
-
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-#include "sljitNativePPC_32.c"
+#define GPR_REG		0x0f
+#define DOUBLE_DATA	0x10
+#define SINGLE_DATA	0x12
+
+#define MEM_MASK	0x1f
+
+#define ARG_TEST	0x00020
+#define ALT_KEEP_CACHE	0x00040
+#define CUMULATIVE_OP	0x00080
+#define IMM_OP		0x00100
+#define MOVE_OP		0x00200
+#define SRC2_IMM	0x00400
+
+#define UNUSED_DEST	0x00800
+#define REG_DEST	0x01000
+#define REG1_SOURCE	0x02000
+#define REG2_SOURCE	0x04000
+#define SLOW_SRC1	0x08000
+#define SLOW_SRC2	0x10000
+#define SLOW_DEST	0x20000
+
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+#define STACK_STORE	SW
+#define STACK_LOAD	LW
 #else
-#include "sljitNativePPC_64.c"
-#endif
-
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-#define STACK_STORE	STW
-#define STACK_LOAD	LWZ
-#else
-#define STACK_STORE	STD
+#define STACK_STORE	SD
 #define STACK_LOAD	LD
 #endif
 
-#if (defined SLJIT_PPC_STACK_FRAME_V2 && SLJIT_PPC_STACK_FRAME_V2)
-#define LR_SAVE_OFFSET		2 * SSIZE_OF(sw)
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+#include "sljitNativeRISCV_32.c"
 #else
-#define LR_SAVE_OFFSET		SSIZE_OF(sw)
+#include "sljitNativeRISCV_64.c"
 #endif
 
-#define STACK_MAX_DISTANCE	(0x8000 - SSIZE_OF(sw) - LR_SAVE_OFFSET)
+#define STACK_MAX_DISTANCE (-SIMM_MIN)
+
+static sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg, sljit_s32 arg, sljit_sw argw);
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_enter(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
-	sljit_s32 i, tmp, base, offset;
-	sljit_s32 word_arg_count = 0;
-	sljit_s32 saved_arg_count = 0;
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	sljit_s32 arg_count = 0;
-#endif
+	sljit_s32 i, tmp, offset;
+	sljit_s32 saved_arg_count = SLJIT_KEPT_SAVEDS_COUNT(options);
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
-	local_size += GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1)
-		+ GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
+	local_size += GET_SAVED_REGISTERS_SIZE(scratches, saveds - saved_arg_count, 1);
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	if (fsaveds > 0 || fscratches >= SLJIT_FIRST_SAVED_FLOAT_REG) {
+		if ((local_size & SSIZE_OF(sw)) != 0)
+			local_size += SSIZE_OF(sw);
+		local_size += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
+	}
+#else
+	local_size += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
+#endif
 	local_size = (local_size + SLJIT_LOCALS_OFFSET + 15) & ~0xf;
 	compiler->local_size = local_size;
 
-	FAIL_IF(push_inst(compiler, MFLR | D(0)));
-
-	base = SLJIT_SP;
-	offset = local_size;
-
 	if (local_size <= STACK_MAX_DISTANCE) {
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-		FAIL_IF(push_inst(compiler, STWU | S(SLJIT_SP) | A(SLJIT_SP) | IMM(-local_size)));
-#else
-		FAIL_IF(push_inst(compiler, STDU | S(SLJIT_SP) | A(SLJIT_SP) | IMM(-local_size)));
-#endif
-	} else {
-		base = TMP_REG1;
-		FAIL_IF(push_inst(compiler, OR | S(SLJIT_SP) | A(TMP_REG1) | B(SLJIT_SP)));
-		FAIL_IF(load_immediate(compiler, TMP_REG2, -local_size));
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-		FAIL_IF(push_inst(compiler, STWUX | S(SLJIT_SP) | A(SLJIT_SP) | B(TMP_REG2)));
-#else
-		FAIL_IF(push_inst(compiler, STDUX | S(SLJIT_SP) | A(SLJIT_SP) | B(TMP_REG2)));
-#endif
+		/* Frequent case. */
+		FAIL_IF(push_inst(compiler, ADDI | RD(SLJIT_SP) | RS1(SLJIT_SP) | IMM_I(-local_size)));
+		offset = local_size - SSIZE_OF(sw);
 		local_size = 0;
-		offset = 0;
-	}
-
-	tmp = SLJIT_FS0 - fsaveds;
-	for (i = SLJIT_FS0; i > tmp; i--) {
-		offset -= SSIZE_OF(f64);
-		FAIL_IF(push_inst(compiler, STFD | FS(i) | A(base) | IMM(offset)));
-	}
+	} else {
+		FAIL_IF(push_inst(compiler, ADDI | RD(SLJIT_SP) | RS1(SLJIT_SP) | IMM_I(STACK_MAX_DISTANCE)));
+		local_size -= STACK_MAX_DISTANCE;
 
-	for (i = fscratches; i >= SLJIT_FIRST_SAVED_FLOAT_REG; i--) {
-		offset -= SSIZE_OF(f64);
-		FAIL_IF(push_inst(compiler, STFD | FS(i) | A(base) | IMM(offset)));
+		if (local_size > STACK_MAX_DISTANCE)
+			FAIL_IF(load_immediate(compiler, TMP_REG1, local_size, TMP_REG3));
+		offset = STACK_MAX_DISTANCE - SSIZE_OF(sw);
 	}
 
-	offset -= SSIZE_OF(sw);
-	FAIL_IF(push_inst(compiler, STACK_STORE | S(TMP_ZERO) | A(base) | IMM(offset)));
+	FAIL_IF(push_imm_s_inst(compiler, STACK_STORE | RS1(SLJIT_SP) | RS2(RETURN_ADDR_REG), offset));
 
 	tmp = SLJIT_S0 - saveds;
-	for (i = SLJIT_S0; i > tmp; i--) {
+	for (i = SLJIT_S0 - saved_arg_count; i > tmp; i--) {
 		offset -= SSIZE_OF(sw);
-		FAIL_IF(push_inst(compiler, STACK_STORE | S(i) | A(base) | IMM(offset)));
+		FAIL_IF(push_imm_s_inst(compiler, STACK_STORE | RS1(SLJIT_SP) | RS2(i), offset));
 	}
 
 	for (i = scratches; i >= SLJIT_FIRST_SAVED_REG; i--) {
 		offset -= SSIZE_OF(sw);
-		FAIL_IF(push_inst(compiler, STACK_STORE | S(i) | A(base) | IMM(offset)));
+		FAIL_IF(push_imm_s_inst(compiler, STACK_STORE | RS1(SLJIT_SP) | RS2(i), offset));
+	}
+
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	/* This alignment is valid because offset is not used after storing FPU regs. */
+	if ((offset & SSIZE_OF(sw)) != 0)
+		offset -= SSIZE_OF(sw);
+#endif
+
+	tmp = SLJIT_FS0 - fsaveds;
+	for (i = SLJIT_FS0; i > tmp; i--) {
+		offset -= SSIZE_OF(f64);
+		FAIL_IF(push_imm_s_inst(compiler, FSD | RS1(SLJIT_SP) | FRS2(i), offset));
 	}
 
-	FAIL_IF(push_inst(compiler, STACK_STORE | S(0) | A(base) | IMM(local_size + LR_SAVE_OFFSET)));
-	FAIL_IF(push_inst(compiler, ADDI | D(TMP_ZERO) | A(0) | 0));
+	for (i = fscratches; i >= SLJIT_FIRST_SAVED_FLOAT_REG; i--) {
+		offset -= SSIZE_OF(f64);
+		FAIL_IF(push_imm_s_inst(compiler, FSD | RS1(SLJIT_SP) | FRS2(i), offset));
+	}
+
+	if (local_size > STACK_MAX_DISTANCE)
+		FAIL_IF(push_inst(compiler, SUB | RD(SLJIT_SP) | RS1(SLJIT_SP) | RS2(TMP_REG1)));
+	else if (local_size > 0)
+		FAIL_IF(push_inst(compiler, ADDI | RD(SLJIT_SP) | RS1(SLJIT_SP) | IMM_I(-local_size)));
+
+	if (options & SLJIT_ENTER_REG_ARG)
+		return SLJIT_SUCCESS;
 
 	arg_types >>= SLJIT_ARG_SHIFT;
+	saved_arg_count = 0;
+	tmp = SLJIT_R0;
 
 	while (arg_types > 0) {
 		if ((arg_types & SLJIT_ARG_MASK) < SLJIT_ARG_TYPE_F64) {
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-			do {
-				if (!(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG)) {
-					tmp = SLJIT_S0 - saved_arg_count;
-					saved_arg_count++;
-				} else if (arg_count != word_arg_count)
-					tmp = SLJIT_R0 + word_arg_count;
-				else
-					break;
-
-				FAIL_IF(push_inst(compiler, OR | S(SLJIT_R0 + arg_count) | A(tmp) | B(SLJIT_R0 + arg_count)));
-			} while (0);
-#else
 			if (!(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG)) {
-				FAIL_IF(push_inst(compiler, OR | S(SLJIT_R0 + word_arg_count) | A(SLJIT_S0 - saved_arg_count) | B(SLJIT_R0 + word_arg_count)));
+				FAIL_IF(push_inst(compiler, ADDI | RD(SLJIT_S0 - saved_arg_count) | RS1(tmp) | IMM_I(0)));
 				saved_arg_count++;
 			}
-#endif
-			word_arg_count++;
+			tmp++;
 		}
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-		arg_count++;
-#endif
 		arg_types >>= SLJIT_ARG_SHIFT;
 	}
 
 	return SLJIT_SUCCESS;
 }
 
+#undef STACK_MAX_DISTANCE
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_set_context(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
-	local_size += GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1)
-		+ GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
+	local_size += GET_SAVED_REGISTERS_SIZE(scratches, saveds - SLJIT_KEPT_SAVEDS_COUNT(options), 1);
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	if (fsaveds > 0 || fscratches >= SLJIT_FIRST_SAVED_FLOAT_REG) {
+		if ((local_size & SSIZE_OF(sw)) != 0)
+			local_size += SSIZE_OF(sw);
+		local_size += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
+	}
+#else
+	local_size += GET_SAVED_FLOAT_REGISTERS_SIZE(fscratches, fsaveds, sizeof(sljit_f64));
+#endif
 	compiler->local_size = (local_size + SLJIT_LOCALS_OFFSET + 15) & ~0xf;
+
 	return SLJIT_SUCCESS;
 }
 
+#define STACK_MAX_DISTANCE (-SIMM_MIN - 16)
 
-static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler)
+static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler, sljit_s32 is_return_to)
 {
-	sljit_s32 i, tmp, base, offset;
+	sljit_s32 i, tmp, offset;
 	sljit_s32 local_size = compiler->local_size;
 
-	base = SLJIT_SP;
 	if (local_size > STACK_MAX_DISTANCE) {
-		base = TMP_REG1;
-		if (local_size > 2 * STACK_MAX_DISTANCE + LR_SAVE_OFFSET) {
-			FAIL_IF(push_inst(compiler, STACK_LOAD | D(base) | A(SLJIT_SP) | IMM(0)));
-			local_size = 0;
-		} else {
-			FAIL_IF(push_inst(compiler, ADDI | D(TMP_REG1) | A(SLJIT_SP) | IMM(local_size - STACK_MAX_DISTANCE)));
-			local_size = STACK_MAX_DISTANCE;
-		}
-	}
+		local_size -= STACK_MAX_DISTANCE;
 
-	offset = local_size;
-	FAIL_IF(push_inst(compiler, STACK_LOAD | S(0) | A(base) | IMM(offset + LR_SAVE_OFFSET)));
+		if (local_size > STACK_MAX_DISTANCE) {
+			FAIL_IF(load_immediate(compiler, TMP_REG2, local_size, TMP_REG3));
+			FAIL_IF(push_inst(compiler, ADD | RD(SLJIT_SP) | RS1(SLJIT_SP) | RS2(TMP_REG2)));
+		} else
+			FAIL_IF(push_inst(compiler, ADDI | RD(SLJIT_SP) | RS1(SLJIT_SP) | IMM_I(local_size)));
 
-	tmp = SLJIT_FS0 - compiler->fsaveds;
-	for (i = SLJIT_FS0; i > tmp; i--) {
-		offset -= SSIZE_OF(f64);
-		FAIL_IF(push_inst(compiler, LFD | FS(i) | A(base) | IMM(offset)));
+		local_size = STACK_MAX_DISTANCE;
 	}
 
-	for (i = compiler->fscratches; i >= SLJIT_FIRST_SAVED_FLOAT_REG; i--) {
-		offset -= SSIZE_OF(f64);
-		FAIL_IF(push_inst(compiler, LFD | FS(i) | A(base) | IMM(offset)));
-	}
+	SLJIT_ASSERT(local_size > 0);
 
-	offset -= SSIZE_OF(sw);
-	FAIL_IF(push_inst(compiler, STACK_LOAD | S(TMP_ZERO) | A(base) | IMM(offset)));
+	offset = local_size - SSIZE_OF(sw);
+	if (!is_return_to)
+		FAIL_IF(push_inst(compiler, STACK_LOAD | RD(RETURN_ADDR_REG) | RS1(SLJIT_SP) | IMM_I(offset)));
 
 	tmp = SLJIT_S0 - compiler->saveds;
-	for (i = SLJIT_S0; i > tmp; i--) {
+	for (i = SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options); i > tmp; i--) {
 		offset -= SSIZE_OF(sw);
-		FAIL_IF(push_inst(compiler, STACK_LOAD | S(i) | A(base) | IMM(offset)));
+		FAIL_IF(push_inst(compiler, STACK_LOAD | RD(i) | RS1(SLJIT_SP) | IMM_I(offset)));
 	}
 
 	for (i = compiler->scratches; i >= SLJIT_FIRST_SAVED_REG; i--) {
 		offset -= SSIZE_OF(sw);
-		FAIL_IF(push_inst(compiler, STACK_LOAD | S(i) | A(base) | IMM(offset)));
+		FAIL_IF(push_inst(compiler, STACK_LOAD | RD(i) | RS1(SLJIT_SP) | IMM_I(offset)));
 	}
 
-	push_inst(compiler, MTLR | S(0));
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	/* This alignment is valid because offset is not used after storing FPU regs. */
+	if ((offset & SSIZE_OF(sw)) != 0)
+		offset -= SSIZE_OF(sw);
+#endif
 
-	if (local_size > 0)
-		return push_inst(compiler, ADDI | D(SLJIT_SP) | A(base) | IMM(local_size));
+	tmp = SLJIT_FS0 - compiler->fsaveds;
+	for (i = SLJIT_FS0; i > tmp; i--) {
+		offset -= SSIZE_OF(f64);
+		FAIL_IF(push_inst(compiler, FLD | FRD(i) | RS1(SLJIT_SP) | IMM_I(offset)));
+	}
 
-	SLJIT_ASSERT(base == TMP_REG1);
-	return push_inst(compiler, OR | S(base) | A(SLJIT_SP) | B(base));
+	for (i = compiler->fscratches; i >= SLJIT_FIRST_SAVED_FLOAT_REG; i--) {
+		offset -= SSIZE_OF(f64);
+		FAIL_IF(push_inst(compiler, FLD | FRD(i) | RS1(SLJIT_SP) | IMM_I(offset)));
+	}
+
+	return push_inst(compiler, ADDI | RD(SLJIT_SP) | RS1(SLJIT_SP) | IMM_I(local_size));
 }
 
+#undef STACK_MAX_DISTANCE
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_void(struct sljit_compiler *compiler)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_return_void(compiler));
 
-	FAIL_IF(emit_stack_frame_release(compiler));
-	return push_inst(compiler, BLR);
+	FAIL_IF(emit_stack_frame_release(compiler, 0));
+	return push_inst(compiler, JALR | RD(TMP_ZERO) | RS1(RETURN_ADDR_REG) | IMM_I(0));
 }
 
-#undef STACK_STORE
-#undef STACK_LOAD
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_to(struct sljit_compiler *compiler,
+	sljit_s32 src, sljit_sw srcw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_return_to(compiler, src, srcw));
 
-/* --------------------------------------------------------------------- */
-/*  Operators                                                            */
-/* --------------------------------------------------------------------- */
+	if (src & SLJIT_MEM) {
+		ADJUST_LOCAL_OFFSET(src, srcw);
+		FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, TMP_REG1, src, srcw));
+		src = TMP_REG1;
+		srcw = 0;
+	} else if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
+		FAIL_IF(push_inst(compiler, ADDI | RD(TMP_REG1) | RS1(src) | IMM_I(0)));
+		src = TMP_REG1;
+		srcw = 0;
+	}
 
-/* s/l - store/load (1 bit)
-   i/x - immediate/indexed form
-   u/s - signed/unsigned (1 bit)
-   w/b/h/i - word/byte/half/int allowed (2 bit)
+	FAIL_IF(emit_stack_frame_release(compiler, 1));
 
-   Some opcodes are repeated (e.g. store signed / unsigned byte is the same instruction). */
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_ijump(compiler, SLJIT_JUMP, src, srcw);
+}
 
-/* 64 bit only: [reg+imm] must be aligned to 4 bytes. */
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-#define INT_ALIGNED	0x10000
-#endif
+/* --------------------------------------------------------------------- */
+/*  Operators                                                            */
+/* --------------------------------------------------------------------- */
 
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
 #define ARCH_32_64(a, b)	a
-#define INST_CODE_AND_DST(inst, flags, reg) \
-	((sljit_ins)(inst) | (sljit_ins)(((flags) & MEM_MASK) <= GPR_REG ? D(reg) : FD(reg)))
 #else
 #define ARCH_32_64(a, b)	b
-#define INST_CODE_AND_DST(inst, flags, reg) \
-	(((sljit_ins)(inst) & ~(sljit_ins)INT_ALIGNED) | (sljit_ins)(((flags) & MEM_MASK) <= GPR_REG ? D(reg) : FD(reg)))
 #endif
 
-static const sljit_ins data_transfer_insts[64 + 16] = {
+static const sljit_ins data_transfer_insts[16 + 4] = {
+/* u w s */ ARCH_32_64(F3(0x2) | OPC(0x23) /* sw */, F3(0x3) | OPC(0x23) /* sd */),
+/* u w l */ ARCH_32_64(F3(0x2) | OPC(0x3) /* lw */, F3(0x3) | OPC(0x3) /* ld */),
+/* u b s */ F3(0x0) | OPC(0x23) /* sb */,
+/* u b l */ F3(0x4) | OPC(0x3) /* lbu */,
+/* u h s */ F3(0x1) | OPC(0x23) /* sh */,
+/* u h l */ F3(0x5) | OPC(0x3) /* lhu */,
+/* u i s */ F3(0x2) | OPC(0x23) /* sw */,
+/* u i l */ ARCH_32_64(F3(0x2) | OPC(0x3) /* lw */, F3(0x6) | OPC(0x3) /* lwu */),
+
+/* s w s */ ARCH_32_64(F3(0x2) | OPC(0x23) /* sw */, F3(0x3) | OPC(0x23) /* sd */),
+/* s w l */ ARCH_32_64(F3(0x2) | OPC(0x3) /* lw */, F3(0x3) | OPC(0x3) /* ld */),
+/* s b s */ F3(0x0) | OPC(0x23) /* sb */,
+/* s b l */ F3(0x0) | OPC(0x3) /* lb */,
+/* s h s */ F3(0x1) | OPC(0x23) /* sh */,
+/* s h l */ F3(0x1) | OPC(0x3) /* lh */,
+/* s i s */ F3(0x2) | OPC(0x23) /* sw */,
+/* s i l */ F3(0x2) | OPC(0x3) /* lw */,
+
+/* d   s */ F3(0x3) | OPC(0x27) /* fsd */,
+/* d   l */ F3(0x3) | OPC(0x7) /* fld */,
+/* s   s */ F3(0x2) | OPC(0x27) /* fsw */,
+/* s   l */ F3(0x2) | OPC(0x7) /* flw */,
+};
 
-/* -------- Integer -------- */
+#undef ARCH_32_64
 
-/* Word. */
+static sljit_s32 push_mem_inst(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg, sljit_s32 base, sljit_sw offset)
+{
+	sljit_ins ins;
 
-/* w u i s */ ARCH_32_64(HI(36) /* stw */, HI(62) | INT_ALIGNED | 0x0 /* std */),
-/* w u i l */ ARCH_32_64(HI(32) /* lwz */, HI(58) | INT_ALIGNED | 0x0 /* ld */),
-/* w u x s */ ARCH_32_64(HI(31) | LO(151) /* stwx */, HI(31) | LO(149) /* stdx */),
-/* w u x l */ ARCH_32_64(HI(31) | LO(23) /* lwzx */, HI(31) | LO(21) /* ldx */),
+	SLJIT_ASSERT(FAST_IS_REG(base) && offset <= 0xfff && offset >= SIMM_MIN);
 
-/* w s i s */ ARCH_32_64(HI(36) /* stw */, HI(62) | INT_ALIGNED | 0x0 /* std */),
-/* w s i l */ ARCH_32_64(HI(32) /* lwz */, HI(58) | INT_ALIGNED | 0x0 /* ld */),
-/* w s x s */ ARCH_32_64(HI(31) | LO(151) /* stwx */, HI(31) | LO(149) /* stdx */),
-/* w s x l */ ARCH_32_64(HI(31) | LO(23) /* lwzx */, HI(31) | LO(21) /* ldx */),
+	ins = data_transfer_insts[flags & MEM_MASK] | RS1(base);
+	if (flags & LOAD_DATA)
+		ins |= ((flags & MEM_MASK) <= GPR_REG ? RD(reg) : FRD(reg)) | IMM_I(offset);
+	else
+		ins |= ((flags & MEM_MASK) <= GPR_REG ? RS2(reg) : FRS2(reg)) | IMM_S(offset);
 
-/* Byte. */
+	return push_inst(compiler, ins);
+}
 
-/* b u i s */ HI(38) /* stb */,
-/* b u i l */ HI(34) /* lbz */,
-/* b u x s */ HI(31) | LO(215) /* stbx */,
-/* b u x l */ HI(31) | LO(87) /* lbzx */,
+/* Can perform an operation using at most 1 instruction. */
+static sljit_s32 getput_arg_fast(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg, sljit_s32 arg, sljit_sw argw)
+{
 
-/* b s i s */ HI(38) /* stb */,
-/* b s i l */ HI(34) /* lbz */ /* EXTS_REQ */,
-/* b s x s */ HI(31) | LO(215) /* stbx */,
-/* b s x l */ HI(31) | LO(87) /* lbzx */ /* EXTS_REQ */,
+	SLJIT_ASSERT(arg & SLJIT_MEM);
 
-/* Half. */
+	if (!(arg & OFFS_REG_MASK) && argw <= SIMM_MAX && argw >= SIMM_MIN) {
+		/* Works for both absoulte and relative addresses. */
+		if (SLJIT_UNLIKELY(flags & ARG_TEST))
+			return 1;
 
-/* h u i s */ HI(44) /* sth */,
-/* h u i l */ HI(40) /* lhz */,
-/* h u x s */ HI(31) | LO(407) /* sthx */,
-/* h u x l */ HI(31) | LO(279) /* lhzx */,
+		FAIL_IF(push_mem_inst(compiler, flags, reg, arg & REG_MASK, argw));
+		return -1;
+	}
+	return 0;
+}
 
-/* h s i s */ HI(44) /* sth */,
-/* h s i l */ HI(42) /* lha */,
-/* h s x s */ HI(31) | LO(407) /* sthx */,
-/* h s x l */ HI(31) | LO(343) /* lhax */,
+#define TO_ARGW_HI(argw) (((argw) & ~0xfff) + (((argw) & 0x800) ? 0x1000 : 0))
 
-/* Int. */
+/* See getput_arg below.
+   Note: can_cache is called only for binary operators. */
+static sljit_s32 can_cache(sljit_s32 arg, sljit_sw argw, sljit_s32 next_arg, sljit_sw next_argw)
+{
+	SLJIT_ASSERT((arg & SLJIT_MEM) && (next_arg & SLJIT_MEM));
 
-/* i u i s */ HI(36) /* stw */,
-/* i u i l */ HI(32) /* lwz */,
-/* i u x s */ HI(31) | LO(151) /* stwx */,
-/* i u x l */ HI(31) | LO(23) /* lwzx */,
+	/* Simple operation except for updates. */
+	if (arg & OFFS_REG_MASK) {
+		argw &= 0x3;
+		next_argw &= 0x3;
+		if (argw && argw == next_argw && (arg == next_arg || (arg & OFFS_REG_MASK) == (next_arg & OFFS_REG_MASK)))
+			return 1;
+		return 0;
+	}
 
-/* i s i s */ HI(36) /* stw */,
-/* i s i l */ ARCH_32_64(HI(32) /* lwz */, HI(58) | INT_ALIGNED | 0x2 /* lwa */),
-/* i s x s */ HI(31) | LO(151) /* stwx */,
-/* i s x l */ ARCH_32_64(HI(31) | LO(23) /* lwzx */, HI(31) | LO(341) /* lwax */),
+	if (arg == next_arg) {
+		if (((next_argw - argw) <= SIMM_MAX && (next_argw - argw) >= SIMM_MIN)
+				|| TO_ARGW_HI(argw) == TO_ARGW_HI(next_argw))
+			return 1;
+		return 0;
+	}
 
-/* -------- Floating point -------- */
+	return 0;
+}
 
-/* d   i s */ HI(54) /* stfd */,
-/* d   i l */ HI(50) /* lfd */,
-/* d   x s */ HI(31) | LO(727) /* stfdx */,
-/* d   x l */ HI(31) | LO(599) /* lfdx */,
+/* Emit the necessary instructions. See can_cache above. */
+static sljit_s32 getput_arg(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg, sljit_s32 arg, sljit_sw argw, sljit_s32 next_arg, sljit_sw next_argw)
+{
+	sljit_s32 base = arg & REG_MASK;
+	sljit_s32 tmp_r = TMP_REG1;
+	sljit_sw offset, argw_hi;
 
-/* s   i s */ HI(52) /* stfs */,
-/* s   i l */ HI(48) /* lfs */,
-/* s   x s */ HI(31) | LO(663) /* stfsx */,
-/* s   x l */ HI(31) | LO(535) /* lfsx */,
-};
+	SLJIT_ASSERT(arg & SLJIT_MEM);
+	if (!(next_arg & SLJIT_MEM)) {
+		next_arg = 0;
+		next_argw = 0;
+	}
 
-static const sljit_ins updated_data_transfer_insts[64] = {
+	/* Since tmp can be the same as base or offset registers,
+	 * these might be unavailable after modifying tmp. */
+	if ((flags & MEM_MASK) <= GPR_REG && (flags & LOAD_DATA))
+		tmp_r = reg;
 
-/* -------- Integer -------- */
+	if (SLJIT_UNLIKELY(arg & OFFS_REG_MASK)) {
+		argw &= 0x3;
 
-/* Word. */
+		/* Using the cache. */
+		if (argw == compiler->cache_argw) {
+			if (arg == compiler->cache_arg)
+				return push_mem_inst(compiler, flags, reg, TMP_REG3, 0);
+
+			if ((SLJIT_MEM | (arg & OFFS_REG_MASK)) == compiler->cache_arg) {
+				if (arg == next_arg && argw == (next_argw & 0x3)) {
+					compiler->cache_arg = arg;
+					compiler->cache_argw = argw;
+					FAIL_IF(push_inst(compiler, ADD | RD(TMP_REG3) | RS1(TMP_REG3) | RS2(base)));
+					return push_mem_inst(compiler, flags, reg, TMP_REG3, 0);
+				}
+				FAIL_IF(push_inst(compiler, ADD | RD(tmp_r) | RS1(base) | RS2(TMP_REG3)));
+				return push_mem_inst(compiler, flags, reg, tmp_r, 0);
+			}
+		}
 
-/* w u i s */ ARCH_32_64(HI(37) /* stwu */, HI(62) | INT_ALIGNED | 0x1 /* stdu */),
-/* w u i l */ ARCH_32_64(HI(33) /* lwzu */, HI(58) | INT_ALIGNED | 0x1 /* ldu */),
-/* w u x s */ ARCH_32_64(HI(31) | LO(183) /* stwux */, HI(31) | LO(181) /* stdux */),
-/* w u x l */ ARCH_32_64(HI(31) | LO(55) /* lwzux */, HI(31) | LO(53) /* ldux */),
+		if (SLJIT_UNLIKELY(argw)) {
+			compiler->cache_arg = SLJIT_MEM | (arg & OFFS_REG_MASK);
+			compiler->cache_argw = argw;
+			FAIL_IF(push_inst(compiler, SLLI | RD(TMP_REG3) | RS1(OFFS_REG(arg)) | IMM_I(argw)));
+		}
 
-/* w s i s */ ARCH_32_64(HI(37) /* stwu */, HI(62) | INT_ALIGNED | 0x1 /* stdu */),
-/* w s i l */ ARCH_32_64(HI(33) /* lwzu */, HI(58) | INT_ALIGNED | 0x1 /* ldu */),
-/* w s x s */ ARCH_32_64(HI(31) | LO(183) /* stwux */, HI(31) | LO(181) /* stdux */),
-/* w s x l */ ARCH_32_64(HI(31) | LO(55) /* lwzux */, HI(31) | LO(53) /* ldux */),
+		if (arg == next_arg && argw == (next_argw & 0x3)) {
+			compiler->cache_arg = arg;
+			compiler->cache_argw = argw;
+			FAIL_IF(push_inst(compiler, ADD | RD(TMP_REG3) | RS1(base) | RS2(!argw ? OFFS_REG(arg) : TMP_REG3)));
+			tmp_r = TMP_REG3;
+		}
+		else
+			FAIL_IF(push_inst(compiler, ADD | RD(tmp_r) | RS1(base) | RS2(!argw ? OFFS_REG(arg) : TMP_REG3)));
+		return push_mem_inst(compiler, flags, reg, tmp_r, 0);
+	}
 
-/* Byte. */
+	if (compiler->cache_arg == arg && argw - compiler->cache_argw <= SIMM_MAX && argw - compiler->cache_argw >= SIMM_MIN)
+		return push_mem_inst(compiler, flags, reg, TMP_REG3, argw - compiler->cache_argw);
 
-/* b u i s */ HI(39) /* stbu */,
-/* b u i l */ HI(35) /* lbzu */,
-/* b u x s */ HI(31) | LO(247) /* stbux */,
-/* b u x l */ HI(31) | LO(119) /* lbzux */,
+	if (compiler->cache_arg == SLJIT_MEM && (argw - compiler->cache_argw <= SIMM_MAX) && (argw - compiler->cache_argw >= SIMM_MIN)) {
+		offset = argw - compiler->cache_argw;
+	} else {
+		compiler->cache_arg = SLJIT_MEM;
 
-/* b s i s */ HI(39) /* stbu */,
-/* b s i l */ 0 /* no such instruction */,
-/* b s x s */ HI(31) | LO(247) /* stbux */,
-/* b s x l */ 0 /* no such instruction */,
+		argw_hi = TO_ARGW_HI(argw);
 
-/* Half. */
+		if (next_arg && next_argw - argw <= SIMM_MAX && next_argw - argw >= SIMM_MIN && argw_hi != TO_ARGW_HI(next_argw)) {
+			FAIL_IF(load_immediate(compiler, TMP_REG3, argw, tmp_r));
+			compiler->cache_argw = argw;
+			offset = 0;
+		} else {
+			FAIL_IF(load_immediate(compiler, TMP_REG3, argw_hi, tmp_r));
+			compiler->cache_argw = argw_hi;
+			offset = argw & 0xfff;
+			argw = argw_hi;
+		}
+	}
 
-/* h u i s */ HI(45) /* sthu */,
-/* h u i l */ HI(41) /* lhzu */,
-/* h u x s */ HI(31) | LO(439) /* sthux */,
-/* h u x l */ HI(31) | LO(311) /* lhzux */,
+	if (!base)
+		return push_mem_inst(compiler, flags, reg, TMP_REG3, offset);
 
-/* h s i s */ HI(45) /* sthu */,
-/* h s i l */ HI(43) /* lhau */,
-/* h s x s */ HI(31) | LO(439) /* sthux */,
-/* h s x l */ HI(31) | LO(375) /* lhaux */,
+	if (arg == next_arg && next_argw - argw <= SIMM_MAX && next_argw - argw >= SIMM_MIN) {
+		compiler->cache_arg = arg;
+		FAIL_IF(push_inst(compiler, ADD | RD(TMP_REG3) | RS1(TMP_REG3) | RS2(base)));
+		return push_mem_inst(compiler, flags, reg, TMP_REG3, offset);
+	}
 
-/* Int. */
+	FAIL_IF(push_inst(compiler, ADD | RD(tmp_r) | RS1(TMP_REG3) | RS2(base)));
+	return push_mem_inst(compiler, flags, reg, tmp_r, offset);
+}
 
-/* i u i s */ HI(37) /* stwu */,
-/* i u i l */ HI(33) /* lwzu */,
-/* i u x s */ HI(31) | LO(183) /* stwux */,
-/* i u x l */ HI(31) | LO(55) /* lwzux */,
+static sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg, sljit_s32 arg, sljit_sw argw)
+{
+	sljit_s32 base = arg & REG_MASK;
+	sljit_s32 tmp_r = TMP_REG1;
 
-/* i s i s */ HI(37) /* stwu */,
-/* i s i l */ ARCH_32_64(HI(33) /* lwzu */, 0 /* no such instruction */),
-/* i s x s */ HI(31) | LO(183) /* stwux */,
-/* i s x l */ ARCH_32_64(HI(31) | LO(55) /* lwzux */, HI(31) | LO(373) /* lwaux */),
+	if (getput_arg_fast(compiler, flags, reg, arg, argw))
+		return compiler->error;
 
-/* -------- Floating point -------- */
+	if ((flags & MEM_MASK) <= GPR_REG && (flags & LOAD_DATA))
+		tmp_r = reg;
 
-/* d   i s */ HI(55) /* stfdu */,
-/* d   i l */ HI(51) /* lfdu */,
-/* d   x s */ HI(31) | LO(759) /* stfdux */,
-/* d   x l */ HI(31) | LO(631) /* lfdux */,
+	if (SLJIT_UNLIKELY(arg & OFFS_REG_MASK)) {
+		argw &= 0x3;
 
-/* s   i s */ HI(53) /* stfsu */,
-/* s   i l */ HI(49) /* lfsu */,
-/* s   x s */ HI(31) | LO(695) /* stfsux */,
-/* s   x l */ HI(31) | LO(567) /* lfsux */,
-};
+		if (SLJIT_UNLIKELY(argw)) {
+			FAIL_IF(push_inst(compiler, SLLI | RD(tmp_r) | RS1(OFFS_REG(arg)) | IMM_I(argw)));
+			FAIL_IF(push_inst(compiler, ADD | RD(tmp_r) | RS1(tmp_r) | RS2(base)));
+		}
+		else
+			FAIL_IF(push_inst(compiler, ADD | RD(tmp_r) | RS1(base) | RS2(OFFS_REG(arg))));
 
-#undef ARCH_32_64
+		argw = 0;
+	} else {
+		FAIL_IF(load_immediate(compiler, tmp_r, TO_ARGW_HI(argw), TMP_REG3));
+
+		if (base != 0)
+			FAIL_IF(push_inst(compiler, ADD | RD(tmp_r) | RS1(tmp_r) | RS2(base)));
+	}
 
-/* Simple cases, (no caching is required). */
-static sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 inp_flags, sljit_s32 reg,
-	sljit_s32 arg, sljit_sw argw, sljit_s32 tmp_reg)
+	return push_mem_inst(compiler, flags, reg, tmp_r, argw & 0xfff);
+}
+
+static SLJIT_INLINE sljit_s32 emit_op_mem2(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg, sljit_s32 arg1, sljit_sw arg1w, sljit_s32 arg2, sljit_sw arg2w)
 {
-	sljit_ins inst;
-	sljit_s32 offs_reg;
-	sljit_sw high_short;
+	if (getput_arg_fast(compiler, flags, reg, arg1, arg1w))
+		return compiler->error;
+	return getput_arg(compiler, flags, reg, arg1, arg1w, arg2, arg2w);
+}
 
-	/* Should work when (arg & REG_MASK) == 0. */
-	SLJIT_ASSERT(A(0) == 0);
-	SLJIT_ASSERT(arg & SLJIT_MEM);
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+#define WORD 0
+#define IMM_EXTEND(v) (IMM_I(v))
+#else /* !SLJIT_CONFIG_RISCV_32 */
+#define WORD word
+#define IMM_EXTEND(v) (IMM_I((op & SLJIT_32) ? (v) : (32 + (v))))
+#endif /* SLJIT_CONFIG_RISCV_32 */
 
-	if (SLJIT_UNLIKELY(arg & OFFS_REG_MASK)) {
-		argw &= 0x3;
-		offs_reg = OFFS_REG(arg);
+static sljit_s32 emit_clz_ctz(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 dst, sljit_sw src)
+{
+	sljit_s32 is_clz = (GET_OPCODE(op) == SLJIT_CLZ);
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+	sljit_ins word = (op & SLJIT_32) >> 5;
+	sljit_ins max = (op & SLJIT_32) ? 32 : 64;
+#else /* !SLJIT_CONFIG_RISCV_64 */
+	sljit_ins max = 32;
+#endif /* SLJIT_CONFIG_RISCV_64 */
 
-		if (argw != 0) {
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-			FAIL_IF(push_inst(compiler, RLWINM | S(OFFS_REG(arg)) | A(tmp_reg) | ((sljit_ins)argw << 11) | ((31 - (sljit_ins)argw) << 1)));
-#else
-			FAIL_IF(push_inst(compiler, RLDI(tmp_reg, OFFS_REG(arg), argw, 63 - argw, 1)));
-#endif
-			offs_reg = tmp_reg;
-		}
+	SLJIT_ASSERT(WORD == 0 || WORD == 0x8);
 
-		inst = data_transfer_insts[(inp_flags | INDEXED) & MEM_MASK];
+	/* The OTHER_FLAG is the counter. */
+	FAIL_IF(push_inst(compiler, ADDI | WORD | RD(OTHER_FLAG) | RS1(TMP_ZERO) | IMM_I(max)));
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-		SLJIT_ASSERT(!(inst & INT_ALIGNED));
-#endif
+	/* The TMP_REG2 is the next value. */
+	if (src != TMP_REG2)
+		FAIL_IF(push_inst(compiler, ADDI | WORD | RD(TMP_REG2) | RS1(src) | IMM_I(0)));
 
-		return push_inst(compiler, INST_CODE_AND_DST(inst, inp_flags, reg) | A(arg & REG_MASK) | B(offs_reg));
-	}
+	FAIL_IF(push_inst(compiler, BEQ | RS1(TMP_REG2) | RS2(TMP_ZERO) | ((sljit_ins)((is_clz ? 4 : 5) * SSIZE_OF(ins)) << 7) | ((sljit_ins)(8 * SSIZE_OF(ins)) << 20)));
+
+	FAIL_IF(push_inst(compiler, ADDI | WORD | RD(OTHER_FLAG) | RS1(TMP_ZERO) | IMM_I(0)));
+	if (!is_clz) {
+		FAIL_IF(push_inst(compiler, ANDI | RD(TMP_REG1) | RS1(TMP_REG2) | IMM_I(1)));
+		FAIL_IF(push_inst(compiler, BNE | RS1(TMP_REG1) | RS2(TMP_ZERO) | ((sljit_ins)(2 * SSIZE_OF(ins)) << 7) | ((sljit_ins)(8 * SSIZE_OF(ins)) << 20)));
+	} else
+		FAIL_IF(push_inst(compiler, BLT | RS1(TMP_REG2) | RS2(TMP_ZERO) | ((sljit_ins)(2 * SSIZE_OF(ins)) << 7) | ((sljit_ins)(8 * SSIZE_OF(ins)) << 20)));
+
+	/* The TMP_REG1 is the next shift. */
+	FAIL_IF(push_inst(compiler, ADDI | WORD | RD(TMP_REG1) | RS1(TMP_ZERO) | IMM_I(max)));
 
-	inst = data_transfer_insts[inp_flags & MEM_MASK];
-	arg &= REG_MASK;
+	FAIL_IF(push_inst(compiler, ADDI | WORD | RD(EQUAL_FLAG) | RS1(TMP_REG2) | IMM_I(0)));
+	FAIL_IF(push_inst(compiler, SRLI | WORD | RD(TMP_REG1) | RS1(TMP_REG1) | IMM_I(1)));
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	if ((inst & INT_ALIGNED) && (argw & 0x3) != 0) {
-		FAIL_IF(load_immediate(compiler, tmp_reg, argw));
+	FAIL_IF(push_inst(compiler, (is_clz ? SRL : SLL) | WORD | RD(TMP_REG2) | RS1(EQUAL_FLAG) | RS2(TMP_REG1)));
+	FAIL_IF(push_inst(compiler, BNE | RS1(TMP_REG2) | RS2(TMP_ZERO) | ((sljit_ins)0xfe000e80 - ((2 * SSIZE_OF(ins)) << 7))));
+	FAIL_IF(push_inst(compiler, ADDI | WORD | RD(TMP_REG2) | RS1(TMP_REG1) | IMM_I(-1)));
+	FAIL_IF(push_inst(compiler, (is_clz ? SRL : SLL) | WORD | RD(TMP_REG2) | RS1(EQUAL_FLAG) | RS2(TMP_REG2)));
+	FAIL_IF(push_inst(compiler, OR | RD(OTHER_FLAG) | RS1(OTHER_FLAG) | RS2(TMP_REG1)));
+	FAIL_IF(push_inst(compiler, BEQ | RS1(TMP_REG2) | RS2(TMP_ZERO) | ((sljit_ins)0xfe000e80 - ((5 * SSIZE_OF(ins)) << 7))));
 
-		inst = data_transfer_insts[(inp_flags | INDEXED) & MEM_MASK];
-		return push_inst(compiler, INST_CODE_AND_DST(inst, inp_flags, reg) | A(arg) | B(tmp_reg));
+	return push_inst(compiler, ADDI | WORD | RD(dst) | RS1(OTHER_FLAG) | IMM_I(0));
+}
+
+#define EMIT_LOGICAL(op_imm, op_reg) \
+	if (flags & SRC2_IMM) { \
+		if (op & SLJIT_SET_Z) \
+			FAIL_IF(push_inst(compiler, op_imm | RD(EQUAL_FLAG) | RS1(src1) | IMM_I(src2))); \
+		if (!(flags & UNUSED_DEST)) \
+			FAIL_IF(push_inst(compiler, op_imm | RD(dst) | RS1(src1) | IMM_I(src2))); \
+	} \
+	else { \
+		if (op & SLJIT_SET_Z) \
+			FAIL_IF(push_inst(compiler, op_reg | RD(EQUAL_FLAG) | RS1(src1) | RS2(src2))); \
+		if (!(flags & UNUSED_DEST)) \
+			FAIL_IF(push_inst(compiler, op_reg | RD(dst) | RS1(src1) | RS2(src2))); \
 	}
-#endif
 
-	if (argw <= SIMM_MAX && argw >= SIMM_MIN)
-		return push_inst(compiler, INST_CODE_AND_DST(inst, inp_flags, reg) | A(arg) | IMM(argw));
+#define EMIT_SHIFT(imm, reg) \
+	op_imm = (imm); \
+	op_reg = (reg);
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	if (argw <= 0x7fff7fffl && argw >= -0x80000000l) {
-#endif
+static SLJIT_INLINE sljit_s32 emit_single_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 flags,
+	sljit_s32 dst, sljit_s32 src1, sljit_sw src2)
+{
+	sljit_s32 is_overflow, is_carry, carry_src_r, is_handled;
+	sljit_ins op_imm, op_reg;
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+	sljit_ins word = (op & SLJIT_32) >> 5;
+#endif /* SLJIT_CONFIG_RISCV_64 */
 
-		high_short = (sljit_s32)(argw + ((argw & 0x8000) << 1)) & ~0xffff;
+	SLJIT_ASSERT(WORD == 0 || WORD == 0x8);
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-		SLJIT_ASSERT(high_short && high_short <= 0x7fffffffl && high_short >= -0x80000000l);
-#else
-		SLJIT_ASSERT(high_short);
-#endif
+	switch (GET_OPCODE(op)) {
+	case SLJIT_MOV:
+		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
+		if (dst != src2)
+			return push_inst(compiler, ADDI | RD(dst) | RS1(src2) | IMM_I(0));
+		return SLJIT_SUCCESS;
+
+	case SLJIT_MOV_U8:
+		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
+		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE))
+			return push_inst(compiler, ANDI | RD(dst) | RS1(src2) | IMM_I(0xff));
+		SLJIT_ASSERT(dst == src2);
+		return SLJIT_SUCCESS;
+
+	case SLJIT_MOV_S8:
+		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
+		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
+			FAIL_IF(push_inst(compiler, SLLI | WORD | RD(dst) | RS1(src2) | IMM_EXTEND(24)));
+			return push_inst(compiler, SRAI | WORD | RD(dst) | RS1(dst) | IMM_EXTEND(24));
+		}
+		SLJIT_ASSERT(dst == src2);
+		return SLJIT_SUCCESS;
+
+	case SLJIT_MOV_U16:
+		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
+		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
+			FAIL_IF(push_inst(compiler, SLLI | WORD | RD(dst) | RS1(src2) | IMM_EXTEND(16)));
+			return push_inst(compiler, SRLI | WORD | RD(dst) | RS1(dst) | IMM_EXTEND(16));
+		}
+		SLJIT_ASSERT(dst == src2);
+		return SLJIT_SUCCESS;
+
+	case SLJIT_MOV_S16:
+		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
+		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
+			FAIL_IF(push_inst(compiler, SLLI | WORD | RD(dst) | RS1(src2) | IMM_EXTEND(16)));
+			return push_inst(compiler, SRAI | WORD | RD(dst) | RS1(dst) | IMM_EXTEND(16));
+		}
+		SLJIT_ASSERT(dst == src2);
+		return SLJIT_SUCCESS;
+
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+	case SLJIT_MOV_U32:
+		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
+		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
+			FAIL_IF(push_inst(compiler, SLLI | RD(dst) | RS1(src2) | IMM_I(32)));
+			return push_inst(compiler, SRLI | RD(dst) | RS1(dst) | IMM_I(32));
+		}
+		SLJIT_ASSERT(dst == src2);
+		return SLJIT_SUCCESS;
+
+	case SLJIT_MOV_S32:
+		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
+		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE))
+			return push_inst(compiler, ADDI | 0x8 | RD(dst) | RS1(src2) | IMM_I(0));
+		SLJIT_ASSERT(dst == src2);
+		return SLJIT_SUCCESS;
+#endif /* SLJIT_CONFIG_RISCV_64 */
+
+	case SLJIT_CLZ:
+	case SLJIT_CTZ:
+		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
+		return emit_clz_ctz(compiler, op, dst, src2);
+
+	case SLJIT_ADD:
+		/* Overflow computation (both add and sub): overflow = src1_sign ^ src2_sign ^ result_sign ^ carry_flag */
+		is_overflow = GET_FLAG_TYPE(op) == SLJIT_OVERFLOW;
+		carry_src_r = GET_FLAG_TYPE(op) == GET_FLAG_TYPE(SLJIT_SET_CARRY);
+
+		if (flags & SRC2_IMM) {
+			if (is_overflow) {
+				if (src2 >= 0)
+					FAIL_IF(push_inst(compiler, ADDI | RD(EQUAL_FLAG) | RS1(src1) | IMM_I(0)));
+				else
+					FAIL_IF(push_inst(compiler, XORI | RD(EQUAL_FLAG) | RS1(src1) | IMM_I(-1)));
+			}
+			else if (op & SLJIT_SET_Z)
+				FAIL_IF(push_inst(compiler, ADDI | WORD | RD(EQUAL_FLAG) | RS1(src1) | IMM_I(src2)));
+
+			/* Only the zero flag is needed. */
+			if (!(flags & UNUSED_DEST) || (op & VARIABLE_FLAG_MASK))
+				FAIL_IF(push_inst(compiler, ADDI | WORD | RD(dst) | RS1(src1) | IMM_I(src2)));
+		}
+		else {
+			if (is_overflow)
+				FAIL_IF(push_inst(compiler, XOR | RD(EQUAL_FLAG) | RS1(src1) | RS2(src2)));
+			else if (op & SLJIT_SET_Z)
+				FAIL_IF(push_inst(compiler, ADD | WORD | RD(EQUAL_FLAG) | RS1(src1) | RS2(src2)));
+
+			if (is_overflow || carry_src_r != 0) {
+				if (src1 != dst)
+					carry_src_r = (sljit_s32)src1;
+				else if (src2 != dst)
+					carry_src_r = (sljit_s32)src2;
+				else {
+					FAIL_IF(push_inst(compiler, ADDI | RD(OTHER_FLAG) | RS1(src1) | IMM_I(0)));
+					carry_src_r = OTHER_FLAG;
+				}
+			}
+
+			/* Only the zero flag is needed. */
+			if (!(flags & UNUSED_DEST) || (op & VARIABLE_FLAG_MASK))
+				FAIL_IF(push_inst(compiler, ADD | WORD | RD(dst) | RS1(src1) | RS2(src2)));
+		}
+
+		/* Carry is zero if a + b >= a or a + b >= b, otherwise it is 1. */
+		if (is_overflow || carry_src_r != 0) {
+			if (flags & SRC2_IMM)
+				FAIL_IF(push_inst(compiler, SLTUI | RD(OTHER_FLAG) | RS1(dst) | IMM_I(src2)));
+			else
+				FAIL_IF(push_inst(compiler, SLTU | RD(OTHER_FLAG) | RS1(dst) | RS2(carry_src_r)));
+		}
+
+		if (!is_overflow)
+			return SLJIT_SUCCESS;
+
+		FAIL_IF(push_inst(compiler, XOR | RD(TMP_REG1) | RS1(dst) | RS2(EQUAL_FLAG)));
+		if (op & SLJIT_SET_Z)
+			FAIL_IF(push_inst(compiler, ADDI | RD(EQUAL_FLAG) | RS1(dst) | IMM_I(0)));
+		FAIL_IF(push_inst(compiler, SRLI | WORD | RD(TMP_REG1) | RS1(TMP_REG1) | IMM_EXTEND(31)));
+		return push_inst(compiler, XOR | RD(OTHER_FLAG) | RS1(TMP_REG1) | RS2(OTHER_FLAG));
+
+	case SLJIT_ADDC:
+		carry_src_r = GET_FLAG_TYPE(op) == GET_FLAG_TYPE(SLJIT_SET_CARRY);
+
+		if (flags & SRC2_IMM) {
+			FAIL_IF(push_inst(compiler, ADDI | WORD | RD(dst) | RS1(src1) | IMM_I(src2)));
+		} else {
+			if (carry_src_r != 0) {
+				if (src1 != dst)
+					carry_src_r = (sljit_s32)src1;
+				else if (src2 != dst)
+					carry_src_r = (sljit_s32)src2;
+				else {
+					FAIL_IF(push_inst(compiler, ADDI | RD(EQUAL_FLAG) | RS1(src1) | IMM_I(0)));
+					carry_src_r = EQUAL_FLAG;
+				}
+			}
+
+			FAIL_IF(push_inst(compiler, ADD | WORD | RD(dst) | RS1(src1) | RS2(src2)));
+		}
+
+		/* Carry is zero if a + b >= a or a + b >= b, otherwise it is 1. */
+		if (carry_src_r != 0) {
+			if (flags & SRC2_IMM)
+				FAIL_IF(push_inst(compiler, SLTUI | RD(EQUAL_FLAG) | RS1(dst) | IMM_I(src2)));
+			else
+				FAIL_IF(push_inst(compiler, SLTU | RD(EQUAL_FLAG) | RS1(dst) | RS2(carry_src_r)));
+		}
+
+		FAIL_IF(push_inst(compiler, ADD | WORD | RD(dst) | RS1(dst) | RS2(OTHER_FLAG)));
+
+		if (carry_src_r == 0)
+			return SLJIT_SUCCESS;
+
+		/* Set ULESS_FLAG (dst == 0) && (OTHER_FLAG == 1). */
+		FAIL_IF(push_inst(compiler, SLTU | RD(OTHER_FLAG) | RS1(dst) | RS2(OTHER_FLAG)));
+		/* Set carry flag. */
+		return push_inst(compiler, OR | RD(OTHER_FLAG) | RS1(OTHER_FLAG) | RS2(EQUAL_FLAG));
+
+	case SLJIT_SUB:
+		if ((flags & SRC2_IMM) && src2 == SIMM_MIN) {
+			FAIL_IF(push_inst(compiler, ADDI | RD(TMP_REG2) | RS1(TMP_ZERO) | IMM_I(src2)));
+			src2 = TMP_REG2;
+			flags &= ~SRC2_IMM;
+		}
+
+		is_handled = 0;
+
+		if (flags & SRC2_IMM) {
+			if (GET_FLAG_TYPE(op) == SLJIT_LESS || GET_FLAG_TYPE(op) == SLJIT_GREATER_EQUAL) {
+				FAIL_IF(push_inst(compiler, SLTUI | RD(OTHER_FLAG) | RS1(src1) | IMM_I(src2)));
+				is_handled = 1;
+			}
+			else if (GET_FLAG_TYPE(op) == SLJIT_SIG_LESS || GET_FLAG_TYPE(op) == SLJIT_SIG_GREATER_EQUAL) {
+				FAIL_IF(push_inst(compiler, SLTI | RD(OTHER_FLAG) | RS1(src1) | IMM_I(src2)));
+				is_handled = 1;
+			}
+		}
+
+		if (!is_handled && GET_FLAG_TYPE(op) >= SLJIT_LESS && GET_FLAG_TYPE(op) <= SLJIT_SIG_LESS_EQUAL) {
+			is_handled = 1;
+
+			if (flags & SRC2_IMM) {
+				FAIL_IF(push_inst(compiler, ADDI | RD(TMP_REG2) | RS1(TMP_ZERO) | IMM_I(src2)));
+				src2 = TMP_REG2;
+				flags &= ~SRC2_IMM;
+			}
+
+			switch (GET_FLAG_TYPE(op)) {
+			case SLJIT_LESS:
+			case SLJIT_GREATER_EQUAL:
+				FAIL_IF(push_inst(compiler, SLTU | RD(OTHER_FLAG) | RS1(src1) | RS2(src2)));
+				break;
+			case SLJIT_GREATER:
+			case SLJIT_LESS_EQUAL:
+				FAIL_IF(push_inst(compiler, SLTU | RD(OTHER_FLAG) | RS1(src2) | RS2(src1)));
+				break;
+			case SLJIT_SIG_LESS:
+			case SLJIT_SIG_GREATER_EQUAL:
+				FAIL_IF(push_inst(compiler, SLT | RD(OTHER_FLAG) | RS1(src1) | RS2(src2)));
+				break;
+			case SLJIT_SIG_GREATER:
+			case SLJIT_SIG_LESS_EQUAL:
+				FAIL_IF(push_inst(compiler, SLT | RD(OTHER_FLAG) | RS1(src2) | RS2(src1)));
+				break;
+			}
+		}
+
+		if (is_handled) {
+			if (flags & SRC2_IMM) {
+				if (op & SLJIT_SET_Z)
+					FAIL_IF(push_inst(compiler, ADDI | WORD | RD(EQUAL_FLAG) | RS1(src1) | IMM_I(-src2)));
+				if (!(flags & UNUSED_DEST))
+					return push_inst(compiler, ADDI | WORD | RD(dst) | RS1(src1) | IMM_I(-src2));
+			}
+			else {
+				if (op & SLJIT_SET_Z)
+					FAIL_IF(push_inst(compiler, SUB | WORD | RD(EQUAL_FLAG) | RS1(src1) | RS2(src2)));
+				if (!(flags & UNUSED_DEST))
+					return push_inst(compiler, SUB | WORD | RD(dst) | RS1(src1) | RS2(src2));
+			}
+			return SLJIT_SUCCESS;
+		}
+
+		is_overflow = GET_FLAG_TYPE(op) == SLJIT_OVERFLOW;
+		is_carry = GET_FLAG_TYPE(op) == GET_FLAG_TYPE(SLJIT_SET_CARRY);
+
+		if (flags & SRC2_IMM) {
+			if (is_overflow) {
+				if (src2 >= 0)
+					FAIL_IF(push_inst(compiler, ADDI | RD(EQUAL_FLAG) | RS1(src1) | IMM_I(0)));
+				else
+					FAIL_IF(push_inst(compiler, XORI | RD(EQUAL_FLAG) | RS1(src1) | IMM_I(-1)));
+			}
+			else if (op & SLJIT_SET_Z)
+				FAIL_IF(push_inst(compiler, ADDI | WORD | RD(EQUAL_FLAG) | RS1(src1) | IMM_I(-src2)));
+
+			if (is_overflow || is_carry)
+				FAIL_IF(push_inst(compiler, SLTUI | RD(OTHER_FLAG) | RS1(src1) | IMM_I(src2)));
+
+			/* Only the zero flag is needed. */
+			if (!(flags & UNUSED_DEST) || (op & VARIABLE_FLAG_MASK))
+				FAIL_IF(push_inst(compiler, ADDI | WORD | RD(dst) | RS1(src1) | IMM_I(-src2)));
+		}
+		else {
+			if (is_overflow)
+				FAIL_IF(push_inst(compiler, XOR | RD(EQUAL_FLAG) | RS1(src1) | RS2(src2)));
+			else if (op & SLJIT_SET_Z)
+				FAIL_IF(push_inst(compiler, SUB | WORD | RD(EQUAL_FLAG) | RS1(src1) | RS2(src2)));
+
+			if (is_overflow || is_carry)
+				FAIL_IF(push_inst(compiler, SLTU | RD(OTHER_FLAG) | RS1(src1) | RS2(src2)));
+
+			/* Only the zero flag is needed. */
+			if (!(flags & UNUSED_DEST) || (op & VARIABLE_FLAG_MASK))
+				FAIL_IF(push_inst(compiler, SUB | WORD | RD(dst) | RS1(src1) | RS2(src2)));
+		}
+
+		if (!is_overflow)
+			return SLJIT_SUCCESS;
+
+		FAIL_IF(push_inst(compiler, XOR | RD(TMP_REG1) | RS1(dst) | RS2(EQUAL_FLAG)));
+		if (op & SLJIT_SET_Z)
+			FAIL_IF(push_inst(compiler, ADDI | RD(EQUAL_FLAG) | RS1(dst) | IMM_I(0)));
+		FAIL_IF(push_inst(compiler, SRLI | WORD | RD(TMP_REG1) | RS1(TMP_REG1) | IMM_EXTEND(31)));
+		return push_inst(compiler, XOR | RD(OTHER_FLAG) | RS1(TMP_REG1) | RS2(OTHER_FLAG));
+
+	case SLJIT_SUBC:
+		if ((flags & SRC2_IMM) && src2 == SIMM_MIN) {
+			FAIL_IF(push_inst(compiler, ADDI | RD(TMP_REG2) | RS1(TMP_ZERO) | IMM_I(src2)));
+			src2 = TMP_REG2;
+			flags &= ~SRC2_IMM;
+		}
+
+		is_carry = GET_FLAG_TYPE(op) == GET_FLAG_TYPE(SLJIT_SET_CARRY);
+
+		if (flags & SRC2_IMM) {
+			if (is_carry)
+				FAIL_IF(push_inst(compiler, SLTUI | RD(EQUAL_FLAG) | RS1(src1) | IMM_I(src2)));
+
+			FAIL_IF(push_inst(compiler, ADDI | WORD | RD(dst) | RS1(src1) | IMM_I(-src2)));
+		}
+		else {
+			if (is_carry)
+				FAIL_IF(push_inst(compiler, SLTU | RD(EQUAL_FLAG) | RS1(src1) | RS2(src2)));
+
+			FAIL_IF(push_inst(compiler, SUB | WORD | RD(dst) | RS1(src1) | RS2(src2)));
+		}
+
+		if (is_carry)
+			FAIL_IF(push_inst(compiler, SLTU | RD(TMP_REG1) | RS1(dst) | RS2(OTHER_FLAG)));
+
+		FAIL_IF(push_inst(compiler, SUB | WORD | RD(dst) | RS1(dst) | RS2(OTHER_FLAG)));
+
+		if (!is_carry)
+			return SLJIT_SUCCESS;
+
+		return push_inst(compiler, OR | RD(OTHER_FLAG) | RS1(EQUAL_FLAG) | RS2(TMP_REG1));
+
+	case SLJIT_MUL:
+		SLJIT_ASSERT(!(flags & SRC2_IMM));
+
+		if (GET_FLAG_TYPE(op) != SLJIT_OVERFLOW)
+			return push_inst(compiler, MUL | WORD | RD(dst) | RS1(src1) | RS2(src2));
+
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+		if (word) {
+			FAIL_IF(push_inst(compiler, MUL | RD(OTHER_FLAG) | RS1(src1) | RS2(src2)));
+			FAIL_IF(push_inst(compiler, MUL | 0x8 | RD(dst) | RS1(src1) | RS2(src2)));
+			return push_inst(compiler, SUB | RD(OTHER_FLAG) | RS1(dst) | RS2(OTHER_FLAG));
+		}
+#endif /* SLJIT_CONFIG_RISCV_64 */
+
+		FAIL_IF(push_inst(compiler, MULH | RD(EQUAL_FLAG) | RS1(src1) | RS2(src2)));
+		FAIL_IF(push_inst(compiler, MUL | RD(dst) | RS1(src1) | RS2(src2)));
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+		FAIL_IF(push_inst(compiler, SRAI | RD(OTHER_FLAG) | RS1(dst) | IMM_I(31)));
+#else /* !SLJIT_CONFIG_RISCV_32 */
+		FAIL_IF(push_inst(compiler, SRAI | RD(OTHER_FLAG) | RS1(dst) | IMM_I(63)));
+#endif /* SLJIT_CONFIG_RISCV_32 */
+		return push_inst(compiler, SUB | RD(OTHER_FLAG) | RS1(EQUAL_FLAG) | RS2(OTHER_FLAG));
+
+	case SLJIT_AND:
+		EMIT_LOGICAL(ANDI, AND);
+		return SLJIT_SUCCESS;
+
+	case SLJIT_OR:
+		EMIT_LOGICAL(ORI, OR);
+		return SLJIT_SUCCESS;
+
+	case SLJIT_XOR:
+		EMIT_LOGICAL(XORI, XOR);
+		return SLJIT_SUCCESS;
+
+	case SLJIT_SHL:
+	case SLJIT_MSHL:
+		EMIT_SHIFT(SLLI, SLL);
+		break;
 
-		FAIL_IF(push_inst(compiler, ADDIS | D(tmp_reg) | A(arg) | IMM(high_short >> 16)));
-		return push_inst(compiler, INST_CODE_AND_DST(inst, inp_flags, reg) | A(tmp_reg) | IMM(argw));
+	case SLJIT_LSHR:
+	case SLJIT_MLSHR:
+		EMIT_SHIFT(SRLI, SRL);
+		break;
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	case SLJIT_ASHR:
+	case SLJIT_MASHR:
+		EMIT_SHIFT(SRAI, SRA);
+		break;
+
+	case SLJIT_ROTL:
+	case SLJIT_ROTR:
+		if (flags & SRC2_IMM) {
+			SLJIT_ASSERT(src2 != 0);
+
+			op_imm = (GET_OPCODE(op) == SLJIT_ROTL) ? SLLI : SRLI;
+			FAIL_IF(push_inst(compiler, op_imm | WORD | RD(OTHER_FLAG) | RS1(src1) | IMM_I(src2)));
+
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+			src2 = ((op & SLJIT_32) ? 32 : 64) - src2;
+#else /* !SLJIT_CONFIG_RISCV_64 */
+			src2 = 32 - src2;
+#endif /* SLJIT_CONFIG_RISCV_64 */
+			op_imm = (GET_OPCODE(op) == SLJIT_ROTL) ? SRLI : SLLI;
+			FAIL_IF(push_inst(compiler, op_imm | WORD | RD(dst) | RS1(src1) | IMM_I(src2)));
+			return push_inst(compiler, OR | RD(dst) | RS1(dst) | RS2(OTHER_FLAG));
+		}
+
+		if (src2 == TMP_ZERO) {
+			if (dst != src1)
+				return push_inst(compiler, ADDI | WORD | RD(dst) | RS1(src1) | IMM_I(0));
+			return SLJIT_SUCCESS;
+		}
+
+		FAIL_IF(push_inst(compiler, SUB | WORD | RD(EQUAL_FLAG) | RS1(TMP_ZERO) | RS2(src2)));
+		op_reg = (GET_OPCODE(op) == SLJIT_ROTL) ? SLL : SRL;
+		FAIL_IF(push_inst(compiler, op_reg | WORD | RD(OTHER_FLAG) | RS1(src1) | RS2(src2)));
+		op_reg = (GET_OPCODE(op) == SLJIT_ROTL) ? SRL : SLL;
+		FAIL_IF(push_inst(compiler, op_reg | WORD | RD(dst) | RS1(src1) | RS2(EQUAL_FLAG)));
+		return push_inst(compiler, OR | RD(dst) | RS1(dst) | RS2(OTHER_FLAG));
+
+	default:
+		SLJIT_UNREACHABLE();
+		return SLJIT_SUCCESS;
 	}
 
-	/* The rest is PPC-64 only. */
+	if (flags & SRC2_IMM) {
+		if (op & SLJIT_SET_Z)
+			FAIL_IF(push_inst(compiler, op_imm | WORD | RD(EQUAL_FLAG) | RS1(src1) | IMM_I(src2)));
+
+		if (flags & UNUSED_DEST)
+			return SLJIT_SUCCESS;
+		return push_inst(compiler, op_imm | WORD | RD(dst) | RS1(src1) | IMM_I(src2));
+	}
 
-	FAIL_IF(load_immediate(compiler, tmp_reg, argw));
+	if (op & SLJIT_SET_Z)
+		FAIL_IF(push_inst(compiler, op_reg | WORD | RD(EQUAL_FLAG) | RS1(src1) | RS2(src2)));
 
-	inst = data_transfer_insts[(inp_flags | INDEXED) & MEM_MASK];
-	return push_inst(compiler, INST_CODE_AND_DST(inst, inp_flags, reg) | A(arg) | B(tmp_reg));
-#endif
+	if (flags & UNUSED_DEST)
+		return SLJIT_SUCCESS;
+	return push_inst(compiler, op_reg | WORD | RD(dst) | RS1(src1) | RS2(src2));
 }
 
-static sljit_s32 emit_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 input_flags,
+#undef IMM_EXTEND
+
+static sljit_s32 emit_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 flags,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 	/* arg1 goes to TMP_REG1 or src reg
 	   arg2 goes to TMP_REG2, imm or src reg
-	   result goes to TMP_REG2, so put result can use TMP_REG1. */
+	   TMP_REG3 can be used for caching
+	   result goes to TMP_REG2, so put result can use TMP_REG1 and TMP_REG3. */
 	sljit_s32 dst_r = TMP_REG2;
 	sljit_s32 src1_r;
-	sljit_s32 src2_r;
+	sljit_sw src2_r = 0;
 	sljit_s32 sugg_src2_r = TMP_REG2;
-	sljit_s32 flags = input_flags & (ALT_FORM1 | ALT_FORM2 | ALT_FORM3 | ALT_FORM4 | ALT_FORM5 | ALT_SIGN_EXT | ALT_SET_FLAGS);
 
-	/* Destination check. */
-	if (FAST_IS_REG(dst)) {
+	if (!(flags & ALT_KEEP_CACHE)) {
+		compiler->cache_arg = 0;
+		compiler->cache_argw = 0;
+	}
+
+	if (dst == TMP_REG2) {
+		SLJIT_ASSERT(HAS_FLAGS(op));
+		flags |= UNUSED_DEST;
+	}
+	else if (FAST_IS_REG(dst)) {
 		dst_r = dst;
-		/* The REG_DEST is only used by SLJIT_MOV operations, although
-		 * it is set for op2 operations with unset destination. */
 		flags |= REG_DEST;
-
-		if (op >= SLJIT_MOV && op <= SLJIT_MOV_P)
+		if (flags & MOVE_OP)
 			sugg_src2_r = dst_r;
 	}
+	else if ((dst & SLJIT_MEM) && !getput_arg_fast(compiler, flags | ARG_TEST, TMP_REG1, dst, dstw))
+		flags |= SLOW_DEST;
+
+	if (flags & IMM_OP) {
+		if ((src2 & SLJIT_IMM) && src2w != 0 && src2w <= SIMM_MAX && src2w >= SIMM_MIN) {
+			flags |= SRC2_IMM;
+			src2_r = src2w;
+		}
+		else if ((flags & CUMULATIVE_OP) && (src1 & SLJIT_IMM) && src1w != 0 && src1w <= SIMM_MAX && src1w >= SIMM_MIN) {
+			flags |= SRC2_IMM;
+			src2_r = src1w;
+
+			/* And swap arguments. */
+			src1 = src2;
+			src1w = src2w;
+			src2 = SLJIT_IMM;
+			/* src2w = src2_r unneeded. */
+		}
+	}
 
 	/* Source 1. */
 	if (FAST_IS_REG(src1)) {
 		src1_r = src1;
 		flags |= REG1_SOURCE;
 	}
 	else if (src1 & SLJIT_IMM) {
-		src1_r = TMP_ZERO;
-		if (src1w != 0) {
-			FAIL_IF(load_immediate(compiler, TMP_REG1, src1w));
+		if (src1w) {
+			FAIL_IF(load_immediate(compiler, TMP_REG1, src1w, TMP_REG3));
 			src1_r = TMP_REG1;
 		}
+		else
+			src1_r = TMP_ZERO;
 	}
 	else {
-		FAIL_IF(emit_op_mem(compiler, input_flags | LOAD_DATA, TMP_REG1, src1, src1w, TMP_REG1));
+		if (getput_arg_fast(compiler, flags | LOAD_DATA, TMP_REG1, src1, src1w))
+			FAIL_IF(compiler->error);
+		else
+			flags |= SLOW_SRC1;
 		src1_r = TMP_REG1;
 	}
 
 	/* Source 2. */
 	if (FAST_IS_REG(src2)) {
 		src2_r = src2;
 		flags |= REG2_SOURCE;
-
-		if (!(flags & REG_DEST) && op >= SLJIT_MOV && op <= SLJIT_MOV_P)
-			dst_r = src2_r;
+		if ((flags & (REG_DEST | MOVE_OP)) == MOVE_OP)
+			dst_r = (sljit_s32)src2_r;
 	}
 	else if (src2 & SLJIT_IMM) {
-		src2_r = TMP_ZERO;
-		if (src2w != 0) {
-			FAIL_IF(load_immediate(compiler, sugg_src2_r, src2w));
-			src2_r = sugg_src2_r;
+		if (!(flags & SRC2_IMM)) {
+			if (src2w) {
+				FAIL_IF(load_immediate(compiler, sugg_src2_r, src2w, TMP_REG3));
+				src2_r = sugg_src2_r;
+			}
+			else {
+				src2_r = TMP_ZERO;
+				if (flags & MOVE_OP) {
+					if (dst & SLJIT_MEM)
+						dst_r = 0;
+					else
+						op = SLJIT_MOV;
+				}
+			}
 		}
 	}
 	else {
-		FAIL_IF(emit_op_mem(compiler, input_flags | LOAD_DATA, sugg_src2_r, src2, src2w, TMP_REG2));
+		if (getput_arg_fast(compiler, flags | LOAD_DATA, sugg_src2_r, src2, src2w))
+			FAIL_IF(compiler->error);
+		else
+			flags |= SLOW_SRC2;
 		src2_r = sugg_src2_r;
 	}
 
+	if ((flags & (SLOW_SRC1 | SLOW_SRC2)) == (SLOW_SRC1 | SLOW_SRC2)) {
+		SLJIT_ASSERT(src2_r == TMP_REG2);
+		if (!can_cache(src1, src1w, src2, src2w) && can_cache(src1, src1w, dst, dstw)) {
+			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, TMP_REG2, src2, src2w, src1, src1w));
+			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, TMP_REG1, src1, src1w, dst, dstw));
+		}
+		else {
+			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, TMP_REG1, src1, src1w, src2, src2w));
+			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, TMP_REG2, src2, src2w, dst, dstw));
+		}
+	}
+	else if (flags & SLOW_SRC1)
+		FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, TMP_REG1, src1, src1w, dst, dstw));
+	else if (flags & SLOW_SRC2)
+		FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, sugg_src2_r, src2, src2w, dst, dstw));
+
 	FAIL_IF(emit_single_op(compiler, op, flags, dst_r, src1_r, src2_r));
 
-	if (!(dst & SLJIT_MEM))
-		return SLJIT_SUCCESS;
+	if (dst & SLJIT_MEM) {
+		if (!(flags & SLOW_DEST)) {
+			getput_arg_fast(compiler, flags, dst_r, dst, dstw);
+			return compiler->error;
+		}
+		return getput_arg(compiler, flags, dst_r, dst, dstw, 0, 0);
+	}
 
-	return emit_op_mem(compiler, input_flags, dst_r, dst, dstw, TMP_REG1);
+	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op0(struct sljit_compiler *compiler, sljit_s32 op)
 {
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	sljit_s32 int_op = op & SLJIT_32;
-#endif
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+	sljit_ins word = (op & SLJIT_32) >> 5;
+
+	SLJIT_ASSERT(word == 0 || word == 0x8);
+#endif /* SLJIT_CONFIG_RISCV_64 */
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op0(compiler, op));
 
-	op = GET_OPCODE(op);
-	switch (op) {
+	switch (GET_OPCODE(op)) {
 	case SLJIT_BREAKPOINT:
+		return push_inst(compiler, EBREAK);
 	case SLJIT_NOP:
-		return push_inst(compiler, NOP);
+		return push_inst(compiler, ADDI | RD(TMP_ZERO) | RS1(TMP_ZERO) | IMM_I(0));
 	case SLJIT_LMUL_UW:
+		FAIL_IF(push_inst(compiler, ADDI | RD(TMP_REG1) | RS1(SLJIT_R1) | IMM_I(0)));
+		FAIL_IF(push_inst(compiler, MULHU | RD(SLJIT_R1) | RS1(SLJIT_R0) | RS2(SLJIT_R1)));
+		return push_inst(compiler, MUL | RD(SLJIT_R0) | RS1(SLJIT_R0) | RS2(TMP_REG1));
 	case SLJIT_LMUL_SW:
-		FAIL_IF(push_inst(compiler, OR | S(SLJIT_R0) | A(TMP_REG1) | B(SLJIT_R0)));
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-		FAIL_IF(push_inst(compiler, MULLD | D(SLJIT_R0) | A(TMP_REG1) | B(SLJIT_R1)));
-		return push_inst(compiler, (op == SLJIT_LMUL_UW ? MULHDU : MULHD) | D(SLJIT_R1) | A(TMP_REG1) | B(SLJIT_R1));
-#else
-		FAIL_IF(push_inst(compiler, MULLW | D(SLJIT_R0) | A(TMP_REG1) | B(SLJIT_R1)));
-		return push_inst(compiler, (op == SLJIT_LMUL_UW ? MULHWU : MULHW) | D(SLJIT_R1) | A(TMP_REG1) | B(SLJIT_R1));
-#endif
+		FAIL_IF(push_inst(compiler, ADDI | RD(TMP_REG1) | RS1(SLJIT_R1) | IMM_I(0)));
+		FAIL_IF(push_inst(compiler, MULH | RD(SLJIT_R1) | RS1(SLJIT_R0) | RS2(SLJIT_R1)));
+		return push_inst(compiler, MUL | RD(SLJIT_R0) | RS1(SLJIT_R0) | RS2(TMP_REG1));
 	case SLJIT_DIVMOD_UW:
+		FAIL_IF(push_inst(compiler, ADDI | RD(TMP_REG1) | RS1(SLJIT_R0) | IMM_I(0)));
+		FAIL_IF(push_inst(compiler, DIVU | WORD | RD(SLJIT_R0) | RS1(SLJIT_R0) | RS2(SLJIT_R1)));
+		return push_inst(compiler, REMU | WORD | RD(SLJIT_R1) | RS1(TMP_REG1) | RS2(SLJIT_R1));
 	case SLJIT_DIVMOD_SW:
-		FAIL_IF(push_inst(compiler, OR | S(SLJIT_R0) | A(TMP_REG1) | B(SLJIT_R0)));
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-		FAIL_IF(push_inst(compiler, (int_op ? (op == SLJIT_DIVMOD_UW ? DIVWU : DIVW) : (op == SLJIT_DIVMOD_UW ? DIVDU : DIVD)) | D(SLJIT_R0) | A(SLJIT_R0) | B(SLJIT_R1)));
-		FAIL_IF(push_inst(compiler, (int_op ? MULLW : MULLD) | D(SLJIT_R1) | A(SLJIT_R0) | B(SLJIT_R1)));
-#else
-		FAIL_IF(push_inst(compiler, (op == SLJIT_DIVMOD_UW ? DIVWU : DIVW) | D(SLJIT_R0) | A(SLJIT_R0) | B(SLJIT_R1)));
-		FAIL_IF(push_inst(compiler, MULLW | D(SLJIT_R1) | A(SLJIT_R0) | B(SLJIT_R1)));
-#endif
-		return push_inst(compiler, SUBF | D(SLJIT_R1) | A(SLJIT_R1) | B(TMP_REG1));
+		FAIL_IF(push_inst(compiler, ADDI | RD(TMP_REG1) | RS1(SLJIT_R0) | IMM_I(0)));
+		FAIL_IF(push_inst(compiler, DIV | WORD | RD(SLJIT_R0) | RS1(SLJIT_R0) | RS2(SLJIT_R1)));
+		return push_inst(compiler, REM | WORD | RD(SLJIT_R1) | RS1(TMP_REG1) | RS2(SLJIT_R1));
 	case SLJIT_DIV_UW:
+		return push_inst(compiler, DIVU | WORD | RD(SLJIT_R0) | RS1(SLJIT_R0) | RS2(SLJIT_R1));
 	case SLJIT_DIV_SW:
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-		return push_inst(compiler, (int_op ? (op == SLJIT_DIV_UW ? DIVWU : DIVW) : (op == SLJIT_DIV_UW ? DIVDU : DIVD)) | D(SLJIT_R0) | A(SLJIT_R0) | B(SLJIT_R1));
-#else
-		return push_inst(compiler, (op == SLJIT_DIV_UW ? DIVWU : DIVW) | D(SLJIT_R0) | A(SLJIT_R0) | B(SLJIT_R1));
-#endif
+		return push_inst(compiler, DIV | WORD | RD(SLJIT_R0) | RS1(SLJIT_R0) | RS2(SLJIT_R1));
 	case SLJIT_ENDBR:
 	case SLJIT_SKIP_FRAMES_BEFORE_RETURN:
 		return SLJIT_SUCCESS;
 	}
 
 	return SLJIT_SUCCESS;
 }
 
-static sljit_s32 emit_prefetch(struct sljit_compiler *compiler,
-        sljit_s32 src, sljit_sw srcw)
-{
-	if (!(src & OFFS_REG_MASK)) {
-		if (srcw == 0 && (src & REG_MASK))
-			return push_inst(compiler, DCBT | A(0) | B(src & REG_MASK));
-
-		FAIL_IF(load_immediate(compiler, TMP_REG1, srcw));
-		/* Works with SLJIT_MEM0() case as well. */
-		return push_inst(compiler, DCBT | A(src & REG_MASK) | B(TMP_REG1));
-	}
-
-	srcw &= 0x3;
-
-	if (srcw == 0)
-		return push_inst(compiler, DCBT | A(src & REG_MASK) | B(OFFS_REG(src)));
-
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-	FAIL_IF(push_inst(compiler, RLWINM | S(OFFS_REG(src)) | A(TMP_REG1) | ((sljit_ins)srcw << 11) | ((31 - (sljit_ins)srcw) << 1)));
-#else
-	FAIL_IF(push_inst(compiler, RLDI(TMP_REG1, OFFS_REG(src), srcw, 63 - srcw, 1)));
-#endif
-	return push_inst(compiler, DCBT | A(src & REG_MASK) | B(TMP_REG1));
-}
-
-#define EMIT_MOV(type, type_flags, type_cast) \
-	emit_op(compiler, (src & SLJIT_IMM) ? SLJIT_MOV : type, flags | (type_flags), dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? type_cast srcw : srcw)
-
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op1(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src, sljit_sw srcw)
 {
-	sljit_s32 flags = HAS_FLAGS(op) ? ALT_SET_FLAGS : 0;
-	sljit_s32 op_flags = GET_ALL_FLAGS(op);
+	sljit_s32 flags = 0;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op1(compiler, op, dst, dstw, src, srcw));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 	ADJUST_LOCAL_OFFSET(src, srcw);
 
-	op = GET_OPCODE(op);
-
-	if (GET_FLAG_TYPE(op_flags) == SLJIT_OVERFLOW)
-		FAIL_IF(push_inst(compiler, MTXER | S(TMP_ZERO)));
-
-	if (op < SLJIT_NOT && FAST_IS_REG(src) && src == dst) {
-		if (!TYPE_CAST_NEEDED(op))
-			return SLJIT_SUCCESS;
-	}
-
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	if (op_flags & SLJIT_32) {
-		if (op < SLJIT_NOT) {
-			if (src & SLJIT_MEM) {
-				if (op == SLJIT_MOV_S32)
-					op = SLJIT_MOV_U32;
-			}
-			else if (src & SLJIT_IMM) {
-				if (op == SLJIT_MOV_U32)
-					op = SLJIT_MOV_S32;
-			}
-		}
-		else {
-			/* Most operations expect sign extended arguments. */
-			flags |= INT_DATA | SIGNED_DATA;
-			if (HAS_FLAGS(op_flags))
-				flags |= ALT_SIGN_EXT;
-		}
-	}
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+	if (op & SLJIT_32)
+		flags = INT_DATA | SIGNED_DATA;
 #endif
 
-	switch (op) {
+	switch (GET_OPCODE(op)) {
 	case SLJIT_MOV:
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
 	case SLJIT_MOV_U32:
 	case SLJIT_MOV_S32:
 	case SLJIT_MOV32:
 #endif
 	case SLJIT_MOV_P:
-		return emit_op(compiler, SLJIT_MOV, flags | WORD_DATA, dst, dstw, TMP_REG1, 0, src, srcw);
+		return emit_op(compiler, SLJIT_MOV, WORD_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, srcw);
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
 	case SLJIT_MOV_U32:
-		return EMIT_MOV(SLJIT_MOV_U32, INT_DATA, (sljit_u32));
+		return emit_op(compiler, SLJIT_MOV_U32, INT_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_u32)srcw : srcw);
 
 	case SLJIT_MOV_S32:
+	/* Logical operators have no W variant, so sign extended input is necessary for them. */
 	case SLJIT_MOV32:
-		return EMIT_MOV(SLJIT_MOV_S32, INT_DATA | SIGNED_DATA, (sljit_s32));
+		return emit_op(compiler, SLJIT_MOV_S32, INT_DATA | SIGNED_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_s32)srcw : srcw);
 #endif
 
 	case SLJIT_MOV_U8:
-		return EMIT_MOV(SLJIT_MOV_U8, BYTE_DATA, (sljit_u8));
+		return emit_op(compiler, op, BYTE_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_u8)srcw : srcw);
 
 	case SLJIT_MOV_S8:
-		return EMIT_MOV(SLJIT_MOV_S8, BYTE_DATA | SIGNED_DATA, (sljit_s8));
+		return emit_op(compiler, op, BYTE_DATA | SIGNED_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_s8)srcw : srcw);
 
 	case SLJIT_MOV_U16:
-		return EMIT_MOV(SLJIT_MOV_U16, HALF_DATA, (sljit_u16));
+		return emit_op(compiler, op, HALF_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_u16)srcw : srcw);
 
 	case SLJIT_MOV_S16:
-		return EMIT_MOV(SLJIT_MOV_S16, HALF_DATA | SIGNED_DATA, (sljit_s16));
+		return emit_op(compiler, op, HALF_DATA | SIGNED_DATA | MOVE_OP, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_s16)srcw : srcw);
 
 	case SLJIT_NOT:
-		return emit_op(compiler, SLJIT_NOT, flags, dst, dstw, TMP_REG1, 0, src, srcw);
+		return emit_op(compiler, SLJIT_XOR | (op & (SLJIT_32 | SLJIT_SET_Z)), flags, dst, dstw, src, srcw, SLJIT_IMM, -1);
 
 	case SLJIT_CLZ:
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-		return emit_op(compiler, SLJIT_CLZ, flags | (!(op_flags & SLJIT_32) ? 0 : ALT_FORM1), dst, dstw, TMP_REG1, 0, src, srcw);
-#else
-		return emit_op(compiler, SLJIT_CLZ, flags, dst, dstw, TMP_REG1, 0, src, srcw);
-#endif
+	case SLJIT_CTZ:
+		return emit_op(compiler, op, flags, dst, dstw, TMP_REG1, 0, src, srcw);
 	}
 
+	SLJIT_UNREACHABLE();
 	return SLJIT_SUCCESS;
 }
 
-#undef EMIT_MOV
-
-#define TEST_SL_IMM(src, srcw) \
-	(((src) & SLJIT_IMM) && (srcw) <= SIMM_MAX && (srcw) >= SIMM_MIN)
-
-#define TEST_UL_IMM(src, srcw) \
-	(((src) & SLJIT_IMM) && !((srcw) & ~0xffff))
-
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-#define TEST_SH_IMM(src, srcw) \
-	(((src) & SLJIT_IMM) && !((srcw) & 0xffff) && (srcw) <= 0x7fffffffl && (srcw) >= -0x80000000l)
-#else
-#define TEST_SH_IMM(src, srcw) \
-	(((src) & SLJIT_IMM) && !((srcw) & 0xffff))
-#endif
-
-#define TEST_UH_IMM(src, srcw) \
-	(((src) & SLJIT_IMM) && !((srcw) & ~(sljit_sw)0xffff0000))
-
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-#define TEST_ADD_IMM(src, srcw) \
-	(((src) & SLJIT_IMM) && (srcw) <= 0x7fff7fffl && (srcw) >= -0x80000000l)
-#else
-#define TEST_ADD_IMM(src, srcw) \
-	((src) & SLJIT_IMM)
-#endif
-
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-#define TEST_UI_IMM(src, srcw) \
-	(((src) & SLJIT_IMM) && !((srcw) & ~0xffffffff))
-#else
-#define TEST_UI_IMM(src, srcw) \
-	((src) & SLJIT_IMM)
-#endif
-
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-#define TEST_ADD_FORM1(op) \
-	(GET_FLAG_TYPE(op) == SLJIT_OVERFLOW \
-		|| (op & (SLJIT_32 | SLJIT_SET_Z | VARIABLE_FLAG_MASK)) == (SLJIT_32 | SLJIT_SET_Z | SLJIT_SET_CARRY))
-#define TEST_SUB_FORM2(op) \
-	((GET_FLAG_TYPE(op) >= SLJIT_SIG_LESS && GET_FLAG_TYPE(op) <= SLJIT_SIG_LESS_EQUAL) \
-		|| (op & (SLJIT_32 | SLJIT_SET_Z | VARIABLE_FLAG_MASK)) == (SLJIT_32 | SLJIT_SET_Z))
-#define TEST_SUB_FORM3(op) \
-	(GET_FLAG_TYPE(op) == SLJIT_OVERFLOW \
-		|| (op & (SLJIT_32 | SLJIT_SET_Z)) == (SLJIT_32 | SLJIT_SET_Z))
-#else
-#define TEST_ADD_FORM1(op) \
-	(GET_FLAG_TYPE(op) == SLJIT_OVERFLOW)
-#define TEST_SUB_FORM2(op) \
-	(GET_FLAG_TYPE(op) >= SLJIT_SIG_LESS && GET_FLAG_TYPE(op) <= SLJIT_SIG_LESS_EQUAL)
-#define TEST_SUB_FORM3(op) \
-	(GET_FLAG_TYPE(op) == SLJIT_OVERFLOW)
-#endif
-
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
-	sljit_s32 flags = HAS_FLAGS(op) ? ALT_SET_FLAGS : 0;
+	sljit_s32 flags = 0;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op2(compiler, op, 0, dst, dstw, src1, src1w, src2, src2w));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 	ADJUST_LOCAL_OFFSET(src1, src1w);
 	ADJUST_LOCAL_OFFSET(src2, src2w);
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
 	if (op & SLJIT_32) {
-		/* Most operations expect sign extended arguments. */
 		flags |= INT_DATA | SIGNED_DATA;
 		if (src1 & SLJIT_IMM)
-			src1w = (sljit_s32)(src1w);
+			src1w = (sljit_s32)src1w;
 		if (src2 & SLJIT_IMM)
-			src2w = (sljit_s32)(src2w);
-		if (HAS_FLAGS(op))
-			flags |= ALT_SIGN_EXT;
+			src2w = (sljit_s32)src2w;
 	}
 #endif
-	if (GET_FLAG_TYPE(op) == SLJIT_OVERFLOW)
-		FAIL_IF(push_inst(compiler, MTXER | S(TMP_ZERO)));
 
 	switch (GET_OPCODE(op)) {
 	case SLJIT_ADD:
-		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_ADD;
-
-		if (TEST_ADD_FORM1(op))
-			return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM1, dst, dstw, src1, src1w, src2, src2w);
-
-		if (!HAS_FLAGS(op) && ((src1 | src2) & SLJIT_IMM)) {
-			if (TEST_SL_IMM(src2, src2w)) {
-				compiler->imm = (sljit_ins)src2w & 0xffff;
-				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			if (TEST_SL_IMM(src1, src1w)) {
-				compiler->imm = (sljit_ins)src1w & 0xffff;
-				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2, dst, dstw, src2, src2w, TMP_REG2, 0);
-			}
-			if (TEST_SH_IMM(src2, src2w)) {
-				compiler->imm = (sljit_ins)(src2w >> 16) & 0xffff;
-				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2 | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			if (TEST_SH_IMM(src1, src1w)) {
-				compiler->imm = (sljit_ins)(src1w >> 16) & 0xffff;
-				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2 | ALT_FORM3, dst, dstw, src2, src2w, TMP_REG2, 0);
-			}
-			/* Range between -1 and -32768 is covered above. */
-			if (TEST_ADD_IMM(src2, src2w)) {
-				compiler->imm = (sljit_ins)src2w & 0xffffffff;
-				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2 | ALT_FORM4, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			if (TEST_ADD_IMM(src1, src1w)) {
-				compiler->imm = (sljit_ins)src1w & 0xffffffff;
-				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2 | ALT_FORM4, dst, dstw, src2, src2w, TMP_REG2, 0);
-			}
-		}
-
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-		if ((op & (SLJIT_32 | SLJIT_SET_Z)) == (SLJIT_32 | SLJIT_SET_Z)) {
-			if (TEST_SL_IMM(src2, src2w)) {
-				compiler->imm = (sljit_ins)src2w & 0xffff;
-				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM4 | ALT_FORM5, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			if (TEST_SL_IMM(src1, src1w)) {
-				compiler->imm = (sljit_ins)src1w & 0xffff;
-				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM4 | ALT_FORM5, dst, dstw, src2, src2w, TMP_REG2, 0);
-			}
-			return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM4, dst, dstw, src1, src1w, src2, src2w);
-		}
-#endif
-		if (HAS_FLAGS(op)) {
-			if (TEST_SL_IMM(src2, src2w)) {
-				compiler->imm = (sljit_ins)src2w & 0xffff;
-				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			if (TEST_SL_IMM(src1, src1w)) {
-				compiler->imm = (sljit_ins)src1w & 0xffff;
-				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM3, dst, dstw, src2, src2w, TMP_REG2, 0);
-			}
-		}
-		return emit_op(compiler, SLJIT_ADD, flags | ((GET_FLAG_TYPE(op) == GET_FLAG_TYPE(SLJIT_SET_CARRY)) ? ALT_FORM5 : 0), dst, dstw, src1, src1w, src2, src2w);
-
 	case SLJIT_ADDC:
 		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_ADD;
-		return emit_op(compiler, SLJIT_ADDC, flags, dst, dstw, src1, src1w, src2, src2w);
+		return emit_op(compiler, op, flags | CUMULATIVE_OP | IMM_OP, dst, dstw, src1, src1w, src2, src2w);
 
 	case SLJIT_SUB:
-		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_SUB;
-
-		if (GET_FLAG_TYPE(op) >= SLJIT_LESS && GET_FLAG_TYPE(op) <= SLJIT_LESS_EQUAL) {
-			if (dst == TMP_REG2) {
-				if (TEST_UL_IMM(src2, src2w)) {
-					compiler->imm = (sljit_ins)src2w & 0xffff;
-					return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM1 | ALT_FORM2, dst, dstw, src1, src1w, TMP_REG2, 0);
-				}
-				return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM1, dst, dstw, src1, src1w, src2, src2w);
-			}
-
-			if ((src2 & SLJIT_IMM) && src2w >= 0 && src2w <= (SIMM_MAX + 1)) {
-				compiler->imm = (sljit_ins)src2w;
-				return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM1 | ALT_FORM2 | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM1 | ALT_FORM3, dst, dstw, src1, src1w, src2, src2w);
-		}
-
-		if (dst == TMP_REG2 && GET_FLAG_TYPE(op) <= SLJIT_SIG_LESS_EQUAL) {
-			if (TEST_SL_IMM(src2, src2w)) {
-				compiler->imm = (sljit_ins)src2w & 0xffff;
-				return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM2 | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM2, dst, dstw, src1, src1w, src2, src2w);
-		}
-
-		if (TEST_SUB_FORM2(op)) {
-			if ((src2 & SLJIT_IMM) && src2w >= -SIMM_MAX && src2w <= SIMM_MAX) {
-				compiler->imm = (sljit_ins)src2w & 0xffff;
-				return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM2 | ALT_FORM3 | ALT_FORM4, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM2 | ALT_FORM4, dst, dstw, src1, src1w, src2, src2w);
-		}
-
-		if (TEST_SUB_FORM3(op))
-			return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM3, dst, dstw, src1, src1w, src2, src2w);
-
-		if (TEST_SL_IMM(src2, -src2w)) {
-			compiler->imm = (sljit_ins)(-src2w) & 0xffff;
-			return emit_op(compiler, SLJIT_ADD, flags | (!HAS_FLAGS(op) ? ALT_FORM2 : ALT_FORM3), dst, dstw, src1, src1w, TMP_REG2, 0);
-		}
-
-		if (TEST_SL_IMM(src1, src1w) && !(op & SLJIT_SET_Z)) {
-			compiler->imm = (sljit_ins)src1w & 0xffff;
-			return emit_op(compiler, SLJIT_SUB, flags | ALT_FORM4, dst, dstw, src2, src2w, TMP_REG2, 0);
-		}
-
-		if (!HAS_FLAGS(op)) {
-			if (TEST_SH_IMM(src2, -src2w)) {
-				compiler->imm = (sljit_ins)((-src2w) >> 16) & 0xffff;
-				return emit_op(compiler, SLJIT_ADD, flags |  ALT_FORM2 | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			/* Range between -1 and -32768 is covered above. */
-			if (TEST_ADD_IMM(src2, -src2w)) {
-				compiler->imm = (sljit_ins)-src2w;
-				return emit_op(compiler, SLJIT_ADD, flags | ALT_FORM2 | ALT_FORM4, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-		}
-
-		/* We know ALT_SIGN_EXT is set if it is an SLJIT_32 on 64 bit systems. */
-		return emit_op(compiler, SLJIT_SUB, flags | ((GET_FLAG_TYPE(op) == GET_FLAG_TYPE(SLJIT_SET_CARRY)) ? ALT_FORM5 : 0), dst, dstw, src1, src1w, src2, src2w);
-
 	case SLJIT_SUBC:
 		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_SUB;
-		return emit_op(compiler, SLJIT_SUBC, flags, dst, dstw, src1, src1w, src2, src2w);
+		return emit_op(compiler, op, flags | IMM_OP, dst, dstw, src1, src1w, src2, src2w);
 
 	case SLJIT_MUL:
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-		if (op & SLJIT_32)
-			flags |= ALT_FORM2;
-#endif
-		if (!HAS_FLAGS(op)) {
-			if (TEST_SL_IMM(src2, src2w)) {
-				compiler->imm = (sljit_ins)src2w & 0xffff;
-				return emit_op(compiler, SLJIT_MUL, flags | ALT_FORM1, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			if (TEST_SL_IMM(src1, src1w)) {
-				compiler->imm = (sljit_ins)src1w & 0xffff;
-				return emit_op(compiler, SLJIT_MUL, flags | ALT_FORM1, dst, dstw, src2, src2w, TMP_REG2, 0);
-			}
-		}
-		else
-			FAIL_IF(push_inst(compiler, MTXER | S(TMP_ZERO)));
-		return emit_op(compiler, SLJIT_MUL, flags, dst, dstw, src1, src1w, src2, src2w);
+		compiler->status_flags_state = 0;
+		return emit_op(compiler, op, flags | CUMULATIVE_OP, dst, dstw, src1, src1w, src2, src2w);
 
 	case SLJIT_AND:
 	case SLJIT_OR:
 	case SLJIT_XOR:
-		/* Commutative unsigned operations. */
-		if (!HAS_FLAGS(op) || GET_OPCODE(op) == SLJIT_AND) {
-			if (TEST_UL_IMM(src2, src2w)) {
-				compiler->imm = (sljit_ins)src2w;
-				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM1, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			if (TEST_UL_IMM(src1, src1w)) {
-				compiler->imm = (sljit_ins)src1w;
-				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM1, dst, dstw, src2, src2w, TMP_REG2, 0);
-			}
-			if (TEST_UH_IMM(src2, src2w)) {
-				compiler->imm = (sljit_ins)(src2w >> 16) & 0xffff;
-				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM2, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			if (TEST_UH_IMM(src1, src1w)) {
-				compiler->imm = (sljit_ins)(src1w >> 16) & 0xffff;
-				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM2, dst, dstw, src2, src2w, TMP_REG2, 0);
-			}
-		}
-		if (GET_OPCODE(op) != SLJIT_AND) {
-			/* Unlike or and xor, the and resets unwanted bits as well. */
-			if (TEST_UI_IMM(src2, src2w)) {
-				compiler->imm = (sljit_ins)src2w;
-				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM3, dst, dstw, src1, src1w, TMP_REG2, 0);
-			}
-			if (TEST_UI_IMM(src1, src1w)) {
-				compiler->imm = (sljit_ins)src1w;
-				return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM3, dst, dstw, src2, src2w, TMP_REG2, 0);
-			}
-		}
-		return emit_op(compiler, GET_OPCODE(op), flags, dst, dstw, src1, src1w, src2, src2w);
+		return emit_op(compiler, op, flags | CUMULATIVE_OP | IMM_OP, dst, dstw, src1, src1w, src2, src2w);
 
 	case SLJIT_SHL:
+	case SLJIT_MSHL:
 	case SLJIT_LSHR:
+	case SLJIT_MLSHR:
 	case SLJIT_ASHR:
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-		if (op & SLJIT_32)
-			flags |= ALT_FORM2;
-#endif
+	case SLJIT_MASHR:
+	case SLJIT_ROTL:
+	case SLJIT_ROTR:
 		if (src2 & SLJIT_IMM) {
-			compiler->imm = (sljit_ins)src2w;
-			return emit_op(compiler, GET_OPCODE(op), flags | ALT_FORM1, dst, dstw, src1, src1w, TMP_REG2, 0);
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+			src2w &= 0x1f;
+#else /* !SLJIT_CONFIG_RISCV_32 */
+			if (op & SLJIT_32)
+				src2w &= 0x1f;
+			else
+				src2w &= 0x3f;
+#endif /* SLJIT_CONFIG_RISCV_32 */
 		}
-		return emit_op(compiler, GET_OPCODE(op), flags, dst, dstw, src1, src1w, src2, src2w);
+
+		return emit_op(compiler, op, flags | IMM_OP, dst, dstw, src1, src1w, src2, src2w);
 	}
 
+	SLJIT_UNREACHABLE();
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2u(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op2(compiler, op, 1, 0, 0, src1, src1w, src2, src2w));
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_op2(compiler, op, TMP_REG2, 0, src1, src1w, src2, src2w);
 }
 
-#undef TEST_ADD_FORM1
-#undef TEST_SUB_FORM2
-#undef TEST_SUB_FORM3
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_shift_into(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 src_dst,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+	sljit_s32 is_left;
+	sljit_ins ins1, ins2, ins3;
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+	sljit_ins word = (op & SLJIT_32) >> 5;
+	sljit_s32 inp_flags = ((op & SLJIT_32) ? INT_DATA : WORD_DATA) | LOAD_DATA;
+	sljit_sw bit_length = (op & SLJIT_32) ? 32 : 64;
+#else /* !SLJIT_CONFIG_RISCV_64 */
+	sljit_s32 inp_flags = WORD_DATA | LOAD_DATA;
+	sljit_sw bit_length = 32;
+#endif /* SLJIT_CONFIG_RISCV_64 */
+
+	SLJIT_ASSERT(WORD == 0 || WORD == 0x8);
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_shift_into(compiler, op, src_dst, src1, src1w, src2, src2w));
+
+	is_left = (GET_OPCODE(op) == SLJIT_SHL || GET_OPCODE(op) == SLJIT_MSHL);
+
+	if (src_dst == src1) {
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_op2(compiler, (is_left ? SLJIT_ROTL : SLJIT_ROTR) | (op & SLJIT_32), src_dst, 0, src_dst, 0, src2, src2w);
+	}
+
+	ADJUST_LOCAL_OFFSET(src1, src1w);
+	ADJUST_LOCAL_OFFSET(src2, src2w);
+
+	if (src2 & SLJIT_IMM) {
+		src2w &= bit_length - 1;
+
+		if (src2w == 0)
+			return SLJIT_SUCCESS;
+	} else if (src2 & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, inp_flags, TMP_REG2, src2, src2w));
+		src2 = TMP_REG2;
+	}
+
+	if (src1 & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem(compiler, inp_flags, TMP_REG1, src1, src1w));
+		src1 = TMP_REG1;
+	} else if (src1 & SLJIT_IMM) {
+		FAIL_IF(load_immediate(compiler, TMP_REG1, src1w, TMP_REG3));
+		src1 = TMP_REG1;
+	}
+
+	if (src2 & SLJIT_IMM) {
+		if (is_left) {
+			ins1 = SLLI | WORD | IMM_I(src2w);
+			src2w = bit_length - src2w;
+			ins2 = SRLI | WORD | IMM_I(src2w);
+		} else {
+			ins1 = SRLI | WORD | IMM_I(src2w);
+			src2w = bit_length - src2w;
+			ins2 = SLLI | WORD | IMM_I(src2w);
+		}
+
+		FAIL_IF(push_inst(compiler, ins1 | RD(src_dst) | RS1(src_dst)));
+		FAIL_IF(push_inst(compiler, ins2 | RD(TMP_REG1) | RS1(src1)));
+		return push_inst(compiler, OR | RD(src_dst) | RS1(src_dst) | RS2(TMP_REG1));
+	}
+
+	if (is_left) {
+		ins1 = SLL;
+		ins2 = SRLI;
+		ins3 = SRL;
+	} else {
+		ins1 = SRL;
+		ins2 = SLLI;
+		ins3 = SLL;
+	}
+
+	FAIL_IF(push_inst(compiler, ins1 | WORD | RD(src_dst) | RS1(src_dst) | RS2(src2)));
+
+	if (!(op & SLJIT_SHIFT_INTO_NON_ZERO)) {
+		FAIL_IF(push_inst(compiler, ins2 | WORD | RD(TMP_REG1) | RS1(src1) | IMM_I(1)));
+		FAIL_IF(push_inst(compiler, XORI | RD(TMP_REG2) | RS1(src2) | IMM_I((sljit_ins)bit_length - 1)));
+		src1 = TMP_REG1;
+	} else
+		FAIL_IF(push_inst(compiler, SUB | WORD | RD(TMP_REG2) | RS1(TMP_ZERO) | RS2(src2)));
+
+	FAIL_IF(push_inst(compiler, ins3 | WORD | RD(TMP_REG1) | RS1(src1) | RS2(TMP_REG2)));
+	return push_inst(compiler, OR | RD(src_dst) | RS1(src_dst) | RS2(TMP_REG1));
+}
+
+#undef WORD
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_src(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src, sljit_sw srcw)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_src(compiler, op, src, srcw));
 	ADJUST_LOCAL_OFFSET(src, srcw);
 
 	switch (op) {
 	case SLJIT_FAST_RETURN:
 		if (FAST_IS_REG(src))
-			FAIL_IF(push_inst(compiler, MTLR | S(src)));
-		else {
-			FAIL_IF(emit_op(compiler, SLJIT_MOV, WORD_DATA, TMP_REG2, 0, TMP_REG1, 0, src, srcw));
-			FAIL_IF(push_inst(compiler, MTLR | S(TMP_REG2)));
-		}
+			FAIL_IF(push_inst(compiler, ADDI | RD(RETURN_ADDR_REG) | RS1(src) | IMM_I(0)));
+		else
+			FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, RETURN_ADDR_REG, src, srcw));
 
-		return push_inst(compiler, BLR);
+		return push_inst(compiler, JALR | RD(TMP_ZERO) | RS1(RETURN_ADDR_REG) | IMM_I(0));
 	case SLJIT_SKIP_FRAMES_BEFORE_FAST_RETURN:
 		return SLJIT_SUCCESS;
 	case SLJIT_PREFETCH_L1:
 	case SLJIT_PREFETCH_L2:
 	case SLJIT_PREFETCH_L3:
 	case SLJIT_PREFETCH_ONCE:
-		return emit_prefetch(compiler, src, srcw);
+		return SLJIT_SUCCESS;
 	}
 
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_register_index(sljit_s32 reg)
 {
@@ -1724,305 +1968,301 @@
 	return push_inst(compiler, *(sljit_ins*)instruction);
 }
 
 /* --------------------------------------------------------------------- */
 /*  Floating point operators                                             */
 /* --------------------------------------------------------------------- */
 
-#define FLOAT_DATA(op) (DOUBLE_DATA | ((op & SLJIT_32) >> 6))
-#define SELECT_FOP(op, single, double) ((sljit_ins)((op & SLJIT_32) ? single : double))
-
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-#define FLOAT_TMP_MEM_OFFSET (6 * sizeof(sljit_sw))
-#else
-#define FLOAT_TMP_MEM_OFFSET (2 * sizeof(sljit_sw))
-
-#if (defined SLJIT_LITTLE_ENDIAN && SLJIT_LITTLE_ENDIAN)
-#define FLOAT_TMP_MEM_OFFSET_LOW (2 * sizeof(sljit_sw))
-#define FLOAT_TMP_MEM_OFFSET_HI (3 * sizeof(sljit_sw))
-#else
-#define FLOAT_TMP_MEM_OFFSET_LOW (3 * sizeof(sljit_sw))
-#define FLOAT_TMP_MEM_OFFSET_HI (2 * sizeof(sljit_sw))
-#endif
-
-#endif /* SLJIT_CONFIG_PPC_64 */
+#define FLOAT_DATA(op) (DOUBLE_DATA | ((op & SLJIT_32) >> 7))
+#define FMT(op) ((sljit_ins)((op & SLJIT_32) ^ SLJIT_32) << 17)
 
 static SLJIT_INLINE sljit_s32 sljit_emit_fop1_conv_sw_from_f64(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src, sljit_sw srcw)
 {
-	if (src & SLJIT_MEM) {
-		/* We can ignore the temporary data store on the stack from caching point of view. */
-		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src, srcw, TMP_REG1));
-		src = TMP_FREG1;
-	}
-
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	op = GET_OPCODE(op);
-	FAIL_IF(push_inst(compiler, (op == SLJIT_CONV_S32_FROM_F64 ? FCTIWZ : FCTIDZ) | FD(TMP_FREG1) | FB(src)));
-
-	if (op == SLJIT_CONV_SW_FROM_F64) {
-		if (FAST_IS_REG(dst)) {
-			FAIL_IF(emit_op_mem(compiler, DOUBLE_DATA, TMP_FREG1, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1));
-			return emit_op_mem(compiler, WORD_DATA | LOAD_DATA, dst, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1);
-		}
-		return emit_op_mem(compiler, DOUBLE_DATA, TMP_FREG1, dst, dstw, TMP_REG1);
-	}
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+#	define flags (sljit_u32)0
 #else
-	FAIL_IF(push_inst(compiler, FCTIWZ | FD(TMP_FREG1) | FB(src)));
+	sljit_u32 flags = ((sljit_u32)(GET_OPCODE(op) == SLJIT_CONV_SW_FROM_F64)) << 21;
 #endif
+	sljit_s32 dst_r = FAST_IS_REG(dst) ? dst : TMP_REG2;
 
-	if (FAST_IS_REG(dst)) {
-		FAIL_IF(load_immediate(compiler, TMP_REG1, FLOAT_TMP_MEM_OFFSET));
-		FAIL_IF(push_inst(compiler, STFIWX | FS(TMP_FREG1) | A(SLJIT_SP) | B(TMP_REG1)));
-		return emit_op_mem(compiler, INT_DATA | LOAD_DATA, dst, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1);
+	if (src & SLJIT_MEM) {
+		FAIL_IF(emit_op_mem2(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src, srcw, dst, dstw));
+		src = TMP_FREG1;
 	}
 
-	SLJIT_ASSERT(dst & SLJIT_MEM);
+	FAIL_IF(push_inst(compiler, FCVT_W_S | FMT(op) | flags | RD(dst_r) | FRS1(src)));
 
-	if (dst & OFFS_REG_MASK) {
-		dstw &= 0x3;
-		if (dstw) {
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-			FAIL_IF(push_inst(compiler, RLWINM | S(OFFS_REG(dst)) | A(TMP_REG1) | ((sljit_ins)dstw << 11) | ((31 - (sljit_ins)dstw) << 1)));
+	/* Store the integer value from a VFP register. */
+	if (dst & SLJIT_MEM) {
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+		return emit_op_mem2(compiler, WORD_DATA, TMP_REG2, dst, dstw, 0, 0);
 #else
-			FAIL_IF(push_inst(compiler, RLDI(TMP_REG1, OFFS_REG(dst), dstw, 63 - dstw, 1)));
+		return emit_op_mem2(compiler, flags ? WORD_DATA : INT_DATA, TMP_REG2, dst, dstw, 0, 0);
 #endif
-			dstw = TMP_REG1;
-		}
-		else
-			dstw = OFFS_REG(dst);
-	}
-	else {
-		if ((dst & REG_MASK) && !dstw) {
-			dstw = dst & REG_MASK;
-			dst = 0;
-		}
-		else {
-			/* This works regardless we have SLJIT_MEM1 or SLJIT_MEM0. */
-			FAIL_IF(load_immediate(compiler, TMP_REG1, dstw));
-			dstw = TMP_REG1;
-		}
 	}
+	return SLJIT_SUCCESS;
 
-	return push_inst(compiler, STFIWX | FS(TMP_FREG1) | A(dst & REG_MASK) | B(dstw));
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+#	undef flags
+#endif
 }
 
 static SLJIT_INLINE sljit_s32 sljit_emit_fop1_conv_f64_from_sw(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src, sljit_sw srcw)
 {
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	sljit_ins inst;
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
+	sljit_u32 flags = ((sljit_u32)(GET_OPCODE(op) == SLJIT_CONV_F64_FROM_SW)) << 21;
+#endif
 
 	sljit_s32 dst_r = FAST_IS_REG(dst) ? dst : TMP_FREG1;
 
-	if (src & SLJIT_IMM) {
+	if (src & SLJIT_MEM) {
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+		FAIL_IF(emit_op_mem2(compiler, WORD_DATA | LOAD_DATA, TMP_REG1, src, srcw, dst, dstw));
+#else
+		FAIL_IF(emit_op_mem2(compiler, (flags ? WORD_DATA : INT_DATA) | LOAD_DATA, TMP_REG1, src, srcw, dst, dstw));
+#endif
+		src = TMP_REG1;
+	} else if (src & SLJIT_IMM) {
+#if (defined SLJIT_CONFIG_RISCV_64 && SLJIT_CONFIG_RISCV_64)
 		if (GET_OPCODE(op) == SLJIT_CONV_F64_FROM_S32)
 			srcw = (sljit_s32)srcw;
-		FAIL_IF(load_immediate(compiler, TMP_REG1, srcw));
-		src = TMP_REG1;
-	}
-	else if (GET_OPCODE(op) == SLJIT_CONV_F64_FROM_S32) {
-		if (FAST_IS_REG(src))
-			FAIL_IF(push_inst(compiler, EXTSW | S(src) | A(TMP_REG1)));
-		else
-			FAIL_IF(emit_op_mem(compiler, INT_DATA | SIGNED_DATA | LOAD_DATA, TMP_REG1, src, srcw, TMP_REG1));
-		src = TMP_REG1;
-	}
+#endif
 
-	if (FAST_IS_REG(src)) {
-		FAIL_IF(emit_op_mem(compiler, WORD_DATA, src, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1));
-		FAIL_IF(emit_op_mem(compiler, DOUBLE_DATA | LOAD_DATA, TMP_FREG1, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1));
+		FAIL_IF(load_immediate(compiler, TMP_REG1, srcw, TMP_REG3));
+		src = TMP_REG1;
 	}
-	else
-		FAIL_IF(emit_op_mem(compiler, DOUBLE_DATA | LOAD_DATA, TMP_FREG1, src, srcw, TMP_REG1));
 
-	FAIL_IF(push_inst(compiler, FCFID | FD(dst_r) | FB(TMP_FREG1)));
+	inst = FCVT_S_W | FMT(op) | FRD(dst_r) | RS1(src);
 
-	if (dst & SLJIT_MEM)
-		return emit_op_mem(compiler, FLOAT_DATA(op), TMP_FREG1, dst, dstw, TMP_REG1);
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
 	if (op & SLJIT_32)
-		return push_inst(compiler, FRSP | FD(dst_r) | FB(dst_r));
-	return SLJIT_SUCCESS;
-
+		inst |= F3(0x7);
 #else
+	inst |= flags;
 
-	sljit_s32 dst_r = FAST_IS_REG(dst) ? dst : TMP_FREG1;
-	sljit_s32 invert_sign = 1;
-
-	if (src & SLJIT_IMM) {
-		FAIL_IF(load_immediate(compiler, TMP_REG1, srcw ^ (sljit_sw)0x80000000));
-		src = TMP_REG1;
-		invert_sign = 0;
-	}
-	else if (!FAST_IS_REG(src)) {
-		FAIL_IF(emit_op_mem(compiler, WORD_DATA | SIGNED_DATA | LOAD_DATA, TMP_REG1, src, srcw, TMP_REG1));
-		src = TMP_REG1;
-	}
-
-	/* First, a special double floating point value is constructed: (2^53 + (input xor (2^31)))
-	   The double precision format has exactly 53 bit precision, so the lower 32 bit represents
-	   the lower 32 bit of such value. The result of xor 2^31 is the same as adding 0x80000000
-	   to the input, which shifts it into the 0 - 0xffffffff range. To get the converted floating
-	   point value, we need to substract 2^53 + 2^31 from the constructed value. */
-	FAIL_IF(push_inst(compiler, ADDIS | D(TMP_REG2) | A(0) | 0x4330));
-	if (invert_sign)
-		FAIL_IF(push_inst(compiler, XORIS | S(src) | A(TMP_REG1) | 0x8000));
-	FAIL_IF(emit_op_mem(compiler, WORD_DATA, TMP_REG2, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET_HI, TMP_REG1));
-	FAIL_IF(emit_op_mem(compiler, WORD_DATA, TMP_REG1, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET_LOW, TMP_REG2));
-	FAIL_IF(push_inst(compiler, ADDIS | D(TMP_REG1) | A(0) | 0x8000));
-	FAIL_IF(emit_op_mem(compiler, DOUBLE_DATA | LOAD_DATA, TMP_FREG1, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1));
-	FAIL_IF(emit_op_mem(compiler, WORD_DATA, TMP_REG1, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET_LOW, TMP_REG2));
-	FAIL_IF(emit_op_mem(compiler, DOUBLE_DATA | LOAD_DATA, TMP_FREG2, SLJIT_MEM1(SLJIT_SP), FLOAT_TMP_MEM_OFFSET, TMP_REG1));
+	if (op != SLJIT_CONV_F64_FROM_S32)
+		inst |= F3(0x7);
+#endif
 
-	FAIL_IF(push_inst(compiler, FSUB | FD(dst_r) | FA(TMP_FREG1) | FB(TMP_FREG2)));
+	FAIL_IF(push_inst(compiler, inst));
 
 	if (dst & SLJIT_MEM)
-		return emit_op_mem(compiler, FLOAT_DATA(op), TMP_FREG1, dst, dstw, TMP_REG1);
-	if (op & SLJIT_32)
-		return push_inst(compiler, FRSP | FD(dst_r) | FB(dst_r));
+		return emit_op_mem2(compiler, FLOAT_DATA(op), TMP_FREG1, dst, dstw, 0, 0);
 	return SLJIT_SUCCESS;
-
-#endif
 }
 
 static SLJIT_INLINE sljit_s32 sljit_emit_fop1_cmp(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
+	sljit_ins inst;
+
 	if (src1 & SLJIT_MEM) {
-		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src1, src1w, TMP_REG1));
+		FAIL_IF(emit_op_mem2(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src1, src1w, src2, src2w));
 		src1 = TMP_FREG1;
 	}
 
 	if (src2 & SLJIT_MEM) {
-		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG2, src2, src2w, TMP_REG2));
+		FAIL_IF(emit_op_mem2(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG2, src2, src2w, 0, 0));
 		src2 = TMP_FREG2;
 	}
 
-	return push_inst(compiler, FCMPU | CRD(4) | FA(src1) | FB(src2));
+	switch (GET_FLAG_TYPE(op)) {
+	case SLJIT_F_EQUAL:
+	case SLJIT_F_NOT_EQUAL:
+	case SLJIT_ORDERED_EQUAL:
+	case SLJIT_UNORDERED_OR_NOT_EQUAL:
+		inst = FEQ_S | FMT(op) | RD(OTHER_FLAG) | FRS1(src1) | FRS2(src2);
+		break;
+	case SLJIT_F_LESS:
+	case SLJIT_F_GREATER_EQUAL:
+	case SLJIT_ORDERED_LESS:
+	case SLJIT_UNORDERED_OR_GREATER_EQUAL:
+		inst = FLT_S | FMT(op) | RD(OTHER_FLAG) | FRS1(src1) | FRS2(src2);
+		break;
+	case SLJIT_ORDERED_GREATER:
+	case SLJIT_UNORDERED_OR_LESS_EQUAL:
+		inst = FLT_S | FMT(op) | RD(OTHER_FLAG) | FRS1(src2) | FRS2(src1);
+		break;
+	case SLJIT_F_GREATER:
+	case SLJIT_F_LESS_EQUAL:
+	case SLJIT_UNORDERED_OR_GREATER:
+	case SLJIT_ORDERED_LESS_EQUAL:
+		inst = FLE_S | FMT(op) | RD(OTHER_FLAG) | FRS1(src1) | FRS2(src2);
+		break;
+	case SLJIT_UNORDERED_OR_LESS:
+	case SLJIT_ORDERED_GREATER_EQUAL:
+		inst = FLE_S | FMT(op) | RD(OTHER_FLAG) | FRS1(src2) | FRS2(src1);
+		break;
+	case SLJIT_UNORDERED_OR_EQUAL: /* Not supported. */
+	case SLJIT_ORDERED_NOT_EQUAL: /* Not supported. */
+		FAIL_IF(push_inst(compiler, FLT_S | FMT(op) | RD(OTHER_FLAG) | FRS1(src1) | FRS2(src2)));
+		FAIL_IF(push_inst(compiler, FLT_S | FMT(op) | RD(TMP_REG1) | FRS1(src2) | FRS2(src1)));
+		inst = OR | RD(OTHER_FLAG) | RS1(OTHER_FLAG) | RS2(TMP_REG1);
+		break;
+	default: /* SLJIT_UNORDERED, SLJIT_ORDERED */
+		FAIL_IF(push_inst(compiler, FADD_S | FMT(op) | FRD(TMP_FREG1) | FRS1(src1) | FRS2(src2)));
+		inst = FEQ_S | FMT(op) | RD(OTHER_FLAG) | FRS1(TMP_FREG1) | FRS2(TMP_FREG1);
+		break;
+	}
+
+	return push_inst(compiler, inst);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fop1(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src, sljit_sw srcw)
 {
 	sljit_s32 dst_r;
 
 	CHECK_ERROR();
+	compiler->cache_arg = 0;
+	compiler->cache_argw = 0;
 
-	SLJIT_COMPILE_ASSERT((SLJIT_32 == 0x100) && !(DOUBLE_DATA & 0x4), float_transfer_bit_error);
+	SLJIT_COMPILE_ASSERT((SLJIT_32 == 0x100) && !(DOUBLE_DATA & 0x2), float_transfer_bit_error);
 	SELECT_FOP1_OPERATION_WITH_CHECKS(compiler, op, dst, dstw, src, srcw);
 
 	if (GET_OPCODE(op) == SLJIT_CONV_F64_FROM_F32)
 		op ^= SLJIT_32;
 
 	dst_r = FAST_IS_REG(dst) ? dst : TMP_FREG1;
 
 	if (src & SLJIT_MEM) {
-		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, dst_r, src, srcw, TMP_REG1));
+		FAIL_IF(emit_op_mem2(compiler, FLOAT_DATA(op) | LOAD_DATA, dst_r, src, srcw, dst, dstw));
 		src = dst_r;
 	}
 
 	switch (GET_OPCODE(op)) {
-	case SLJIT_CONV_F64_FROM_F32:
-		op ^= SLJIT_32;
-		if (op & SLJIT_32) {
-			FAIL_IF(push_inst(compiler, FRSP | FD(dst_r) | FB(src)));
-			break;
-		}
-		/* Fall through. */
 	case SLJIT_MOV_F64:
 		if (src != dst_r) {
 			if (dst_r != TMP_FREG1)
-				FAIL_IF(push_inst(compiler, FMR | FD(dst_r) | FB(src)));
+				FAIL_IF(push_inst(compiler, FSGNJ_S | FMT(op) | FRD(dst_r) | FRS1(src) | FRS2(src)));
 			else
 				dst_r = src;
 		}
 		break;
 	case SLJIT_NEG_F64:
-		FAIL_IF(push_inst(compiler, FNEG | FD(dst_r) | FB(src)));
+		FAIL_IF(push_inst(compiler, FSGNJN_S | FMT(op) | FRD(dst_r) | FRS1(src) | FRS2(src)));
 		break;
 	case SLJIT_ABS_F64:
-		FAIL_IF(push_inst(compiler, FABS | FD(dst_r) | FB(src)));
+		FAIL_IF(push_inst(compiler, FSGNJX_S | FMT(op) | FRD(dst_r) | FRS1(src) | FRS2(src)));
+		break;
+	case SLJIT_CONV_F64_FROM_F32:
+		/* The SLJIT_32 bit is inverted because sljit_f32 needs to be loaded from the memory. */
+		FAIL_IF(push_inst(compiler, FCVT_S_D | ((op & SLJIT_32) ? (1 << 25) : ((1 << 20) | F3(7))) | FRD(dst_r) | FRS1(src)));
+		op ^= SLJIT_32;
 		break;
 	}
 
 	if (dst & SLJIT_MEM)
-		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op), dst_r, dst, dstw, TMP_REG1));
+		return emit_op_mem2(compiler, FLOAT_DATA(op), dst_r, dst, dstw, 0, 0);
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fop2(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
-	sljit_s32 dst_r;
+	sljit_s32 dst_r, flags = 0;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_fop2(compiler, op, dst, dstw, src1, src1w, src2, src2w));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 	ADJUST_LOCAL_OFFSET(src1, src1w);
 	ADJUST_LOCAL_OFFSET(src2, src2w);
 
+	compiler->cache_arg = 0;
+	compiler->cache_argw = 0;
+
 	dst_r = FAST_IS_REG(dst) ? dst : TMP_FREG2;
 
 	if (src1 & SLJIT_MEM) {
-		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src1, src1w, TMP_REG1));
-		src1 = TMP_FREG1;
+		if (getput_arg_fast(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src1, src1w)) {
+			FAIL_IF(compiler->error);
+			src1 = TMP_FREG1;
+		} else
+			flags |= SLOW_SRC1;
 	}
 
 	if (src2 & SLJIT_MEM) {
-		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG2, src2, src2w, TMP_REG2));
-		src2 = TMP_FREG2;
+		if (getput_arg_fast(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG2, src2, src2w)) {
+			FAIL_IF(compiler->error);
+			src2 = TMP_FREG2;
+		} else
+			flags |= SLOW_SRC2;
 	}
 
+	if ((flags & (SLOW_SRC1 | SLOW_SRC2)) == (SLOW_SRC1 | SLOW_SRC2)) {
+		if (!can_cache(src1, src1w, src2, src2w) && can_cache(src1, src1w, dst, dstw)) {
+			FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG2, src2, src2w, src1, src1w));
+			FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src1, src1w, dst, dstw));
+		}
+		else {
+			FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src1, src1w, src2, src2w));
+			FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG2, src2, src2w, dst, dstw));
+		}
+	}
+	else if (flags & SLOW_SRC1)
+		FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG1, src1, src1w, dst, dstw));
+	else if (flags & SLOW_SRC2)
+		FAIL_IF(getput_arg(compiler, FLOAT_DATA(op) | LOAD_DATA, TMP_FREG2, src2, src2w, dst, dstw));
+
+	if (flags & SLOW_SRC1)
+		src1 = TMP_FREG1;
+	if (flags & SLOW_SRC2)
+		src2 = TMP_FREG2;
+
 	switch (GET_OPCODE(op)) {
 	case SLJIT_ADD_F64:
-		FAIL_IF(push_inst(compiler, SELECT_FOP(op, FADDS, FADD) | FD(dst_r) | FA(src1) | FB(src2)));
+		FAIL_IF(push_inst(compiler, FADD_S | FMT(op) | FRD(dst_r) | FRS1(src1) | FRS2(src2)));
 		break;
 
 	case SLJIT_SUB_F64:
-		FAIL_IF(push_inst(compiler, SELECT_FOP(op, FSUBS, FSUB) | FD(dst_r) | FA(src1) | FB(src2)));
+		FAIL_IF(push_inst(compiler, FSUB_S | FMT(op) | FRD(dst_r) | FRS1(src1) | FRS2(src2)));
 		break;
 
 	case SLJIT_MUL_F64:
-		FAIL_IF(push_inst(compiler, SELECT_FOP(op, FMULS, FMUL) | FD(dst_r) | FA(src1) | FC(src2) /* FMUL use FC as src2 */));
+		FAIL_IF(push_inst(compiler, FMUL_S | FMT(op) | FRD(dst_r) | FRS1(src1) | FRS2(src2)));
 		break;
 
 	case SLJIT_DIV_F64:
-		FAIL_IF(push_inst(compiler, SELECT_FOP(op, FDIVS, FDIV) | FD(dst_r) | FA(src1) | FB(src2)));
+		FAIL_IF(push_inst(compiler, FDIV_S | FMT(op) | FRD(dst_r) | FRS1(src1) | FRS2(src2)));
 		break;
 	}
 
-	if (dst & SLJIT_MEM)
-		FAIL_IF(emit_op_mem(compiler, FLOAT_DATA(op), TMP_FREG2, dst, dstw, TMP_REG1));
+	if (dst_r == TMP_FREG2)
+		FAIL_IF(emit_op_mem2(compiler, FLOAT_DATA(op), TMP_FREG2, dst, dstw, 0, 0));
 
 	return SLJIT_SUCCESS;
 }
 
-#undef SELECT_FOP
+#undef FLOAT_DATA
+#undef FMT
 
 /* --------------------------------------------------------------------- */
 /*  Other instructions                                                   */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_fast_enter(compiler, dst, dstw));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 
 	if (FAST_IS_REG(dst))
-		return push_inst(compiler, MFLR | D(dst));
+		return push_inst(compiler, ADDI | RD(dst) | RS1(RETURN_ADDR_REG) | IMM_I(0));
 
 	/* Memory. */
-	FAIL_IF(push_inst(compiler, MFLR | D(TMP_REG2)));
-	return emit_op(compiler, SLJIT_MOV, WORD_DATA, dst, dstw, TMP_REG1, 0, TMP_REG2, 0);
+	return emit_op_mem(compiler, WORD_DATA, RETURN_ADDR_REG, dst, dstw);
 }
 
 /* --------------------------------------------------------------------- */
 /*  Conditional instructions                                             */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_label* sljit_emit_label(struct sljit_compiler *compiler)
@@ -2037,365 +2277,372 @@
 
 	label = (struct sljit_label*)ensure_abuf(compiler, sizeof(struct sljit_label));
 	PTR_FAIL_IF(!label);
 	set_label(label, compiler);
 	return label;
 }
 
-static sljit_ins get_bo_bi_flags(struct sljit_compiler *compiler, sljit_s32 type)
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+#define BRANCH_LENGTH	((sljit_ins)(3 * sizeof(sljit_ins)) << 7)
+#else
+#define BRANCH_LENGTH	((sljit_ins)(7 * sizeof(sljit_ins)) << 7)
+#endif
+
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_jump(struct sljit_compiler *compiler, sljit_s32 type)
 {
-	switch (type) {
-	case SLJIT_NOT_CARRY:
-		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_SUB)
-			return (4 << 21) | (2 << 16);
-		/* fallthrough */
+	struct sljit_jump *jump;
+	sljit_ins inst;
 
-	case SLJIT_EQUAL:
-		return (12 << 21) | (2 << 16);
+	CHECK_ERROR_PTR();
+	CHECK_PTR(check_sljit_emit_jump(compiler, type));
 
-	case SLJIT_CARRY:
-		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_SUB)
-			return (12 << 21) | (2 << 16);
-		/* fallthrough */
+	jump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));
+	PTR_FAIL_IF(!jump);
+	set_jump(jump, compiler, type & SLJIT_REWRITABLE_JUMP);
+	type &= 0xff;
 
+	switch (type) {
+	case SLJIT_EQUAL:
+		inst = BNE | RS1(EQUAL_FLAG) | RS2(TMP_ZERO) | BRANCH_LENGTH;
+		break;
 	case SLJIT_NOT_EQUAL:
-		return (4 << 21) | (2 << 16);
-
+		inst = BEQ | RS1(EQUAL_FLAG) | RS2(TMP_ZERO) | BRANCH_LENGTH;
+		break;
 	case SLJIT_LESS:
-	case SLJIT_SIG_LESS:
-		return (12 << 21) | (0 << 16);
-
-	case SLJIT_GREATER_EQUAL:
-	case SLJIT_SIG_GREATER_EQUAL:
-		return (4 << 21) | (0 << 16);
-
 	case SLJIT_GREATER:
+	case SLJIT_SIG_LESS:
 	case SLJIT_SIG_GREATER:
-		return (12 << 21) | (1 << 16);
-
+	case SLJIT_OVERFLOW:
+	case SLJIT_CARRY:
+	case SLJIT_F_EQUAL:
+	case SLJIT_ORDERED_EQUAL:
+	case SLJIT_ORDERED_NOT_EQUAL: /* Not supported. */
+	case SLJIT_F_LESS:
+	case SLJIT_ORDERED_LESS:
+	case SLJIT_ORDERED_GREATER:
+	case SLJIT_F_LESS_EQUAL:
+	case SLJIT_ORDERED_LESS_EQUAL:
+	case SLJIT_ORDERED_GREATER_EQUAL:
+	case SLJIT_ORDERED:
+		inst = BEQ | RS1(OTHER_FLAG) | RS2(TMP_ZERO) | BRANCH_LENGTH;
+		break;
+	case SLJIT_GREATER_EQUAL:
 	case SLJIT_LESS_EQUAL:
+	case SLJIT_SIG_GREATER_EQUAL:
 	case SLJIT_SIG_LESS_EQUAL:
-		return (4 << 21) | (1 << 16);
-
-	case SLJIT_LESS_F64:
-		return (12 << 21) | ((4 + 0) << 16);
-
-	case SLJIT_GREATER_EQUAL_F64:
-		return (4 << 21) | ((4 + 0) << 16);
-
-	case SLJIT_GREATER_F64:
-		return (12 << 21) | ((4 + 1) << 16);
-
-	case SLJIT_LESS_EQUAL_F64:
-		return (4 << 21) | ((4 + 1) << 16);
+	case SLJIT_NOT_OVERFLOW:
+	case SLJIT_NOT_CARRY:
+	case SLJIT_F_NOT_EQUAL:
+	case SLJIT_UNORDERED_OR_NOT_EQUAL:
+	case SLJIT_UNORDERED_OR_EQUAL: /* Not supported. */
+	case SLJIT_F_GREATER_EQUAL:
+	case SLJIT_UNORDERED_OR_GREATER_EQUAL:
+	case SLJIT_UNORDERED_OR_LESS_EQUAL:
+	case SLJIT_F_GREATER:
+	case SLJIT_UNORDERED_OR_GREATER:
+	case SLJIT_UNORDERED_OR_LESS:
+	case SLJIT_UNORDERED:
+		inst = BNE | RS1(OTHER_FLAG) | RS2(TMP_ZERO) | BRANCH_LENGTH;
+		break;
+	default:
+		/* Not conditional branch. */
+		inst = 0;
+		break;
+	}
 
-	case SLJIT_OVERFLOW:
-		return (12 << 21) | (3 << 16);
+	if (inst != 0) {
+		PTR_FAIL_IF(push_inst(compiler, inst));
+		jump->flags |= IS_COND;
+	}
 
-	case SLJIT_NOT_OVERFLOW:
-		return (4 << 21) | (3 << 16);
+	jump->addr = compiler->size;
+	inst = JALR | RS1(TMP_REG1) | IMM_I(0);
 
-	case SLJIT_EQUAL_F64:
-		return (12 << 21) | ((4 + 2) << 16);
+	if (type >= SLJIT_FAST_CALL) {
+		jump->flags |= IS_CALL;
+		inst |= RD(RETURN_ADDR_REG);
+	}
 
-	case SLJIT_NOT_EQUAL_F64:
-		return (4 << 21) | ((4 + 2) << 16);
+	PTR_FAIL_IF(push_inst(compiler, inst));
 
-	case SLJIT_UNORDERED_F64:
-		return (12 << 21) | ((4 + 3) << 16);
+	/* Maximum number of instructions required for generating a constant. */
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	compiler->size += 1;
+#else
+	compiler->size += 5;
+#endif
+	return jump;
+}
 
-	case SLJIT_ORDERED_F64:
-		return (4 << 21) | ((4 + 3) << 16);
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 arg_types)
+{
+	SLJIT_UNUSED_ARG(arg_types);
+	CHECK_ERROR_PTR();
+	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
 
-	default:
-		SLJIT_ASSERT(type >= SLJIT_JUMP && type <= SLJIT_CALL_CDECL);
-		return (20 << 21);
+	if (type & SLJIT_CALL_RETURN) {
+		PTR_FAIL_IF(emit_stack_frame_release(compiler, 0));
+		type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
 	}
+
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_jump(compiler, type);
 }
 
-SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_jump(struct sljit_compiler *compiler, sljit_s32 type)
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_cmp(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
 {
 	struct sljit_jump *jump;
-	sljit_ins bo_bi_flags;
+	sljit_s32 flags;
+	sljit_ins inst;
 
 	CHECK_ERROR_PTR();
-	CHECK_PTR(check_sljit_emit_jump(compiler, type));
+	CHECK_PTR(check_sljit_emit_cmp(compiler, type, src1, src1w, src2, src2w));
+	ADJUST_LOCAL_OFFSET(src1, src1w);
+	ADJUST_LOCAL_OFFSET(src2, src2w);
+
+	compiler->cache_arg = 0;
+	compiler->cache_argw = 0;
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	flags = WORD_DATA | LOAD_DATA;
+#else /* !SLJIT_CONFIG_RISCV_32 */
+	flags = ((type & SLJIT_32) ? INT_DATA : WORD_DATA) | LOAD_DATA;
+#endif /* SLJIT_CONFIG_RISCV_32 */
+
+	if (src1 & SLJIT_MEM) {
+		PTR_FAIL_IF(emit_op_mem2(compiler, flags, TMP_REG1, src1, src1w, src2, src2w));
+		src1 = TMP_REG1;
+	}
+
+	if (src2 & SLJIT_MEM) {
+		PTR_FAIL_IF(emit_op_mem2(compiler, flags, TMP_REG2, src2, src2w, 0, 0));
+		src2 = TMP_REG2;
+	}
+
+	if (src1 & SLJIT_IMM) {
+		if (src1w != 0) {
+			PTR_FAIL_IF(load_immediate(compiler, TMP_REG1, src1w, TMP_REG3));
+			src1 = TMP_REG1;
+		}
+		else
+			src1 = TMP_ZERO;
+	}
 
-	bo_bi_flags = get_bo_bi_flags(compiler, type & 0xff);
-	if (!bo_bi_flags)
-		return NULL;
+	if (src2 & SLJIT_IMM) {
+		if (src2w != 0) {
+			PTR_FAIL_IF(load_immediate(compiler, TMP_REG2, src2w, TMP_REG3));
+			src2 = TMP_REG2;
+		}
+		else
+			src2 = TMP_ZERO;
+	}
 
 	jump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));
 	PTR_FAIL_IF(!jump);
-	set_jump(jump, compiler, (sljit_u32)type & SLJIT_REWRITABLE_JUMP);
+	set_jump(jump, compiler, (sljit_u32)((type & SLJIT_REWRITABLE_JUMP) | IS_COND));
 	type &= 0xff;
 
-	if (type == SLJIT_CARRY || type == SLJIT_NOT_CARRY)
-		PTR_FAIL_IF(push_inst(compiler, ADDE | RC(ALT_SET_FLAGS) | D(TMP_REG1) | A(TMP_ZERO) | B(TMP_ZERO)));
+	switch (type) {
+	case SLJIT_EQUAL:
+		inst = BNE | RS1(src1) | RS2(src2) | BRANCH_LENGTH;
+		break;
+	case SLJIT_NOT_EQUAL:
+		inst = BEQ | RS1(src1) | RS2(src2) | BRANCH_LENGTH;
+		break;
+	case SLJIT_LESS:
+		inst = BGEU | RS1(src1) | RS2(src2) | BRANCH_LENGTH;
+		break;
+	case SLJIT_GREATER_EQUAL:
+		inst = BLTU | RS1(src1) | RS2(src2) | BRANCH_LENGTH;
+		break;
+	case SLJIT_GREATER:
+		inst = BGEU | RS1(src2) | RS2(src1) | BRANCH_LENGTH;
+		break;
+	case SLJIT_LESS_EQUAL:
+		inst = BLTU | RS1(src2) | RS2(src1) | BRANCH_LENGTH;
+		break;
+	case SLJIT_SIG_LESS:
+		inst = BGE | RS1(src1) | RS2(src2) | BRANCH_LENGTH;
+		break;
+	case SLJIT_SIG_GREATER_EQUAL:
+		inst = BLT | RS1(src1) | RS2(src2) | BRANCH_LENGTH;
+		break;
+	case SLJIT_SIG_GREATER:
+		inst = BGE | RS1(src2) | RS2(src1) | BRANCH_LENGTH;
+		break;
+	case SLJIT_SIG_LESS_EQUAL:
+		inst = BLT | RS1(src2) | RS2(src1) | BRANCH_LENGTH;
+		break;
+	}
 
-	/* In PPC, we don't need to touch the arguments. */
-	if (type < SLJIT_JUMP)
-		jump->flags |= IS_COND;
-#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL)
-	if (type >= SLJIT_CALL)
-		jump->flags |= IS_CALL;
-#endif
+	PTR_FAIL_IF(push_inst(compiler, inst));
 
-	PTR_FAIL_IF(emit_const(compiler, TMP_CALL_REG, 0));
-	PTR_FAIL_IF(push_inst(compiler, MTCTR | S(TMP_CALL_REG)));
 	jump->addr = compiler->size;
-	PTR_FAIL_IF(push_inst(compiler, BCCTR | bo_bi_flags | (type >= SLJIT_FAST_CALL ? 1 : 0)));
-	return jump;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,
-	sljit_s32 arg_types)
-{
-	CHECK_ERROR_PTR();
-	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
-
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	PTR_FAIL_IF(call_with_args(compiler, arg_types, NULL));
-#endif
-
-	if (type & SLJIT_CALL_RETURN) {
-		PTR_FAIL_IF(emit_stack_frame_release(compiler));
-		type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
-	}
+	PTR_FAIL_IF(push_inst(compiler, JALR | RD(TMP_ZERO) | RS1(TMP_REG1) | IMM_I(0)));
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
+	/* Maximum number of instructions required for generating a constant. */
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	compiler->size += 1;
+#else
+	compiler->size += 5;
 #endif
-
-	return sljit_emit_jump(compiler, type);
+	return jump;
 }
 
+#undef BRANCH_LENGTH
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_ijump(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 src, sljit_sw srcw)
 {
-	struct sljit_jump *jump = NULL;
-	sljit_s32 src_r;
+	struct sljit_jump *jump;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_ijump(compiler, type, src, srcw));
-	ADJUST_LOCAL_OFFSET(src, srcw);
 
-	if (FAST_IS_REG(src)) {
-#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL)
-		if (type >= SLJIT_CALL && src != TMP_CALL_REG) {
-			FAIL_IF(push_inst(compiler, OR | S(src) | A(TMP_CALL_REG) | B(src)));
-			src_r = TMP_CALL_REG;
+	if (!(src & SLJIT_IMM)) {
+		if (src & SLJIT_MEM) {
+			ADJUST_LOCAL_OFFSET(src, srcw);
+			FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, TMP_REG1, src, srcw));
+			src = TMP_REG1;
 		}
-		else
-			src_r = src;
-#else /* SLJIT_PASS_ENTRY_ADDR_TO_CALL */
-		src_r = src;
-#endif /* SLJIT_PASS_ENTRY_ADDR_TO_CALL */
-	} else if (src & SLJIT_IMM) {
-		/* These jumps are converted to jump/call instructions when possible. */
-		jump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));
-		FAIL_IF(!jump);
-		set_jump(jump, compiler, JUMP_ADDR);
-		jump->u.target = (sljit_uw)srcw;
-
-#if (defined SLJIT_PASS_ENTRY_ADDR_TO_CALL && SLJIT_PASS_ENTRY_ADDR_TO_CALL)
-		if (type >= SLJIT_CALL)
-			jump->flags |= IS_CALL;
-#endif /* SLJIT_PASS_ENTRY_ADDR_TO_CALL */
-
-		FAIL_IF(emit_const(compiler, TMP_CALL_REG, 0));
-		src_r = TMP_CALL_REG;
-	}
-	else {
-		FAIL_IF(emit_op(compiler, SLJIT_MOV, WORD_DATA, TMP_CALL_REG, 0, TMP_REG1, 0, src, srcw));
-		src_r = TMP_CALL_REG;
+		return push_inst(compiler, JALR | RD((type >= SLJIT_FAST_CALL) ? RETURN_ADDR_REG : TMP_ZERO) | RS1(src) | IMM_I(0));
 	}
 
-	FAIL_IF(push_inst(compiler, MTCTR | S(src_r)));
-	if (jump)
-		jump->addr = compiler->size;
-	return push_inst(compiler, BCCTR | (20 << 21) | (type >= SLJIT_FAST_CALL ? 1 : 0));
+	/* These jumps are converted to jump/call instructions when possible. */
+	jump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));
+	FAIL_IF(!jump);
+	set_jump(jump, compiler, JUMP_ADDR | ((type >= SLJIT_FAST_CALL) ? IS_CALL : 0));
+	jump->u.target = (sljit_uw)srcw;
+
+	jump->addr = compiler->size;
+	FAIL_IF(push_inst(compiler, JALR | RD((type >= SLJIT_FAST_CALL) ? RETURN_ADDR_REG : TMP_ZERO) | RS1(TMP_REG1) | IMM_I(0)));
+
+	/* Maximum number of instructions required for generating a constant. */
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	compiler->size += 1;
+#else
+	compiler->size += 5;
+#endif
+	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_icall(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 arg_types,
 	sljit_s32 src, sljit_sw srcw)
 {
+	SLJIT_UNUSED_ARG(arg_types);
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_icall(compiler, type, arg_types, src, srcw));
 
 	if (src & SLJIT_MEM) {
 		ADJUST_LOCAL_OFFSET(src, srcw);
-		FAIL_IF(emit_op(compiler, SLJIT_MOV, WORD_DATA, TMP_CALL_REG, 0, TMP_REG1, 0, src, srcw));
-		src = TMP_CALL_REG;
+		FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, TMP_REG1, src, srcw));
+		src = TMP_REG1;
 	}
 
 	if (type & SLJIT_CALL_RETURN) {
-		if (src >= SLJIT_FIRST_SAVED_REG && src <= SLJIT_S0) {
-			FAIL_IF(push_inst(compiler, OR | S(src) | A(TMP_CALL_REG) | B(src)));
-			src = TMP_CALL_REG;
+		if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
+			FAIL_IF(push_inst(compiler, ADDI | RD(TMP_REG1) | RS1(src) | IMM_I(0)));
+			src = TMP_REG1;
 		}
 
-		FAIL_IF(emit_stack_frame_release(compiler));
+		FAIL_IF(emit_stack_frame_release(compiler, 0));
 		type = SLJIT_JUMP;
 	}
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	FAIL_IF(call_with_args(compiler, arg_types, &src));
-#endif
-
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
-
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_ijump(compiler, type, src, srcw);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_flags(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 type)
 {
-	sljit_s32 reg, invert;
-	sljit_u32 bit, from_xer;
+	sljit_s32 src_r, dst_r, invert;
 	sljit_s32 saved_op = op;
-	sljit_sw saved_dstw = dstw;
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	sljit_s32 input_flags = ((op & SLJIT_32) || op == SLJIT_MOV32) ? INT_DATA : WORD_DATA;
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	sljit_s32 mem_type = WORD_DATA;
 #else
-	sljit_s32 input_flags = WORD_DATA;
+	sljit_s32 mem_type = ((op & SLJIT_32) || op == SLJIT_MOV32) ? (INT_DATA | SIGNED_DATA) : WORD_DATA;
 #endif
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_flags(compiler, op, dst, dstw, type));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 
 	op = GET_OPCODE(op);
-	reg = (op < SLJIT_ADD && FAST_IS_REG(dst)) ? dst : TMP_REG2;
-
-	if (op >= SLJIT_ADD && (dst & SLJIT_MEM))
-		FAIL_IF(emit_op_mem(compiler, input_flags | LOAD_DATA, TMP_REG1, dst, dstw, TMP_REG1));
-
-	invert = 0;
-	bit = 0;
-	from_xer = 0;
-
-	switch (type & 0xff) {
-	case SLJIT_LESS:
-	case SLJIT_SIG_LESS:
-		break;
-
-	case SLJIT_GREATER_EQUAL:
-	case SLJIT_SIG_GREATER_EQUAL:
-		invert = 1;
-		break;
-
-	case SLJIT_GREATER:
-	case SLJIT_SIG_GREATER:
-		bit = 1;
-		break;
-
-	case SLJIT_LESS_EQUAL:
-	case SLJIT_SIG_LESS_EQUAL:
-		bit = 1;
-		invert = 1;
-		break;
+	dst_r = (op < SLJIT_ADD && FAST_IS_REG(dst)) ? dst : TMP_REG2;
 
-	case SLJIT_EQUAL:
-		bit = 2;
-		break;
-
-	case SLJIT_NOT_EQUAL:
-		bit = 2;
-		invert = 1;
-		break;
-
-	case SLJIT_OVERFLOW:
-		from_xer = 1;
-		bit = 1;
-		break;
-
-	case SLJIT_NOT_OVERFLOW:
-		from_xer = 1;
-		bit = 1;
-		invert = 1;
-		break;
-
-	case SLJIT_CARRY:
-		from_xer = 1;
-		bit = 2;
-		invert = (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_SUB) != 0;
-		break;
-
-	case SLJIT_NOT_CARRY:
-		from_xer = 1;
-		bit = 2;
-		invert = (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_ADD) != 0;
-		break;
-
-	case SLJIT_LESS_F64:
-		bit = 4 + 0;
-		break;
-
-	case SLJIT_GREATER_EQUAL_F64:
-		bit = 4 + 0;
-		invert = 1;
-		break;
-
-	case SLJIT_GREATER_F64:
-		bit = 4 + 1;
-		break;
+	compiler->cache_arg = 0;
+	compiler->cache_argw = 0;
 
-	case SLJIT_LESS_EQUAL_F64:
-		bit = 4 + 1;
-		invert = 1;
-		break;
-
-	case SLJIT_EQUAL_F64:
-		bit = 4 + 2;
-		break;
-
-	case SLJIT_NOT_EQUAL_F64:
-		bit = 4 + 2;
-		invert = 1;
-		break;
-
-	case SLJIT_UNORDERED_F64:
-		bit = 4 + 3;
-		break;
+	if (op >= SLJIT_ADD && (dst & SLJIT_MEM))
+		FAIL_IF(emit_op_mem2(compiler, mem_type | LOAD_DATA, TMP_REG1, dst, dstw, dst, dstw));
 
-	case SLJIT_ORDERED_F64:
-		bit = 4 + 3;
-		invert = 1;
-		break;
+	if (type < SLJIT_F_EQUAL) {
+		src_r = OTHER_FLAG;
+		invert = type & 0x1;
+
+		switch (type) {
+		case SLJIT_EQUAL:
+		case SLJIT_NOT_EQUAL:
+			FAIL_IF(push_inst(compiler, SLTUI | RD(dst_r) | RS1(EQUAL_FLAG) | IMM_I(1)));
+			src_r = dst_r;
+			break;
+		case SLJIT_OVERFLOW:
+		case SLJIT_NOT_OVERFLOW:
+			if (compiler->status_flags_state & (SLJIT_CURRENT_FLAGS_ADD | SLJIT_CURRENT_FLAGS_SUB)) {
+				src_r = OTHER_FLAG;
+				break;
+			}
+			FAIL_IF(push_inst(compiler, SLTUI | RD(dst_r) | RS1(OTHER_FLAG) | IMM_I(1)));
+			src_r = dst_r;
+			invert ^= 0x1;
+			break;
+		}
+	} else {
+		invert = 0;
+		src_r = OTHER_FLAG;
 
-	default:
-		SLJIT_UNREACHABLE();
-		break;
+		switch (type) {
+		case SLJIT_F_NOT_EQUAL:
+		case SLJIT_UNORDERED_OR_NOT_EQUAL:
+		case SLJIT_UNORDERED_OR_EQUAL: /* Not supported. */
+		case SLJIT_F_GREATER_EQUAL:
+		case SLJIT_UNORDERED_OR_GREATER_EQUAL:
+		case SLJIT_UNORDERED_OR_LESS_EQUAL:
+		case SLJIT_F_GREATER:
+		case SLJIT_UNORDERED_OR_GREATER:
+		case SLJIT_UNORDERED_OR_LESS:
+		case SLJIT_UNORDERED:
+			invert = 1;
+			break;
+		}
 	}
 
-	FAIL_IF(push_inst(compiler, (from_xer ? MFXER : MFCR) | D(reg)));
-	FAIL_IF(push_inst(compiler, RLWINM | S(reg) | A(reg) | ((1 + bit) << 11) | (31 << 6) | (31 << 1)));
-
-	if (invert)
-		FAIL_IF(push_inst(compiler, XORI | S(reg) | A(reg) | 0x1));
+	if (invert) {
+		FAIL_IF(push_inst(compiler, XORI | RD(dst_r) | RS1(src_r) | IMM_I(1)));
+		src_r = dst_r;
+	}
 
 	if (op < SLJIT_ADD) {
-		if (!(dst & SLJIT_MEM))
-			return SLJIT_SUCCESS;
-		return emit_op_mem(compiler, input_flags, reg, dst, dstw, TMP_REG1);
+		if (dst & SLJIT_MEM)
+			return emit_op_mem(compiler, mem_type, src_r, dst, dstw);
+
+		if (src_r != dst_r)
+			return push_inst(compiler, ADDI | RD(dst_r) | RS1(src_r) | IMM_I(0));
+		return SLJIT_SUCCESS;
 	}
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	mem_type |= CUMULATIVE_OP | IMM_OP | ALT_KEEP_CACHE;
+
 	if (dst & SLJIT_MEM)
-		return sljit_emit_op2(compiler, saved_op, dst, saved_dstw, TMP_REG1, 0, TMP_REG2, 0);
-	return sljit_emit_op2(compiler, saved_op, dst, 0, dst, 0, TMP_REG2, 0);
+		return emit_op(compiler, saved_op, mem_type, dst, dstw, TMP_REG1, 0, src_r, 0);
+	return emit_op(compiler, saved_op, mem_type, dst, dstw, dst, dstw, src_r, 0);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_cmov(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 dst_reg,
 	sljit_s32 src, sljit_sw srcw)
 {
 	CHECK_ERROR();
@@ -2404,144 +2651,65 @@
 	return sljit_emit_cmov_generic(compiler, type, dst_reg, src, srcw);;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 reg,
 	sljit_s32 mem, sljit_sw memw)
 {
-	sljit_s32 mem_flags;
-	sljit_ins inst;
+	sljit_s32 flags;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_mem(compiler, type, reg, mem, memw));
 
-	if (type & SLJIT_MEM_POST)
-		return SLJIT_ERR_UNSUPPORTED;
+	if (!(reg & REG_PAIR_MASK))
+		return sljit_emit_mem_unaligned(compiler, type, reg, mem, memw);
 
-	switch (type & 0xff) {
-	case SLJIT_MOV:
-	case SLJIT_MOV_P:
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-	case SLJIT_MOV_U32:
-	case SLJIT_MOV_S32:
-	case SLJIT_MOV32:
-#endif
-		mem_flags = WORD_DATA;
-		break;
-
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-	case SLJIT_MOV_U32:
-	case SLJIT_MOV32:
-		mem_flags = INT_DATA;
-		break;
-
-	case SLJIT_MOV_S32:
-		mem_flags = INT_DATA;
+	if (SLJIT_UNLIKELY(mem & OFFS_REG_MASK)) {
+		memw &= 0x3;
 
-		if (!(type & SLJIT_MEM_STORE) && !(type & SLJIT_32)) {
-			if (mem & OFFS_REG_MASK)
-				mem_flags |= SIGNED_DATA;
-			else
-				return SLJIT_ERR_UNSUPPORTED;
+		if (SLJIT_UNLIKELY(memw != 0)) {
+			FAIL_IF(push_inst(compiler, SLLI | RD(TMP_REG1) | RS1(OFFS_REG(mem)) | IMM_I(memw)));
+			FAIL_IF(push_inst(compiler, ADD | RD(TMP_REG1) | RS1(TMP_REG1) | RS2(mem & REG_MASK)));
+		} else
+			FAIL_IF(push_inst(compiler, ADD | RD(TMP_REG1) | RS1(mem & REG_MASK) | RS2(OFFS_REG(mem))));
+
+		mem = TMP_REG1;
+		memw = 0;
+	} else if (memw > SIMM_MAX - SSIZE_OF(sw) || memw < SIMM_MIN) {
+		if (((memw + 0x800) & 0xfff) <= 0xfff - SSIZE_OF(sw)) {
+			FAIL_IF(load_immediate(compiler, TMP_REG1, TO_ARGW_HI(memw), TMP_REG3));
+			memw &= 0xfff;
+		} else {
+			FAIL_IF(load_immediate(compiler, TMP_REG1, memw, TMP_REG3));
+			memw = 0;
 		}
-		break;
-#endif
-
-	case SLJIT_MOV_U8:
-	case SLJIT_MOV_S8:
-		mem_flags = BYTE_DATA;
-		break;
-
-	case SLJIT_MOV_U16:
-		mem_flags = HALF_DATA;
-		break;
 
-	case SLJIT_MOV_S16:
-		mem_flags = HALF_DATA | SIGNED_DATA;
-		break;
+		if (mem & REG_MASK)
+			FAIL_IF(push_inst(compiler, ADD | RD(TMP_REG1) | RS1(TMP_REG1) | RS2(mem & REG_MASK)));
 
-	default:
-		SLJIT_UNREACHABLE();
-		mem_flags = WORD_DATA;
-		break;
+		mem = TMP_REG1;
+	} else {
+		mem &= REG_MASK;
+		memw &= 0xfff;
 	}
 
-	if (!(type & SLJIT_MEM_STORE))
-		mem_flags |= LOAD_DATA;
+	SLJIT_ASSERT((memw >= 0 && memw <= SIMM_MAX - SSIZE_OF(sw)) || (memw > SIMM_MAX && memw <= 0xfff));
 
-	if (SLJIT_UNLIKELY(mem & OFFS_REG_MASK)) {
-		if (memw != 0)
-			return SLJIT_ERR_UNSUPPORTED;
-
-		if (type & SLJIT_MEM_SUPP)
-			return SLJIT_SUCCESS;
-
-		inst = updated_data_transfer_insts[mem_flags | INDEXED];
-		FAIL_IF(push_inst(compiler, INST_CODE_AND_DST(inst, 0, reg) | A(mem & REG_MASK) | B(OFFS_REG(mem))));
+	if (!(type & SLJIT_MEM_STORE) && mem == REG_PAIR_FIRST(reg)) {
+		FAIL_IF(push_mem_inst(compiler, WORD_DATA | LOAD_DATA, REG_PAIR_SECOND(reg), mem, (memw + SSIZE_OF(sw)) & 0xfff));
+		return push_mem_inst(compiler, WORD_DATA | LOAD_DATA, REG_PAIR_FIRST(reg), mem, memw);
 	}
-	else {
-		if (memw > SIMM_MAX || memw < SIMM_MIN)
-			return SLJIT_ERR_UNSUPPORTED;
 
-		inst = updated_data_transfer_insts[mem_flags];
+	flags = WORD_DATA | (!(type & SLJIT_MEM_STORE) ? LOAD_DATA : 0);
 
-#if (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
-		if ((inst & INT_ALIGNED) && (memw & 0x3) != 0)
-			return SLJIT_ERR_UNSUPPORTED;
-#endif
-
-		if (type & SLJIT_MEM_SUPP)
-			return SLJIT_SUCCESS;
-
-		FAIL_IF(push_inst(compiler, INST_CODE_AND_DST(inst, 0, reg) | A(mem & REG_MASK) | IMM(memw)));
-	}
-
-	if ((mem_flags & LOAD_DATA) && (type & 0xff) == SLJIT_MOV_S8)
-		return push_inst(compiler, EXTSB | S(reg) | A(reg));
-	return SLJIT_SUCCESS;
+	FAIL_IF(push_mem_inst(compiler, flags, REG_PAIR_FIRST(reg), mem, memw));
+	return push_mem_inst(compiler, flags, REG_PAIR_SECOND(reg), mem, (memw + SSIZE_OF(sw)) & 0xfff);
 }
 
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fmem(struct sljit_compiler *compiler, sljit_s32 type,
-	sljit_s32 freg,
-	sljit_s32 mem, sljit_sw memw)
-{
-	sljit_s32 mem_flags;
-	sljit_ins inst;
-
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_fmem(compiler, type, freg, mem, memw));
-
-	if (type & SLJIT_MEM_POST)
-		return SLJIT_ERR_UNSUPPORTED;
-
-	if (SLJIT_UNLIKELY(mem & OFFS_REG_MASK)) {
-		if (memw != 0)
-			return SLJIT_ERR_UNSUPPORTED;
-	}
-	else {
-		if (memw > SIMM_MAX || memw < SIMM_MIN)
-			return SLJIT_ERR_UNSUPPORTED;
-	}
-
-	if (type & SLJIT_MEM_SUPP)
-		return SLJIT_SUCCESS;
-
-	mem_flags = FLOAT_DATA(type);
-
-	if (!(type & SLJIT_MEM_STORE))
-		mem_flags |= LOAD_DATA;
-
-	if (SLJIT_UNLIKELY(mem & OFFS_REG_MASK)) {
-		inst = updated_data_transfer_insts[mem_flags | INDEXED];
-		return push_inst(compiler, INST_CODE_AND_DST(inst, DOUBLE_DATA, freg) | A(mem & REG_MASK) | B(OFFS_REG(mem)));
-	}
-
-	inst = updated_data_transfer_insts[mem_flags];
-	return push_inst(compiler, INST_CODE_AND_DST(inst, DOUBLE_DATA, freg) | A(mem & REG_MASK) | IMM(memw));
-}
+#undef TO_ARGW_HI
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_const* sljit_emit_const(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw init_value)
 {
 	struct sljit_const *const_;
 	sljit_s32 dst_r;
 
 	CHECK_ERROR_PTR();
@@ -2549,18 +2717,18 @@
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 
 	const_ = (struct sljit_const*)ensure_abuf(compiler, sizeof(struct sljit_const));
 	PTR_FAIL_IF(!const_);
 	set_const(const_, compiler);
 
 	dst_r = FAST_IS_REG(dst) ? dst : TMP_REG2;
-	PTR_FAIL_IF(emit_const(compiler, dst_r, init_value));
+	PTR_FAIL_IF(emit_const(compiler, dst_r, init_value, ADDI | RD(dst_r)));
 
 	if (dst & SLJIT_MEM)
-		PTR_FAIL_IF(emit_op(compiler, SLJIT_MOV, WORD_DATA, dst, dstw, TMP_REG1, 0, TMP_REG2, 0));
+		PTR_FAIL_IF(emit_op_mem(compiler, WORD_DATA, TMP_REG2, dst, dstw));
 
 	return const_;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_put_label* sljit_emit_put_label(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw)
 {
 	struct sljit_put_label *put_label;
@@ -2571,19 +2739,24 @@
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 
 	put_label = (struct sljit_put_label*)ensure_abuf(compiler, sizeof(struct sljit_put_label));
 	PTR_FAIL_IF(!put_label);
 	set_put_label(put_label, compiler, 0);
 
 	dst_r = FAST_IS_REG(dst) ? dst : TMP_REG2;
-#if (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32)
-	PTR_FAIL_IF(emit_const(compiler, dst_r, 0));
-#else
 	PTR_FAIL_IF(push_inst(compiler, (sljit_ins)dst_r));
-	compiler->size += 4;
+#if (defined SLJIT_CONFIG_RISCV_32 && SLJIT_CONFIG_RISCV_32)
+	compiler->size += 1;
+#else
+	compiler->size += 5;
 #endif
 
 	if (dst & SLJIT_MEM)
-		PTR_FAIL_IF(emit_op(compiler, SLJIT_MOV, WORD_DATA, dst, dstw, TMP_REG1, 0, TMP_REG2, 0));
+		PTR_FAIL_IF(emit_op_mem(compiler, WORD_DATA, TMP_REG2, dst, dstw));
 
 	return put_label;
 }
+
+SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
+{
+	sljit_set_jump_addr(addr, (sljit_uw)new_constant, executable_offset);
+}
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeS390X.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeS390X.c`

 * *Files 4% similar despite different names*

```diff
@@ -99,19 +99,16 @@
 /* TODO(carenas): flags should move to a different register so that
  *                link register doesn't need to change
  */
 
 /* When reg cannot be unused. */
 #define IS_GPR_REG(reg)		((reg > 0) && (reg) <= SLJIT_SP)
 
-/* Link registers. The normal link register is r14, but since
-   we use that for flags we need to use r0 instead to do fast
-   calls so that flags are preserved. */
+/* Link register. */
 static const sljit_gpr link_r = 14;     /* r14 */
-static const sljit_gpr fast_link_r = 0; /* r0 */
 
 #define TMP_FREG1	(0)
 
 static const sljit_u8 freg_map[SLJIT_NUMBER_OF_FLOAT_REGISTERS + 1] = {
 	1, 0, 2, 4, 6, 3, 5, 7, 15, 14, 13, 12, 11, 10, 9, 8,
 };
 
@@ -216,93 +213,113 @@
 				return cc0;
 			if (type == SLJIT_OVERFLOW)
 				return (cc0 | cc3);
 			return (cc0 | cc2);
 		}
 		/* fallthrough */
 
-	case SLJIT_EQUAL_F64:
+	case SLJIT_F_EQUAL:
+	case SLJIT_ORDERED_EQUAL:
 		return cc0;
 
 	case SLJIT_NOT_EQUAL:
 		if (SLJIT_ADD_SUB_NO_COMPARE(compiler->status_flags_state)) {
 			sljit_s32 type = GET_FLAG_TYPE(compiler->status_flags_state);
 			if (type >= SLJIT_SIG_LESS && type <= SLJIT_SIG_LESS_EQUAL)
 				return (cc1 | cc2 | cc3);
 			if (type == SLJIT_OVERFLOW)
 				return (cc1 | cc2);
 			return (cc1 | cc3);
 		}
 		/* fallthrough */
 
-	case SLJIT_NOT_EQUAL_F64:
+	case SLJIT_UNORDERED_OR_NOT_EQUAL:
 		return (cc1 | cc2 | cc3);
 
 	case SLJIT_LESS:
 		return cc1;
 
 	case SLJIT_GREATER_EQUAL:
+	case SLJIT_UNORDERED_OR_GREATER_EQUAL:
 		return (cc0 | cc2 | cc3);
 
 	case SLJIT_GREATER:
 		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_COMPARE)
 			return cc2;
 		return cc3;
 
 	case SLJIT_LESS_EQUAL:
 		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_COMPARE)
 			return (cc0 | cc1);
 		return (cc0 | cc1 | cc2);
 
 	case SLJIT_SIG_LESS:
-	case SLJIT_LESS_F64:
+	case SLJIT_F_LESS:
+	case SLJIT_ORDERED_LESS:
 		return cc1;
 
 	case SLJIT_NOT_CARRY:
 		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_SUB)
 			return (cc2 | cc3);
 		/* fallthrough */
 
 	case SLJIT_SIG_LESS_EQUAL:
-	case SLJIT_LESS_EQUAL_F64:
+	case SLJIT_F_LESS_EQUAL:
+	case SLJIT_ORDERED_LESS_EQUAL:
 		return (cc0 | cc1);
 
 	case SLJIT_CARRY:
 		if (compiler->status_flags_state & SLJIT_CURRENT_FLAGS_SUB)
 			return (cc0 | cc1);
 		/* fallthrough */
 
 	case SLJIT_SIG_GREATER:
+	case SLJIT_UNORDERED_OR_GREATER:
 		/* Overflow is considered greater, see SLJIT_SUB. */
 		return cc2 | cc3;
 
 	case SLJIT_SIG_GREATER_EQUAL:
 		return (cc0 | cc2 | cc3);
 
 	case SLJIT_OVERFLOW:
 		if (compiler->status_flags_state & SLJIT_SET_Z)
 			return (cc2 | cc3);
 		/* fallthrough */
 
-	case SLJIT_UNORDERED_F64:
+	case SLJIT_UNORDERED:
 		return cc3;
 
 	case SLJIT_NOT_OVERFLOW:
 		if (compiler->status_flags_state & SLJIT_SET_Z)
 			return (cc0 | cc1);
 		/* fallthrough */
 
-	case SLJIT_ORDERED_F64:
+	case SLJIT_ORDERED:
 		return (cc0 | cc1 | cc2);
 
-	case SLJIT_GREATER_F64:
+	case SLJIT_F_NOT_EQUAL:
+	case SLJIT_ORDERED_NOT_EQUAL:
+		return (cc1 | cc2);
+
+	case SLJIT_F_GREATER:
+	case SLJIT_ORDERED_GREATER:
 		return cc2;
 
-	case SLJIT_GREATER_EQUAL_F64:
+	case SLJIT_F_GREATER_EQUAL:
+	case SLJIT_ORDERED_GREATER_EQUAL:
 		return (cc0 | cc2);
+
+	case SLJIT_UNORDERED_OR_LESS_EQUAL:
+		return (cc0 | cc1 | cc3);
+
+	case SLJIT_UNORDERED_OR_EQUAL:
+		return (cc0 | cc3);
+
+	case SLJIT_UNORDERED_OR_LESS:
+		return (cc1 | cc3);
 	}
 
 	SLJIT_UNREACHABLE();
 	return (sljit_u8)-1;
 }
 
 /* Facility to bit index mappings.
@@ -974,55 +991,69 @@
 }
 
 #define EVAL(op, r, addr) op(r, addr.offset, addr.index, addr.base)
 #define WHEN(cond, r, i1, i2, addr) \
 	(cond) ? EVAL(i1, r, addr) : EVAL(i2, r, addr)
 
 /* May clobber tmp1. */
-static sljit_s32 load_word(struct sljit_compiler *compiler, sljit_gpr dst,
+static sljit_s32 load_word(struct sljit_compiler *compiler, sljit_gpr dst_r,
 		sljit_s32 src, sljit_sw srcw,
 		sljit_s32 is_32bit)
 {
 	struct addr addr;
 	sljit_ins ins;
 
 	SLJIT_ASSERT(src & SLJIT_MEM);
-	if (have_ldisp() || !is_32bit)
-		FAIL_IF(make_addr_bxy(compiler, &addr, src, srcw, tmp1));
-	else
+
+	if (is_32bit && ((src & OFFS_REG_MASK) || is_u12(srcw) || !is_s20(srcw))) {
 		FAIL_IF(make_addr_bx(compiler, &addr, src, srcw, tmp1));
+		return push_inst(compiler, 0x58000000 /* l */ | R20A(dst_r) | R16A(addr.index) | R12A(addr.base) | (sljit_ins)addr.offset);
+	}
 
-	if (is_32bit)
-		ins = WHEN(is_u12(addr.offset), dst, l, ly, addr);
-	else
-		ins = lg(dst, addr.offset, addr.index, addr.base);
+	FAIL_IF(make_addr_bxy(compiler, &addr, src, srcw, tmp1));
 
-	return push_inst(compiler, ins);
+	ins = is_32bit ? 0xe30000000058 /* ly */ : 0xe30000000004 /* lg */;
+	return push_inst(compiler, ins | R36A(dst_r) | R32A(addr.index) | R28A(addr.base) | disp_s20(addr.offset));
+}
+
+/* May clobber tmp1. */
+static sljit_s32 load_unsigned_word(struct sljit_compiler *compiler, sljit_gpr dst_r,
+		sljit_s32 src, sljit_sw srcw,
+		sljit_s32 is_32bit)
+{
+	struct addr addr;
+	sljit_ins ins;
+
+	SLJIT_ASSERT(src & SLJIT_MEM);
+
+	FAIL_IF(make_addr_bxy(compiler, &addr, src, srcw, tmp1));
+
+	ins = is_32bit ? 0xe30000000016 /* llgf */ : 0xe30000000004 /* lg */;
+	return push_inst(compiler, ins | R36A(dst_r) | R32A(addr.index) | R28A(addr.base) | disp_s20(addr.offset));
 }
 
 /* May clobber tmp1. */
-static sljit_s32 store_word(struct sljit_compiler *compiler, sljit_gpr src,
+static sljit_s32 store_word(struct sljit_compiler *compiler, sljit_gpr src_r,
 		sljit_s32 dst, sljit_sw dstw,
 		sljit_s32 is_32bit)
 {
 	struct addr addr;
 	sljit_ins ins;
 
 	SLJIT_ASSERT(dst & SLJIT_MEM);
-	if (have_ldisp() || !is_32bit)
-		FAIL_IF(make_addr_bxy(compiler, &addr, dst, dstw, tmp1));
-	else
+
+	if (is_32bit && ((dst & OFFS_REG_MASK) || is_u12(dstw) || !is_s20(dstw))) {
 		FAIL_IF(make_addr_bx(compiler, &addr, dst, dstw, tmp1));
+		return push_inst(compiler, 0x50000000 /* st */ | R20A(src_r) | R16A(addr.index) | R12A(addr.base) | (sljit_ins)addr.offset);
+	}
 
-	if (is_32bit)
-		ins = WHEN(is_u12(addr.offset), src, st, sty, addr);
-	else
-		ins = stg(src, addr.offset, addr.index, addr.base);
+	FAIL_IF(make_addr_bxy(compiler, &addr, dst, dstw, tmp1));
 
-	return push_inst(compiler, ins);
+	ins = is_32bit ? 0xe30000000050 /* sty */ : 0xe30000000024 /* stg */;
+	return push_inst(compiler, ins | R36A(src_r) | R32A(addr.index) | R28A(addr.base) | disp_s20(addr.offset));
 }
 
 #undef WHEN
 
 static sljit_s32 emit_move(struct sljit_compiler *compiler,
 	sljit_gpr dst_r,
 	sljit_s32 src, sljit_sw srcw)
@@ -1614,64 +1645,92 @@
 	return code;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_has_cpu_feature(sljit_s32 feature_type)
 {
 	/* TODO(mundaym): implement all */
 	switch (feature_type) {
+	case SLJIT_HAS_FPU:
 	case SLJIT_HAS_CLZ:
-		return have_eimm() ? 1 : 0; /* FLOGR instruction */
+	case SLJIT_HAS_ROT:
+	case SLJIT_HAS_PREFETCH:
+		return 1;
+	case SLJIT_HAS_CTZ:
+		return 2;
 	case SLJIT_HAS_CMOV:
 		return have_lscond1() ? 1 : 0;
-	case SLJIT_HAS_FPU:
-		return 1;
 	}
 	return 0;
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_cmp_info(sljit_s32 type)
+{
+	return (type >= SLJIT_UNORDERED && type <= SLJIT_ORDERED_LESS_EQUAL);
+}
+
 /* --------------------------------------------------------------------- */
 /*  Entry, exit                                                          */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_enter(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
-	sljit_s32 word_arg_count = 0;
+	sljit_s32 saved_arg_count = SLJIT_KEPT_SAVEDS_COUNT(options);
 	sljit_s32 offset, i, tmp;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
 	/* Saved registers are stored in callee allocated save area. */
 	SLJIT_ASSERT(gpr(SLJIT_FIRST_SAVED_REG) == r6 && gpr(SLJIT_S0) == r13);
 
 	offset = 2 * SSIZE_OF(sw);
 	if (saveds + scratches >= SLJIT_NUMBER_OF_REGISTERS) {
-		FAIL_IF(push_inst(compiler, stmg(r6, r14, offset, r15))); /* save registers TODO(MGM): optimize */
-		offset += 9 * SSIZE_OF(sw);
+		if (saved_arg_count == 0) {
+			FAIL_IF(push_inst(compiler, stmg(r6, r14, offset, r15)));
+			offset += 9 * SSIZE_OF(sw);
+		} else {
+			FAIL_IF(push_inst(compiler, stmg(r6, r13 - (sljit_gpr)saved_arg_count, offset, r15)));
+			offset += (8 - saved_arg_count) * SSIZE_OF(sw);
+		}
 	} else {
 		if (scratches == SLJIT_FIRST_SAVED_REG) {
 			FAIL_IF(push_inst(compiler, stg(r6, offset, 0, r15)));
 			offset += SSIZE_OF(sw);
 		} else if (scratches > SLJIT_FIRST_SAVED_REG) {
 			FAIL_IF(push_inst(compiler, stmg(r6, r6 + (sljit_gpr)(scratches - SLJIT_FIRST_SAVED_REG), offset, r15)));
 			offset += (scratches - (SLJIT_FIRST_SAVED_REG - 1)) * SSIZE_OF(sw);
 		}
 
-		if (saveds == 0) {
-			FAIL_IF(push_inst(compiler, stg(r14, offset, 0, r15)));
-			offset += SSIZE_OF(sw);
-		} else {
-			FAIL_IF(push_inst(compiler, stmg(r14 - (sljit_gpr)saveds, r14, offset, r15)));
-			offset += (saveds + 1) * SSIZE_OF(sw);
+		if (saved_arg_count == 0) {
+			if (saveds == 0) {
+				FAIL_IF(push_inst(compiler, stg(r14, offset, 0, r15)));
+				offset += SSIZE_OF(sw);
+			} else {
+				FAIL_IF(push_inst(compiler, stmg(r14 - (sljit_gpr)saveds, r14, offset, r15)));
+				offset += (saveds + 1) * SSIZE_OF(sw);
+			}
+		} else if (saveds > saved_arg_count) {
+			if (saveds == saved_arg_count + 1) {
+				FAIL_IF(push_inst(compiler, stg(r14 - (sljit_gpr)saveds, offset, 0, r15)));
+				offset += SSIZE_OF(sw);
+			} else {
+				FAIL_IF(push_inst(compiler, stmg(r14 - (sljit_gpr)saveds, r13 - (sljit_gpr)saved_arg_count, offset, r15)));
+				offset += (saveds - saved_arg_count) * SSIZE_OF(sw);
+			}
 		}
 	}
 
+	if (saved_arg_count > 0) {
+		FAIL_IF(push_inst(compiler, stg(r14, offset, 0, r15)));
+		offset += SSIZE_OF(sw);
+	}
+
 	tmp = SLJIT_FS0 - fsaveds;
 	for (i = SLJIT_FS0; i > tmp; i--) {
 		FAIL_IF(push_inst(compiler, 0x60000000 /* std */ | F20(i) | R12A(r15) | (sljit_ins)offset));
 		offset += SSIZE_OF(sw);
 	}
 
 	for (i = fscratches; i >= SLJIT_FIRST_SAVED_FLOAT_REG; i--) {
@@ -1680,23 +1739,27 @@
 	}
 
 	local_size = (local_size + SLJIT_S390X_DEFAULT_STACK_FRAME_SIZE + 0xf) & ~0xf;
 	compiler->local_size = local_size;
 
 	FAIL_IF(push_inst(compiler, 0xe30000000071 /* lay */ | R36A(r15) | R28A(r15) | disp_s20(-local_size)));
 
+	if (options & SLJIT_ENTER_REG_ARG)
+		return SLJIT_SUCCESS;
+
 	arg_types >>= SLJIT_ARG_SHIFT;
+	saved_arg_count = 0;
 	tmp = 0;
 	while (arg_types > 0) {
 		if ((arg_types & SLJIT_ARG_MASK) < SLJIT_ARG_TYPE_F64) {
 			if (!(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG)) {
-				FAIL_IF(push_inst(compiler, lgr(gpr(SLJIT_S0 - tmp), gpr(SLJIT_R0 + word_arg_count))));
-				tmp++;
+				FAIL_IF(push_inst(compiler, lgr(gpr(SLJIT_S0 - saved_arg_count), gpr(SLJIT_R0 + tmp))));
+				saved_arg_count++;
 			}
-			word_arg_count++;
+			tmp++;
 		}
 
 		arg_types >>= SLJIT_ARG_SHIFT;
 	}
 
 	return SLJIT_SUCCESS;
 }
@@ -1709,48 +1772,74 @@
 	CHECK(check_sljit_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
 	compiler->local_size = (local_size + SLJIT_S390X_DEFAULT_STACK_FRAME_SIZE + 0xf) & ~0xf;
 	return SLJIT_SUCCESS;
 }
 
-static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler)
+static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler, sljit_gpr last_reg)
 {
 	sljit_s32 offset, i, tmp;
 	sljit_s32 local_size = compiler->local_size;
 	sljit_s32 saveds = compiler->saveds;
 	sljit_s32 scratches = compiler->scratches;
+	sljit_s32 kept_saveds_count = SLJIT_KEPT_SAVEDS_COUNT(compiler->options);
 
 	if (is_u12(local_size))
 		FAIL_IF(push_inst(compiler, 0x41000000 /* ly */ | R20A(r15) | R12A(r15) | (sljit_ins)local_size));
 	else
 		FAIL_IF(push_inst(compiler, 0xe30000000071 /* lay */ | R36A(r15) | R28A(r15) | disp_s20(local_size)));
 
 	offset = 2 * SSIZE_OF(sw);
 	if (saveds + scratches >= SLJIT_NUMBER_OF_REGISTERS) {
-		FAIL_IF(push_inst(compiler, lmg(r6, r14, offset, r15))); /* save registers TODO(MGM): optimize */
-		offset += 9 * SSIZE_OF(sw);
+		if (kept_saveds_count == 0) {
+			FAIL_IF(push_inst(compiler, lmg(r6, last_reg, offset, r15)));
+			offset += 9 * SSIZE_OF(sw);
+		} else {
+			FAIL_IF(push_inst(compiler, lmg(r6, r13 - (sljit_gpr)kept_saveds_count, offset, r15)));
+			offset += (8 - kept_saveds_count) * SSIZE_OF(sw);
+		}
 	} else {
 		if (scratches == SLJIT_FIRST_SAVED_REG) {
 			FAIL_IF(push_inst(compiler, lg(r6, offset, 0, r15)));
 			offset += SSIZE_OF(sw);
 		} else if (scratches > SLJIT_FIRST_SAVED_REG) {
 			FAIL_IF(push_inst(compiler, lmg(r6, r6 + (sljit_gpr)(scratches - SLJIT_FIRST_SAVED_REG), offset, r15)));
 			offset += (scratches - (SLJIT_FIRST_SAVED_REG - 1)) * SSIZE_OF(sw);
 		}
 
-		if (saveds == 0) {
-			FAIL_IF(push_inst(compiler, lg(r14, offset, 0, r15)));
-			offset += SSIZE_OF(sw);
-		} else {
-			FAIL_IF(push_inst(compiler, lmg(r14 - (sljit_gpr)saveds, r14, offset, r15)));
-			offset += (saveds + 1) * SSIZE_OF(sw);
+		if (kept_saveds_count == 0) {
+			if (saveds == 0) {
+				if (last_reg == r14)
+					FAIL_IF(push_inst(compiler, lg(r14, offset, 0, r15)));
+				offset += SSIZE_OF(sw);
+			} else if (saveds == 1 && last_reg == r13) {
+				FAIL_IF(push_inst(compiler, lg(r13, offset, 0, r15)));
+				offset += 2 * SSIZE_OF(sw);
+			} else {
+				FAIL_IF(push_inst(compiler, lmg(r14 - (sljit_gpr)saveds, last_reg, offset, r15)));
+				offset += (saveds + 1) * SSIZE_OF(sw);
+			}
+		} else if (saveds > kept_saveds_count) {
+			if (saveds == kept_saveds_count + 1) {
+				FAIL_IF(push_inst(compiler, lg(r14 - (sljit_gpr)saveds, offset, 0, r15)));
+				offset += SSIZE_OF(sw);
+			} else {
+				FAIL_IF(push_inst(compiler, lmg(r14 - (sljit_gpr)saveds, r13 - (sljit_gpr)kept_saveds_count, offset, r15)));
+				offset += (saveds - kept_saveds_count) * SSIZE_OF(sw);
+			}
 		}
 	}
 
+	if (kept_saveds_count > 0) {
+		if (last_reg == r14)
+			FAIL_IF(push_inst(compiler, lg(r14, offset, 0, r15)));
+		offset += SSIZE_OF(sw);
+	}
+
 	tmp = SLJIT_FS0 - compiler->fsaveds;
 	for (i = SLJIT_FS0; i > tmp; i--) {
 		FAIL_IF(push_inst(compiler, 0x68000000 /* ld */ | F20(i) | R12A(r15) | (sljit_ins)offset));
 		offset += SSIZE_OF(sw);
 	}
 
 	for (i = compiler->fscratches; i >= SLJIT_FIRST_SAVED_FLOAT_REG; i--) {
@@ -1762,18 +1851,41 @@
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_void(struct sljit_compiler *compiler)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_return_void(compiler));
 
-	FAIL_IF(emit_stack_frame_release(compiler));
+	FAIL_IF(emit_stack_frame_release(compiler, r14));
 	return push_inst(compiler, br(r14)); /* return */
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_to(struct sljit_compiler *compiler,
+	sljit_s32 src, sljit_sw srcw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_return_to(compiler, src, srcw));
+
+	if (src & SLJIT_MEM) {
+		ADJUST_LOCAL_OFFSET(src, srcw);
+		FAIL_IF(load_word(compiler, tmp1, src, srcw, 0 /* 64-bit */));
+		src = TMP_REG2;
+		srcw = 0;
+	} else if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
+		FAIL_IF(push_inst(compiler, lgr(tmp1, gpr(src))));
+		src = TMP_REG2;
+		srcw = 0;
+	}
+
+	FAIL_IF(emit_stack_frame_release(compiler, r13));
+
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_ijump(compiler, SLJIT_JUMP, src, srcw);
+}
+
 /* --------------------------------------------------------------------- */
 /*  Operators                                                            */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op0(struct sljit_compiler *compiler, sljit_s32 op)
 {
 	sljit_gpr arg0 = gpr(SLJIT_R0);
@@ -1854,14 +1966,55 @@
 	}
 	/* swap result registers */
 	FAIL_IF(push_inst(compiler, lgr(tmp0, arg0)));
 	FAIL_IF(push_inst(compiler, lgr(arg0, arg1)));
 	return push_inst(compiler, lgr(arg1, tmp0));
 }
 
+static sljit_s32 sljit_emit_clz_ctz(struct sljit_compiler *compiler, sljit_s32 op, sljit_gpr dst_r, sljit_gpr src_r)
+{
+	sljit_s32 is_ctz = (GET_OPCODE(op) == SLJIT_CTZ);
+
+	if ((op & SLJIT_32) && src_r != tmp0) {
+		FAIL_IF(push_inst(compiler, 0xb9160000 /* llgfr */ | R4A(tmp0) | R0A(src_r)));
+		src_r = tmp0;
+	}
+
+	if (is_ctz) {
+		FAIL_IF(push_inst(compiler, ((op & SLJIT_32) ? 0x1300 /* lcr */ : 0xb9030000 /* lcgr */) | R4A(tmp1) | R0A(src_r)));
+
+		if (src_r == tmp0)
+			FAIL_IF(push_inst(compiler, ((op & SLJIT_32) ? 0x1400 /* nr */ : 0xb9800000 /* ngr */) | R4A(tmp0) | R0A(tmp1)));
+		else
+			FAIL_IF(push_inst(compiler, 0xb9e40000 /* ngrk */ | R12A(tmp1) | R4A(tmp0) | R0A(src_r)));
+
+		src_r = tmp0;
+	}
+
+	FAIL_IF(push_inst(compiler, 0xb9830000 /* flogr */ | R4A(tmp0) | R0A(src_r)));
+
+	if (is_ctz)
+		FAIL_IF(push_inst(compiler, 0xec00000000d9 /* aghik */ | R36A(tmp1) | R32A(tmp0) | ((sljit_ins)(-64 & 0xffff) << 16)));
+
+	if (op & SLJIT_32) {
+		if (!is_ctz && dst_r != tmp0)
+			return push_inst(compiler, 0xec00000000d9 /* aghik */ | R36A(dst_r) | R32A(tmp0) | ((sljit_ins)(-32 & 0xffff) << 16));
+
+		FAIL_IF(push_inst(compiler, 0xc20800000000 /* agfi */ | R36A(tmp0) | (sljit_u32)-32));
+	}
+
+	if (is_ctz)
+		FAIL_IF(push_inst(compiler, 0xec0000000057 /* rxsbg */ | R36A(tmp0) | R32A(tmp1) | ((sljit_ins)((op & SLJIT_32) ? 59 : 58) << 24) | (63 << 16) | ((sljit_ins)((op & SLJIT_32) ? 5 : 6) << 8)));
+
+	if (dst_r == tmp0)
+		return SLJIT_SUCCESS;
+
+	return push_inst(compiler, ((op & SLJIT_32) ? 0x1800 /* lr */ : 0xb9040000 /* lgr */) | R4A(dst_r) | R0A(tmp0));
+}
+
 /* LEVAL will be defined later with different parameters as needed */
 #define WHEN2(cond, i1, i2) (cond) ? LEVAL(i1) : LEVAL(i2)
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op1(struct sljit_compiler *compiler, sljit_s32 op,
         sljit_s32 dst, sljit_sw dstw,
         sljit_s32 src, sljit_sw srcw)
 {
@@ -2087,71 +2240,59 @@
 		SLJIT_UNREACHABLE();
 	}
 
 	SLJIT_ASSERT((src & SLJIT_IMM) == 0); /* no immediates */
 
 	dst_r = FAST_IS_REG(dst) ? gpr(REG_MASK & dst) : tmp0;
 	src_r = FAST_IS_REG(src) ? gpr(REG_MASK & src) : tmp0;
-	if (src & SLJIT_MEM)
-		FAIL_IF(load_word(compiler, src_r, src, srcw, src & SLJIT_32));
 
 	compiler->status_flags_state = op & (VARIABLE_FLAG_MASK | SLJIT_SET_Z);
 
 	/* TODO(mundaym): optimize loads and stores */
-	switch (opcode | (op & SLJIT_32)) {
+	switch (opcode) {
 	case SLJIT_NOT:
-		/* emulate ~x with x^-1 */
-		FAIL_IF(push_load_imm_inst(compiler, tmp1, -1));
-		if (src_r != dst_r)
-			FAIL_IF(push_inst(compiler, lgr(dst_r, src_r)));
+		if (src & SLJIT_MEM)
+			FAIL_IF(load_word(compiler, src_r, src, srcw, op & SLJIT_32));
 
-		FAIL_IF(push_inst(compiler, xgr(dst_r, tmp1)));
-		break;
-	case SLJIT_NOT32:
 		/* emulate ~x with x^-1 */
+		if (!(op & SLJIT_32)) {
+			FAIL_IF(push_load_imm_inst(compiler, tmp1, -1));
+			if (src_r != dst_r)
+				FAIL_IF(push_inst(compiler, lgr(dst_r, src_r)));
+
+			FAIL_IF(push_inst(compiler, xgr(dst_r, tmp1)));
+			break;
+		}
+
 		if (have_eimm())
 			FAIL_IF(push_inst(compiler, xilf(dst_r, 0xffffffff)));
 		else {
 			FAIL_IF(push_load_imm_inst(compiler, tmp1, -1));
 			if (src_r != dst_r)
 				FAIL_IF(push_inst(compiler, lr(dst_r, src_r)));
 
 			FAIL_IF(push_inst(compiler, xr(dst_r, tmp1)));
 		}
 		break;
 	case SLJIT_CLZ:
-		if (have_eimm()) {
-			FAIL_IF(push_inst(compiler, flogr(tmp0, src_r))); /* clobbers tmp1 */
-			if (dst_r != tmp0)
-				FAIL_IF(push_inst(compiler, lgr(dst_r, tmp0)));
-		} else {
-			abort(); /* TODO(mundaym): no eimm (?) */
-		}
-		break;
-	case SLJIT_CLZ32:
-		if (have_eimm()) {
-			FAIL_IF(push_inst(compiler, sllg(tmp1, src_r, 32, 0)));
-			FAIL_IF(push_inst(compiler, iilf(tmp1, 0xffffffff)));
-			FAIL_IF(push_inst(compiler, flogr(tmp0, tmp1))); /* clobbers tmp1 */
-			if (dst_r != tmp0)
-				FAIL_IF(push_inst(compiler, lr(dst_r, tmp0)));
-		} else {
-			abort(); /* TODO(mundaym): no eimm (?) */
-		}
+	case SLJIT_CTZ:
+		if (src & SLJIT_MEM)
+			FAIL_IF(load_unsigned_word(compiler, src_r, src, srcw, op & SLJIT_32));
+
+		FAIL_IF(sljit_emit_clz_ctz(compiler, op, dst_r, src_r));
 		break;
 	default:
 		SLJIT_UNREACHABLE();
 	}
 
 	if ((op & (SLJIT_SET_Z | VARIABLE_FLAG_MASK)) == (SLJIT_SET_Z | SLJIT_SET_OVERFLOW))
 		FAIL_IF(update_zero_overflow(compiler, op, dst_r));
 
-	/* TODO(carenas): doesn't need FAIL_IF */
 	if (dst & SLJIT_MEM)
-		FAIL_IF(store_word(compiler, dst_r, dst, dstw, op & SLJIT_32));
+		return store_word(compiler, dst_r, dst, dstw, op & SLJIT_32);
 
 	return SLJIT_SUCCESS;
 }
 
 static SLJIT_INLINE int is_commutative(sljit_s32 op)
 {
 	switch (GET_OPCODE(op)) {
@@ -2162,19 +2303,14 @@
 	case SLJIT_OR:
 	case SLJIT_XOR:
 		return 1;
 	}
 	return 0;
 }
 
-static SLJIT_INLINE int is_shift(sljit_s32 op) {
-	sljit_s32 v = GET_OPCODE(op);
-	return (v == SLJIT_SHL || v == SLJIT_ASHR || v == SLJIT_LSHR) ? 1 : 0;
-}
-
 static const struct ins_forms add_forms = {
 	0x1a00, /* ar */
 	0xb9080000, /* agr */
 	0xb9f80000, /* ark */
 	0xb9e80000, /* agrk */
 	0x5a000000, /* a */
 	0xe3000000005a, /* ay */
@@ -2600,54 +2736,103 @@
 	sljit_gpr dst_r = FAST_IS_REG(dst) ? gpr(dst & REG_MASK) : tmp0;
 	sljit_gpr src_r = tmp0;
 	sljit_gpr base_r = tmp0;
 	sljit_ins imm = 0;
 	sljit_ins ins;
 
 	if (FAST_IS_REG(src1))
-		src_r = gpr(src1 & REG_MASK);
+		src_r = gpr(src1);
 	else
 		FAIL_IF(emit_move(compiler, tmp0, src1, src1w));
 
-	if (src2 & SLJIT_IMM)
+	if (!(src2 & SLJIT_IMM)) {
+		if (FAST_IS_REG(src2))
+			base_r = gpr(src2);
+		else {
+			FAIL_IF(emit_move(compiler, tmp1, src2, src2w));
+			base_r = tmp1;
+		}
+
+		if ((op & SLJIT_32) && (type == SLJIT_MSHL || type == SLJIT_MLSHR || type == SLJIT_MASHR)) {
+			if (base_r != tmp1) {
+				FAIL_IF(push_inst(compiler, 0xec0000000055 /* risbg */ | R36A(tmp1) | R32A(base_r) | (59 << 24) | (1 << 23) | (63 << 16)));
+				base_r = tmp1;
+			} else
+				FAIL_IF(push_inst(compiler, 0xa5070000 /* nill */ | R20A(tmp1) | 0x1f));
+		}
+	} else
 		imm = (sljit_ins)(src2w & ((op & SLJIT_32) ? 0x1f : 0x3f));
-	else if (FAST_IS_REG(src2))
-		base_r = gpr(src2 & REG_MASK);
-	else {
-		FAIL_IF(emit_move(compiler, tmp1, src2, src2w));
-		base_r = tmp1;
-	}
 
 	if ((op & SLJIT_32) && dst_r == src_r) {
-		if (type == SLJIT_SHL)
+		if (type == SLJIT_SHL || type == SLJIT_MSHL)
 			ins = 0x89000000 /* sll */;
-		else if (type == SLJIT_LSHR)
+		else if (type == SLJIT_LSHR || type == SLJIT_MLSHR)
 			ins = 0x88000000 /* srl */;
 		else
 			ins = 0x8a000000 /* sra */;
 
 		FAIL_IF(push_inst(compiler, ins | R20A(dst_r) | R12A(base_r) | imm));
-	}
-	else {
-		if (type == SLJIT_SHL)
+	} else {
+		if (type == SLJIT_SHL || type == SLJIT_MSHL)
 			ins = (op & SLJIT_32) ? 0xeb00000000df /* sllk */ : 0xeb000000000d /* sllg */;
-		else if (type == SLJIT_LSHR)
+		else if (type == SLJIT_LSHR || type == SLJIT_MLSHR)
 			ins = (op & SLJIT_32) ? 0xeb00000000de /* srlk */ : 0xeb000000000c /* srlg */;
 		else
 			ins = (op & SLJIT_32) ? 0xeb00000000dc /* srak */ : 0xeb000000000a /* srag */;
 
 		FAIL_IF(push_inst(compiler, ins | R36A(dst_r) | R32A(src_r) | R28A(base_r) | (imm << 16)));
 	}
 
 	if ((op & SLJIT_SET_Z) && type != SLJIT_ASHR)
 		return push_inst(compiler, (op & SLJIT_32) ? or(dst_r, dst_r) : ogr(dst_r, dst_r));
 
 	return SLJIT_SUCCESS;
 }
 
+static sljit_s32 sljit_emit_rotate(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 dst,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+	sljit_gpr dst_r = FAST_IS_REG(dst) ? gpr(dst & REG_MASK) : tmp0;
+	sljit_gpr src_r = tmp0;
+	sljit_gpr base_r = tmp0;
+	sljit_ins imm = 0;
+	sljit_ins ins;
+
+	if (FAST_IS_REG(src1))
+		src_r = gpr(src1);
+	else
+		FAIL_IF(emit_move(compiler, tmp0, src1, src1w));
+
+	if (!(src2 & SLJIT_IMM)) {
+		if (FAST_IS_REG(src2))
+			base_r = gpr(src2);
+		else {
+			FAIL_IF(emit_move(compiler, tmp1, src2, src2w));
+			base_r = tmp1;
+		}
+	}
+
+	if (GET_OPCODE(op) == SLJIT_ROTR) {
+		if (!(src2 & SLJIT_IMM)) {
+			ins = (op & SLJIT_32) ? 0x1300 /* lcr */ : 0xb9030000 /* lcgr */;
+			FAIL_IF(push_inst(compiler, ins | R4A(tmp1) | R0A(base_r)));
+			base_r = tmp1;
+		} else
+			src2w = -src2w;
+	}
+
+	if (src2 & SLJIT_IMM)
+		imm = (sljit_ins)(src2w & ((op & SLJIT_32) ? 0x1f : 0x3f));
+
+	ins = (op & SLJIT_32) ? 0xeb000000001d /* rll */ : 0xeb000000001c /* rllg */;
+	return push_inst(compiler, ins | R36A(dst_r) | R32A(src_r) | R28A(base_r) | (imm << 16));
+}
+
 static const struct ins_forms addc_forms = {
 	0xb9980000, /* alcr */
 	0xb9880000, /* alcgr */
 	0,
 	0,
 	0,
 	0xe30000000098, /* alc */
@@ -2712,67 +2897,184 @@
 		break;
 	case SLJIT_AND:
 	case SLJIT_OR:
 	case SLJIT_XOR:
 		FAIL_IF(sljit_emit_bitwise(compiler, op, dst, src1, src1w, src2, src2w));
 		break;
 	case SLJIT_SHL:
+	case SLJIT_MSHL:
 	case SLJIT_LSHR:
+	case SLJIT_MLSHR:
 	case SLJIT_ASHR:
+	case SLJIT_MASHR:
 		FAIL_IF(sljit_emit_shift(compiler, op, dst, src1, src1w, src2, src2w));
 		break;
+	case SLJIT_ROTL:
+	case SLJIT_ROTR:
+		FAIL_IF(sljit_emit_rotate(compiler, op, dst, src1, src1w, src2, src2w));
+		break;
 	}
 
 	if (dst & SLJIT_MEM)
 		return store_word(compiler, tmp0, dst, dstw, op & SLJIT_32);
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2u(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op2(compiler, op, 1, 0, 0, src1, src1w, src2, src2w));
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_op2(compiler, op, (sljit_s32)tmp0, 0, src1, src1w, src2, src2w);
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_shift_into(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 src_dst,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+	sljit_s32 is_right;
+	sljit_sw bit_length = (op & SLJIT_32) ? 32 : 64;
+	sljit_gpr src_dst_r = gpr(src_dst);
+	sljit_gpr src1_r = tmp0;
+	sljit_gpr src2_r = tmp1;
+	sljit_ins ins;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_shift_into(compiler, op, src_dst, src1, src1w, src2, src2w));
+
+	is_right = (GET_OPCODE(op) == SLJIT_LSHR || GET_OPCODE(op) == SLJIT_MLSHR);
+
+	if (src_dst == src1) {
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_op2(compiler, (is_right ? SLJIT_ROTR : SLJIT_ROTL) | (op & SLJIT_32), src_dst, 0, src_dst, 0, src2, src2w);
+	}
+
+	ADJUST_LOCAL_OFFSET(src1, src1w);
+	ADJUST_LOCAL_OFFSET(src2, src2w);
+
+	if (src1 & SLJIT_MEM)
+		FAIL_IF(load_word(compiler, tmp0, src1, src1w, op & SLJIT_32));
+	else if (src1 & SLJIT_IMM)
+		FAIL_IF(push_load_imm_inst(compiler, tmp0, src1w));
+	else
+		src1_r = gpr(src1);
+
+	if (src2 & SLJIT_IMM) {
+		src2w &= bit_length - 1;
+
+		if (src2w == 0)
+			return SLJIT_SUCCESS;
+	} else if (!(src2 & SLJIT_MEM))
+		src2_r = gpr(src2);
+	else
+		FAIL_IF(load_word(compiler, tmp1, src2, src2w, op & SLJIT_32));
+
+	if (src2 & SLJIT_IMM) {
+		if (op & SLJIT_32) {
+			ins = is_right ? 0x88000000 /* srl */ : 0x89000000 /* sll */;
+			FAIL_IF(push_inst(compiler, ins | R20A(src_dst_r) | (sljit_ins)src2w));
+		} else {
+			ins = is_right ? 0xeb000000000c /* srlg */ : 0xeb000000000d /* sllg */;
+			FAIL_IF(push_inst(compiler, ins | R36A(src_dst_r) | R32A(src_dst_r) | ((sljit_ins)src2w << 16)));
+		}
+
+		ins = 0xec0000000055 /* risbg */;
+
+		if (is_right) {
+			src2w = bit_length - src2w;
+			ins |= ((sljit_ins)(64 - bit_length) << 24) | ((sljit_ins)(63 - src2w) << 16) | ((sljit_ins)src2w << 8);
+		} else
+			ins |= ((sljit_ins)(64 - src2w) << 24) | ((sljit_ins)63 << 16) | ((sljit_ins)src2w << 8);
+
+		return push_inst(compiler, ins | R36A(src_dst_r) | R32A(src1_r));
+	}
+
+	if (op & SLJIT_32) {
+		if (GET_OPCODE(op) == SLJIT_MSHL || GET_OPCODE(op) == SLJIT_MLSHR) {
+			if (src2_r != tmp1) {
+				FAIL_IF(push_inst(compiler, 0xec0000000055 /* risbg */ | R36A(tmp1) | R32A(src2_r) | (59 << 24) | (1 << 23) | (63 << 16)));
+				src2_r = tmp1;
+			} else
+				FAIL_IF(push_inst(compiler, 0xa5070000 /* nill */ | R20A(tmp1) | 0x1f));
+		}
+
+		ins = is_right ? 0x88000000 /* srl */ : 0x89000000 /* sll */;
+		FAIL_IF(push_inst(compiler, ins | R20A(src_dst_r) | R12A(src2_r)));
+
+		if (src2_r != tmp1) {
+			FAIL_IF(push_inst(compiler, 0xa50f0000 /* llill */ | R20A(tmp1) | 0x1f));
+			FAIL_IF(push_inst(compiler, 0x1700 /* xr */ | R4A(tmp1) | R0A(src2_r)));
+		} else
+			FAIL_IF(push_inst(compiler, 0xc00700000000 /* xilf */ | R36A(tmp1) | 0x1f));
+
+		if (src1_r == tmp0) {
+			ins = is_right ? 0x89000000 /* sll */ : 0x88000000 /* srl */;
+			FAIL_IF(push_inst(compiler, ins | R20A(tmp0) | R12A(tmp1) | 0x1));
+		} else {
+			ins = is_right ? 0xeb00000000df /* sllk */ : 0xeb00000000de /* srlk */;
+			FAIL_IF(push_inst(compiler, ins | R36A(tmp0) | R32A(src1_r) | R28A(tmp1) | (0x1 << 16)));
+		}
+
+		return push_inst(compiler, 0x1600 /* or */ | R4A(src_dst_r) | R0A(tmp0));
+	}
+
+	ins = is_right ? 0xeb000000000c /* srlg */ : 0xeb000000000d /* sllg */;
+	FAIL_IF(push_inst(compiler, ins | R36A(src_dst_r) | R32A(src_dst_r) | R28A(src2_r)));
+
+	ins = is_right ? 0xeb000000000d /* sllg */ : 0xeb000000000c /* srlg */;
+
+	if (!(op & SLJIT_SHIFT_INTO_NON_ZERO)) {
+		if (src2_r != tmp1)
+			FAIL_IF(push_inst(compiler, 0xa50f0000 /* llill */ | R20A(tmp1) | 0x3f));
+
+		FAIL_IF(push_inst(compiler, ins | R36A(tmp0) | R32A(src1_r) | (0x1 << 16)));
+		src1_r = tmp0;
+
+		if (src2_r != tmp1)
+			FAIL_IF(push_inst(compiler, 0xb9820000 /* xgr */ | R4A(tmp1) | R0A(src2_r)));
+		else
+			FAIL_IF(push_inst(compiler, 0xc00700000000 /* xilf */ | R36A(tmp1) | 0x3f));
+	} else
+		FAIL_IF(push_inst(compiler, 0xb9030000 /* lcgr */ | R4A(tmp1) | R0A(src2_r)));
+
+	FAIL_IF(push_inst(compiler, ins | R36A(tmp0) | R32A(src1_r) | R28A(tmp1)));
+	return push_inst(compiler, 0xb9810000 /* ogr */ | R4A(src_dst_r) | R0A(tmp0));
+}
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_src(
 	struct sljit_compiler *compiler,
 	sljit_s32 op, sljit_s32 src, sljit_sw srcw)
 {
 	sljit_gpr src_r;
+	struct addr addr;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_src(compiler, op, src, srcw));
 	ADJUST_LOCAL_OFFSET(src, srcw);
 
 	switch (op) {
 	case SLJIT_FAST_RETURN:
 		src_r = FAST_IS_REG(src) ? gpr(src) : tmp1;
 		if (src & SLJIT_MEM)
 			FAIL_IF(load_word(compiler, tmp1, src, srcw, 0));
 
 		return push_inst(compiler, br(src_r));
 	case SLJIT_SKIP_FRAMES_BEFORE_FAST_RETURN:
-		/* TODO(carenas): implement? */
 		return SLJIT_SUCCESS;
 	case SLJIT_PREFETCH_L1:
 	case SLJIT_PREFETCH_L2:
 	case SLJIT_PREFETCH_L3:
 	case SLJIT_PREFETCH_ONCE:
-		/* TODO(carenas): implement */
-		return SLJIT_SUCCESS;
+		FAIL_IF(make_addr_bxy(compiler, &addr, src, srcw, tmp1));
+		return push_inst(compiler, 0xe31000000036 /* pfd */ | R32A(addr.index) | R28A(addr.base) | disp_s20(addr.offset));
 	default:
-                /* TODO(carenas): probably should not success by default */
 		return SLJIT_SUCCESS;
 	}
 
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_register_index(sljit_s32 reg)
@@ -3060,18 +3362,18 @@
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_fast_enter(compiler, dst, dstw));
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 
 	if (FAST_IS_REG(dst))
-		return push_inst(compiler, lgr(gpr(dst), fast_link_r));
+		return push_inst(compiler, lgr(gpr(dst), link_r));
 
 	/* memory */
-	return store_word(compiler, fast_link_r, dst, dstw, 0);
+	return store_word(compiler, link_r, dst, dstw, 0);
 }
 
 /* --------------------------------------------------------------------- */
 /*  Conditional instructions                                             */
 /* --------------------------------------------------------------------- */
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_label* sljit_emit_label(struct sljit_compiler *compiler)
@@ -3103,37 +3405,34 @@
 	PTR_FAIL_IF(!jump);
 	set_jump(jump, compiler, type & SLJIT_REWRITABLE_JUMP);
 	jump->addr = compiler->size;
 
 	/* emit jump instruction */
 	type &= 0xff;
 	if (type >= SLJIT_FAST_CALL)
-		PTR_FAIL_IF(push_inst(compiler, brasl(type == SLJIT_FAST_CALL ? fast_link_r : link_r, 0)));
+		PTR_FAIL_IF(push_inst(compiler, brasl(link_r, 0)));
 	else
 		PTR_FAIL_IF(push_inst(compiler, brcl(mask, 0)));
 
 	return jump;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 arg_types)
 {
+	SLJIT_UNUSED_ARG(arg_types);
 	CHECK_ERROR_PTR();
 	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
 
 	if (type & SLJIT_CALL_RETURN) {
-		PTR_FAIL_IF(emit_stack_frame_release(compiler));
+		PTR_FAIL_IF(emit_stack_frame_release(compiler, r14));
 		type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
 	}
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
-
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_jump(compiler, type);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_ijump(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 src, sljit_sw srcw)
 {
 	sljit_gpr src_r = FAST_IS_REG(src) ? gpr(src) : tmp1;
 
@@ -3147,15 +3446,15 @@
 	else if (src & SLJIT_MEM) {
 		ADJUST_LOCAL_OFFSET(src, srcw);
 		FAIL_IF(load_word(compiler, src_r, src, srcw, 0 /* 64-bit */));
 	}
 
 	/* emit jump instruction */
 	if (type >= SLJIT_FAST_CALL)
-		return push_inst(compiler, basr(type == SLJIT_FAST_CALL ? fast_link_r : link_r, src_r));
+		return push_inst(compiler, basr(link_r, src_r));
 
 	return push_inst(compiler, br(src_r));
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_icall(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 arg_types,
 	sljit_s32 src, sljit_sw srcw)
@@ -3165,39 +3464,37 @@
 
 	SLJIT_ASSERT(gpr(TMP_REG2) == tmp1);
 
 	if (src & SLJIT_MEM) {
 		ADJUST_LOCAL_OFFSET(src, srcw);
 		FAIL_IF(load_word(compiler, tmp1, src, srcw, 0 /* 64-bit */));
 		src = TMP_REG2;
+		srcw = 0;
 	}
 
 	if (type & SLJIT_CALL_RETURN) {
-		if (src >= SLJIT_FIRST_SAVED_REG && src <= SLJIT_S0) {
+		if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
 			FAIL_IF(push_inst(compiler, lgr(tmp1, gpr(src))));
 			src = TMP_REG2;
+			srcw = 0;
 		}
 
-		FAIL_IF(emit_stack_frame_release(compiler));
+		FAIL_IF(emit_stack_frame_release(compiler, r14));
 		type = SLJIT_JUMP;
 	}
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
-
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_ijump(compiler, type, src, srcw);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_flags(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 type)
 {
-	sljit_u8 mask = get_cc(compiler, type & 0xff);
+	sljit_u8 mask = get_cc(compiler, type);
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_flags(compiler, op, dst, dstw, type));
 
 	sljit_gpr dst_r = FAST_IS_REG(dst) ? gpr(dst & REG_MASK) : tmp0;
 	sljit_gpr loc_r = tmp1;
 	switch (GET_OPCODE(op)) {
@@ -3259,35 +3556,100 @@
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_cmov(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 dst_reg,
 	sljit_s32 src, sljit_sw srcw)
 {
-	sljit_u8 mask = get_cc(compiler, type & 0xff);
-	sljit_gpr dst_r = gpr(dst_reg & ~SLJIT_32);
-	sljit_gpr src_r = FAST_IS_REG(src) ? gpr(src) : tmp0;
+	sljit_ins mask = get_cc(compiler, type & ~SLJIT_32);
+	sljit_gpr src_r;
+	sljit_ins ins;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_cmov(compiler, type, dst_reg, src, srcw));
 
+	if (type & SLJIT_32)
+		srcw = (sljit_s32)srcw;
+
+	if (have_lscond2() && (src & SLJIT_IMM) && is_s16(srcw)) {
+		ins = (type & SLJIT_32) ? 0xec0000000042 /* lochi */ : 0xec0000000046 /* locghi */;
+		return push_inst(compiler, ins | R36A(gpr(dst_reg)) | (mask << 32) | (sljit_ins)(srcw & 0xffff) << 16);
+	}
+
 	if (src & SLJIT_IMM) {
-		/* TODO(mundaym): fast path with lscond2 */
-		FAIL_IF(push_load_imm_inst(compiler, src_r, srcw));
+		FAIL_IF(push_load_imm_inst(compiler, tmp0, srcw));
+		src_r = tmp0;
+	} else
+		src_r = gpr(src);
+
+	if (have_lscond1()) {
+		ins = (type & SLJIT_32) ? 0xb9f20000 /* locr */ : 0xb9e20000 /* locgr */;
+		return push_inst(compiler, ins | (mask << 12) | R4A(gpr(dst_reg)) | R0A(src_r));
 	}
 
-	#define LEVAL(i) i(dst_r, src_r, mask)
-	if (have_lscond1())
-		return push_inst(compiler,
-			WHEN2(dst_reg & SLJIT_32, locr, locgr));
+	return sljit_emit_cmov_generic(compiler, type, dst_reg, src, srcw);
+}
 
-	#undef LEVAL
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	sljit_ins ins, reg1, reg2, base, offs = 0;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_mem(compiler, type, reg, mem, memw));
+
+	if (!(reg & REG_PAIR_MASK))
+		return sljit_emit_mem_unaligned(compiler, type, reg, mem, memw);
+
+	ADJUST_LOCAL_OFFSET(mem, memw);
+
+	base = gpr(mem & REG_MASK);
+	reg1 = gpr(REG_PAIR_FIRST(reg));
+	reg2 = gpr(REG_PAIR_SECOND(reg));
+
+	if (mem & OFFS_REG_MASK) {
+		memw &= 0x3;
+		offs = gpr(OFFS_REG(mem));
+
+		if (memw != 0) {
+			FAIL_IF(push_inst(compiler, 0xeb000000000d /* sllg */ | R36A(tmp1) | R32A(offs) | ((sljit_ins)memw << 16)));
+			offs = tmp1;
+		} else if (!(type & SLJIT_MEM_STORE) && (base == reg1 || base == reg2) && (offs == reg1 || offs == reg2)) {
+			FAIL_IF(push_inst(compiler, 0xb9f80000 | R12A(tmp1) | R4A(base) | R0A(offs)));
+			base = tmp1;
+			offs = 0;
+		}
+
+		memw = 0;
+	} else if (memw < -0x80000 || memw > 0x7ffff - ((reg2 == reg1 + 1) ? 0 : SSIZE_OF(sw))) {
+		FAIL_IF(push_load_imm_inst(compiler, tmp1, memw));
+
+		if (base == 0)
+			base = tmp1;
+		else
+			offs = tmp1;
+
+		memw = 0;
+	}
+
+	if (offs == 0 && reg2 == (reg1 + 1)) {
+		ins = (type & SLJIT_MEM_STORE) ? 0xeb0000000024 /* stmg */ : 0xeb0000000004 /* lmg */;
+		return push_inst(compiler, ins | R36A(reg1) | R32A(reg2) | R28A(base) | disp_s20((sljit_s32)memw));
+	}
+
+	ins = ((type & SLJIT_MEM_STORE) ? 0xe30000000024 /* stg */ : 0xe30000000004 /* lg */) | R32A(offs) | R28A(base);
+
+	if (!(type & SLJIT_MEM_STORE) && base == reg1) {
+		FAIL_IF(push_inst(compiler, ins | R36A(reg2) | disp_s20((sljit_s32)memw + SSIZE_OF(sw))));
+		return push_inst(compiler, ins | R36A(reg1) | disp_s20((sljit_s32)memw));
+	}
 
-	/* TODO(mundaym): implement */
-	return SLJIT_ERR_UNSUPPORTED;
+	FAIL_IF(push_inst(compiler, ins | R36A(reg1) | disp_s20((sljit_s32)memw)));
+	return push_inst(compiler, ins | R36A(reg2) | disp_s20((sljit_s32)memw + SSIZE_OF(sw)));
 }
 
 /* --------------------------------------------------------------------- */
 /*  Other instructions                                                   */
 /* --------------------------------------------------------------------- */
 
 /* On s390x we build a literal pool to hold constants. This has two main
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeSPARC_32.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeMIPS_64.c`

 * *Files 22% similar despite different names*

```diff
@@ -20,264 +20,300 @@
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-static sljit_s32 load_immediate(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw imm)
+/* mips 64-bit arch dependent functions. */
+
+static sljit_s32 load_immediate(struct sljit_compiler *compiler, sljit_s32 dst_ar, sljit_sw imm)
 {
-	if (imm <= SIMM_MAX && imm >= SIMM_MIN)
-		return push_inst(compiler, OR | D(dst) | S1(0) | IMM(imm), DR(dst));
+	sljit_s32 shift = 32;
+	sljit_s32 shift2;
+	sljit_s32 inv = 0;
+	sljit_ins ins;
+	sljit_uw uimm;
+
+	if (!(imm & ~0xffff))
+		return push_inst(compiler, ORI | SA(0) | TA(dst_ar) | IMM(imm), dst_ar);
+
+	if (imm < 0 && imm >= SIMM_MIN)
+		return push_inst(compiler, ADDIU | SA(0) | TA(dst_ar) | IMM(imm), dst_ar);
+
+	if (imm <= 0x7fffffffl && imm >= -0x80000000l) {
+		FAIL_IF(push_inst(compiler, LUI | TA(dst_ar) | IMM(imm >> 16), dst_ar));
+		return (imm & 0xffff) ? push_inst(compiler, ORI | SA(dst_ar) | TA(dst_ar) | IMM(imm), dst_ar) : SLJIT_SUCCESS;
+	}
 
-	FAIL_IF(push_inst(compiler, SETHI | D(dst) | ((imm >> 10) & 0x3fffff), DR(dst)));
-	return (imm & 0x3ff) ? push_inst(compiler, OR | D(dst) | S1(dst) | IMM_ARG | (imm & 0x3ff), DR(dst)) : SLJIT_SUCCESS;
-}
+	/* Zero extended number. */
+	uimm = (sljit_uw)imm;
+	if (imm < 0) {
+		uimm = ~(sljit_uw)imm;
+		inv = 1;
+	}
 
-#define ARG2(flags, src2) ((flags & SRC2_IMM) ? IMM(src2) : S2(src2))
+	while (!(uimm & 0xff00000000000000l)) {
+		shift -= 8;
+		uimm <<= 8;
+	}
 
-static SLJIT_INLINE sljit_s32 emit_single_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_u32 flags,
-	sljit_s32 dst, sljit_s32 src1, sljit_sw src2)
-{
-	SLJIT_COMPILE_ASSERT(ICC_IS_SET == SET_FLAGS, icc_is_set_and_set_flags_must_be_the_same);
+	if (!(uimm & 0xf000000000000000l)) {
+		shift -= 4;
+		uimm <<= 4;
+	}
 
-	switch (op) {
-	case SLJIT_MOV:
-		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
-		if (dst != src2)
-			return push_inst(compiler, OR | D(dst) | S1(0) | S2(src2), DR(dst));
-		return SLJIT_SUCCESS;
-
-	case SLJIT_MOV_U8:
-	case SLJIT_MOV_S8:
-		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
-		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
-			if (op == SLJIT_MOV_U8)
-				return push_inst(compiler, AND | D(dst) | S1(src2) | IMM(0xff), DR(dst));
-			FAIL_IF(push_inst(compiler, SLL | D(dst) | S1(src2) | IMM(24), DR(dst)));
-			return push_inst(compiler, SRA | D(dst) | S1(dst) | IMM(24), DR(dst));
-		}
-		SLJIT_ASSERT(dst == src2);
-		return SLJIT_SUCCESS;
+	if (!(uimm & 0xc000000000000000l)) {
+		shift -= 2;
+		uimm <<= 2;
+	}
 
-	case SLJIT_MOV_U16:
-	case SLJIT_MOV_S16:
-		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
-		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
-			FAIL_IF(push_inst(compiler, SLL | D(dst) | S1(src2) | IMM(16), DR(dst)));
-			return push_inst(compiler, (op == SLJIT_MOV_S16 ? SRA : SRL) | D(dst) | S1(dst) | IMM(16), DR(dst));
-		}
-		SLJIT_ASSERT(dst == src2);
-		return SLJIT_SUCCESS;
+	if ((sljit_sw)uimm < 0) {
+		uimm >>= 1;
+		shift += 1;
+	}
+	SLJIT_ASSERT(((uimm & 0xc000000000000000l) == 0x4000000000000000l) && (shift > 0) && (shift <= 32));
+
+	if (inv)
+		uimm = ~uimm;
 
-	case SLJIT_NOT:
-		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
-		return push_inst(compiler, XNOR | (flags & SET_FLAGS) | D(dst) | S1(0) | S2(src2), DRF(dst, flags));
-
-	case SLJIT_CLZ:
-		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
-		FAIL_IF(push_inst(compiler, SUB | SET_FLAGS | D(0) | S1(src2) | S2(0), SET_FLAGS));
-		FAIL_IF(push_inst(compiler, OR | D(TMP_REG1) | S1(0) | S2(src2), DR(TMP_REG1)));
-		FAIL_IF(push_inst(compiler, BICC | DA(0x1) | (7 & DISP_MASK), UNMOVABLE_INS));
-		FAIL_IF(push_inst(compiler, OR | D(dst) | S1(0) | IMM(32), UNMOVABLE_INS));
-		FAIL_IF(push_inst(compiler, OR | D(dst) | S1(0) | IMM(-1), DR(dst)));
-
-		/* Loop. */
-		FAIL_IF(push_inst(compiler, SUB | SET_FLAGS | D(0) | S1(TMP_REG1) | S2(0), SET_FLAGS));
-		FAIL_IF(push_inst(compiler, SLL | D(TMP_REG1) | S1(TMP_REG1) | IMM(1), DR(TMP_REG1)));
-		FAIL_IF(push_inst(compiler, BICC | DA(0xe) | ((sljit_ins)-2 & DISP_MASK), UNMOVABLE_INS));
-		return push_inst(compiler, ADD | D(dst) | S1(dst) | IMM(1), UNMOVABLE_INS);
-
-	case SLJIT_ADD:
-		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_ADD;
-		return push_inst(compiler, ADD | (flags & SET_FLAGS) | D(dst) | S1(src1) | ARG2(flags, src2), DRF(dst, flags));
-
-	case SLJIT_ADDC:
-		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_ADD;
-		return push_inst(compiler, ADDC | (flags & SET_FLAGS) | D(dst) | S1(src1) | ARG2(flags, src2), DRF(dst, flags));
-
-	case SLJIT_SUB:
-		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_SUB;
-		return push_inst(compiler, SUB | (flags & SET_FLAGS) | D(dst) | S1(src1) | ARG2(flags, src2), DRF(dst, flags));
-
-	case SLJIT_SUBC:
-		compiler->status_flags_state = SLJIT_CURRENT_FLAGS_SUB;
-		return push_inst(compiler, SUBC | (flags & SET_FLAGS) | D(dst) | S1(src1) | ARG2(flags, src2), DRF(dst, flags));
-
-	case SLJIT_MUL:
-		compiler->status_flags_state = 0;
-		FAIL_IF(push_inst(compiler, SMUL | D(dst) | S1(src1) | ARG2(flags, src2), DR(dst)));
-		if (!(flags & SET_FLAGS))
-			return SLJIT_SUCCESS;
-		FAIL_IF(push_inst(compiler, SRA | D(TMP_REG1) | S1(dst) | IMM(31), DR(TMP_REG1)));
-		FAIL_IF(push_inst(compiler, RDY | D(TMP_LINK), DR(TMP_LINK)));
-		return push_inst(compiler, SUB | SET_FLAGS | D(0) | S1(TMP_REG1) | S2(TMP_LINK), MOVABLE_INS | SET_FLAGS);
-
-	case SLJIT_AND:
-		return push_inst(compiler, AND | (flags & SET_FLAGS) | D(dst) | S1(src1) | ARG2(flags, src2), DRF(dst, flags));
-
-	case SLJIT_OR:
-		return push_inst(compiler, OR | (flags & SET_FLAGS) | D(dst) | S1(src1) | ARG2(flags, src2), DRF(dst, flags));
-
-	case SLJIT_XOR:
-		return push_inst(compiler, XOR | (flags & SET_FLAGS) | D(dst) | S1(src1) | ARG2(flags, src2), DRF(dst, flags));
-
-	case SLJIT_SHL:
-		FAIL_IF(push_inst(compiler, SLL | D(dst) | S1(src1) | ARG2(flags, src2), DR(dst)));
-		return !(flags & SET_FLAGS) ? SLJIT_SUCCESS : push_inst(compiler, SUB | SET_FLAGS | D(0) | S1(dst) | S2(0), SET_FLAGS);
-
-	case SLJIT_LSHR:
-		FAIL_IF(push_inst(compiler, SRL | D(dst) | S1(src1) | ARG2(flags, src2), DR(dst)));
-		return !(flags & SET_FLAGS) ? SLJIT_SUCCESS : push_inst(compiler, SUB | SET_FLAGS | D(0) | S1(dst) | S2(0), SET_FLAGS);
-
-	case SLJIT_ASHR:
-		FAIL_IF(push_inst(compiler, SRA | D(dst) | S1(src1) | ARG2(flags, src2), DR(dst)));
-		return !(flags & SET_FLAGS) ? SLJIT_SUCCESS : push_inst(compiler, SUB | SET_FLAGS | D(0) | S1(dst) | S2(0), SET_FLAGS);
+	FAIL_IF(push_inst(compiler, LUI | TA(dst_ar) | IMM(uimm >> 48), dst_ar));
+	if (uimm & 0x0000ffff00000000l)
+		FAIL_IF(push_inst(compiler, ORI | SA(dst_ar) | TA(dst_ar) | IMM(uimm >> 32), dst_ar));
+
+	imm &= (1l << shift) - 1;
+	if (!(imm & ~0xffff)) {
+		ins = (shift == 32) ? DSLL32 : DSLL;
+		if (shift < 32)
+			ins |= SH_IMM(shift);
+		FAIL_IF(push_inst(compiler, ins | TA(dst_ar) | DA(dst_ar), dst_ar));
+		return !(imm & 0xffff) ? SLJIT_SUCCESS : push_inst(compiler, ORI | SA(dst_ar) | TA(dst_ar) | IMM(imm), dst_ar);
 	}
 
-	SLJIT_UNREACHABLE();
-	return SLJIT_SUCCESS;
+	/* Double shifts needs to be performed. */
+	uimm <<= 32;
+	shift2 = shift - 16;
+
+	while (!(uimm & 0xf000000000000000l)) {
+		shift2 -= 4;
+		uimm <<= 4;
+	}
+
+	if (!(uimm & 0xc000000000000000l)) {
+		shift2 -= 2;
+		uimm <<= 2;
+	}
+
+	if (!(uimm & 0x8000000000000000l)) {
+		shift2--;
+		uimm <<= 1;
+	}
+
+	SLJIT_ASSERT((uimm & 0x8000000000000000l) && (shift2 > 0) && (shift2 <= 16));
+
+	FAIL_IF(push_inst(compiler, DSLL | TA(dst_ar) | DA(dst_ar) | SH_IMM(shift - shift2), dst_ar));
+	FAIL_IF(push_inst(compiler, ORI | SA(dst_ar) | TA(dst_ar) | IMM(uimm >> 48), dst_ar));
+	FAIL_IF(push_inst(compiler, DSLL | TA(dst_ar) | DA(dst_ar) | SH_IMM(shift2), dst_ar));
+
+	imm &= (1l << shift2) - 1;
+	return !(imm & 0xffff) ? SLJIT_SUCCESS : push_inst(compiler, ORI | SA(dst_ar) | TA(dst_ar) | IMM(imm), dst_ar);
 }
 
-static sljit_s32 call_with_args(struct sljit_compiler *compiler, sljit_s32 arg_types, sljit_s32 *src)
+static SLJIT_INLINE sljit_s32 emit_const(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw init_value)
 {
-	sljit_s32 reg_index = 8;
-	sljit_s32 word_reg_index = 8;
-	sljit_s32 float_arg_index = 1;
-	sljit_s32 double_arg_count = 0;
-	sljit_u32 float_offset = (16 + 6) * sizeof(sljit_sw);
-	sljit_s32 types = 0;
-	sljit_s32 reg = 0;
-	sljit_s32 move_to_tmp2 = 0;
-
-	if (src)
-		reg = reg_map[*src & REG_MASK];
+	FAIL_IF(push_inst(compiler, LUI | T(dst) | IMM(init_value >> 48), DR(dst)));
+	FAIL_IF(push_inst(compiler, ORI | S(dst) | T(dst) | IMM(init_value >> 32), DR(dst)));
+	FAIL_IF(push_inst(compiler, DSLL | T(dst) | D(dst) | SH_IMM(16), DR(dst)));
+	FAIL_IF(push_inst(compiler, ORI | S(dst) | T(dst) | IMM(init_value >> 16), DR(dst)));
+	FAIL_IF(push_inst(compiler, DSLL | T(dst) | D(dst) | SH_IMM(16), DR(dst)));
+	return push_inst(compiler, ORI | S(dst) | T(dst) | IMM(init_value), DR(dst));
+}
 
-	arg_types >>= SLJIT_ARG_SHIFT;
+SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
+{
+	sljit_ins *inst = (sljit_ins *)addr;
+	SLJIT_UNUSED_ARG(executable_offset);
 
-	while (arg_types) {
-		types = (types << SLJIT_ARG_SHIFT) | (arg_types & SLJIT_ARG_MASK);
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 6, 0);
+	inst[0] = (inst[0] & 0xffff0000) | ((sljit_ins)(new_target >> 48) & 0xffff);
+	inst[1] = (inst[1] & 0xffff0000) | ((sljit_ins)(new_target >> 32) & 0xffff);
+	inst[3] = (inst[3] & 0xffff0000) | ((sljit_ins)(new_target >> 16) & 0xffff);
+	inst[5] = (inst[5] & 0xffff0000) | ((sljit_ins)new_target & 0xffff);
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 6, 1);
+	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
+	SLJIT_CACHE_FLUSH(inst, inst + 6);
+}
 
-		switch (arg_types & SLJIT_ARG_MASK) {
-		case SLJIT_ARG_TYPE_F64:
-			float_arg_index++;
-			double_arg_count++;
-			if (reg_index == reg || reg_index + 1 == reg)
-				move_to_tmp2 = 1;
-			reg_index += 2;
-			break;
-		case SLJIT_ARG_TYPE_F32:
-			float_arg_index++;
-			if (reg_index == reg)
-				move_to_tmp2 = 1;
-			reg_index++;
-			break;
-		default:
-			if (reg_index != word_reg_index && reg_index == reg)
-				move_to_tmp2 = 1;
-			reg_index++;
-			word_reg_index++;
-			break;
-		}
+SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
+{
+	sljit_set_jump_addr(addr, (sljit_uw)new_constant, executable_offset);
+}
 
-		arg_types >>= SLJIT_ARG_SHIFT;
-	}
+static sljit_s32 call_with_args(struct sljit_compiler *compiler, sljit_s32 arg_types, sljit_ins *ins_ptr)
+{
+	sljit_s32 arg_count = 0;
+	sljit_s32 word_arg_count = 0;
+	sljit_s32 float_arg_count = 0;
+	sljit_s32 types = 0;
+	sljit_ins prev_ins = *ins_ptr;
+	sljit_ins ins = NOP;
 
-	if (move_to_tmp2) {
-		if (reg < 14)
-			FAIL_IF(push_inst(compiler, OR | D(TMP_REG1) | S1(0) | S2A(reg), DR(TMP_REG1)));
-		*src = TMP_REG1;
-	}
+	SLJIT_ASSERT(reg_map[TMP_REG1] == 4 && freg_map[TMP_FREG1] == 12);
 
-	arg_types = types;
+	arg_types >>= SLJIT_ARG_SHIFT;
 
 	while (arg_types) {
+		types = (types << SLJIT_ARG_SHIFT) | (arg_types & SLJIT_ARG_MASK);
+
 		switch (arg_types & SLJIT_ARG_MASK) {
 		case SLJIT_ARG_TYPE_F64:
-			float_arg_index--;
-			if (float_arg_index == 4 && double_arg_count == 4) {
-				/* The address is not doubleword aligned, so two instructions are required to store the double. */
-				FAIL_IF(push_inst(compiler, STF | FD(float_arg_index) | S1(SLJIT_SP) | IMM((16 + 7) * sizeof(sljit_sw)), MOVABLE_INS));
-				FAIL_IF(push_inst(compiler, STF | FD(float_arg_index) | (1 << 25) | S1(SLJIT_SP) | IMM((16 + 8) * sizeof(sljit_sw)), MOVABLE_INS));
-			}
-			else
-				FAIL_IF(push_inst(compiler, STDF | FD(float_arg_index) | S1(SLJIT_SP) | IMM(float_offset), MOVABLE_INS));
-			float_offset -= sizeof(sljit_f64);
-			break;
 		case SLJIT_ARG_TYPE_F32:
-			float_arg_index--;
-			FAIL_IF(push_inst(compiler, STF | FD(float_arg_index) | S1(SLJIT_SP) | IMM(float_offset), MOVABLE_INS));
-			float_offset -= sizeof(sljit_f64);
+			arg_count++;
+			float_arg_count++;
 			break;
 		default:
+			arg_count++;
+			word_arg_count++;
 			break;
 		}
 
 		arg_types >>= SLJIT_ARG_SHIFT;
 	}
 
-	float_offset = (16 + 6) * sizeof(sljit_sw);
-
 	while (types) {
 		switch (types & SLJIT_ARG_MASK) {
 		case SLJIT_ARG_TYPE_F64:
-			reg_index -= 2;
-			if (reg_index < 14) {
-				if ((reg_index & 0x1) != 0) {
-					FAIL_IF(push_inst(compiler, LDUW | DA(reg_index) | S1(SLJIT_SP) | IMM(float_offset), reg_index));
-					if (reg_index < 8 + 6 - 1)
-						FAIL_IF(push_inst(compiler, LDUW | DA(reg_index + 1) | S1(SLJIT_SP) | IMM(float_offset + sizeof(sljit_sw)), reg_index + 1));
-				}
-				else
-					FAIL_IF(push_inst(compiler, LDD | DA(reg_index) | S1(SLJIT_SP) | IMM(float_offset), reg_index));
-			}
-			float_offset -= sizeof(sljit_f64);
+			if (arg_count != float_arg_count)
+				ins = MOV_S | FMT_D | FS(float_arg_count) | FD(arg_count);
+			else if (arg_count == 1)
+				ins = MOV_S | FMT_D | FS(SLJIT_FR0) | FD(TMP_FREG1);
+			arg_count--;
+			float_arg_count--;
 			break;
 		case SLJIT_ARG_TYPE_F32:
-			reg_index--;
-			if (reg_index < 8 + 6)
-				FAIL_IF(push_inst(compiler, LDUW | DA(reg_index) | S1(SLJIT_SP) | IMM(float_offset), reg_index));
-			float_offset -= sizeof(sljit_f64);
+			if (arg_count != float_arg_count)
+				ins = MOV_S | FMT_S | FS(float_arg_count) | FD(arg_count);
+			else if (arg_count == 1)
+				ins = MOV_S | FMT_S | FS(SLJIT_FR0) | FD(TMP_FREG1);
+			arg_count--;
+			float_arg_count--;
 			break;
 		default:
-			reg_index--;
-			word_reg_index--;
-
-			if (reg_index != word_reg_index) {
-				if (reg_index < 14)
-					FAIL_IF(push_inst(compiler, OR | DA(reg_index) | S1(0) | S2A(word_reg_index), reg_index));
-				else
-					FAIL_IF(push_inst(compiler, STW | DA(word_reg_index) | S1(SLJIT_SP) | IMM(92), word_reg_index));
-			}
+			if (arg_count != word_arg_count)
+				ins = DADDU | S(word_arg_count) | TA(0) | D(arg_count);
+			else if (arg_count == 1)
+				ins = DADDU | S(SLJIT_R0) | TA(0) | DA(4);
+			arg_count--;
+			word_arg_count--;
 			break;
 		}
 
+		if (ins != NOP) {
+			if (prev_ins != NOP)
+				FAIL_IF(push_inst(compiler, prev_ins, MOVABLE_INS));
+			prev_ins = ins;
+			ins = NOP;
+		}
+
 		types >>= SLJIT_ARG_SHIFT;
 	}
 
+	*ins_ptr = prev_ins;
+
 	return SLJIT_SUCCESS;
 }
 
-static SLJIT_INLINE sljit_s32 emit_const(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw init_value)
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 arg_types)
 {
-	FAIL_IF(push_inst(compiler, SETHI | D(dst) | ((init_value >> 10) & 0x3fffff), DR(dst)));
-	return push_inst(compiler, OR | D(dst) | S1(dst) | IMM_ARG | (init_value & 0x3ff), DR(dst));
-}
+	struct sljit_jump *jump;
+	sljit_ins ins = NOP;
 
-SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
-{
-	sljit_ins *inst = (sljit_ins *)addr;
-	SLJIT_UNUSED_ARG(executable_offset);
+	CHECK_ERROR_PTR();
+	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
 
-	SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 0);
-	SLJIT_ASSERT(((inst[0] & 0xc1c00000) == 0x01000000) && ((inst[1] & 0xc1f82000) == 0x80102000));
-	inst[0] = (inst[0] & 0xffc00000) | ((new_target >> 10) & 0x3fffff);
-	inst[1] = (inst[1] & 0xfffffc00) | (new_target & 0x3ff);
-	SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 1);
-	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
-	SLJIT_CACHE_FLUSH(inst, inst + 2);
+	jump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));
+	PTR_FAIL_IF(!jump);
+	set_jump(jump, compiler, type & SLJIT_REWRITABLE_JUMP);
+
+	if (type & SLJIT_CALL_RETURN)
+		PTR_FAIL_IF(emit_stack_frame_release(compiler, 0, &ins));
+
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG)
+		PTR_FAIL_IF(call_with_args(compiler, arg_types, &ins));
+
+	SLJIT_ASSERT(DR(PIC_ADDR_REG) == 25 && PIC_ADDR_REG == TMP_REG2);
+
+	if (ins == NOP && compiler->delay_slot != UNMOVABLE_INS)
+		jump->flags |= IS_MOVABLE;
+
+	if (!(type & SLJIT_CALL_RETURN)) {
+		jump->flags |= IS_JAL;
+
+		if ((type & 0xff) != SLJIT_CALL_REG_ARG)
+			jump->flags |= IS_CALL;
+
+		PTR_FAIL_IF(push_inst(compiler, JALR | S(PIC_ADDR_REG) | DA(RETURN_ADDR_REG), UNMOVABLE_INS));
+	} else
+		PTR_FAIL_IF(push_inst(compiler, JR | S(PIC_ADDR_REG), UNMOVABLE_INS));
+
+	jump->addr = compiler->size;
+	PTR_FAIL_IF(push_inst(compiler, ins, UNMOVABLE_INS));
+
+	/* Maximum number of instructions required for generating a constant. */
+	compiler->size += 6;
+	return jump;
 }
 
-SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_icall(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 arg_types,
+	sljit_s32 src, sljit_sw srcw)
 {
-	sljit_set_jump_addr(addr, (sljit_uw)new_constant, executable_offset);
+	sljit_ins ins = NOP;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_icall(compiler, type, arg_types, src, srcw));
+
+	if (src & SLJIT_MEM) {
+		ADJUST_LOCAL_OFFSET(src, srcw);
+		FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, DR(PIC_ADDR_REG), src, srcw));
+		src = PIC_ADDR_REG;
+		srcw = 0;
+	}
+
+	if ((type & 0xff) == SLJIT_CALL_REG_ARG) {
+		if (type & SLJIT_CALL_RETURN) {
+			if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
+				FAIL_IF(push_inst(compiler, DADDU | S(src) | TA(0) | D(PIC_ADDR_REG), DR(PIC_ADDR_REG)));
+				src = PIC_ADDR_REG;
+				srcw = 0;
+			}
+
+			FAIL_IF(emit_stack_frame_release(compiler, 0, &ins));
+
+			if (ins != NOP)
+				FAIL_IF(push_inst(compiler, ins, MOVABLE_INS));
+		}
+
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_ijump(compiler, type, src, srcw);
+	}
+
+	SLJIT_ASSERT(DR(PIC_ADDR_REG) == 25 && PIC_ADDR_REG == TMP_REG2);
+
+	if (src & SLJIT_IMM)
+		FAIL_IF(load_immediate(compiler, DR(PIC_ADDR_REG), srcw));
+	else if (src != PIC_ADDR_REG)
+		FAIL_IF(push_inst(compiler, DADDU | S(src) | TA(0) | D(PIC_ADDR_REG), DR(PIC_ADDR_REG)));
+
+	if (type & SLJIT_CALL_RETURN)
+		FAIL_IF(emit_stack_frame_release(compiler, 0, &ins));
+
+	FAIL_IF(call_with_args(compiler, arg_types, &ins));
+
+	/* Register input. */
+	if (!(type & SLJIT_CALL_RETURN))
+		FAIL_IF(push_inst(compiler, JALR | S(PIC_ADDR_REG) | DA(RETURN_ADDR_REG), UNMOVABLE_INS));
+	else
+		FAIL_IF(push_inst(compiler, JR | S(PIC_ADDR_REG), UNMOVABLE_INS));
+	return push_inst(compiler, ins, UNMOVABLE_INS);
 }
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeX86_32.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeX86_32.c`

 * *Files 14% similar despite different names*

```diff
@@ -76,44 +76,51 @@
 		inst_size++;
 
 	/* Calculate size of b. */
 	inst_size += 1; /* mod r/m byte. */
 	if (b & SLJIT_MEM) {
 		if (!(b & REG_MASK))
 			inst_size += sizeof(sljit_sw);
-		else if (immb != 0 && !(b & OFFS_REG_MASK)) {
-			/* Immediate operand. */
-			if (immb <= 127 && immb >= -128)
-				inst_size += sizeof(sljit_s8);
-			else
-				inst_size += sizeof(sljit_sw);
-		}
-		else if (reg_map[b & REG_MASK] == 5)
-			inst_size += sizeof(sljit_s8);
+		else {
+			if (immb != 0 && !(b & OFFS_REG_MASK)) {
+				/* Immediate operand. */
+				if (immb <= 127 && immb >= -128)
+					inst_size += sizeof(sljit_s8);
+				else
+					inst_size += sizeof(sljit_sw);
+			}
+			else if (reg_map[b & REG_MASK] == 5) {
+				/* Swap registers if possible. */
+				if ((b & OFFS_REG_MASK) && (immb & 0x3) == 0 && reg_map[OFFS_REG(b)] != 5)
+					b = SLJIT_MEM | OFFS_REG(b) | TO_OFFS_REG(b & REG_MASK);
+				else
+					inst_size += sizeof(sljit_s8);
+			}
 
-		if ((b & REG_MASK) == SLJIT_SP && !(b & OFFS_REG_MASK))
-			b |= TO_OFFS_REG(SLJIT_SP);
+			if (reg_map[b & REG_MASK] == 4 && !(b & OFFS_REG_MASK))
+				b |= TO_OFFS_REG(SLJIT_SP);
 
-		if (b & OFFS_REG_MASK)
-			inst_size += 1; /* SIB byte. */
+			if (b & OFFS_REG_MASK)
+				inst_size += 1; /* SIB byte. */
+		}
 	}
 
 	/* Calculate size of a. */
 	if (a & SLJIT_IMM) {
 		if (flags & EX86_BIN_INS) {
 			if (imma <= 127 && imma >= -128) {
 				inst_size += 1;
 				flags |= EX86_BYTE_ARG;
 			} else
 				inst_size += 4;
 		}
 		else if (flags & EX86_SHIFT_INS) {
-			imma &= 0x1f;
+			SLJIT_ASSERT(imma <= 0x1f);
 			if (imma != 1) {
-				inst_size ++;
+				inst_size++;
 				flags |= EX86_BYTE_ARG;
 			}
 		} else if (flags & EX86_BYTE_ARG)
 			inst_size++;
 		else if (flags & EX86_HALF_ARG)
 			inst_size += sizeof(short);
 		else
@@ -161,15 +168,15 @@
 
 	if (!(b & SLJIT_MEM)) {
 		*buf_ptr = U8(*buf_ptr | MOD_REG | (!(flags & EX86_SSE2_OP2) ? reg_map[b] : b));
 		buf_ptr++;
 	} else if (b & REG_MASK) {
 		reg_map_b = reg_map[b & REG_MASK];
 
-		if (!(b & OFFS_REG_MASK) || (b & OFFS_REG_MASK) == TO_OFFS_REG(SLJIT_SP) || reg_map_b == 5) {
+		if (!(b & OFFS_REG_MASK) || (b & OFFS_REG_MASK) == TO_OFFS_REG(SLJIT_SP)) {
 			if (immb != 0 || reg_map_b == 5) {
 				if (immb <= 127 && immb >= -128)
 					*buf_ptr |= 0x40;
 				else
 					*buf_ptr |= 0x80;
 			}
 
@@ -186,16 +193,22 @@
 				else {
 					sljit_unaligned_store_sw(buf_ptr, immb); /* 32 bit displacement. */
 					buf_ptr += sizeof(sljit_sw);
 				}
 			}
 		}
 		else {
+			if (reg_map_b == 5)
+				*buf_ptr |= 0x40;
+
 			*buf_ptr++ |= 0x04;
 			*buf_ptr++ = U8(reg_map_b | (reg_map[OFFS_REG(b)] << 3) | (immb << 6));
+
+			if (reg_map_b == 5)
+				*buf_ptr++ = 0;
 		}
 	}
 	else {
 		*buf_ptr++ |= 0x05;
 		sljit_unaligned_store_sw(buf_ptr, immb); /* 32 bit displacement. */
 		buf_ptr += sizeof(sljit_sw);
 	}
@@ -239,27 +252,24 @@
 	else
 		sljit_unaligned_store_sw(code_ptr, (sljit_sw)(jump->u.target - (jump->addr + 4) - (sljit_uw)executable_offset));
 	code_ptr += 4;
 
 	return code_ptr;
 }
 
-#define ENTER_R2_USED	0x00001
-#define ENTER_R2_TO_S	0x00002
-#define ENTER_R2_TO_R0	0x00004
-#define ENTER_R1_TO_S	0x00008
-#define ENTER_TMP_TO_R4	0x00010
-#define ENTER_TMP_TO_S	0x00020
+#define ENTER_TMP_TO_R4		0x00001
+#define ENTER_TMP_TO_S		0x00002
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_enter(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
 	sljit_s32 word_arg_count, saved_arg_count, float_arg_count;
-	sljit_s32 size, locals_offset, args_size, types, status;
+	sljit_s32 size, args_size, types, status;
+	sljit_s32 kept_saveds_count = SLJIT_KEPT_SAVEDS_COUNT(options);
 	sljit_u8 *inst;
 #ifdef _WIN32
 	sljit_s32 r2_offset = -1;
 #endif
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
@@ -267,187 +277,139 @@
 
 	/* Emit ENDBR32 at function entry if needed.  */
 	FAIL_IF(emit_endbranch(compiler));
 
 	SLJIT_COMPILE_ASSERT(SLJIT_FR0 == 1, float_register_index_start);
 
 	arg_types >>= SLJIT_ARG_SHIFT;
-	types = arg_types;
 	word_arg_count = 0;
-	saved_arg_count = 0;
-	float_arg_count = 0;
-	args_size = SSIZE_OF(sw);
 	status = 0;
-	while (types) {
-		switch (types & SLJIT_ARG_MASK) {
-		case SLJIT_ARG_TYPE_F64:
-			float_arg_count++;
-			FAIL_IF(emit_sse2_load(compiler, 0, float_arg_count, SLJIT_MEM1(SLJIT_SP), args_size));
-			args_size += SSIZE_OF(f64);
-			break;
-		case SLJIT_ARG_TYPE_F32:
-			float_arg_count++;
-			FAIL_IF(emit_sse2_load(compiler, 1, float_arg_count, SLJIT_MEM1(SLJIT_SP), args_size));
-			args_size += SSIZE_OF(f32);
-			break;
-		default:
-			word_arg_count++;
 
-			if (!(types & SLJIT_ARG_TYPE_SCRATCH_REG)) {
-				saved_arg_count++;
-				if (saved_arg_count == 4)
-					status |= ENTER_TMP_TO_S;
-			} else {
-				if (word_arg_count == 4)
+	if (options & SLJIT_ENTER_REG_ARG) {
+		args_size = 3 * SSIZE_OF(sw);
+
+		while (arg_types) {
+			if ((arg_types & SLJIT_ARG_MASK) < SLJIT_ARG_TYPE_F64) {
+				word_arg_count++;
+				if (word_arg_count >= 4)
 					status |= ENTER_TMP_TO_R4;
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-				if (word_arg_count == 3)
-					status |= ENTER_R2_USED;
-#endif
 			}
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-			if (word_arg_count <= 2 && !(options & SLJIT_ENTER_CDECL))
-				break;
-#endif
-
-			args_size += SSIZE_OF(sw);
-			break;
+			arg_types >>= SLJIT_ARG_SHIFT;
 		}
-		types >>= SLJIT_ARG_SHIFT;
-	}
 
-	args_size -= SSIZE_OF(sw);
-	compiler->args_size = args_size;
+		compiler->args_size = 0;
+	} else {
+		types = arg_types;
+		saved_arg_count = 0;
+		float_arg_count = 0;
+		args_size = SSIZE_OF(sw);
+		while (types) {
+			switch (types & SLJIT_ARG_MASK) {
+			case SLJIT_ARG_TYPE_F64:
+				float_arg_count++;
+				FAIL_IF(emit_sse2_load(compiler, 0, float_arg_count, SLJIT_MEM1(SLJIT_SP), args_size));
+				args_size += SSIZE_OF(f64);
+				break;
+			case SLJIT_ARG_TYPE_F32:
+				float_arg_count++;
+				FAIL_IF(emit_sse2_load(compiler, 1, float_arg_count, SLJIT_MEM1(SLJIT_SP), args_size));
+				args_size += SSIZE_OF(f32);
+				break;
+			default:
+				word_arg_count++;
 
-	/* [esp+0] for saving temporaries and function calls. */
-	locals_offset = 2 * SSIZE_OF(sw);
+				if (!(types & SLJIT_ARG_TYPE_SCRATCH_REG))
+					saved_arg_count++;
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	if ((options & SLJIT_ENTER_CDECL) && scratches >= 3)
-		locals_offset = 4 * SSIZE_OF(sw);
-#else
-	if (scratches >= 3)
-		locals_offset = 4 * SSIZE_OF(sw);
-#endif
+				if (word_arg_count == 4) {
+					if (types & SLJIT_ARG_TYPE_SCRATCH_REG) {
+						status |= ENTER_TMP_TO_R4;
+						arg_types &= ~(SLJIT_ARG_FULL_MASK << 3 * SLJIT_ARG_SHIFT);
+					} else if (saved_arg_count == 4) {
+						status |= ENTER_TMP_TO_S;
+						arg_types &= ~(SLJIT_ARG_FULL_MASK << 3 * SLJIT_ARG_SHIFT);
+					}
+				}
 
-	compiler->scratches_offset = locals_offset;
+				args_size += SSIZE_OF(sw);
+				break;
+			}
+			types >>= SLJIT_ARG_SHIFT;
+		}
 
-	if (scratches > 3)
-		locals_offset += ((scratches > (3 + 6)) ? 6 : (scratches - 3)) * SSIZE_OF(sw);
+		args_size -= SSIZE_OF(sw);
+		compiler->args_size = args_size;
+	}
 
-	if (saveds > 3)
-		locals_offset += (saveds - 3) * SSIZE_OF(sw);
+	size = (scratches > 9 ? (scratches - 9) : 0) + (saveds <= 3 ? saveds : 3) - kept_saveds_count;
+	if (!(options & SLJIT_ENTER_REG_ARG))
+		size++;
 
-	compiler->locals_offset = locals_offset;
+	if (size != 0) {
+		inst = (sljit_u8*)ensure_buf(compiler, (sljit_uw)(size + 1));
+		FAIL_IF(!inst);
 
-	size = 1 + (scratches > 9 ? (scratches - 9) : 0) + (saveds <= 3 ? saveds : 3);
-	inst = (sljit_u8*)ensure_buf(compiler, (sljit_uw)(size + 1));
-	FAIL_IF(!inst);
+		INC_SIZE((sljit_uw)size);
+
+		if (!(options & SLJIT_ENTER_REG_ARG))
+			PUSH_REG(reg_map[TMP_REG1]);
 
-	INC_SIZE((sljit_uw)size);
-	PUSH_REG(reg_map[TMP_REG1]);
-	if (saveds > 2 || scratches > 9)
-		PUSH_REG(reg_map[SLJIT_S2]);
-	if (saveds > 1 || scratches > 10)
-		PUSH_REG(reg_map[SLJIT_S1]);
-	if (saveds > 0 || scratches > 11)
-		PUSH_REG(reg_map[SLJIT_S0]);
+		if ((saveds > 2 && kept_saveds_count <= 2) || scratches > 9)
+			PUSH_REG(reg_map[SLJIT_S2]);
+		if ((saveds > 1 && kept_saveds_count <= 1) || scratches > 10)
+			PUSH_REG(reg_map[SLJIT_S1]);
+		if ((saveds > 0 && kept_saveds_count == 0) || scratches > 11)
+			PUSH_REG(reg_map[SLJIT_S0]);
 
-	size *= SSIZE_OF(sw);
+		size *= SSIZE_OF(sw);
+	}
 
 	if (status & (ENTER_TMP_TO_R4 | ENTER_TMP_TO_S))
 		EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_MEM1(SLJIT_SP), args_size + size);
 
 	size += SSIZE_OF(sw);
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	if (!(options & SLJIT_ENTER_CDECL))
-		size += args_size;
-#endif
-
-	local_size = ((locals_offset + local_size + size + 0xf) & ~0xf) - size;
+	local_size = ((SLJIT_LOCALS_OFFSET_BASE + local_size + size + 0xf) & ~0xf) - size;
 	compiler->local_size = local_size;
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	if (!(options & SLJIT_ENTER_CDECL))
-		size -= args_size;
-#endif
-
 	word_arg_count = 0;
 	saved_arg_count = 0;
 	args_size = size;
 	while (arg_types) {
 		switch (arg_types & SLJIT_ARG_MASK) {
 		case SLJIT_ARG_TYPE_F64:
 			args_size += SSIZE_OF(f64);
 			break;
 		case SLJIT_ARG_TYPE_F32:
 			args_size += SSIZE_OF(f32);
 			break;
 		default:
 			word_arg_count++;
+			SLJIT_ASSERT(word_arg_count <= 3 || (word_arg_count == 4 && !(status & (ENTER_TMP_TO_R4 | ENTER_TMP_TO_S))));
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-			if (!(options & SLJIT_ENTER_CDECL) && word_arg_count <= 2) {
-				if (word_arg_count == 1) {
-					if (status & ENTER_R2_USED) {
-						EMIT_MOV(compiler, (arg_types & SLJIT_ARG_TYPE_SCRATCH_REG) ? SLJIT_R0 : SLJIT_S0, 0, SLJIT_R2, 0);
-					} else if (!(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG)) {
-						status |= ENTER_R2_TO_S;
-						saved_arg_count++;
-					} else
-						status |= ENTER_R2_TO_R0;
-				} else if (!(arg_types & SLJIT_ARG_TYPE_SCRATCH_REG)) {
-					status |= ENTER_R1_TO_S;
-					saved_arg_count++;
-				}
-				break;
-			}
-#endif
 			if (arg_types & SLJIT_ARG_TYPE_SCRATCH_REG) {
-				SLJIT_ASSERT(word_arg_count <= 3 || (status & ENTER_TMP_TO_R4));
-
-				if (word_arg_count <= 3) {
 #ifdef _WIN32
-					if (word_arg_count == 3 && local_size > 4 * 4096)
-						r2_offset = local_size + args_size;
-					else
+				if (word_arg_count == 3 && local_size > 4 * 4096)
+					r2_offset = local_size + args_size;
+				else
 #endif
-						EMIT_MOV(compiler, word_arg_count, 0, SLJIT_MEM1(SLJIT_SP), args_size);
-				}
-			} else {
-				SLJIT_ASSERT(saved_arg_count <= 3 || (status & ENTER_TMP_TO_S));
+					EMIT_MOV(compiler, word_arg_count, 0, SLJIT_MEM1(SLJIT_SP), args_size);
 
-				if (saved_arg_count <= 3)
-					EMIT_MOV(compiler, SLJIT_S0 - saved_arg_count, 0, SLJIT_MEM1(SLJIT_SP), args_size);
+			} else {
+				EMIT_MOV(compiler, SLJIT_S0 - saved_arg_count, 0, SLJIT_MEM1(SLJIT_SP), args_size);
 				saved_arg_count++;
 			}
+
 			args_size += SSIZE_OF(sw);
 			break;
 		}
 		arg_types >>= SLJIT_ARG_SHIFT;
 	}
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	if (!(options & SLJIT_ENTER_CDECL)) {
-		if (status & ENTER_R2_TO_R0)
-			EMIT_MOV(compiler, SLJIT_R0, 0, SLJIT_R2, 0);
-
-		saved_arg_count = 0;
-		if (status & ENTER_R2_TO_S) {
-			EMIT_MOV(compiler, SLJIT_S0, 0, SLJIT_R2, 0);
-			saved_arg_count++;
-		}
-
-		if (status & ENTER_R1_TO_S)
-			EMIT_MOV(compiler, SLJIT_S0 - saved_arg_count, 0, SLJIT_R1, 0);
-	}
-#endif
-
 	SLJIT_ASSERT(SLJIT_LOCALS_OFFSET > 0);
 
 #ifdef _WIN32
 	SLJIT_ASSERT(r2_offset == -1 || local_size > 4 * 4096);
 
 	if (local_size > 4096) {
 		if (local_size <= 4 * 4096) {
@@ -455,14 +417,26 @@
 
 			if (local_size > 2 * 4096)
 				BINARY_IMM32(OR, 0, SLJIT_MEM1(SLJIT_SP), -4096 * 2);
 			if (local_size > 3 * 4096)
 				BINARY_IMM32(OR, 0, SLJIT_MEM1(SLJIT_SP), -4096 * 3);
 		}
 		else {
+			if (options & SLJIT_ENTER_REG_ARG) {
+				SLJIT_ASSERT(r2_offset == -1);
+
+				inst = (sljit_u8*)ensure_buf(compiler, (sljit_uw)(1 + 1));
+				FAIL_IF(!inst);
+				INC_SIZE(1);
+				PUSH_REG(reg_map[SLJIT_R2]);
+
+				local_size -= SSIZE_OF(sw);
+				r2_offset = local_size;
+			}
+
 			EMIT_MOV(compiler, SLJIT_R2, 0, SLJIT_IMM, local_size >> 12);
 
 			BINARY_IMM32(OR, 0, SLJIT_MEM1(SLJIT_SP), -4096);
 			BINARY_IMM32(SUB, 4096, SLJIT_SP, 0);
 
 			inst = (sljit_u8*)ensure_buf(compiler, 1 + 2);
 			FAIL_IF(!inst);
@@ -486,263 +460,175 @@
 
 	SLJIT_ASSERT(local_size > 0);
 
 	BINARY_IMM32(SUB, local_size, SLJIT_SP, 0);
 
 #endif /* _WIN32 */
 
+	size = SLJIT_LOCALS_OFFSET_BASE - SSIZE_OF(sw);
+	kept_saveds_count = SLJIT_R3 - kept_saveds_count;
+
+	while (saved_arg_count > 3) {
+		EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), size, kept_saveds_count, 0);
+		kept_saveds_count++;
+		size -= SSIZE_OF(sw);
+		saved_arg_count--;
+	}
+
 	if (status & (ENTER_TMP_TO_R4 | ENTER_TMP_TO_S)) {
-		size = (status & ENTER_TMP_TO_R4) ? compiler->scratches_offset : compiler->locals_offset - SSIZE_OF(sw);
+		if (status & ENTER_TMP_TO_R4)
+			size = 2 * SSIZE_OF(sw);
+
 		EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), size, TMP_REG1, 0);
 	}
 
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_set_context(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
-	sljit_s32 args_size, locals_offset;
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	sljit_s32 word_arg_count = 0;
-#endif
+	sljit_s32 args_size;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
 	arg_types >>= SLJIT_ARG_SHIFT;
 	args_size = 0;
-	while (arg_types) {
-		switch (arg_types & SLJIT_ARG_MASK) {
-		case SLJIT_ARG_TYPE_F64:
-			args_size += SSIZE_OF(f64);
-			break;
-		case SLJIT_ARG_TYPE_F32:
-			args_size += SSIZE_OF(f32);
-			break;
-		default:
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-			if (word_arg_count >= 2)
+
+	if (!(options & SLJIT_ENTER_REG_ARG)) {
+		while (arg_types) {
+			switch (arg_types & SLJIT_ARG_MASK) {
+			case SLJIT_ARG_TYPE_F64:
+				args_size += SSIZE_OF(f64);
+				break;
+			case SLJIT_ARG_TYPE_F32:
+				args_size += SSIZE_OF(f32);
+				break;
+			default:
 				args_size += SSIZE_OF(sw);
-			word_arg_count++;
-#else
-			args_size += SSIZE_OF(sw);
-#endif
-			break;
+				break;
+			}
+			arg_types >>= SLJIT_ARG_SHIFT;
 		}
-		arg_types >>= SLJIT_ARG_SHIFT;
 	}
 
 	compiler->args_size = args_size;
 
-	/* [esp+0] for saving temporaries and function calls. */
-	locals_offset = 2 * SSIZE_OF(sw);
+	/* [esp+0] for saving temporaries and for function calls. */
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	if ((options & SLJIT_ENTER_CDECL) && scratches >= 3)
-		locals_offset = 4 * SSIZE_OF(sw);
-#else
-	if (scratches >= 3)
-		locals_offset = 4 * SSIZE_OF(sw);
-#endif
-
-	compiler->scratches_offset = locals_offset;
-
-	if (scratches > 3)
-		locals_offset += ((scratches > (3 + 6)) ? 6 : (scratches - 3)) * SSIZE_OF(sw);
-
-	if (saveds > 3)
-		locals_offset += (saveds - 3) * SSIZE_OF(sw);
-
-	compiler->locals_offset = locals_offset;
-
-	saveds = (2 + (scratches > 9 ? (scratches - 9) : 0) + (saveds <= 3 ? saveds : 3)) * SSIZE_OF(sw);
+	saveds = (1 + (scratches > 9 ? (scratches - 9) : 0) + (saveds <= 3 ? saveds : 3) - SLJIT_KEPT_SAVEDS_COUNT(options)) * SSIZE_OF(sw);
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	if (!(options & SLJIT_ENTER_CDECL))
-		saveds += args_size;
-#endif
+	/* Saving ebp. */
+	if (!(options & SLJIT_ENTER_REG_ARG))
+		saveds += SSIZE_OF(sw);
 
-	compiler->local_size = ((locals_offset + local_size + saveds + 0xf) & ~0xf) - saveds;
+	compiler->local_size = ((SLJIT_LOCALS_OFFSET_BASE + local_size + saveds + 0xf) & ~0xf) - saveds;
 	return SLJIT_SUCCESS;
 }
 
-static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler)
+static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler, sljit_s32 is_return_to)
 {
+	sljit_s32 kept_saveds_count = SLJIT_KEPT_SAVEDS_COUNT(compiler->options);
+	sljit_s32 local_size, saveds;
 	sljit_uw size;
 	sljit_u8 *inst;
 
-	size = (sljit_uw)(1 + (compiler->scratches > 9 ? (compiler->scratches - 9) : 0) +
-		(compiler->saveds <= 3 ? compiler->saveds : 3));
+	size = (sljit_uw)((compiler->scratches > 9 ? (compiler->scratches - 9) : 0) +
+		(compiler->saveds <= 3 ? compiler->saveds : 3) - kept_saveds_count);
+
+	local_size = compiler->local_size;
+
+	if (!(compiler->options & SLJIT_ENTER_REG_ARG))
+		size++;
+	else if (is_return_to && size == 0) {
+		local_size += SSIZE_OF(sw);
+		is_return_to = 0;
+	}
+
+	if (local_size > 0)
+		BINARY_IMM32(ADD, local_size, SLJIT_SP, 0);
+
+	if (size == 0)
+		return SLJIT_SUCCESS;
+
 	inst = (sljit_u8*)ensure_buf(compiler, 1 + size);
 	FAIL_IF(!inst);
 
 	INC_SIZE(size);
 
-	if (compiler->saveds > 0 || compiler->scratches > 11)
+	saveds = compiler->saveds;
+
+	if ((saveds > 0 && kept_saveds_count == 0) || compiler->scratches > 11)
 		POP_REG(reg_map[SLJIT_S0]);
-	if (compiler->saveds > 1 || compiler->scratches > 10)
+	if ((saveds > 1 && kept_saveds_count <= 1) || compiler->scratches > 10)
 		POP_REG(reg_map[SLJIT_S1]);
-	if (compiler->saveds > 2 || compiler->scratches > 9)
+	if ((saveds > 2 && kept_saveds_count <= 2) || compiler->scratches > 9)
 		POP_REG(reg_map[SLJIT_S2]);
-	POP_REG(reg_map[TMP_REG1]);
+
+	if (!(compiler->options & SLJIT_ENTER_REG_ARG))
+		POP_REG(reg_map[TMP_REG1]);
+
+	if (is_return_to)
+		BINARY_IMM32(ADD, sizeof(sljit_sw), SLJIT_SP, 0);
 
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_void(struct sljit_compiler *compiler)
 {
-	sljit_uw size;
 	sljit_u8 *inst;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_return_void(compiler));
 
 	SLJIT_ASSERT(compiler->args_size >= 0);
 	SLJIT_ASSERT(compiler->local_size > 0);
 
-	BINARY_IMM32(ADD, compiler->local_size, SLJIT_SP, 0);
+	FAIL_IF(emit_stack_frame_release(compiler, 0));
 
-	FAIL_IF(emit_stack_frame_release(compiler));
-
-	size = 1;
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	if (compiler->args_size > 0 && !(compiler->options & SLJIT_ENTER_CDECL))
-		size = 3;
-#endif
-	inst = (sljit_u8*)ensure_buf(compiler, 1 + size);
+	inst = (sljit_u8*)ensure_buf(compiler, 1 + 1);
 	FAIL_IF(!inst);
-
-	INC_SIZE(size);
-
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	if (compiler->args_size > 0 && !(compiler->options & SLJIT_ENTER_CDECL)) {
-		RET_I16(U8(compiler->args_size));
-		return SLJIT_SUCCESS;
-	}
-#endif
-
+	INC_SIZE(1);
 	RET();
 	return SLJIT_SUCCESS;
 }
 
-/* --------------------------------------------------------------------- */
-/*  Call / return instructions                                           */
-/* --------------------------------------------------------------------- */
-
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-
-static sljit_sw c_fast_call_get_stack_size(sljit_s32 arg_types, sljit_s32 *word_arg_count_ptr)
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_to(struct sljit_compiler *compiler,
+	sljit_s32 src, sljit_sw srcw)
 {
-	sljit_sw stack_size = 0;
-	sljit_s32 word_arg_count = 0;
-
-	arg_types >>= SLJIT_ARG_SHIFT;
+	sljit_s32 src_r;
 
-	while (arg_types) {
-		switch (arg_types & SLJIT_ARG_MASK) {
-		case SLJIT_ARG_TYPE_F64:
-			stack_size += SSIZE_OF(f64);
-			break;
-		case SLJIT_ARG_TYPE_F32:
-			stack_size += SSIZE_OF(f32);
-			break;
-		default:
-			word_arg_count++;
-			if (word_arg_count > 2)
-				stack_size += SSIZE_OF(sw);
-			break;
-		}
-
-		arg_types >>= SLJIT_ARG_SHIFT;
-	}
-
-	if (word_arg_count_ptr)
-		*word_arg_count_ptr = word_arg_count;
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_return_to(compiler, src, srcw));
 
-	return stack_size;
-}
+	if ((src & SLJIT_MEM) || (src > SLJIT_R2 && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options)))) {
+		ADJUST_LOCAL_OFFSET(src, srcw);
+		CHECK_EXTRA_REGS(src, srcw, (void)0);
 
-static sljit_s32 c_fast_call_with_args(struct sljit_compiler *compiler,
-	sljit_s32 arg_types, sljit_sw stack_size, sljit_s32 word_arg_count, sljit_s32 swap_args)
-{
-	sljit_u8 *inst;
-	sljit_s32 float_arg_count;
+		src_r = (compiler->options & SLJIT_ENTER_REG_ARG) ? TMP_REG1 : SLJIT_R1;
 
-	if (stack_size == SSIZE_OF(sw) && word_arg_count == 3) {
-		inst = (sljit_u8*)ensure_buf(compiler, 1 + 1);
-		FAIL_IF(!inst);
-		INC_SIZE(1);
-		PUSH_REG(reg_map[SLJIT_R2]);
+		EMIT_MOV(compiler, src_r, 0, src, srcw);
+		src = src_r;
+		srcw = 0;
 	}
-	else if (stack_size > 0) {
-		if (word_arg_count >= 4)
-			EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_MEM1(SLJIT_SP), compiler->scratches_offset);
 
-		BINARY_IMM32(SUB, stack_size, SLJIT_SP, 0);
+	FAIL_IF(emit_stack_frame_release(compiler, 1));
 
-		stack_size = 0;
-		arg_types >>= SLJIT_ARG_SHIFT;
-		word_arg_count = 0;
-		float_arg_count = 0;
-		while (arg_types) {
-			switch (arg_types & SLJIT_ARG_MASK) {
-			case SLJIT_ARG_TYPE_F64:
-				float_arg_count++;
-				FAIL_IF(emit_sse2_store(compiler, 0, SLJIT_MEM1(SLJIT_SP), stack_size, float_arg_count));
-				stack_size += SSIZE_OF(f64);
-				break;
-			case SLJIT_ARG_TYPE_F32:
-				float_arg_count++;
-				FAIL_IF(emit_sse2_store(compiler, 1, SLJIT_MEM1(SLJIT_SP), stack_size, float_arg_count));
-				stack_size += SSIZE_OF(f32);
-				break;
-			default:
-				word_arg_count++;
-				if (word_arg_count == 3) {
-					EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), stack_size, SLJIT_R2, 0);
-					stack_size += SSIZE_OF(sw);
-				}
-				else if (word_arg_count == 4) {
-					EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), stack_size, TMP_REG1, 0);
-					stack_size += SSIZE_OF(sw);
-				}
-				break;
-			}
-
-			arg_types >>= SLJIT_ARG_SHIFT;
-		}
-	}
-
-	if (word_arg_count > 0) {
-		if (swap_args) {
-			inst = (sljit_u8*)ensure_buf(compiler, 1 + 1);
-			FAIL_IF(!inst);
-			INC_SIZE(1);
-
-			*inst++ = U8(XCHG_EAX_r | reg_map[SLJIT_R2]);
-		}
-		else {
-			inst = (sljit_u8*)ensure_buf(compiler, 1 + 2);
-			FAIL_IF(!inst);
-			INC_SIZE(2);
-
-			*inst++ = MOV_r_rm;
-			*inst++ = U8(MOD_REG | (reg_map[SLJIT_R2] << 3) | reg_map[SLJIT_R0]);
-		}
-	}
-
-	return SLJIT_SUCCESS;
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_ijump(compiler, SLJIT_JUMP, src, srcw);
 }
 
-#endif
+/* --------------------------------------------------------------------- */
+/*  Call / return instructions                                           */
+/* --------------------------------------------------------------------- */
 
-static sljit_s32 cdecl_call_get_stack_size(struct sljit_compiler *compiler, sljit_s32 arg_types, sljit_s32 *word_arg_count_ptr)
+static sljit_s32 call_get_stack_size(sljit_s32 arg_types, sljit_s32 *word_arg_count_ptr)
 {
 	sljit_sw stack_size = 0;
 	sljit_s32 word_arg_count = 0;
 
 	arg_types >>= SLJIT_ARG_SHIFT;
 
 	while (arg_types) {
@@ -761,52 +647,62 @@
 
 		arg_types >>= SLJIT_ARG_SHIFT;
 	}
 
 	if (word_arg_count_ptr)
 		*word_arg_count_ptr = word_arg_count;
 
-	if (stack_size <= compiler->scratches_offset)
+	if (stack_size <= 4 * SSIZE_OF(sw))
 		return 0;
 
-	return ((stack_size - compiler->scratches_offset + 0xf) & ~0xf);
+	return ((stack_size - (4 * SSIZE_OF(sw)) + 0xf) & ~0xf);
 }
 
-static sljit_s32 cdecl_call_with_args(struct sljit_compiler *compiler,
-	sljit_s32 arg_types, sljit_sw stack_size, sljit_s32 word_arg_count)
+static sljit_s32 call_with_args(struct sljit_compiler *compiler,
+	sljit_s32 arg_types, sljit_sw stack_size, sljit_s32 word_arg_count, sljit_s32 keep_tmp1)
 {
-	sljit_s32 float_arg_count = 0;
+	sljit_s32 float_arg_count = 0, arg4_reg = 0, arg_offset;
 	sljit_u8 *inst;
 
-	if (word_arg_count >= 4)
-		EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_MEM1(SLJIT_SP), compiler->scratches_offset);
+	if (word_arg_count >= 4) {
+		arg4_reg = SLJIT_R0;
+
+		if (!keep_tmp1) {
+			EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_MEM1(SLJIT_SP), 2 * SSIZE_OF(sw));
+			arg4_reg = TMP_REG1;
+		}
+	}
 
 	if (stack_size > 0)
 		BINARY_IMM32(SUB, stack_size, SLJIT_SP, 0);
 
-	stack_size = 0;
+	arg_offset = 0;
 	word_arg_count = 0;
 	arg_types >>= SLJIT_ARG_SHIFT;
 
 	while (arg_types) {
 		switch (arg_types & SLJIT_ARG_MASK) {
 		case SLJIT_ARG_TYPE_F64:
 			float_arg_count++;
-			FAIL_IF(emit_sse2_store(compiler, 0, SLJIT_MEM1(SLJIT_SP), stack_size, float_arg_count));
-			stack_size += SSIZE_OF(f64);
+			FAIL_IF(emit_sse2_store(compiler, 0, SLJIT_MEM1(SLJIT_SP), arg_offset, float_arg_count));
+			arg_offset += SSIZE_OF(f64);
 			break;
 		case SLJIT_ARG_TYPE_F32:
 			float_arg_count++;
-			FAIL_IF(emit_sse2_store(compiler, 1, SLJIT_MEM1(SLJIT_SP), stack_size, float_arg_count));
-			stack_size += SSIZE_OF(f32);
+			FAIL_IF(emit_sse2_store(compiler, 1, SLJIT_MEM1(SLJIT_SP), arg_offset, float_arg_count));
+			arg_offset += SSIZE_OF(f32);
 			break;
 		default:
 			word_arg_count++;
-			EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), stack_size, (word_arg_count >= 4) ? TMP_REG1 : word_arg_count, 0);
-			stack_size += SSIZE_OF(sw);
+			EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), arg_offset, (word_arg_count >= 4) ? arg4_reg : word_arg_count, 0);
+
+			if (word_arg_count == 1 && arg4_reg == SLJIT_R0)
+				EMIT_MOV(compiler, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_SP), 2 * SSIZE_OF(sw) + stack_size);
+
+			arg_offset += SSIZE_OF(sw);
 			break;
 		}
 
 		arg_types >>= SLJIT_ARG_SHIFT;
 	}
 
 	return SLJIT_SUCCESS;
@@ -836,29 +732,27 @@
 	return emit_sse2_load(compiler, single, SLJIT_FR0, SLJIT_MEM1(SLJIT_SP), 0);
 }
 
 static sljit_s32 tail_call_with_args(struct sljit_compiler *compiler,
 	sljit_s32 *extra_space, sljit_s32 arg_types,
 	sljit_s32 src, sljit_sw srcw)
 {
-	sljit_sw args_size, prev_args_size, saved_regs_size;
+	sljit_sw args_size, saved_regs_size;
 	sljit_sw types, word_arg_count, float_arg_count;
 	sljit_sw stack_size, prev_stack_size, min_size, offset;
 	sljit_sw word_arg4_offset;
 	sljit_u8 r2_offset = 0;
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	sljit_u8 fast_call = (*extra_space & 0xff) == SLJIT_CALL;
-#endif
+	sljit_s32 kept_saveds_count = SLJIT_KEPT_SAVEDS_COUNT(compiler->options);
 	sljit_u8* inst;
 
 	ADJUST_LOCAL_OFFSET(src, srcw);
 	CHECK_EXTRA_REGS(src, srcw, (void)0);
 
 	saved_regs_size = (1 + (compiler->scratches > 9 ? (compiler->scratches - 9) : 0)
-		+ (compiler->saveds <= 3 ? compiler->saveds : 3)) * SSIZE_OF(sw);
+		+ (compiler->saveds <= 3 ? compiler->saveds : 3) - kept_saveds_count) * SSIZE_OF(sw);
 
 	word_arg_count = 0;
 	float_arg_count = 0;
 	arg_types >>= SLJIT_ARG_SHIFT;
 	types = 0;
 	args_size = 0;
 
@@ -872,80 +766,34 @@
 			break;
 		case SLJIT_ARG_TYPE_F32:
 			args_size += SSIZE_OF(f32);
 			float_arg_count++;
 			break;
 		default:
 			word_arg_count++;
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-			if (!fast_call || word_arg_count > 2)
-				args_size += SSIZE_OF(sw);
-#else
 			args_size += SSIZE_OF(sw);
-#endif
 			break;
 		}
 		arg_types >>= SLJIT_ARG_SHIFT;
 	}
 
-	if (args_size <= compiler->args_size
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-			&& (!(compiler->options & SLJIT_ENTER_CDECL) || args_size == 0 || !fast_call)
-#endif /* SLJIT_X86_32_FASTCALL */
-			&& 1) {
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-		*extra_space = fast_call ? 0 : args_size;
-		prev_args_size = compiler->args_size;
-		stack_size = prev_args_size + SSIZE_OF(sw) + saved_regs_size;
-#else /* !SLJIT_X86_32_FASTCALL */
+	if (args_size <= compiler->args_size) {
 		*extra_space = 0;
 		stack_size = args_size + SSIZE_OF(sw) + saved_regs_size;
-#endif /* SLJIT_X86_32_FASTCALL */
 
 		offset = stack_size + compiler->local_size;
 
 		if (!(src & SLJIT_IMM) && src != SLJIT_R0) {
 			if (word_arg_count >= 1) {
 				EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), 0, SLJIT_R0, 0);
 				r2_offset = sizeof(sljit_sw);
 			}
 			EMIT_MOV(compiler, SLJIT_R0, 0, src, srcw);
 		}
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-		if (!(compiler->options & SLJIT_ENTER_CDECL)) {
-			if (!fast_call)
-				offset -= SSIZE_OF(sw);
-
-			if (word_arg_count >= 3) {
-				word_arg4_offset = SSIZE_OF(sw);
-
-				if (word_arg_count + float_arg_count >= 4) {
-					word_arg4_offset = SSIZE_OF(sw) + SSIZE_OF(sw);
-					if ((types & SLJIT_ARG_MASK) == SLJIT_ARG_TYPE_F64)
-						word_arg4_offset = SSIZE_OF(sw) + SSIZE_OF(f64);
-				}
-
-				/* In cdecl mode, at least one more word value must
-				 * be present on the stack before the return address. */
-				EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset - word_arg4_offset, SLJIT_R2, 0);
-			}
-
-			if (fast_call) {
-				if (args_size < prev_args_size) {
-					EMIT_MOV(compiler, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), offset - prev_args_size - SSIZE_OF(sw));
-					EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset - args_size - SSIZE_OF(sw), SLJIT_R2, 0);
-				}
-			} else if (prev_args_size > 0) {
-				EMIT_MOV(compiler, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), offset - prev_args_size);
-				EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R2, 0);
-			}
-		}
-#endif /* SLJIT_X86_32_FASTCALL */
-
 		while (types != 0) {
 			switch (types & SLJIT_ARG_MASK) {
 			case SLJIT_ARG_TYPE_F64:
 				offset -= SSIZE_OF(f64);
 				FAIL_IF(emit_sse2_store(compiler, 0, SLJIT_MEM1(SLJIT_SP), offset, float_arg_count));
 				float_arg_count--;
 				break;
@@ -953,81 +801,57 @@
 				offset -= SSIZE_OF(f32);
 				FAIL_IF(emit_sse2_store(compiler, 0, SLJIT_MEM1(SLJIT_SP), offset, float_arg_count));
 				float_arg_count--;
 				break;
 			default:
 				switch (word_arg_count) {
 				case 1:
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-					if (fast_call) {
-						EMIT_MOV(compiler, SLJIT_R2, 0, r2_offset != 0 ? SLJIT_MEM1(SLJIT_SP) : SLJIT_R0, 0);
-						break;
-					}
-#endif
 					offset -= SSIZE_OF(sw);
 					if (r2_offset != 0) {
 						EMIT_MOV(compiler, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), 0);
 						EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R2, 0);
 					} else
 						EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R0, 0);
 					break;
 				case 2:
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-					if (fast_call)
-						break;
-#endif
 					offset -= SSIZE_OF(sw);
 					EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R1, 0);
 					break;
 				case 3:
 					offset -= SSIZE_OF(sw);
 					break;
 				case 4:
 					offset -= SSIZE_OF(sw);
-					EMIT_MOV(compiler, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), compiler->scratches_offset);
+					EMIT_MOV(compiler, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), 2 * SSIZE_OF(sw));
 					EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R2, 0);
 					break;
 				}
 				word_arg_count--;
 				break;
 			}
 			types >>= SLJIT_ARG_SHIFT;
 		}
 
-		BINARY_IMM32(ADD, compiler->local_size, SLJIT_SP, 0);
-		FAIL_IF(emit_stack_frame_release(compiler));
-
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-		if (args_size < prev_args_size)
-			BINARY_IMM32(ADD, prev_args_size - args_size, SLJIT_SP, 0);
-#endif
-
-		return SLJIT_SUCCESS;
+		return emit_stack_frame_release(compiler, 0);
 	}
 
 	stack_size = args_size + SSIZE_OF(sw);
 
 	if (word_arg_count >= 1 && !(src & SLJIT_IMM) && src != SLJIT_R0) {
 		r2_offset = SSIZE_OF(sw);
 		stack_size += SSIZE_OF(sw);
 	}
 
 	if (word_arg_count >= 3)
 		stack_size += SSIZE_OF(sw);
 
-	prev_args_size = 0;
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	if (!(compiler->options & SLJIT_ENTER_CDECL))
-		prev_args_size = compiler->args_size;
-#endif
-
-	prev_stack_size = prev_args_size + SSIZE_OF(sw) + saved_regs_size;
+	prev_stack_size = SSIZE_OF(sw) + saved_regs_size;
 	min_size = prev_stack_size + compiler->local_size;
 
-	word_arg4_offset = compiler->scratches_offset;
+	word_arg4_offset = 2 * SSIZE_OF(sw);
 
 	if (stack_size > min_size) {
 		BINARY_IMM32(SUB, stack_size - min_size, SLJIT_SP, 0);
 		if (src == SLJIT_MEM1(SLJIT_SP))
 			srcw += stack_size - min_size;
 		word_arg4_offset += stack_size - min_size;
 	}
@@ -1046,83 +870,38 @@
 			SLJIT_ASSERT(r2_offset == sizeof(sljit_sw));
 			EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), 0, SLJIT_R0, 0);
 		}
 		EMIT_MOV(compiler, SLJIT_R0, 0, src, srcw);
 	}
 
 	/* Restore saved registers. */
-	offset = stack_size - prev_args_size - 2 * SSIZE_OF(sw);
+	offset = stack_size - 2 * SSIZE_OF(sw);
 	EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_MEM1(SLJIT_SP), offset);
 
 	if (compiler->saveds > 2 || compiler->scratches > 9) {
 		offset -= SSIZE_OF(sw);
 		EMIT_MOV(compiler, SLJIT_S2, 0, SLJIT_MEM1(SLJIT_SP), offset);
 	}
-	if (compiler->saveds > 1 || compiler->scratches > 10) {
+	if ((compiler->saveds > 1 && kept_saveds_count <= 1) || compiler->scratches > 10) {
 		offset -= SSIZE_OF(sw);
 		EMIT_MOV(compiler, SLJIT_S1, 0, SLJIT_MEM1(SLJIT_SP), offset);
 	}
-	if (compiler->saveds > 0 || compiler->scratches > 11) {
+	if ((compiler->saveds > 0 && kept_saveds_count == 0) || compiler->scratches > 11) {
 		offset -= SSIZE_OF(sw);
 		EMIT_MOV(compiler, SLJIT_S0, 0, SLJIT_MEM1(SLJIT_SP), offset);
 	}
 
 	/* Copy fourth argument and return address. */
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	if (fast_call) {
-		offset = stack_size;
-		*extra_space = 0;
-
-		if (word_arg_count >= 4 && prev_args_size == 0) {
-			offset -= SSIZE_OF(sw);
-			inst = emit_x86_instruction(compiler, 1, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), offset);
-			FAIL_IF(!inst);
-			*inst = XCHG_r_rm;
-
-			SLJIT_ASSERT(args_size != prev_args_size);
-		} else {
-			if (word_arg_count >= 4) {
-				offset -= SSIZE_OF(sw);
-				EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R2, 0);
-			}
+	offset = stack_size - SSIZE_OF(sw);
+	*extra_space = args_size;
 
-			if (args_size != prev_args_size)
-				EMIT_MOV(compiler, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), stack_size - prev_args_size - SSIZE_OF(sw));
-		}
-
-		if (args_size != prev_args_size)
-			EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), stack_size - args_size - SSIZE_OF(sw), SLJIT_R2, 0);
-	} else {
-#endif /* SLJIT_X86_32_FASTCALL */
-		offset = stack_size - SSIZE_OF(sw);
-		*extra_space = args_size;
-
-		if (word_arg_count >= 4 && prev_args_size == SSIZE_OF(sw)) {
-			offset -= SSIZE_OF(sw);
-			inst = emit_x86_instruction(compiler, 1, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), offset);
-			FAIL_IF(!inst);
-			*inst = XCHG_r_rm;
-
-			SLJIT_ASSERT(prev_args_size > 0);
-		} else {
-			if (word_arg_count >= 4) {
-				offset -= SSIZE_OF(sw);
-				EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R2, 0);
-			}
-
-			if (prev_args_size > 0)
-				EMIT_MOV(compiler, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), stack_size - prev_args_size - SSIZE_OF(sw));
-		}
-
-		/* Copy return address. */
-		if (prev_args_size > 0)
-			EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), stack_size - SSIZE_OF(sw), SLJIT_R2, 0);
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
+	if (word_arg_count >= 4) {
+		offset -= SSIZE_OF(sw);
+		EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R2, 0);
 	}
-#endif /* SLJIT_X86_32_FASTCALL */
 
 	while (types != 0) {
 		switch (types & SLJIT_ARG_MASK) {
 		case SLJIT_ARG_TYPE_F64:
 			offset -= SSIZE_OF(f64);
 			FAIL_IF(emit_sse2_store(compiler, 0, SLJIT_MEM1(SLJIT_SP), offset, float_arg_count));
 			float_arg_count--;
@@ -1131,32 +910,22 @@
 			offset -= SSIZE_OF(f32);
 			FAIL_IF(emit_sse2_store(compiler, 0, SLJIT_MEM1(SLJIT_SP), offset, float_arg_count));
 			float_arg_count--;
 			break;
 		default:
 			switch (word_arg_count) {
 			case 1:
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-				if (fast_call) {
-					EMIT_MOV(compiler, SLJIT_R2, 0, r2_offset != 0 ? SLJIT_MEM1(SLJIT_SP) : SLJIT_R0, 0);
-					break;
-				}
-#endif
 				offset -= SSIZE_OF(sw);
 				if (r2_offset != 0) {
 					EMIT_MOV(compiler, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), 0);
 					EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R2, 0);
 				} else
 					EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R0, 0);
 				break;
 			case 2:
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-				if (fast_call)
-					break;
-#endif
 				offset -= SSIZE_OF(sw);
 				EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R1, 0);
 				break;
 			case 3:
 				offset -= SSIZE_OF(sw);
 				EMIT_MOV(compiler, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), r2_offset);
 				EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, SLJIT_R2, 0);
@@ -1164,20 +933,14 @@
 			}
 			word_arg_count--;
 			break;
 		}
 		types >>= SLJIT_ARG_SHIFT;
 	}
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	/* Skip return address. */
-	if (fast_call)
-		offset -= SSIZE_OF(sw);
-#endif
-
 	SLJIT_ASSERT(offset >= 0);
 
 	if (offset == 0)
 		return SLJIT_SUCCESS;
 
 	BINARY_IMM32(ADD, offset, SLJIT_SP, 0);
 	return SLJIT_SUCCESS;
@@ -1194,163 +957,193 @@
 	FAIL_IF(!inst);
 	INC_SIZE(1);
 	RET();
 
 	return SLJIT_SUCCESS;
 }
 
+static sljit_s32 tail_call_reg_arg_with_args(struct sljit_compiler *compiler, sljit_s32 arg_types)
+{
+	sljit_s32 word_arg_count = 0;
+	sljit_s32 kept_saveds_count, offset;
+
+	arg_types >>= SLJIT_ARG_SHIFT;
+
+	while (arg_types) {
+		if ((arg_types & SLJIT_ARG_MASK) < SLJIT_ARG_TYPE_F64)
+			word_arg_count++;
+
+		arg_types >>= SLJIT_ARG_SHIFT;
+	}
+
+	if (word_arg_count < 4)
+		return SLJIT_SUCCESS;
+
+	EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_MEM1(SLJIT_SP), 2 * SSIZE_OF(sw));
+
+	kept_saveds_count = SLJIT_KEPT_SAVEDS_COUNT(compiler->options);
+	offset = compiler->local_size + 3 * SSIZE_OF(sw);
+
+	if ((compiler->saveds > 0 && kept_saveds_count == 0) || compiler->scratches > 11)
+		offset += SSIZE_OF(sw);
+	if ((compiler->saveds > 1 && kept_saveds_count <= 1) || compiler->scratches > 10)
+		offset += SSIZE_OF(sw);
+	if ((compiler->saveds > 2 && kept_saveds_count <= 2) || compiler->scratches > 9)
+		offset += SSIZE_OF(sw);
+
+	return emit_mov(compiler, SLJIT_MEM1(SLJIT_SP), offset, TMP_REG1, 0);
+}
+
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 arg_types)
 {
 	struct sljit_jump *jump;
 	sljit_sw stack_size = 0;
 	sljit_s32 word_arg_count;
 
 	CHECK_ERROR_PTR();
 	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
 
 	if (type & SLJIT_CALL_RETURN) {
+		if ((type & 0xff) == SLJIT_CALL_REG_ARG) {
+			PTR_FAIL_IF(tail_call_reg_arg_with_args(compiler, arg_types));
+			PTR_FAIL_IF(emit_stack_frame_release(compiler, 0));
+
+			SLJIT_SKIP_CHECKS(compiler);
+			return sljit_emit_jump(compiler, SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP));
+		}
+
 		stack_size = type;
 		PTR_FAIL_IF(tail_call_with_args(compiler, &stack_size, arg_types, SLJIT_IMM, 0));
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-			|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-		compiler->skip_checks = 1;
-#endif
+		SLJIT_SKIP_CHECKS(compiler);
 
-		if (stack_size == 0) {
-			type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
-			return sljit_emit_jump(compiler, type);
-		}
+		if (stack_size == 0)
+			return sljit_emit_jump(compiler, SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP));
 
 		jump = sljit_emit_jump(compiler, type);
 		PTR_FAIL_IF(jump == NULL);
 
 		PTR_FAIL_IF(emit_tail_call_end(compiler, stack_size));
 		return jump;
 	}
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	if ((type & 0xff) == SLJIT_CALL) {
-		stack_size = c_fast_call_get_stack_size(arg_types, &word_arg_count);
-		PTR_FAIL_IF(c_fast_call_with_args(compiler, arg_types, stack_size, word_arg_count, 0));
-
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-		compiler->skip_checks = 1;
-#endif
-
-		jump = sljit_emit_jump(compiler, type);
-		PTR_FAIL_IF(jump == NULL);
-
-		PTR_FAIL_IF(post_call_with_args(compiler, arg_types, 0));
-		return jump;
+	if ((type & 0xff) == SLJIT_CALL_REG_ARG) {
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_jump(compiler, type);
 	}
-#endif
 
-	stack_size = cdecl_call_get_stack_size(compiler, arg_types, &word_arg_count);
-	PTR_FAIL_IF(cdecl_call_with_args(compiler, arg_types, stack_size, word_arg_count));
-
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	stack_size = call_get_stack_size(arg_types, &word_arg_count);
+	PTR_FAIL_IF(call_with_args(compiler, arg_types, stack_size, word_arg_count, 0));
 
+	SLJIT_SKIP_CHECKS(compiler);
 	jump = sljit_emit_jump(compiler, type);
 	PTR_FAIL_IF(jump == NULL);
 
 	PTR_FAIL_IF(post_call_with_args(compiler, arg_types, stack_size));
 	return jump;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_icall(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 arg_types,
 	sljit_s32 src, sljit_sw srcw)
 {
 	sljit_sw stack_size = 0;
 	sljit_s32 word_arg_count;
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	sljit_s32 swap_args;
-#endif
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_icall(compiler, type, arg_types, src, srcw));
 
 	if (type & SLJIT_CALL_RETURN) {
+		if ((type & 0xff) == SLJIT_CALL_REG_ARG) {
+			FAIL_IF(tail_call_reg_arg_with_args(compiler, arg_types));
+
+			if ((src & SLJIT_MEM) || (src > SLJIT_R2 && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options)))) {
+				ADJUST_LOCAL_OFFSET(src, srcw);
+				CHECK_EXTRA_REGS(src, srcw, (void)0);
+
+				EMIT_MOV(compiler, TMP_REG1, 0, src, srcw);
+				src = TMP_REG1;
+				srcw = 0;
+			}
+
+			FAIL_IF(emit_stack_frame_release(compiler, 0));
+
+			SLJIT_SKIP_CHECKS(compiler);
+			return sljit_emit_ijump(compiler, SLJIT_JUMP, src, srcw);
+		}
+
 		stack_size = type;
 		FAIL_IF(tail_call_with_args(compiler, &stack_size, arg_types, src, srcw));
 
 		if (!(src & SLJIT_IMM)) {
 			src = SLJIT_R0;
 			srcw = 0;
 		}
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-			|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-		compiler->skip_checks = 1;
-#endif
+		SLJIT_SKIP_CHECKS(compiler);
 
 		if (stack_size == 0)
 			return sljit_emit_ijump(compiler, SLJIT_JUMP, src, srcw);
 
 		FAIL_IF(sljit_emit_ijump(compiler, type, src, srcw));
 		return emit_tail_call_end(compiler, stack_size);
 	}
 
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	SLJIT_ASSERT(reg_map[SLJIT_R0] == 0 && reg_map[SLJIT_R2] == 1 && SLJIT_R0 == 1 && SLJIT_R2 == 3);
+	if ((type & 0xff) == SLJIT_CALL_REG_ARG) {
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_ijump(compiler, type, src, srcw);
+	}
 
-	if ((type & 0xff) == SLJIT_CALL) {
-		stack_size = c_fast_call_get_stack_size(arg_types, &word_arg_count);
-		swap_args = 0;
-
-		if (word_arg_count > 0) {
-			if ((src & REG_MASK) == SLJIT_R2 || OFFS_REG(src) == SLJIT_R2) {
-				swap_args = 1;
-				if (((src & REG_MASK) | 0x2) == SLJIT_R2)
-					src ^= 0x2;
-				if ((OFFS_REG(src) | 0x2) == SLJIT_R2)
-					src ^= TO_OFFS_REG(0x2);
-			}
-		}
+	ADJUST_LOCAL_OFFSET(src, srcw);
+	CHECK_EXTRA_REGS(src, srcw, (void)0);
 
-		FAIL_IF(c_fast_call_with_args(compiler, arg_types, stack_size, word_arg_count, swap_args));
+	if (src & SLJIT_MEM) {
+		EMIT_MOV(compiler, TMP_REG1, 0, src, srcw);
+		src = TMP_REG1;
+		srcw = 0;
+	}
 
-		compiler->scratches_offset += stack_size;
-		compiler->locals_offset += stack_size;
+	stack_size = call_get_stack_size(arg_types, &word_arg_count);
+	FAIL_IF(call_with_args(compiler, arg_types, stack_size, word_arg_count, src == TMP_REG1));
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-		compiler->skip_checks = 1;
-#endif
-		FAIL_IF(sljit_emit_ijump(compiler, type, src, srcw));
+	if (stack_size > 0 && src == SLJIT_MEM1(SLJIT_SP))
+		srcw += stack_size;
 
-		compiler->scratches_offset -= stack_size;
-		compiler->locals_offset -= stack_size;
+	SLJIT_SKIP_CHECKS(compiler);
+	FAIL_IF(sljit_emit_ijump(compiler, type, src, srcw));
 
-		return post_call_with_args(compiler, arg_types, 0);
-	}
-#endif
+	return post_call_with_args(compiler, arg_types, stack_size);
+}
 
-	stack_size = cdecl_call_get_stack_size(compiler, arg_types, &word_arg_count);
-	FAIL_IF(cdecl_call_with_args(compiler, arg_types, stack_size, word_arg_count));
+static SLJIT_INLINE sljit_s32 emit_fmov_before_return(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 src, sljit_sw srcw)
+{
+	sljit_u8* inst;
 
-	compiler->scratches_offset += stack_size;
-	compiler->locals_offset += stack_size;
+	if (compiler->options & SLJIT_ENTER_REG_ARG) {
+		if (src == SLJIT_FR0)
+			return SLJIT_SUCCESS;
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
-	FAIL_IF(sljit_emit_ijump(compiler, type, src, srcw));
+		SLJIT_SKIP_CHECKS(compiler);
+		return sljit_emit_fop1(compiler, op, SLJIT_RETURN_FREG, 0, src, srcw);
+	}
+
+	if (FAST_IS_REG(src)) {
+		FAIL_IF(emit_sse2_store(compiler, op & SLJIT_32, SLJIT_MEM1(SLJIT_SP), 0, src));
+
+		src = SLJIT_MEM1(SLJIT_SP);
+		srcw = 0;
+	} else {
+		ADJUST_LOCAL_OFFSET(src, srcw);
+	}
 
-	compiler->scratches_offset -= stack_size;
-	compiler->locals_offset -= stack_size;
+	inst = emit_x86_instruction(compiler, 1 | EX86_SSE2_OP1, 0, 0, src, srcw);
+	*inst = (op & SLJIT_32) ? FLDS : FLDL;
 
-	return post_call_with_args(compiler, arg_types, stack_size);
+	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw)
 {
 	sljit_u8 *inst;
 
 	CHECK_ERROR();
@@ -1400,14 +1193,96 @@
 		INC_SIZE(1);
 	}
 
 	RET();
 	return SLJIT_SUCCESS;
 }
 
+/* --------------------------------------------------------------------- */
+/*  Other operations                                                     */
+/* --------------------------------------------------------------------- */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	sljit_u8* inst;
+	sljit_s32 i, next, reg_idx, offset;
+	sljit_u8 regs[2];
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_mem(compiler, type, reg, mem, memw));
+
+	if (!(reg & REG_PAIR_MASK))
+		return sljit_emit_mem_unaligned(compiler, type, reg, mem, memw);
+
+	ADJUST_LOCAL_OFFSET(mem, memw);
+
+	regs[0] = U8(REG_PAIR_FIRST(reg));
+	regs[1] = U8(REG_PAIR_SECOND(reg));
+
+	next = SSIZE_OF(sw);
+
+	if (!(type & SLJIT_MEM_STORE) && (regs[0] == (mem & REG_MASK) || regs[0] == OFFS_REG(mem))) {
+		if (regs[1] == (mem & REG_MASK) || regs[1] == OFFS_REG(mem)) {
+			/* None of them are virtual register so TMP_REG1 will not be used. */
+			EMIT_MOV(compiler, TMP_REG1, 0, OFFS_REG(mem), 0);
+
+			if (regs[1] == OFFS_REG(mem))
+				next = -SSIZE_OF(sw);
+
+			mem = (mem & ~OFFS_REG_MASK) | TO_OFFS_REG(TMP_REG1);
+		} else {
+			next = -SSIZE_OF(sw);
+
+			if (!(mem & OFFS_REG_MASK))
+				memw += SSIZE_OF(sw);
+		}
+	}
+
+	for (i = 0; i < 2; i++) {
+		reg_idx = next > 0 ? i : (i ^ 0x1);
+		reg = regs[reg_idx];
+
+		offset = -1;
+
+		if (reg >= SLJIT_R3 && reg <= SLJIT_S3) {
+			offset = (2 * SSIZE_OF(sw)) + ((reg) - SLJIT_R3) * SSIZE_OF(sw);
+			reg = TMP_REG1;
+
+			if (type & SLJIT_MEM_STORE)
+				EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_MEM1(SLJIT_SP), offset);
+		}
+
+		if ((mem & OFFS_REG_MASK) && (reg_idx == 1)) {
+			inst = (sljit_u8*)ensure_buf(compiler, (sljit_uw)(1 + 4));
+			FAIL_IF(!inst);
+
+			INC_SIZE(4);
+
+			inst[0] = (type & SLJIT_MEM_STORE) ? MOV_rm_r : MOV_r_rm;
+			inst[1] = 0x44 | U8(reg_map[reg] << 3);
+			inst[2] = U8(memw << 6) | U8(reg_map[OFFS_REG(mem)] << 3) | reg_map[mem & REG_MASK];
+			inst[3] = sizeof(sljit_sw);
+		} else if (type & SLJIT_MEM_STORE) {
+			EMIT_MOV(compiler, mem, memw, reg, 0);
+		} else {
+			EMIT_MOV(compiler, reg, 0, mem, memw);
+		}
+
+		if (!(mem & OFFS_REG_MASK))
+			memw += next;
+
+		if (!(type & SLJIT_MEM_STORE) && offset != -1)
+			EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), offset, TMP_REG1, 0);
+	}
+
+	return SLJIT_SUCCESS;
+}
+
 static sljit_s32 skip_frames_before_return(struct sljit_compiler *compiler)
 {
 	sljit_sw size;
 
 	/* Don't adjust shadow stack if it isn't enabled.  */
 	if (!cpu_has_shadow_stack())
 		return SLJIT_SUCCESS;
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeX86_64.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeX86_64.c`

 * *Files 4% similar despite different names*

```diff
@@ -97,42 +97,46 @@
 		inst_size++;
 	if (flags & EX86_PREF_66)
 		inst_size++;
 
 	/* Calculate size of b. */
 	inst_size += 1; /* mod r/m byte. */
 	if (b & SLJIT_MEM) {
-		if (!(b & OFFS_REG_MASK)) {
-			if (NOT_HALFWORD(immb)) {
-				PTR_FAIL_IF(emit_load_imm64(compiler, TMP_REG2, immb));
-				immb = 0;
-				if (b & REG_MASK)
-					b |= TO_OFFS_REG(TMP_REG2);
-				else
-					b |= TMP_REG2;
-			}
-			else if (reg_lmap[b & REG_MASK] == 4)
-				b |= TO_OFFS_REG(SLJIT_SP);
+		if (!(b & OFFS_REG_MASK) && NOT_HALFWORD(immb)) {
+			PTR_FAIL_IF(emit_load_imm64(compiler, TMP_REG2, immb));
+			immb = 0;
+			if (b & REG_MASK)
+				b |= TO_OFFS_REG(TMP_REG2);
+			else
+				b |= TMP_REG2;
 		}
 
 		if (!(b & REG_MASK))
 			inst_size += 1 + sizeof(sljit_s32); /* SIB byte required to avoid RIP based addressing. */
 		else {
-			if (reg_map[b & REG_MASK] >= 8)
-				rex |= REX_B;
-
-			if (immb != 0 && (!(b & OFFS_REG_MASK) || (b & OFFS_REG_MASK) == TO_OFFS_REG(SLJIT_SP))) {
+			if (immb != 0 && !(b & OFFS_REG_MASK)) {
 				/* Immediate operand. */
 				if (immb <= 127 && immb >= -128)
 					inst_size += sizeof(sljit_s8);
 				else
 					inst_size += sizeof(sljit_s32);
 			}
-			else if (reg_lmap[b & REG_MASK] == 5)
-				inst_size += sizeof(sljit_s8);
+			else if (reg_lmap[b & REG_MASK] == 5) {
+				/* Swap registers if possible. */
+				if ((b & OFFS_REG_MASK) && (immb & 0x3) == 0 && reg_lmap[OFFS_REG(b)] != 5)
+					b = SLJIT_MEM | OFFS_REG(b) | TO_OFFS_REG(b & REG_MASK);
+				else
+					inst_size += sizeof(sljit_s8);
+			}
+
+			if (reg_map[b & REG_MASK] >= 8)
+				rex |= REX_B;
+
+			if (reg_lmap[b & REG_MASK] == 4 && !(b & OFFS_REG_MASK))
+				b |= TO_OFFS_REG(SLJIT_SP);
 
 			if (b & OFFS_REG_MASK) {
 				inst_size += 1; /* SIB byte. */
 				if (reg_map[OFFS_REG(b)] >= 8)
 					rex |= REX_X;
 			}
 		}
@@ -149,17 +153,17 @@
 			if (imma <= 127 && imma >= -128) {
 				inst_size += 1;
 				flags |= EX86_BYTE_ARG;
 			} else
 				inst_size += 4;
 		}
 		else if (flags & EX86_SHIFT_INS) {
-			imma &= compiler->mode32 ? 0x1f : 0x3f;
+			SLJIT_ASSERT(imma <= (compiler->mode32 ? 0x1f : 0x3f));
 			if (imma != 1) {
-				inst_size ++;
+				inst_size++;
 				flags |= EX86_BYTE_ARG;
 			}
 		} else if (flags & EX86_BYTE_ARG)
 			inst_size++;
 		else if (flags & EX86_HALF_ARG)
 			inst_size += sizeof(short);
 		else
@@ -219,15 +223,15 @@
 
 	if (!(b & SLJIT_MEM)) {
 		*buf_ptr = U8(*buf_ptr | MOD_REG | (!(flags & EX86_SSE2_OP2) ? reg_lmap[b] : freg_lmap[b]));
 		buf_ptr++;
 	} else if (b & REG_MASK) {
 		reg_lmap_b = reg_lmap[b & REG_MASK];
 
-		if (!(b & OFFS_REG_MASK) || (b & OFFS_REG_MASK) == TO_OFFS_REG(SLJIT_SP) || reg_lmap_b == 5) {
+		if (!(b & OFFS_REG_MASK) || (b & OFFS_REG_MASK) == TO_OFFS_REG(SLJIT_SP)) {
 			if (immb != 0 || reg_lmap_b == 5) {
 				if (immb <= 127 && immb >= -128)
 					*buf_ptr |= 0x40;
 				else
 					*buf_ptr |= 0x80;
 			}
 
@@ -244,16 +248,22 @@
 				else {
 					sljit_unaligned_store_s32(buf_ptr, (sljit_s32)immb); /* 32 bit displacement. */
 					buf_ptr += sizeof(sljit_s32);
 				}
 			}
 		}
 		else {
+			if (reg_lmap_b == 5)
+				*buf_ptr |= 0x40;
+
 			*buf_ptr++ |= 0x04;
 			*buf_ptr++ = U8(reg_lmap_b | (reg_lmap[OFFS_REG(b)] << 3) | (immb << 6));
+
+			if (reg_lmap_b == 5)
+				*buf_ptr++ = 0;
 		}
 	}
 	else {
 		*buf_ptr++ |= 0x04;
 		*buf_ptr++ = 0x25;
 		sljit_unaligned_store_s32(buf_ptr, (sljit_s32)immb); /* 32 bit displacement. */
 		buf_ptr += sizeof(sljit_s32);
@@ -362,37 +372,40 @@
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_enter(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
 	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
 {
 	sljit_uw size;
 	sljit_s32 word_arg_count = 0;
-	sljit_s32 saved_arg_count = 0;
+	sljit_s32 saved_arg_count = SLJIT_KEPT_SAVEDS_COUNT(options);
 	sljit_s32 saved_regs_size, tmp, i;
 #ifdef _WIN64
 	sljit_s32 saved_float_regs_size;
 	sljit_s32 saved_float_regs_offset = 0;
 	sljit_s32 float_arg_count = 0;
 #endif /* _WIN64 */
 	sljit_u8 *inst;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
 	set_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
 
+	if (options & SLJIT_ENTER_REG_ARG)
+		arg_types = 0;
+
 	/* Emit ENDBR64 at function entry if needed.  */
 	FAIL_IF(emit_endbranch(compiler));
 
 	compiler->mode32 = 0;
 
 	/* Including the return address saved by the call instruction. */
-	saved_regs_size = GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1);
+	saved_regs_size = GET_SAVED_REGISTERS_SIZE(scratches, saveds - saved_arg_count, 1);
 
 	tmp = SLJIT_S0 - saveds;
-	for (i = SLJIT_S0; i > tmp; i--) {
+	for (i = SLJIT_S0 - saved_arg_count; i > tmp; i--) {
 		size = reg_map[i] >= 8 ? 2 : 1;
 		inst = (sljit_u8*)ensure_buf(compiler, 1 + size);
 		FAIL_IF(!inst);
 		INC_SIZE(size);
 		if (reg_map[i] >= 8)
 			*inst++ = REX_B;
 		PUSH_REG(reg_lmap[i]);
@@ -557,23 +570,23 @@
 	if (saved_float_regs_size > 0)
 		local_size = ((local_size + 0xf) & ~0xf) + saved_float_regs_size;
 #else /* !_WIN64 */
 	SLJIT_ASSERT(SLJIT_LOCALS_OFFSET == 0);
 #endif /* _WIN64 */
 
 	/* Including the return address saved by the call instruction. */
-	saved_regs_size = GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1);
+	saved_regs_size = GET_SAVED_REGISTERS_SIZE(scratches, saveds - SLJIT_KEPT_SAVEDS_COUNT(options), 1);
 	compiler->local_size = ((local_size + saved_regs_size + 0xf) & ~0xf) - saved_regs_size;
 	return SLJIT_SUCCESS;
 }
 
-static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler)
+static sljit_s32 emit_stack_frame_release(struct sljit_compiler *compiler, sljit_s32 is_return_to)
 {
 	sljit_uw size;
-	sljit_s32 i, tmp;
+	sljit_s32 local_size, i, tmp;
 	sljit_u8 *inst;
 #ifdef _WIN64
 	sljit_s32 saved_float_regs_offset;
 	sljit_s32 fscratches = compiler->fscratches;
 	sljit_s32 fsaveds = compiler->fsaveds;
 #endif /* _WIN64 */
 
@@ -594,79 +607,97 @@
 
 		for (i = fscratches; i >= SLJIT_FIRST_SAVED_FLOAT_REG; i--) {
 			inst = emit_x86_instruction(compiler, 2 | EX86_SSE2, i, 0, SLJIT_MEM1(SLJIT_SP), saved_float_regs_offset);
 			*inst++ = GROUP_0F;
 			*inst = MOVAPS_x_xm;
 			saved_float_regs_offset += 16;
 		}
+
+		compiler->mode32 = 0;
 	}
 #endif /* _WIN64 */
 
-	if (compiler->local_size > 0) {
-		if (compiler->local_size <= 127) {
-			inst = (sljit_u8*)ensure_buf(compiler, 1 + 4);
-			FAIL_IF(!inst);
-			INC_SIZE(4);
-			*inst++ = REX_W;
-			*inst++ = GROUP_BINARY_83;
-			*inst++ = MOD_REG | ADD | 4;
-			*inst = U8(compiler->local_size);
-		}
-		else {
-			inst = (sljit_u8*)ensure_buf(compiler, 1 + 7);
-			FAIL_IF(!inst);
-			INC_SIZE(7);
-			*inst++ = REX_W;
-			*inst++ = GROUP_BINARY_81;
-			*inst++ = MOD_REG | ADD | 4;
-			sljit_unaligned_store_s32(inst, compiler->local_size);
-		}
+	local_size = compiler->local_size;
+
+	if (is_return_to && compiler->scratches < SLJIT_FIRST_SAVED_REG && (compiler->saveds == SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
+		local_size += SSIZE_OF(sw);
+		is_return_to = 0;
 	}
 
+	if (local_size > 0)
+		BINARY_IMM32(ADD, local_size, SLJIT_SP, 0);
+
 	tmp = compiler->scratches;
 	for (i = SLJIT_FIRST_SAVED_REG; i <= tmp; i++) {
 		size = reg_map[i] >= 8 ? 2 : 1;
 		inst = (sljit_u8*)ensure_buf(compiler, 1 + size);
 		FAIL_IF(!inst);
 		INC_SIZE(size);
 		if (reg_map[i] >= 8)
 			*inst++ = REX_B;
 		POP_REG(reg_lmap[i]);
 	}
 
-	tmp = compiler->saveds < SLJIT_NUMBER_OF_SAVED_REGISTERS ? (SLJIT_S0 + 1 - compiler->saveds) : SLJIT_FIRST_SAVED_REG;
-	for (i = tmp; i <= SLJIT_S0; i++) {
+	tmp = SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options);
+	for (i = SLJIT_S0 + 1 - compiler->saveds; i <= tmp; i++) {
 		size = reg_map[i] >= 8 ? 2 : 1;
 		inst = (sljit_u8*)ensure_buf(compiler, 1 + size);
 		FAIL_IF(!inst);
 		INC_SIZE(size);
 		if (reg_map[i] >= 8)
 			*inst++ = REX_B;
 		POP_REG(reg_lmap[i]);
 	}
 
+	if (is_return_to)
+		BINARY_IMM32(ADD, sizeof(sljit_sw), SLJIT_SP, 0);
+
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_void(struct sljit_compiler *compiler)
 {
 	sljit_u8 *inst;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_return_void(compiler));
 
-	FAIL_IF(emit_stack_frame_release(compiler));
+	compiler->mode32 = 0;
+
+	FAIL_IF(emit_stack_frame_release(compiler, 0));
 
 	inst = (sljit_u8*)ensure_buf(compiler, 1 + 1);
 	FAIL_IF(!inst);
 	INC_SIZE(1);
 	RET();
 	return SLJIT_SUCCESS;
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return_to(struct sljit_compiler *compiler,
+	sljit_s32 src, sljit_sw srcw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_return_to(compiler, src, srcw));
+
+	compiler->mode32 = 0;
+
+	if ((src & SLJIT_MEM) || (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options)))) {
+		ADJUST_LOCAL_OFFSET(src, srcw);
+
+		EMIT_MOV(compiler, TMP_REG2, 0, src, srcw);
+		src = TMP_REG2;
+		srcw = 0;
+	}
+
+	FAIL_IF(emit_stack_frame_release(compiler, 1));
+
+	SLJIT_SKIP_CHECKS(compiler);
+	return sljit_emit_ijump(compiler, SLJIT_JUMP, src, srcw);
+}
+
 /* --------------------------------------------------------------------- */
 /*  Call / return instructions                                           */
 /* --------------------------------------------------------------------- */
 
 #ifndef _WIN64
 
 static sljit_s32 call_with_args(struct sljit_compiler *compiler, sljit_s32 arg_types, sljit_s32 *src_ptr)
@@ -782,25 +813,23 @@
 	sljit_s32 arg_types)
 {
 	CHECK_ERROR_PTR();
 	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
 
 	compiler->mode32 = 0;
 
-	PTR_FAIL_IF(call_with_args(compiler, arg_types, NULL));
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG)
+		PTR_FAIL_IF(call_with_args(compiler, arg_types, NULL));
 
 	if (type & SLJIT_CALL_RETURN) {
-		PTR_FAIL_IF(emit_stack_frame_release(compiler));
+		PTR_FAIL_IF(emit_stack_frame_release(compiler, 0));
 		type = SLJIT_JUMP | (type & SLJIT_REWRITABLE_JUMP);
 	}
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_jump(compiler, type);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_icall(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 arg_types,
 	sljit_s32 src, sljit_sw srcw)
 {
@@ -812,30 +841,29 @@
 	if (src & SLJIT_MEM) {
 		ADJUST_LOCAL_OFFSET(src, srcw);
 		EMIT_MOV(compiler, TMP_REG2, 0, src, srcw);
 		src = TMP_REG2;
 	}
 
 	if (type & SLJIT_CALL_RETURN) {
-		if (src >= SLJIT_FIRST_SAVED_REG && src <= SLJIT_S0) {
+		if (src >= SLJIT_FIRST_SAVED_REG && src <= (SLJIT_S0 - SLJIT_KEPT_SAVEDS_COUNT(compiler->options))) {
 			EMIT_MOV(compiler, TMP_REG2, 0, src, srcw);
 			src = TMP_REG2;
 		}
 
-		FAIL_IF(emit_stack_frame_release(compiler));
-		type = SLJIT_JUMP;
+		FAIL_IF(emit_stack_frame_release(compiler, 0));
 	}
 
-	FAIL_IF(call_with_args(compiler, arg_types, &src));
+	if ((type & 0xff) != SLJIT_CALL_REG_ARG)
+		FAIL_IF(call_with_args(compiler, arg_types, &src));
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	if (type & SLJIT_CALL_RETURN)
+		type = SLJIT_JUMP;
 
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_ijump(compiler, type, src, srcw);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw)
 {
 	sljit_u8 *inst;
 
@@ -903,17 +931,97 @@
 	}
 
 	RET();
 	return SLJIT_SUCCESS;
 }
 
 /* --------------------------------------------------------------------- */
-/*  Extend input                                                         */
+/*  Other operations                                                     */
 /* --------------------------------------------------------------------- */
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_mem(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 reg,
+	sljit_s32 mem, sljit_sw memw)
+{
+	sljit_u8* inst;
+	sljit_s32 i, next, reg_idx;
+	sljit_u8 regs[2];
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_mem(compiler, type, reg, mem, memw));
+
+	if (!(reg & REG_PAIR_MASK))
+		return sljit_emit_mem_unaligned(compiler, type, reg, mem, memw);
+
+	ADJUST_LOCAL_OFFSET(mem, memw);
+
+	compiler->mode32 = 0;
+
+	if ((mem & REG_MASK) == 0) {
+		EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_IMM, memw);
+
+		mem = SLJIT_MEM1(TMP_REG1);
+		memw = 0;
+	} else if (!(mem & OFFS_REG_MASK) && ((memw < HALFWORD_MIN) || (memw > HALFWORD_MAX - SSIZE_OF(sw)))) {
+		EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_IMM, memw);
+
+		mem = SLJIT_MEM2(mem & REG_MASK, TMP_REG1);
+		memw = 0;
+	}
+
+	regs[0] = U8(REG_PAIR_FIRST(reg));
+	regs[1] = U8(REG_PAIR_SECOND(reg));
+
+	next = SSIZE_OF(sw);
+
+	if (!(type & SLJIT_MEM_STORE) && (regs[0] == (mem & REG_MASK) || regs[0] == OFFS_REG(mem))) {
+		if (regs[1] == (mem & REG_MASK) || regs[1] == OFFS_REG(mem)) {
+			/* Base and offset cannot be TMP_REG1. */
+			EMIT_MOV(compiler, TMP_REG1, 0, OFFS_REG(mem), 0);
+
+			if (regs[1] == OFFS_REG(mem))
+				next = -SSIZE_OF(sw);
+
+			mem = (mem & ~OFFS_REG_MASK) | TO_OFFS_REG(TMP_REG1);
+		} else {
+			next = -SSIZE_OF(sw);
+
+			if (!(mem & OFFS_REG_MASK))
+				memw += SSIZE_OF(sw);
+		}
+	}
+
+	for (i = 0; i < 2; i++) {
+		reg_idx = next > 0 ? i : (i ^ 0x1);
+		reg = regs[reg_idx];
+
+		if ((mem & OFFS_REG_MASK) && (reg_idx == 1)) {
+			inst = (sljit_u8*)ensure_buf(compiler, (sljit_uw)(1 + 5));
+			FAIL_IF(!inst);
+
+			INC_SIZE(5);
+
+			inst[0] = U8(REX_W | ((reg_map[reg] >= 8) ? REX_R : 0) | ((reg_map[mem & REG_MASK] >= 8) ? REX_B : 0) | ((reg_map[OFFS_REG(mem)] >= 8) ? REX_X : 0));
+			inst[1] = (type & SLJIT_MEM_STORE) ? MOV_rm_r : MOV_r_rm;
+			inst[2] = 0x44 | U8(reg_lmap[reg] << 3);
+			inst[3] = U8(memw << 6) | U8(reg_lmap[OFFS_REG(mem)] << 3) | reg_lmap[mem & REG_MASK];
+			inst[4] = sizeof(sljit_sw);
+		} else if (type & SLJIT_MEM_STORE) {
+			EMIT_MOV(compiler, mem, memw, reg, 0);
+		} else {
+			EMIT_MOV(compiler, reg, 0, mem, memw);
+		}
+
+		if (!(mem & OFFS_REG_MASK))
+			memw += next;
+	}
+
+	return SLJIT_SUCCESS;
+}
+
 static sljit_s32 emit_mov_int(struct sljit_compiler *compiler, sljit_s32 sign,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src, sljit_sw srcw)
 {
 	sljit_u8* inst;
 	sljit_s32 dst_r;
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitNativeX86_common.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitNativeX86_common.c`

 * *Files 2% similar despite different names*

```diff
@@ -22,19 +22,15 @@
  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 SLJIT_API_FUNC_ATTRIBUTE const char* sljit_get_platform_name(void)
 {
-#if (defined SLJIT_X86_32_FASTCALL && SLJIT_X86_32_FASTCALL)
-	return "x86" SLJIT_CPUINFO " ABI:fastcall";
-#else
 	return "x86" SLJIT_CPUINFO;
-#endif
 }
 
 /*
    32b register indexes:
      0 - EAX
      1 - ECX
      2 - EDX
@@ -74,18 +70,15 @@
 
 static const sljit_u8 reg_map[SLJIT_NUMBER_OF_REGISTERS + 3] = {
 	0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 7, 6, 3, 4, 5
 };
 
 #define CHECK_EXTRA_REGS(p, w, do) \
 	if (p >= SLJIT_R3 && p <= SLJIT_S3) { \
-		if (p <= compiler->scratches) \
-			w = compiler->scratches_offset + ((p) - SLJIT_R3) * SSIZE_OF(sw); \
-		else \
-			w = compiler->locals_offset + ((p) - SLJIT_S2) * SSIZE_OF(sw); \
+		w = (2 * SSIZE_OF(sw)) + ((p) - SLJIT_R3) * SSIZE_OF(sw); \
 		p = SLJIT_MEM1(SLJIT_SP); \
 		do; \
 	}
 
 #else /* SLJIT_CONFIG_X86_32 */
 
 /* Last register + 1. */
@@ -177,27 +170,30 @@
 #define ADC_rm_r	0x11
 #define AND		(/* BINARY */ 4 << 3)
 #define AND_EAX_i32	0x25
 #define AND_r_rm	0x23
 #define AND_rm_r	0x21
 #define ANDPD_x_xm	0x54
 #define BSR_r_rm	(/* GROUP_0F */ 0xbd)
+#define BSF_r_rm	(/* GROUP_0F */ 0xbc)
 #define CALL_i32	0xe8
 #define CALL_rm		(/* GROUP_FF */ 2 << 3)
 #define CDQ		0x99
 #define CMOVE_r_rm	(/* GROUP_0F */ 0x44)
 #define CMP		(/* BINARY */ 7 << 3)
 #define CMP_EAX_i32	0x3d
 #define CMP_r_rm	0x3b
 #define CMP_rm_r	0x39
 #define CVTPD2PS_x_xm	0x5a
 #define CVTSI2SD_x_rm	0x2a
 #define CVTTSD2SI_r_xm	0x2c
 #define DIV		(/* GROUP_F7 */ 6 << 3)
 #define DIVSD_x_xm	0x5e
+#define FLDS		0xd9
+#define FLDL		0xdd
 #define FSTPS		0xd9
 #define FSTPD		0xdd
 #define INT3		0xcc
 #define IDIV		(/* GROUP_F7 */ 7 << 3)
 #define IMUL		(/* GROUP_F7 */ 5 << 3)
 #define IMUL_r_rm	(/* GROUP_0F */ 0xaf)
 #define IMUL_r_rm_i8	0x6b
@@ -205,14 +201,15 @@
 #define JE_i8		0x74
 #define JNE_i8		0x75
 #define JMP_i8		0xeb
 #define JMP_i32		0xe9
 #define JMP_rm		(/* GROUP_FF */ 4 << 3)
 #define LEA_r_m		0x8d
 #define LOOP_i8		0xe2
+#define LZCNT_r_rm	(/* GROUP_F3 */ /* GROUP_0F */ 0xbd)
 #define MOV_r_rm	0x8b
 #define MOV_r_i32	0xb8
 #define MOV_rm_r	0x89
 #define MOV_rm_i32	0xc7
 #define MOV_rm8_i8	0xc6
 #define MOV_rm8_r8	0x88
 #define MOVAPS_x_xm	0x28
@@ -238,41 +235,47 @@
 #define POP_rm		0x8f
 #define POPF		0x9d
 #define PREFETCH	0x18
 #define PUSH_i32	0x68
 #define PUSH_r		0x50
 #define PUSH_rm		(/* GROUP_FF */ 6 << 3)
 #define PUSHF		0x9c
+#define ROL		(/* SHIFT */ 0 << 3)
+#define ROR		(/* SHIFT */ 1 << 3)
 #define RET_near	0xc3
 #define RET_i16		0xc2
 #define SBB		(/* BINARY */ 3 << 3)
 #define SBB_EAX_i32	0x1d
 #define SBB_r_rm	0x1b
 #define SBB_rm_r	0x19
 #define SAR		(/* SHIFT */ 7 << 3)
 #define SHL		(/* SHIFT */ 4 << 3)
+#define SHLD		(/* GROUP_0F */ 0xa5)
+#define SHRD		(/* GROUP_0F */ 0xad)
 #define SHR		(/* SHIFT */ 5 << 3)
 #define SUB		(/* BINARY */ 5 << 3)
 #define SUB_EAX_i32	0x2d
 #define SUB_r_rm	0x2b
 #define SUB_rm_r	0x29
 #define SUBSD_x_xm	0x5c
 #define TEST_EAX_i32	0xa9
 #define TEST_rm_r	0x85
+#define TZCNT_r_rm	(/* GROUP_F3 */ /* GROUP_0F */ 0xbc)
 #define UCOMISD_x_xm	0x2e
 #define UNPCKLPD_x_xm	0x14
 #define XCHG_EAX_r	0x90
 #define XCHG_r_rm	0x87
 #define XOR		(/* BINARY */ 6 << 3)
 #define XOR_EAX_i32	0x35
 #define XOR_r_rm	0x33
 #define XOR_rm_r	0x31
 #define XORPD_x_xm	0x57
 
 #define GROUP_0F	0x0f
+#define GROUP_F3	0xf3
 #define GROUP_F7	0xf7
 #define GROUP_FF	0xff
 #define GROUP_BINARY_81	0x81
 #define GROUP_BINARY_83	0x83
 #define GROUP_SHIFT_1	0xd1
 #define GROUP_SHIFT_N	0xc1
 #define GROUP_SHIFT_CL	0xd3
@@ -286,18 +289,23 @@
 #define POP_REG(r)			(*inst++ = U8(POP_r + (r)))
 #define RET()				(*inst++ = RET_near)
 #define RET_I16(n)			(*inst++ = RET_i16, *inst++ = U8(n), *inst++ = 0)
 
 /* Multithreading does not affect these static variables, since they store
    built-in CPU features. Therefore they can be overwritten by different threads
    if they detect the CPU features in the same time. */
+#define CPU_FEATURE_DETECTED		0x001
 #if (defined SLJIT_DETECT_SSE2 && SLJIT_DETECT_SSE2)
-static sljit_s32 cpu_has_sse2 = -1;
+#define CPU_FEATURE_SSE2		0x002
 #endif
-static sljit_s32 cpu_has_cmov = -1;
+#define CPU_FEATURE_LZCNT		0x004
+#define CPU_FEATURE_TZCNT		0x008
+#define CPU_FEATURE_CMOV		0x010
+
+static sljit_u32 cpu_feature_list = 0;
 
 #ifdef _WIN32_WCE
 #include <cmnintrin.h>
 #elif defined(_MSC_VER) && _MSC_VER >= 1400
 #include <intrin.h>
 #endif
 
@@ -322,90 +330,173 @@
 
 /******************************************************/
 /*    Utility functions                               */
 /******************************************************/
 
 static void get_cpu_features(void)
 {
-	sljit_u32 features;
+	sljit_u32 feature_list = CPU_FEATURE_DETECTED;
+	sljit_u32 value;
 
 #if defined(_MSC_VER) && _MSC_VER >= 1400
 
 	int CPUInfo[4];
+
+	__cpuid(CPUInfo, 0);
+	if (CPUInfo[0] >= 7) {
+		__cpuidex(CPUInfo, 7, 0);
+		if (CPUInfo[1] & 0x8)
+			feature_list |= CPU_FEATURE_TZCNT;
+	}
+
+	__cpuid(CPUInfo, (int)0x80000001);
+	if (CPUInfo[2] & 0x20)
+		feature_list |= CPU_FEATURE_LZCNT;
+
 	__cpuid(CPUInfo, 1);
-	features = (sljit_u32)CPUInfo[3];
+	value = (sljit_u32)CPUInfo[3];
 
 #elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__SUNPRO_C)
 
 	/* AT&T syntax. */
 	__asm__ (
+		"movl $0x0, %%eax\n"
+		"lzcnt %%eax, %%eax\n"
+		"setnz %%al\n"
+		"movl %%eax, %0\n"
+		: "=g" (value)
+		:
+#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
+		: "eax"
+#else
+		: "rax"
+#endif
+	);
+
+	if (value & 0x1)
+		feature_list |= CPU_FEATURE_LZCNT;
+
+	__asm__ (
+		"movl $0x0, %%eax\n"
+		"tzcnt %%eax, %%eax\n"
+		"setnz %%al\n"
+		"movl %%eax, %0\n"
+		: "=g" (value)
+		:
+#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
+		: "eax"
+#else
+		: "rax"
+#endif
+	);
+
+	if (value & 0x1)
+		feature_list |= CPU_FEATURE_TZCNT;
+
+	__asm__ (
 		"movl $0x1, %%eax\n"
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
 		/* On x86-32, there is no red zone, so this
 		   should work (no need for a local variable). */
 		"push %%ebx\n"
 #endif
 		"cpuid\n"
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
 		"pop %%ebx\n"
 #endif
 		"movl %%edx, %0\n"
-		: "=g" (features)
+		: "=g" (value)
 		:
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
 		: "%eax", "%ecx", "%edx"
 #else
 		: "%rax", "%rbx", "%rcx", "%rdx"
 #endif
 	);
 
 #else /* _MSC_VER && _MSC_VER >= 1400 */
 
 	/* Intel syntax. */
 	__asm {
+		mov eax, 0
+		lzcnt eax, eax
+		setnz al
+		mov value, eax
+	}
+
+	if (value & 0x1)
+		feature_list |= CPU_FEATURE_LZCNT;
+
+	__asm {
+		mov eax, 0
+		tzcnt eax, eax
+		setnz al
+		mov value, eax
+	}
+
+	if (value & 0x1)
+		feature_list |= CPU_FEATURE_TZCNT;
+
+	__asm {
 		mov eax, 1
 		cpuid
-		mov features, edx
+		mov value, edx
 	}
 
 #endif /* _MSC_VER && _MSC_VER >= 1400 */
 
 #if (defined SLJIT_DETECT_SSE2 && SLJIT_DETECT_SSE2)
-	cpu_has_sse2 = (features >> 26) & 0x1;
+	if (value & 0x4000000)
+		feature_list |= CPU_FEATURE_SSE2;
 #endif
-	cpu_has_cmov = (features >> 15) & 0x1;
+	if (value & 0x8000)
+		feature_list |= CPU_FEATURE_CMOV;
+
+	cpu_feature_list = feature_list;
 }
 
 static sljit_u8 get_jump_code(sljit_uw type)
 {
 	switch (type) {
 	case SLJIT_EQUAL:
-	case SLJIT_EQUAL_F64:
+	case SLJIT_F_EQUAL:
+	case SLJIT_UNORDERED_OR_EQUAL:
+	case SLJIT_ORDERED_EQUAL: /* Not supported. */
 		return 0x84 /* je */;
 
 	case SLJIT_NOT_EQUAL:
-	case SLJIT_NOT_EQUAL_F64:
+	case SLJIT_F_NOT_EQUAL:
+	case SLJIT_ORDERED_NOT_EQUAL:
+	case SLJIT_UNORDERED_OR_NOT_EQUAL: /* Not supported. */
 		return 0x85 /* jne */;
 
 	case SLJIT_LESS:
 	case SLJIT_CARRY:
-	case SLJIT_LESS_F64:
+	case SLJIT_F_LESS:
+	case SLJIT_UNORDERED_OR_LESS:
+	case SLJIT_UNORDERED_OR_GREATER:
 		return 0x82 /* jc */;
 
 	case SLJIT_GREATER_EQUAL:
 	case SLJIT_NOT_CARRY:
-	case SLJIT_GREATER_EQUAL_F64:
+	case SLJIT_F_GREATER_EQUAL:
+	case SLJIT_ORDERED_GREATER_EQUAL:
+	case SLJIT_ORDERED_LESS_EQUAL:
 		return 0x83 /* jae */;
 
 	case SLJIT_GREATER:
-	case SLJIT_GREATER_F64:
+	case SLJIT_F_GREATER:
+	case SLJIT_ORDERED_LESS:
+	case SLJIT_ORDERED_GREATER:
 		return 0x87 /* jnbe */;
 
 	case SLJIT_LESS_EQUAL:
-	case SLJIT_LESS_EQUAL_F64:
+	case SLJIT_F_LESS_EQUAL:
+	case SLJIT_UNORDERED_OR_GREATER_EQUAL:
+	case SLJIT_UNORDERED_OR_LESS_EQUAL:
 		return 0x86 /* jbe */;
 
 	case SLJIT_SIG_LESS:
 		return 0x8c /* jl */;
 
 	case SLJIT_SIG_GREATER_EQUAL:
 		return 0x8d /* jnl */;
@@ -418,18 +509,18 @@
 
 	case SLJIT_OVERFLOW:
 		return 0x80 /* jo */;
 
 	case SLJIT_NOT_OVERFLOW:
 		return 0x81 /* jno */;
 
-	case SLJIT_UNORDERED_F64:
+	case SLJIT_UNORDERED:
 		return 0x8a /* jp */;
 
-	case SLJIT_ORDERED_F64:
+	case SLJIT_ORDERED:
 		return 0x8b /* jpo */;
 	}
 	return 0;
 }
 
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
 static sljit_u8* generate_far_jump_code(struct sljit_jump *jump, sljit_u8 *code_ptr, sljit_sw executable_offset);
@@ -445,21 +536,21 @@
 	sljit_uw label_addr;
 
 	if (jump->flags & JUMP_LABEL)
 		label_addr = (sljit_uw)(code + jump->u.label->size);
 	else
 		label_addr = jump->u.target - (sljit_uw)executable_offset;
 
-	short_jump = (sljit_sw)(label_addr - (jump->addr + 2)) >= -128 && (sljit_sw)(label_addr - (jump->addr + 2)) <= 127;
-
 #if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
 	if ((sljit_sw)(label_addr - (jump->addr + 1)) > HALFWORD_MAX || (sljit_sw)(label_addr - (jump->addr + 1)) < HALFWORD_MIN)
 		return generate_far_jump_code(jump, code_ptr);
 #endif
 
+	short_jump = (sljit_sw)(label_addr - (jump->addr + 2)) >= -128 && (sljit_sw)(label_addr - (jump->addr + 2)) <= 127;
+
 	if (type == SLJIT_JUMP) {
 		if (short_jump)
 			*code_ptr++ = JMP_i8;
 		else
 			*code_ptr++ = JMP_i32;
 		jump->addr++;
 	}
@@ -577,40 +668,41 @@
 	SLJIT_ASSERT(!jump);
 	SLJIT_ASSERT(!const_);
 	SLJIT_ASSERT(!put_label);
 	SLJIT_ASSERT(code_ptr <= code + compiler->size);
 
 	jump = compiler->jumps;
 	while (jump) {
-		jump_addr = jump->addr + (sljit_uw)executable_offset;
+		if (jump->flags & (PATCH_MB | PATCH_MW)) {
+			if (jump->flags & JUMP_LABEL)
+				jump_addr = jump->u.label->addr;
+			else
+				jump_addr = jump->u.target;
 
-		if (jump->flags & PATCH_MB) {
-			SLJIT_ASSERT((sljit_sw)(jump->u.label->addr - (jump_addr + sizeof(sljit_s8))) >= -128 && (sljit_sw)(jump->u.label->addr - (jump_addr + sizeof(sljit_s8))) <= 127);
-			*(sljit_u8*)jump->addr = U8(jump->u.label->addr - (jump_addr + sizeof(sljit_s8)));
-		} else if (jump->flags & PATCH_MW) {
-			if (jump->flags & JUMP_LABEL) {
-#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
-				sljit_unaligned_store_sw((void*)jump->addr, (sljit_sw)(jump->u.label->addr - (jump_addr + sizeof(sljit_sw))));
-#else
-				SLJIT_ASSERT((sljit_sw)(jump->u.label->addr - (jump_addr + sizeof(sljit_s32))) >= HALFWORD_MIN && (sljit_sw)(jump->u.label->addr - (jump_addr + sizeof(sljit_s32))) <= HALFWORD_MAX);
-				sljit_unaligned_store_s32((void*)jump->addr, (sljit_s32)(jump->u.label->addr - (jump_addr + sizeof(sljit_s32))));
-#endif
-			}
-			else {
+			jump_addr -= jump->addr + (sljit_uw)executable_offset;
+
+			if (jump->flags & PATCH_MB) {
+				jump_addr -= sizeof(sljit_s8);
+				SLJIT_ASSERT((sljit_sw)jump_addr >= -128 && (sljit_sw)jump_addr <= 127);
+				*(sljit_u8*)jump->addr = U8(jump_addr);
+			} else {
+				jump_addr -= sizeof(sljit_s32);
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
-				sljit_unaligned_store_sw((void*)jump->addr, (sljit_sw)(jump->u.target - (jump_addr + sizeof(sljit_sw))));
+				sljit_unaligned_store_sw((void*)jump->addr, (sljit_sw)jump_addr);
 #else
-				SLJIT_ASSERT((sljit_sw)(jump->u.target - (jump_addr + sizeof(sljit_s32))) >= HALFWORD_MIN && (sljit_sw)(jump->u.target - (jump_addr + sizeof(sljit_s32))) <= HALFWORD_MAX);
-				sljit_unaligned_store_s32((void*)jump->addr, (sljit_s32)(jump->u.target - (jump_addr + sizeof(sljit_s32))));
+				SLJIT_ASSERT((sljit_sw)jump_addr >= HALFWORD_MIN && (sljit_sw)jump_addr <= HALFWORD_MAX);
+				sljit_unaligned_store_s32((void*)jump->addr, (sljit_s32)jump_addr);
 #endif
 			}
 		}
 #if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
-		else if (jump->flags & PATCH_MD)
-			sljit_unaligned_store_sw((void*)jump->addr, (sljit_sw)jump->u.label->addr);
+		else if (jump->flags & PATCH_MD) {
+				SLJIT_ASSERT(jump->flags & JUMP_LABEL);
+				sljit_unaligned_store_sw((void*)jump->addr, (sljit_sw)jump->u.label->addr);
+		}
 #endif
 
 		jump = jump->next;
 	}
 
 	put_label = compiler->put_labels;
 	while (put_label) {
@@ -643,49 +735,75 @@
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_has_cpu_feature(sljit_s32 feature_type)
 {
 	switch (feature_type) {
 	case SLJIT_HAS_FPU:
 #ifdef SLJIT_IS_FPU_AVAILABLE
 		return SLJIT_IS_FPU_AVAILABLE;
 #elif (defined SLJIT_DETECT_SSE2 && SLJIT_DETECT_SSE2)
-		if (cpu_has_sse2 == -1)
+		if (cpu_feature_list == 0)
 			get_cpu_features();
-		return cpu_has_sse2;
+		return (cpu_feature_list & CPU_FEATURE_SSE2) != 0;
 #else /* SLJIT_DETECT_SSE2 */
 		return 1;
 #endif /* SLJIT_DETECT_SSE2 */
 
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
 	case SLJIT_HAS_VIRTUAL_REGISTERS:
 		return 1;
-#endif
+#endif /* SLJIT_CONFIG_X86_32 */
 
 	case SLJIT_HAS_CLZ:
+		if (cpu_feature_list == 0)
+			get_cpu_features();
+
+		return (cpu_feature_list & CPU_FEATURE_LZCNT) ? 1 : 2;
+
+	case SLJIT_HAS_CTZ:
+		if (cpu_feature_list == 0)
+			get_cpu_features();
+
+		return (cpu_feature_list & CPU_FEATURE_TZCNT) ? 1 : 2;
+
 	case SLJIT_HAS_CMOV:
-		if (cpu_has_cmov == -1)
+		if (cpu_feature_list == 0)
 			get_cpu_features();
-		return cpu_has_cmov;
+		return (cpu_feature_list & CPU_FEATURE_CMOV) != 0;
 
+	case SLJIT_HAS_ROT:
 	case SLJIT_HAS_PREFETCH:
 		return 1;
 
 	case SLJIT_HAS_SSE2:
 #if (defined SLJIT_DETECT_SSE2 && SLJIT_DETECT_SSE2)
-		if (cpu_has_sse2 == -1)
+		if (cpu_feature_list == 0)
 			get_cpu_features();
-		return cpu_has_sse2;
-#else
+		return (cpu_feature_list & CPU_FEATURE_SSE2) != 0;
+#else /* !SLJIT_DETECT_SSE2 */
 		return 1;
-#endif
+#endif /* SLJIT_DETECT_SSE2 */
 
 	default:
 		return 0;
 	}
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_cmp_info(sljit_s32 type)
+{
+	if (type < SLJIT_UNORDERED || type > SLJIT_ORDERED_LESS_EQUAL)
+		return 0;
+
+	switch (type) {
+	case SLJIT_ORDERED_EQUAL:
+	case SLJIT_UNORDERED_OR_NOT_EQUAL:
+		return 0;
+	}
+
+	return 1;
+}
+
 /* --------------------------------------------------------------------- */
 /*  Operators                                                            */
 /* --------------------------------------------------------------------- */
 
 #define BINARY_OPCODE(opcode) (((opcode ## _EAX_i32) << 24) | ((opcode ## _r_rm) << 16) | ((opcode ## _rm_r) << 8) | (opcode))
 
 #define BINARY_IMM32(op_imm, immw, arg, argw) \
@@ -1381,70 +1499,99 @@
 	*inst = OR_r_rm;
 	EMIT_MOV(compiler, dst, dstw, TMP_REG1, 0);
 	return SLJIT_SUCCESS;
 }
 
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
 static const sljit_sw emit_clz_arg = 32 + 31;
+static const sljit_sw emit_ctz_arg = 32;
 #endif
 
-static sljit_s32 emit_clz(struct sljit_compiler *compiler, sljit_s32 op_flags,
+static sljit_s32 emit_clz_ctz(struct sljit_compiler *compiler, sljit_s32 is_clz,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src, sljit_sw srcw)
 {
 	sljit_u8* inst;
 	sljit_s32 dst_r;
+	sljit_sw max;
 
-	SLJIT_UNUSED_ARG(op_flags);
-
-	if (cpu_has_cmov == -1)
+	if (cpu_feature_list == 0)
 		get_cpu_features();
 
 	dst_r = FAST_IS_REG(dst) ? dst : TMP_REG1;
 
+	if (is_clz ? (cpu_feature_list & CPU_FEATURE_LZCNT) : (cpu_feature_list & CPU_FEATURE_TZCNT)) {
+		/* Group prefix added separately. */
+		inst = (sljit_u8*)ensure_buf(compiler, 1 + 1);
+		FAIL_IF(!inst);
+		INC_SIZE(1);
+		*inst++ = GROUP_F3;
+
+		inst = emit_x86_instruction(compiler, 2, dst_r, 0, src, srcw);
+		FAIL_IF(!inst);
+		*inst++ = GROUP_0F;
+		*inst = is_clz ? LZCNT_r_rm : TZCNT_r_rm;
+
+		if (dst & SLJIT_MEM)
+			EMIT_MOV(compiler, dst, dstw, TMP_REG1, 0);
+		return SLJIT_SUCCESS;
+	}
+
 	inst = emit_x86_instruction(compiler, 2, dst_r, 0, src, srcw);
 	FAIL_IF(!inst);
 	*inst++ = GROUP_0F;
-	*inst = BSR_r_rm;
+	*inst = is_clz ? BSR_r_rm : BSF_r_rm;
 
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
-	if (cpu_has_cmov) {
+	max = is_clz ? (32 + 31) : 32;
+
+	if (cpu_feature_list & CPU_FEATURE_CMOV) {
 		if (dst_r != TMP_REG1) {
-			EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_IMM, 32 + 31);
+			EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_IMM, max);
 			inst = emit_x86_instruction(compiler, 2, dst_r, 0, TMP_REG1, 0);
 		}
 		else
-			inst = emit_x86_instruction(compiler, 2, dst_r, 0, SLJIT_MEM0(), (sljit_sw)&emit_clz_arg);
+			inst = emit_x86_instruction(compiler, 2, dst_r, 0, SLJIT_MEM0(), is_clz ? (sljit_sw)&emit_clz_arg : (sljit_sw)&emit_ctz_arg);
 
 		FAIL_IF(!inst);
 		*inst++ = GROUP_0F;
 		*inst = CMOVE_r_rm;
 	}
 	else
-		FAIL_IF(sljit_emit_cmov_generic(compiler, SLJIT_EQUAL, dst_r, SLJIT_IMM, 32 + 31));
+		FAIL_IF(sljit_emit_cmov_generic(compiler, SLJIT_EQUAL, dst_r, SLJIT_IMM, max));
 
-	inst = emit_x86_instruction(compiler, 1 | EX86_BIN_INS, SLJIT_IMM, 31, dst_r, 0);
+	if (is_clz) {
+		inst = emit_x86_instruction(compiler, 1 | EX86_BIN_INS, SLJIT_IMM, 31, dst_r, 0);
+		FAIL_IF(!inst);
+		*(inst + 1) |= XOR;
+	}
 #else
-	if (cpu_has_cmov) {
-		EMIT_MOV(compiler, TMP_REG2, 0, SLJIT_IMM, !(op_flags & SLJIT_32) ? (64 + 63) : (32 + 31));
+	if (is_clz)
+		max = compiler->mode32 ? (32 + 31) : (64 + 63);
+	else
+		max = compiler->mode32 ? 32 : 64;
+
+	if (cpu_feature_list & CPU_FEATURE_CMOV) {
+		EMIT_MOV(compiler, TMP_REG2, 0, SLJIT_IMM, max);
 
 		inst = emit_x86_instruction(compiler, 2, dst_r, 0, TMP_REG2, 0);
 		FAIL_IF(!inst);
 		*inst++ = GROUP_0F;
 		*inst = CMOVE_r_rm;
 	}
 	else
-		FAIL_IF(sljit_emit_cmov_generic(compiler, SLJIT_EQUAL, dst_r, SLJIT_IMM, !(op_flags & SLJIT_32) ? (64 + 63) : (32 + 31)));
+		FAIL_IF(sljit_emit_cmov_generic(compiler, SLJIT_EQUAL, dst_r, SLJIT_IMM, max));
 
-	inst = emit_x86_instruction(compiler, 1 | EX86_BIN_INS, SLJIT_IMM, !(op_flags & SLJIT_32) ? 63 : 31, dst_r, 0);
+	if (is_clz) {
+		inst = emit_x86_instruction(compiler, 1 | EX86_BIN_INS, SLJIT_IMM, max >> 1, dst_r, 0);
+		FAIL_IF(!inst);
+		*(inst + 1) |= XOR;
+	}
 #endif
 
-	FAIL_IF(!inst);
-	*(inst + 1) |= XOR;
-
 	if (dst & SLJIT_MEM)
 		EMIT_MOV(compiler, dst, dstw, TMP_REG1, 0);
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op1(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 dst, sljit_sw dstw,
@@ -1574,15 +1721,16 @@
 	switch (op) {
 	case SLJIT_NOT:
 		if (SLJIT_UNLIKELY(op_flags & SLJIT_SET_Z))
 			return emit_not_with_flags(compiler, dst, dstw, src, srcw);
 		return emit_unary(compiler, NOT_rm, dst, dstw, src, srcw);
 
 	case SLJIT_CLZ:
-		return emit_clz(compiler, op_flags, dst, dstw, src, srcw);
+	case SLJIT_CTZ:
+		return emit_clz_ctz(compiler, (op == SLJIT_CLZ), dst, dstw, src, srcw);
 	}
 
 	return SLJIT_SUCCESS;
 }
 
 static sljit_s32 emit_cum_binary(struct sljit_compiler *compiler,
 	sljit_u32 op_types,
@@ -2112,14 +2260,17 @@
 
 static sljit_s32 emit_shift(struct sljit_compiler *compiler,
 	sljit_u8 mode,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
+#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+	sljit_s32 mode32;
+#endif
 	sljit_u8* inst;
 
 	if ((src2 & SLJIT_IMM) || (src2 == SLJIT_PREF_SHIFT_REG)) {
 		if (dst == src1 && dstw == src1w) {
 			inst = emit_x86_instruction(compiler, 1 | EX86_SHIFT_INS, src2, src2w, dst, dstw);
 			FAIL_IF(!inst);
 			*inst |= mode;
@@ -2151,67 +2302,89 @@
 
 	if (dst == SLJIT_PREF_SHIFT_REG) {
 		EMIT_MOV(compiler, TMP_REG1, 0, src1, src1w);
 		EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, src2, src2w);
 		inst = emit_x86_instruction(compiler, 1 | EX86_SHIFT_INS, SLJIT_PREF_SHIFT_REG, 0, TMP_REG1, 0);
 		FAIL_IF(!inst);
 		*inst |= mode;
-		EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, TMP_REG1, 0);
+		return emit_mov(compiler, SLJIT_PREF_SHIFT_REG, 0, TMP_REG1, 0);
 	}
-	else if (FAST_IS_REG(dst) && dst != src2 && dst != TMP_REG1 && !ADDRESSING_DEPENDS_ON(src2, dst)) {
+
+	if (FAST_IS_REG(dst) && dst != src2 && dst != TMP_REG1 && !ADDRESSING_DEPENDS_ON(src2, dst)) {
 		if (src1 != dst)
 			EMIT_MOV(compiler, dst, 0, src1, src1w);
+#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+		mode32 = compiler->mode32;
+		compiler->mode32 = 0;
+#endif
 		EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_PREF_SHIFT_REG, 0);
+#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+		compiler->mode32 = mode32;
+#endif
 		EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, src2, src2w);
 		inst = emit_x86_instruction(compiler, 1 | EX86_SHIFT_INS, SLJIT_PREF_SHIFT_REG, 0, dst, 0);
 		FAIL_IF(!inst);
 		*inst |= mode;
+#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+		compiler->mode32 = 0;
+#endif
 		EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, TMP_REG1, 0);
+#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+		compiler->mode32 = mode32;
+#endif
+		return SLJIT_SUCCESS;
 	}
-	else {
-		/* This case is complex since ecx itself may be used for
-		   addressing, and this case must be supported as well. */
-		EMIT_MOV(compiler, TMP_REG1, 0, src1, src1w);
+
+	/* This case is complex since ecx itself may be used for
+	   addressing, and this case must be supported as well. */
+	EMIT_MOV(compiler, TMP_REG1, 0, src1, src1w);
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
-		EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), 0, SLJIT_PREF_SHIFT_REG, 0);
-		EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, src2, src2w);
-		inst = emit_x86_instruction(compiler, 1 | EX86_SHIFT_INS, SLJIT_PREF_SHIFT_REG, 0, TMP_REG1, 0);
-		FAIL_IF(!inst);
-		*inst |= mode;
-		EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, SLJIT_MEM1(SLJIT_SP), 0);
+	EMIT_MOV(compiler, SLJIT_MEM1(SLJIT_SP), 0, SLJIT_PREF_SHIFT_REG, 0);
+#else /* !SLJIT_CONFIG_X86_32 */
+	mode32 = compiler->mode32;
+	compiler->mode32 = 0;
+	EMIT_MOV(compiler, TMP_REG2, 0, SLJIT_PREF_SHIFT_REG, 0);
+	compiler->mode32 = mode32;
+#endif /* SLJIT_CONFIG_X86_32 */
+
+	EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, src2, src2w);
+	inst = emit_x86_instruction(compiler, 1 | EX86_SHIFT_INS, SLJIT_PREF_SHIFT_REG, 0, TMP_REG1, 0);
+	FAIL_IF(!inst);
+	*inst |= mode;
+
+#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
+	EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, SLJIT_MEM1(SLJIT_SP), 0);
 #else
-		EMIT_MOV(compiler, TMP_REG2, 0, SLJIT_PREF_SHIFT_REG, 0);
-		EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, src2, src2w);
-		inst = emit_x86_instruction(compiler, 1 | EX86_SHIFT_INS, SLJIT_PREF_SHIFT_REG, 0, TMP_REG1, 0);
-		FAIL_IF(!inst);
-		*inst |= mode;
-		EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, TMP_REG2, 0);
-#endif
-		if (dst != TMP_REG1)
-			return emit_mov(compiler, dst, dstw, TMP_REG1, 0);
-	}
+	compiler->mode32 = 0;
+	EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, TMP_REG2, 0);
+	compiler->mode32 = mode32;
+#endif /* SLJIT_CONFIG_X86_32 */
+
+	if (dst != TMP_REG1)
+		return emit_mov(compiler, dst, dstw, TMP_REG1, 0);
 
 	return SLJIT_SUCCESS;
 }
 
 static sljit_s32 emit_shift_with_flags(struct sljit_compiler *compiler,
 	sljit_u8 mode, sljit_s32 set_flags,
 	sljit_s32 dst, sljit_sw dstw,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
 	/* The CPU does not set flags if the shift count is 0. */
 	if (src2 & SLJIT_IMM) {
 #if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
-		if ((src2w & 0x3f) != 0 || (compiler->mode32 && (src2w & 0x1f) != 0))
-			return emit_shift(compiler, mode, dst, dstw, src1, src1w, src2, src2w);
-#else
-		if ((src2w & 0x1f) != 0)
+		src2w &= compiler->mode32 ? 0x1f : 0x3f;
+#else /* !SLJIT_CONFIG_X86_64 */
+		src2w &= 0x1f;
+#endif /* SLJIT_CONFIG_X86_64 */
+		if (src2w != 0)
 			return emit_shift(compiler, mode, dst, dstw, src1, src1w, src2, src2w);
-#endif
+
 		if (!set_flags)
 			return emit_mov(compiler, dst, dstw, src1, src1w);
 		/* OR dst, src, 0 */
 		return emit_cum_binary(compiler, BINARY_OPCODE(OR),
 			dst, dstw, src1, src1w, SLJIT_IMM, 0);
 	}
 
@@ -2285,22 +2458,31 @@
 	case SLJIT_OR:
 		return emit_cum_binary(compiler, BINARY_OPCODE(OR),
 			dst, dstw, src1, src1w, src2, src2w);
 	case SLJIT_XOR:
 		return emit_cum_binary(compiler, BINARY_OPCODE(XOR),
 			dst, dstw, src1, src1w, src2, src2w);
 	case SLJIT_SHL:
+	case SLJIT_MSHL:
 		return emit_shift_with_flags(compiler, SHL, HAS_FLAGS(op),
 			dst, dstw, src1, src1w, src2, src2w);
 	case SLJIT_LSHR:
+	case SLJIT_MLSHR:
 		return emit_shift_with_flags(compiler, SHR, HAS_FLAGS(op),
 			dst, dstw, src1, src1w, src2, src2w);
 	case SLJIT_ASHR:
+	case SLJIT_MASHR:
 		return emit_shift_with_flags(compiler, SAR, HAS_FLAGS(op),
 			dst, dstw, src1, src1w, src2, src2w);
+	case SLJIT_ROTL:
+		return emit_shift_with_flags(compiler, ROL, 0,
+			dst, dstw, src1, src1w, src2, src2w);
+	case SLJIT_ROTR:
+		return emit_shift_with_flags(compiler, ROR, 0,
+			dst, dstw, src1, src1w, src2, src2w);
 	}
 
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2u(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
@@ -2308,18 +2490,15 @@
 {
 	sljit_s32 opcode = GET_OPCODE(op);
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op2(compiler, op, 1, 0, 0, src1, src1w, src2, src2w));
 
 	if (opcode != SLJIT_SUB && opcode != SLJIT_AND) {
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-			|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-		compiler->skip_checks = 1;
-#endif
+		SLJIT_SKIP_CHECKS(compiler);
 		return sljit_emit_op2(compiler, op, TMP_REG1, 0, src1, src1w, src2, src2w);
 	}
 
 	ADJUST_LOCAL_OFFSET(src1, src1w);
 	ADJUST_LOCAL_OFFSET(src2, src2w);
 
 	CHECK_EXTRA_REGS(src1, src1w, (void)0);
@@ -2330,14 +2509,130 @@
 
 	if (opcode == SLJIT_SUB) {
 		return emit_cmp_binary(compiler, src1, src1w, src2, src2w);
 	}
 	return emit_test_binary(compiler, src1, src1w, src2, src2w);
 }
 
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_shift_into(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 src_dst,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+	sljit_s32 restore_ecx = 0;
+	sljit_s32 is_rotate, is_left;
+	sljit_u8* inst;
+	sljit_sw dstw = 0;
+#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
+	sljit_s32 tmp2 = SLJIT_MEM1(SLJIT_SP);
+#else /* !SLJIT_CONFIG_X86_32 */
+	sljit_s32 tmp2 = TMP_REG2;
+#endif /* SLJIT_CONFIG_X86_32 */
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_shift_into(compiler, op, src_dst, src1, src1w, src2, src2w));
+	ADJUST_LOCAL_OFFSET(src1, src1w);
+	ADJUST_LOCAL_OFFSET(src2, src2w);
+
+	CHECK_EXTRA_REGS(src1, src1w, (void)0);
+	CHECK_EXTRA_REGS(src2, src2w, (void)0);
+
+#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+	compiler->mode32 = op & SLJIT_32;
+#endif
+
+	if (src2 & SLJIT_IMM) {
+#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
+		src2w &= 0x1f;
+#else /* !SLJIT_CONFIG_X86_32 */
+		src2w &= (op & SLJIT_32) ? 0x1f : 0x3f;
+#endif /* SLJIT_CONFIG_X86_32 */
+
+		if (src2w == 0)
+			return SLJIT_SUCCESS;
+	}
+
+	is_left = (GET_OPCODE(op) == SLJIT_SHL || GET_OPCODE(op) == SLJIT_MSHL);
+
+	is_rotate = (src_dst == src1);
+	CHECK_EXTRA_REGS(src_dst, dstw, (void)0);
+
+	if (is_rotate)
+		return emit_shift(compiler, is_left ? ROL : ROR, src_dst, dstw, src1, src1w, src2, src2w);
+
+	if ((src2 & SLJIT_IMM) || src2 == SLJIT_PREF_SHIFT_REG) {
+		if (!FAST_IS_REG(src1)) {
+			EMIT_MOV(compiler, TMP_REG1, 0, src1, src1w);
+			src1 = TMP_REG1;
+		}
+	} else if (FAST_IS_REG(src1)) {
+#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+		compiler->mode32 = 0;
+#endif
+		EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_PREF_SHIFT_REG, 0);
+#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+		compiler->mode32 = op & SLJIT_32;
+#endif
+		EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, src2, src2w);
+
+		if (src1 == SLJIT_PREF_SHIFT_REG)
+			src1 = TMP_REG1;
+
+		if (src_dst == SLJIT_PREF_SHIFT_REG)
+			src_dst = TMP_REG1;
+
+		restore_ecx = 1;
+	} else {
+		EMIT_MOV(compiler, TMP_REG1, 0, src1, src1w);
+#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+		compiler->mode32 = 0;
+#endif
+		EMIT_MOV(compiler, tmp2, 0, SLJIT_PREF_SHIFT_REG, 0);
+#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+		compiler->mode32 = op & SLJIT_32;
+#endif
+		EMIT_MOV(compiler, SLJIT_PREF_SHIFT_REG, 0, src2, src2w);
+
+		src1 = TMP_REG1;
+
+		if (src_dst == SLJIT_PREF_SHIFT_REG) {
+			src_dst = tmp2;
+			SLJIT_ASSERT(dstw == 0);
+		}
+
+		restore_ecx = 2;
+	}
+
+	inst = emit_x86_instruction(compiler, 2, src1, 0, src_dst, dstw);
+	FAIL_IF(!inst);
+	inst[0] = GROUP_0F;
+
+	if (src2 & SLJIT_IMM) {
+		inst[1] = U8((is_left ? SHLD : SHRD) - 1);
+
+		/* Immedate argument is added separately. */
+		inst = (sljit_u8*)ensure_buf(compiler, 1 + 1);
+		FAIL_IF(!inst);
+		INC_SIZE(1);
+		*inst = U8(src2w);
+	} else
+		inst[1] = U8(is_left ? SHLD : SHRD);
+
+#if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
+	compiler->mode32 = 0;
+#endif
+
+	if (restore_ecx == 1)
+		return emit_mov(compiler, SLJIT_PREF_SHIFT_REG, 0, TMP_REG1, 0);
+	if (restore_ecx == 2)
+		return emit_mov(compiler, SLJIT_PREF_SHIFT_REG, 0, tmp2, 0);
+
+	return SLJIT_SUCCESS;
+}
+
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_src(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src, sljit_sw srcw)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_src(compiler, op, src, srcw));
 	ADJUST_LOCAL_OFFSET(src, srcw);
 
@@ -2512,14 +2807,27 @@
 	return SLJIT_SUCCESS;
 }
 
 static SLJIT_INLINE sljit_s32 sljit_emit_fop1_cmp(struct sljit_compiler *compiler, sljit_s32 op,
 	sljit_s32 src1, sljit_sw src1w,
 	sljit_s32 src2, sljit_sw src2w)
 {
+	switch (GET_FLAG_TYPE(op)) {
+	case SLJIT_ORDERED_LESS:
+	case SLJIT_UNORDERED_OR_GREATER_EQUAL:
+	case SLJIT_UNORDERED_OR_GREATER:
+	case SLJIT_ORDERED_LESS_EQUAL:
+		if (!FAST_IS_REG(src2)) {
+			FAIL_IF(emit_sse2_load(compiler, op & SLJIT_32, TMP_FREG, src2, src2w));
+			src2 = TMP_FREG;
+		}
+
+		return emit_sse2_logic(compiler, UCOMISD_x_xm, !(op & SLJIT_32), src2, src1, src1w);
+	}
+
 	if (!FAST_IS_REG(src1)) {
 		FAIL_IF(emit_sse2_load(compiler, op & SLJIT_32, TMP_FREG, src1, src1w));
 		src1 = TMP_FREG;
 	}
 
 	return emit_sse2_logic(compiler, UCOMISD_x_xm, !(op & SLJIT_32), src1, src2, src2w);
 }
@@ -2765,15 +3073,14 @@
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_op_flags(compiler, op, dst, dstw, type));
 
 	ADJUST_LOCAL_OFFSET(dst, dstw);
 	CHECK_EXTRA_REGS(dst, dstw, (void)0);
 
-	type &= 0xff;
 	/* setcc = jcc + 0x10. */
 	cond_set = U8(get_jump_code((sljit_uw)type) + 0x10);
 
 #if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
 	if (GET_OPCODE(op) == SLJIT_OR && !GET_ALL_FLAGS(op) && FAST_IS_REG(dst)) {
 		inst = (sljit_u8*)ensure_buf(compiler, 1 + 4 + 3);
 		FAIL_IF(!inst);
@@ -2809,18 +3116,15 @@
 		return SLJIT_SUCCESS;
 
 	if (GET_OPCODE(op) < SLJIT_ADD) {
 		compiler->mode32 = GET_OPCODE(op) != SLJIT_MOV;
 		return emit_mov(compiler, dst, dstw, TMP_REG1, 0);
 	}
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_op2(compiler, op, dst_save, dstw_save, dst_save, dstw_save, TMP_REG1, 0);
 
 #else
 	/* The SLJIT_CONFIG_X86_32 code path starts here. */
 	if (GET_OPCODE(op) < SLJIT_ADD && FAST_IS_REG(dst)) {
 		if (reg_map[dst] <= 4) {
 			/* Low byte is accessible. */
@@ -2835,18 +3139,18 @@
 			*inst++ = GROUP_0F;
 			*inst++ = MOVZX_r_rm8;
 			*inst = U8(MOD_REG | (reg_map[dst] << 3) | reg_map[dst]);
 			return SLJIT_SUCCESS;
 		}
 
 		/* Low byte is not accessible. */
-		if (cpu_has_cmov == -1)
+		if (cpu_feature_list == 0)
 			get_cpu_features();
 
-		if (cpu_has_cmov) {
+		if (cpu_feature_list & CPU_FEATURE_CMOV) {
 			EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_IMM, 1);
 			/* a xor reg, reg operation would overwrite the flags. */
 			EMIT_MOV(compiler, dst, 0, SLJIT_IMM, 0);
 
 			inst = (sljit_u8*)ensure_buf(compiler, 1 + 3);
 			FAIL_IF(!inst);
 			INC_SIZE(3);
@@ -2923,59 +3227,56 @@
 	*inst++ = MOD_REG | (0 << 3) /* eax */ | 0 /* eax */;
 
 	*inst++ = U8(XCHG_EAX_r | reg_map[TMP_REG1]);
 
 	if (GET_OPCODE(op) < SLJIT_ADD)
 		return emit_mov(compiler, dst, dstw, TMP_REG1, 0);
 
-#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
-		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
-	compiler->skip_checks = 1;
-#endif
+	SLJIT_SKIP_CHECKS(compiler);
 	return sljit_emit_op2(compiler, op, dst_save, dstw_save, dst_save, dstw_save, TMP_REG1, 0);
 #endif /* SLJIT_CONFIG_X86_64 */
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_cmov(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 dst_reg,
 	sljit_s32 src, sljit_sw srcw)
 {
 	sljit_u8* inst;
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_cmov(compiler, type, dst_reg, src, srcw));
 
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
-	dst_reg &= ~SLJIT_32;
+	type &= ~SLJIT_32;
 
 	if (!sljit_has_cpu_feature(SLJIT_HAS_CMOV) || (dst_reg >= SLJIT_R3 && dst_reg <= SLJIT_S3))
 		return sljit_emit_cmov_generic(compiler, type, dst_reg, src, srcw);
 #else
 	if (!sljit_has_cpu_feature(SLJIT_HAS_CMOV))
 		return sljit_emit_cmov_generic(compiler, type, dst_reg, src, srcw);
 #endif
 
 	/* ADJUST_LOCAL_OFFSET is not needed. */
 	CHECK_EXTRA_REGS(src, srcw, (void)0);
 
 #if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
-	compiler->mode32 = dst_reg & SLJIT_32;
-	dst_reg &= ~SLJIT_32;
+	compiler->mode32 = type & SLJIT_32;
+	type &= ~SLJIT_32;
 #endif
 
 	if (SLJIT_UNLIKELY(src & SLJIT_IMM)) {
 		EMIT_MOV(compiler, TMP_REG1, 0, SLJIT_IMM, srcw);
 		src = TMP_REG1;
 		srcw = 0;
 	}
 
 	inst = emit_x86_instruction(compiler, 2, dst_reg, 0, src, srcw);
 	FAIL_IF(!inst);
 	*inst++ = GROUP_0F;
-	*inst = U8(get_jump_code(type & 0xff) - 0x40);
+	*inst = U8(get_jump_code((sljit_uw)type) - 0x40);
 	return SLJIT_SUCCESS;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_local_base(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw offset)
 {
 	CHECK_ERROR();
 	CHECK(check_sljit_get_local_base(compiler, dst, dstw, offset));
```

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitProtExecAllocator.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitProtExecAllocator.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitUtils.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitUtils.c`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/src/sljit/sljitWXExecAllocator.c` & `pcre2-0.2.0/src/libpcre2/src/sljit/sljitWXExecAllocator.c`

 * *Files 6% similar despite different names*

```diff
@@ -55,73 +55,48 @@
 	sljit_update_wx_flags((from), (to), (enable_exec))
 
 #ifndef _WIN32
 #include <sys/types.h>
 #include <sys/mman.h>
 
 #ifdef __NetBSD__
-#if defined(PROT_MPROTECT)
-#define check_se_protected(ptr, size) (0)
 #define SLJIT_PROT_WX PROT_MPROTECT(PROT_EXEC)
-#else /* !PROT_MPROTECT */
-#ifdef _NETBSD_SOURCE
-#include <sys/param.h>
-#else /* !_NETBSD_SOURCE */
-typedef unsigned int	u_int;
-#define devmajor_t sljit_s32
-#endif /* _NETBSD_SOURCE */
-#include <sys/sysctl.h>
-#include <unistd.h>
-
-#define check_se_protected(ptr, size) netbsd_se_protected()
-
-static SLJIT_INLINE int netbsd_se_protected(void)
-{
-	int mib[3];
-	int paxflags;
-	size_t len = sizeof(paxflags);
-
-	mib[0] = CTL_PROC;
-	mib[1] = getpid();
-	mib[2] = PROC_PID_PAXFLAGS;
-
-	if (SLJIT_UNLIKELY(sysctl(mib, 3, &paxflags, &len, NULL, 0) < 0))
-		return -1;
-
-	return (paxflags & CTL_PROC_PAXFLAGS_MPROTECT) ? -1 : 0;
-}
-#endif /* PROT_MPROTECT */
+#define check_se_protected(ptr, size) (0)
 #else /* POSIX */
+#if !(defined SLJIT_SINGLE_THREADED && SLJIT_SINGLE_THREADED)
+#include <pthread.h>
+#define SLJIT_SE_LOCK()		pthread_mutex_lock(&se_lock)
+#define SLJIT_SE_UNLOCK()	pthread_mutex_unlock(&se_lock)
+#endif /* !SLJIT_SINGLE_THREADED */
+
 #define check_se_protected(ptr, size) generic_se_protected(ptr, size)
 
 static SLJIT_INLINE int generic_se_protected(void *ptr, sljit_uw size)
 {
 	if (SLJIT_LIKELY(!mprotect(ptr, size, PROT_EXEC)))
 		return mprotect(ptr, size, PROT_READ | PROT_WRITE);
 
 	return -1;
 }
 #endif /* NetBSD */
 
-#if defined SLJIT_SINGLE_THREADED && SLJIT_SINGLE_THREADED
+#ifndef SLJIT_SE_LOCK
 #define SLJIT_SE_LOCK()
+#endif
+#ifndef SLJIT_SE_UNLOCK
 #define SLJIT_SE_UNLOCK()
-#else /* !SLJIT_SINGLE_THREADED */
-#include <pthread.h>
-#define SLJIT_SE_LOCK()	pthread_mutex_lock(&se_lock)
-#define SLJIT_SE_UNLOCK()	pthread_mutex_unlock(&se_lock)
-#endif /* SLJIT_SINGLE_THREADED */
-
+#endif
 #ifndef SLJIT_PROT_WX
 #define SLJIT_PROT_WX 0
-#endif /* !SLJIT_PROT_WX */
+#endif
 
 SLJIT_API_FUNC_ATTRIBUTE void* sljit_malloc_exec(sljit_uw size)
 {
-#if !(defined SLJIT_SINGLE_THREADED && SLJIT_SINGLE_THREADED)
+#if !(defined SLJIT_SINGLE_THREADED && SLJIT_SINGLE_THREADED) \
+	&& !defined(__NetBSD__)
 	static pthread_mutex_t se_lock = PTHREAD_MUTEX_INITIALIZER;
 #endif
 	static int se_protected = !SLJIT_PROT_WX;
 	int prot = PROT_READ | PROT_WRITE | SLJIT_PROT_WX;
 	sljit_uw* ptr;
 
 	if (SLJIT_UNLIKELY(se_protected < 0))
```

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/grepinput` & `pcre2-0.2.0/src/libpcre2/testdata/grepinput`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/grepinput3` & `pcre2-0.2.0/src/libpcre2/testdata/grepinput3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/grepinputx` & `pcre2-0.2.0/src/libpcre2/testdata/grepinputx`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/grepoutput` & `pcre2-0.2.0/src/libpcre2/testdata/grepoutput`

 * *Files 16% similar despite different names*

```diff
@@ -646,988 +646,1461 @@
 00002850: 6166 7465 720a 3539 373a 7a65 726f 0a52  after.597:zero.R
 00002860: 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  C=0.------------
 00002870: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00002880: 2054 6573 7420 3434 202d 2d2d 2d2d 2d2d   Test 44 -------
 00002890: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 000028a0: 2d2d 2d2d 2d2d 2d0a 3539 353a 6265 666f  -------.595:befo
 000028b0: 7265 0a35 3935 3a7a 6572 6f0a 3539 363a  re.595:zero.596:
-000028c0: 7a65 726f 0a35 3937 3a7a 6572 6f0a 5243  zero.597:zero.RC
-000028d0: 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  =0.-------------
-000028e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
-000028f0: 5465 7374 2034 3520 2d2d 2d2d 2d2d 2d2d  Test 45 --------
-00002900: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002910: 2d2d 2d2d 2d2d 0a31 303a 7061 7474 6572  ------.10:patter
-00002920: 6e0a 3539 353a 6269 6e61 7279 0a35 3936  n.595:binary.596
-00002930: 3a62 696e 6172 790a 3539 373a 6269 6e61  :binary.597:bina
-00002940: 7279 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  ry.RC=0.--------
-00002950: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002960: 2d2d 2d2d 2054 6573 7420 3436 202d 2d2d  ---- Test 46 ---
-00002970: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002980: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 7063 7265  -----------.pcre
-00002990: 3267 7265 703a 2045 7272 6f72 2069 6e20  2grep: Error in 
-000029a0: 326e 6420 636f 6d6d 616e 642d 6c69 6e65  2nd command-line
-000029b0: 2072 6567 6578 2061 7420 6f66 6673 6574   regex at offset
-000029c0: 2039 3a20 6d69 7373 696e 6720 636c 6f73   9: missing clos
-000029d0: 696e 6720 7061 7265 6e74 6865 7369 730a  ing parenthesis.
-000029e0: 5243 3d32 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=2.-----------
-000029f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002a00: 2d20 5465 7374 2034 3720 2d2d 2d2d 2d2d  - Test 47 ------
-00002a10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002a20: 2d2d 2d2d 2d2d 2d2d 0a41 422e 5645 0a52  --------.AB.VE.R
-00002a30: 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  C=0.------------
-00002a40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002a50: 2054 6573 7420 3438 202d 2d2d 2d2d 2d2d   Test 48 -------
-00002a60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002a70: 2d2d 2d2d 2d2d 2d0a 4142 4f56 4520 7468  -------.ABOVE th
-00002a80: 6520 656c 6570 6861 6e74 200a 4142 2e56  e elephant .AB.V
-00002a90: 450a 4142 2e56 4520 7468 6520 7475 7274  E.AB.VE the turt
-00002aa0: 6c65 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  le.RC=0.--------
-00002ab0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002ac0: 2d2d 2d2d 2054 6573 7420 3439 202d 2d2d  ---- Test 49 ---
-00002ad0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002ae0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 4142 4f56  -----------.ABOV
-00002af0: 4520 7468 6520 656c 6570 6861 6e74 200a  E the elephant .
-00002b00: 4142 2e56 450a 4142 2e56 4520 7468 6520  AB.VE.AB.VE the 
-00002b10: 7475 7274 6c65 0a50 5554 204e 4557 2044  turtle.PUT NEW D
-00002b20: 4154 4120 4142 4f56 4520 5448 4953 204c  ATA ABOVE THIS L
-00002b30: 494e 452e 0a52 433d 300a 2d2d 2d2d 2d2d  INE..RC=0.------
-00002b40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002b50: 2d2d 2d2d 2d2d 2054 6573 7420 3530 202d  ------ Test 50 -
+000028c0: 7a65 726f 0a35 3937 3a61 6674 6572 0a35  zero.597:after.5
+000028d0: 3937 3a7a 6572 6f0a 5243 3d30 0a2d 2d2d  97:zero.RC=0.---
+000028e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000028f0: 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374 2034  --------- Test 4
+00002900: 3520 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  5 --------------
+00002910: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002920: 0a31 303a 7061 7474 6572 6e0a 3539 353a  .10:pattern.595:
+00002930: 6269 6e61 7279 0a35 3936 3a62 696e 6172  binary.596:binar
+00002940: 790a 3539 373a 6269 6e61 7279 0a52 433d  y.597:binary.RC=
+00002950: 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  0.--------------
+00002960: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
+00002970: 6573 7420 3436 202d 2d2d 2d2d 2d2d 2d2d  est 46 ---------
+00002980: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002990: 2d2d 2d2d 2d0a 7063 7265 3267 7265 703a  -----.pcre2grep:
+000029a0: 2045 7272 6f72 2069 6e20 3173 7420 636f   Error in 1st co
+000029b0: 6d6d 616e 642d 6c69 6e65 2072 6567 6578  mmand-line regex
+000029c0: 2061 7420 6f66 6673 6574 2038 3a20 756e   at offset 8: un
+000029d0: 6d61 7463 6865 6420 636c 6f73 696e 6720  matched closing 
+000029e0: 7061 7265 6e74 6865 7369 730a 7063 7265  parenthesis.pcre
+000029f0: 3267 7265 703a 2045 7272 6f72 2069 6e20  2grep: Error in 
+00002a00: 326e 6420 636f 6d6d 616e 642d 6c69 6e65  2nd command-line
+00002a10: 2072 6567 6578 2061 7420 6f66 6673 6574   regex at offset
+00002a20: 2039 3a20 6d69 7373 696e 6720 636c 6f73   9: missing clos
+00002a30: 696e 6720 7061 7265 6e74 6865 7369 730a  ing parenthesis.
+00002a40: 7063 7265 3267 7265 703a 2045 7272 6f72  pcre2grep: Error
+00002a50: 2069 6e20 3372 6420 636f 6d6d 616e 642d   in 3rd command-
+00002a60: 6c69 6e65 2072 6567 6578 2061 7420 6f66  line regex at of
+00002a70: 6673 6574 2039 3a20 6d69 7373 696e 6720  fset 9: missing 
+00002a80: 7465 726d 696e 6174 696e 6720 5d20 666f  terminating ] fo
+00002a90: 7220 6368 6172 6163 7465 7220 636c 6173  r character clas
+00002aa0: 730a 7063 7265 3267 7265 703a 2045 7272  s.pcre2grep: Err
+00002ab0: 6f72 2069 6e20 3474 6820 636f 6d6d 616e  or in 4th comman
+00002ac0: 642d 6c69 6e65 2072 6567 6578 2061 7420  d-line regex at 
+00002ad0: 6f66 6673 6574 2039 3a20 6d69 7373 696e  offset 9: missin
+00002ae0: 6720 7465 726d 696e 6174 696e 6720 5d20  g terminating ] 
+00002af0: 666f 7220 6368 6172 6163 7465 7220 636c  for character cl
+00002b00: 6173 730a 5243 3d32 0a2d 2d2d 2d2d 2d2d  ass.RC=2.-------
+00002b10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002b20: 2d2d 2d2d 2d20 5465 7374 2034 3720 2d2d  ----- Test 47 --
+00002b30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002b40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a41 422e  ------------.AB.
+00002b50: 5645 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  VE.RC=0.--------
 00002b60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002b70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 5243  -------------.RC
-00002b80: 3d31 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  =1.-------------
-00002b90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
-00002ba0: 5465 7374 2035 3120 2d2d 2d2d 2d2d 2d2d  Test 51 --------
-00002bb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002bc0: 2d2d 2d2d 2d2d 0a6f 7665 7220 7468 6520  ------.over the 
-00002bd0: 6c61 7a79 2064 6f67 2e0a 5468 6973 2074  lazy dog..This t
-00002be0: 696d 6520 6974 206a 756d 7073 2061 6e64  ime it jumps and
-00002bf0: 206a 756d 7073 2061 6e64 206a 756d 7073   jumps and jumps
-00002c00: 2e0a 5468 6973 206c 696e 6520 636f 6e74  ..This line cont
-00002c10: 6169 6e73 205c 4520 616e 6420 2872 6567  ains \E and (reg
-00002c20: 6578 2920 2a6d 6574 612a 205b 6368 6172  ex) *meta* [char
-00002c30: 6163 7465 7273 5d2e 0a54 6865 2077 6f72  acters]..The wor
-00002c40: 6420 6973 2063 6174 2069 6e20 7468 6973  d is cat in this
-00002c50: 206c 696e 650a 5468 6520 6361 7465 7270   line.The caterp
-00002c60: 696c 6c61 7220 7361 7420 6f6e 2074 6865  illar sat on the
-00002c70: 206d 6174 0a54 6865 2073 6e6f 7763 6174   mat.The snowcat
-00002c80: 2069 7320 6e6f 7420 616e 2061 6e69 6d61   is not an anima
-00002c90: 6c0a 4120 6275 7269 6564 2066 656c 696e  l.A buried felin
-00002ca0: 6520 696e 2074 6865 2073 796e 6469 6361  e in the syndica
-00002cb0: 7465 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  te.RC=0.--------
-00002cc0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002cd0: 2d2d 2d2d 2054 6573 7420 3532 202d 2d2d  ---- Test 52 ---
-00002ce0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002cf0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 666f 7820  -----------.fox 
-00002d00: 1b5b 313b 3331 6d6a 756d 7073 1b5b 306d  .[1;31mjumps.[0m
-00002d10: 0a54 6869 7320 7469 6d65 2069 7420 1b5b  .This time it .[
-00002d20: 313b 3331 6d6a 756d 7073 1b5b 306d 2061  1;31mjumps.[0m a
-00002d30: 6e64 201b 5b31 3b33 316d 6a75 6d70 731b  nd .[1;31mjumps.
-00002d40: 5b30 6d20 616e 6420 1b5b 313b 3331 6d6a  [0m and .[1;31mj
-00002d50: 756d 7073 1b5b 306d 2e0a 5243 3d30 0a2d  umps.[0m..RC=0.-
-00002d60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002d70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
-00002d80: 2035 3320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   53 ------------
-00002d90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002da0: 2d2d 0a33 3639 3736 2c36 0a33 3639 3934  --.36976,6.36994
-00002db0: 2c34 0a33 3730 3238 2c34 0a33 3730 3730  ,4.37028,4.37070
-00002dc0: 2c35 0a33 3730 3837 2c34 0a52 433d 300a  ,5.37087,4.RC=0.
-00002dd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002de0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573  ------------ Tes
-00002df0: 7420 3534 202d 2d2d 2d2d 2d2d 2d2d 2d2d  t 54 -----------
-00002e00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002e10: 2d2d 2d0a 3539 353a 3135 2c36 0a35 3935  ---.595:15,6.595
-00002e20: 3a33 332c 340a 3539 363a 3238 2c34 0a35  :33,4.596:28,4.5
-00002e30: 3937 3a31 352c 350a 3539 373a 3332 2c34  97:15,5.597:32,4
-00002e40: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
-00002e50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002e60: 2d2d 2054 6573 7420 3535 202d 2d2d 2d2d  -- Test 55 -----
-00002e70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002e80: 2d2d 2d2d 2d2d 2d2d 0a48 6572 6520 6973  --------.Here is
-00002e90: 2074 6865 201b 5b31 3b33 316d 7061 7474   the .[1;31mpatt
-00002ea0: 6572 6e1b 5b30 6d20 6167 6169 6e2e 0a54  ern.[0m again..T
-00002eb0: 6861 7420 7469 6d65 2069 7420 7761 7320  hat time it was 
-00002ec0: 6f6e 2061 201b 5b31 3b33 316d 6c69 6e65  on a .[1;31mline
-00002ed0: 2062 7920 6974 7365 6c66 1b5b 306d 2e0a   by itself.[0m..
-00002ee0: 5468 6973 206c 696e 6520 636f 6e74 6169  This line contai
-00002ef0: 6e73 201b 5b31 3b33 316d 7061 7474 6572  ns .[1;31mpatter
-00002f00: 6e1b 5b30 6d20 6e6f 7420 6f6e 2061 201b  n.[0m not on a .
-00002f10: 5b31 3b33 316d 6c69 6e65 2062 7920 6974  [1;31mline by it
-00002f20: 7365 6c66 1b5b 306d 2e0a 5243 3d30 0a2d  self.[0m..RC=0.-
-00002f30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002f40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
-00002f50: 2035 3620 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   56 ------------
-00002f60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002f70: 2d0a 2e2f 7465 7374 6461 7461 2f67 7265  -../testdata/gre
-00002f80: 7069 6e70 7574 3a34 3536 0a2e 2f74 6573  pinput:456../tes
-00002f90: 7464 6174 612f 6772 6570 696e 7075 7433  tdata/grepinput3
-00002fa0: 3a30 0a2e 2f74 6573 7464 6174 612f 6772  :0../testdata/gr
-00002fb0: 6570 696e 7075 7438 3a30 0a2e 2f74 6573  epinput8:0../tes
-00002fc0: 7464 6174 612f 6772 6570 696e 7075 744d  tdata/grepinputM
-00002fd0: 3a30 0a2e 2f74 6573 7464 6174 612f 6772  :0../testdata/gr
-00002fe0: 6570 696e 7075 7476 3a31 0a2e 2f74 6573  epinputv:1../tes
-00002ff0: 7464 6174 612f 6772 6570 696e 7075 7478  tdata/grepinputx
-00003000: 3a30 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  :0.RC=0.--------
-00003010: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003020: 2d2d 2d2d 2054 6573 7420 3537 202d 2d2d  ---- Test 57 ---
-00003030: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003040: 2d2d 2d2d 2d2d 2d2d 2d2d 0a2e 2f74 6573  ----------../tes
-00003050: 7464 6174 612f 6772 6570 696e 7075 743a  tdata/grepinput:
-00003060: 3435 360a 2e2f 7465 7374 6461 7461 2f67  456../testdata/g
-00003070: 7265 7069 6e70 7574 763a 310a 5243 3d30  repinputv:1.RC=0
-00003080: 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .---------------
-00003090: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465  ------------- Te
-000030a0: 7374 2035 3820 2d2d 2d2d 2d2d 2d2d 2d2d  st 58 ----------
-000030b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000030c0: 2d2d 2d0a 5041 5454 4552 4e20 6174 2074  ---.PATTERN at t
-000030d0: 6865 2073 7461 7274 206f 6620 6120 6c69  he start of a li
-000030e0: 6e65 2e0a 496e 2074 6865 206d 6964 646c  ne..In the middl
-000030f0: 6520 6f66 2061 206c 696e 652c 2050 4154  e of a line, PAT
-00003100: 5445 524e 2061 7070 6561 7273 2e0a 4368  TERN appears..Ch
-00003110: 6563 6b20 7570 206f 6e20 5041 5454 4552  eck up on PATTER
-00003120: 4e20 6e65 6172 2074 6865 2065 6e64 2e0a  N near the end..
-00003130: 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=0.-----------
-00003140: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003150: 2d20 5465 7374 2035 3920 2d2d 2d2d 2d2d  - Test 59 ------
-00003160: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003170: 2d2d 2d2d 2d2d 2d0a 5041 5454 4552 4e20  -------.PATTERN 
-00003180: 6174 2074 6865 2073 7461 7274 206f 6620  at the start of 
-00003190: 6120 6c69 6e65 2e0a 496e 2074 6865 206d  a line..In the m
-000031a0: 6964 646c 6520 6f66 2061 206c 696e 652c  iddle of a line,
-000031b0: 2050 4154 5445 524e 2061 7070 6561 7273   PATTERN appears
-000031c0: 2e0a 4368 6563 6b20 7570 206f 6e20 5041  ..Check up on PA
-000031d0: 5454 4552 4e20 6e65 6172 2074 6865 2065  TTERN near the e
-000031e0: 6e64 2e0a 5243 3d30 0a2d 2d2d 2d2d 2d2d  nd..RC=0.-------
-000031f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003200: 2d2d 2d2d 2d20 5465 7374 2036 3020 2d2d  ----- Test 60 --
-00003210: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003220: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 5041 5454  -----------.PATT
-00003230: 4552 4e20 6174 2074 6865 2073 7461 7274  ERN at the start
-00003240: 206f 6620 6120 6c69 6e65 2e0a 496e 2074   of a line..In t
-00003250: 6865 206d 6964 646c 6520 6f66 2061 206c  he middle of a l
-00003260: 696e 652c 2050 4154 5445 524e 2061 7070  ine, PATTERN app
-00003270: 6561 7273 2e0a 4368 6563 6b20 7570 206f  ears..Check up o
-00003280: 6e20 5041 5454 4552 4e20 6e65 6172 2074  n PATTERN near t
-00003290: 6865 2065 6e64 2e0a 5243 3d30 0a2d 2d2d  he end..RC=0.---
-000032a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000032b0: 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374 2036  --------- Test 6
-000032c0: 3120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  1 --------------
-000032d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
-000032e0: 5041 5454 4552 4e20 6174 2074 6865 2073  PATTERN at the s
-000032f0: 7461 7274 206f 6620 6120 6c69 6e65 2e0a  tart of a line..
-00003300: 496e 2074 6865 206d 6964 646c 6520 6f66  In the middle of
-00003310: 2061 206c 696e 652c 2050 4154 5445 524e   a line, PATTERN
-00003320: 2061 7070 6561 7273 2e0a 4368 6563 6b20   appears..Check 
-00003330: 7570 206f 6e20 5041 5454 4552 4e20 6e65  up on PATTERN ne
-00003340: 6172 2074 6865 2065 6e64 2e0a 5243 3d30  ar the end..RC=0
-00003350: 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .---------------
-00003360: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465  ------------- Te
-00003370: 7374 2036 3220 2d2d 2d2d 2d2d 2d2d 2d2d  st 62 ----------
-00003380: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003390: 2d2d 2d0a 7063 7265 3267 7265 703a 2070  ---.pcre2grep: p
-000033a0: 6372 6532 5f6d 6174 6368 2829 2067 6176  cre2_match() gav
-000033b0: 6520 6572 726f 7220 2d34 3720 7768 696c  e error -47 whil
-000033c0: 6520 6d61 7463 6869 6e67 2074 6578 7420  e matching text 
-000033d0: 7468 6174 2073 7461 7274 733a 0a0a 5468  that starts:..Th
-000033e0: 6973 2069 7320 6120 6669 6c65 206f 6620  is is a file of 
-000033f0: 6d69 7363 656c 6c61 6e65 6f75 7320 7465  miscellaneous te
-00003400: 7874 2074 6861 7420 6973 2075 7365 6420  xt that is used 
-00003410: 6173 2074 6573 7420 6461 7461 2066 6f72  as test data for
-00003420: 2063 6865 636b 696e 670a 7468 6174 2074   checking.that t
-00003430: 6865 2070 6372 6567 7265 7020 636f 6d6d  he pcregrep comm
-00003440: 616e 6420 6973 2077 6f72 6b69 6e67 2063  and is working c
-00003450: 6f72 7265 6374 6c79 2e20 5468 6520 6669  orrectly. The fi
-00003460: 6c65 206d 7573 7420 6265 206d 6f72 6520  le must be more 
-00003470: 7468 616e 0a32 344b 6942 206c 6f6e 6720  than.24KiB long 
-00003480: 736f 2074 6861 7420 6974 206e 6565 6473  so that it needs
-00003490: 206d 6f72 6520 7468 616e 2061 2073 696e   more than a sin
-000034a0: 676c 6520 7265 0a0a 7063 7265 3267 7265  gle re..pcre2gre
-000034b0: 703a 2045 7272 6f72 202d 3436 2c20 2d34  p: Error -46, -4
-000034c0: 372c 202d 3533 206f 7220 2d36 3320 6d65  7, -53 or -63 me
-000034d0: 616e 7320 7468 6174 2061 2072 6573 6f75  ans that a resou
-000034e0: 7263 6520 6c69 6d69 7420 7761 7320 6578  rce limit was ex
-000034f0: 6365 6564 6564 2e0a 7063 7265 3267 7265  ceeded..pcre2gre
-00003500: 703a 2043 6865 636b 2079 6f75 7220 7265  p: Check your re
-00003510: 6765 7820 666f 7220 6e65 7374 6564 2075  gex for nested u
-00003520: 6e6c 696d 6974 6564 206c 6f6f 7073 2e0a  nlimited loops..
-00003530: 5243 3d31 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=1.-----------
-00003540: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003550: 2d20 5465 7374 2036 3320 2d2d 2d2d 2d2d  - Test 63 ------
-00003560: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003570: 2d2d 2d2d 2d2d 2d0a 7063 7265 3267 7265  -------.pcre2gre
-00003580: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
-00003590: 2067 6176 6520 6572 726f 7220 2d35 3320   gave error -53 
-000035a0: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
-000035b0: 6578 7420 7468 6174 2073 7461 7274 733a  ext that starts:
-000035c0: 0a0a 5468 6973 2069 7320 6120 6669 6c65  ..This is a file
-000035d0: 206f 6620 6d69 7363 656c 6c61 6e65 6f75   of miscellaneou
-000035e0: 7320 7465 7874 2074 6861 7420 6973 2075  s text that is u
-000035f0: 7365 6420 6173 2074 6573 7420 6461 7461  sed as test data
-00003600: 2066 6f72 2063 6865 636b 696e 670a 7468   for checking.th
-00003610: 6174 2074 6865 2070 6372 6567 7265 7020  at the pcregrep 
-00003620: 636f 6d6d 616e 6420 6973 2077 6f72 6b69  command is worki
-00003630: 6e67 2063 6f72 7265 6374 6c79 2e20 5468  ng correctly. Th
-00003640: 6520 6669 6c65 206d 7573 7420 6265 206d  e file must be m
-00003650: 6f72 6520 7468 616e 0a32 344b 6942 206c  ore than.24KiB l
-00003660: 6f6e 6720 736f 2074 6861 7420 6974 206e  ong so that it n
-00003670: 6565 6473 206d 6f72 6520 7468 616e 2061  eeds more than a
-00003680: 2073 696e 676c 6520 7265 0a0a 7063 7265   single re..pcre
-00003690: 3267 7265 703a 2045 7272 6f72 202d 3436  2grep: Error -46
-000036a0: 2c20 2d34 372c 202d 3533 206f 7220 2d36  , -47, -53 or -6
-000036b0: 3320 6d65 616e 7320 7468 6174 2061 2072  3 means that a r
-000036c0: 6573 6f75 7263 6520 6c69 6d69 7420 7761  esource limit wa
-000036d0: 7320 6578 6365 6564 6564 2e0a 7063 7265  s exceeded..pcre
-000036e0: 3267 7265 703a 2043 6865 636b 2079 6f75  2grep: Check you
-000036f0: 7220 7265 6765 7820 666f 7220 6e65 7374  r regex for nest
-00003700: 6564 2075 6e6c 696d 6974 6564 206c 6f6f  ed unlimited loo
-00003710: 7073 2e0a 5243 3d31 0a2d 2d2d 2d2d 2d2d  ps..RC=1.-------
-00003720: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003730: 2d2d 2d2d 2d20 5465 7374 2036 3420 2d2d  ----- Test 64 --
-00003740: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003750: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a61 7070  ------------.app
-00003760: 6561 7273 0a52 433d 300a 2d2d 2d2d 2d2d  ears.RC=0.------
-00003770: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003780: 2d2d 2d2d 2d2d 2054 6573 7420 3635 202d  ------ Test 65 -
-00003790: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000037a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 7065  -------------.pe
-000037b0: 6172 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  ar.RC=0.--------
-000037c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000037d0: 2d2d 2d2d 2054 6573 7420 3636 202d 2d2d  ---- Test 66 ---
-000037e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000037f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 5243 3d30  -----------.RC=0
-00003800: 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .---------------
-00003810: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465  ------------- Te
-00003820: 7374 2036 3720 2d2d 2d2d 2d2d 2d2d 2d2d  st 67 ----------
-00003830: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003840: 2d2d 2d2d 0a52 433d 300a 2d2d 2d2d 2d2d  ----.RC=0.------
-00003850: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003860: 2d2d 2d2d 2d2d 2054 6573 7420 3638 202d  ------ Test 68 -
+00002b70: 2d2d 2d2d 2054 6573 7420 3438 202d 2d2d  ---- Test 48 ---
+00002b80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002b90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 4142 4f56  -----------.ABOV
+00002ba0: 4520 7468 6520 656c 6570 6861 6e74 200a  E the elephant .
+00002bb0: 4142 2e56 450a 4142 2e56 4520 7468 6520  AB.VE.AB.VE the 
+00002bc0: 7475 7274 6c65 0a52 433d 300a 2d2d 2d2d  turtle.RC=0.----
+00002bd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002be0: 2d2d 2d2d 2d2d 2d2d 2054 6573 7420 3439  -------- Test 49
+00002bf0: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+00002c00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
+00002c10: 4142 4f56 4520 7468 6520 656c 6570 6861  ABOVE the elepha
+00002c20: 6e74 200a 4142 2e56 450a 4142 2e56 4520  nt .AB.VE.AB.VE 
+00002c30: 7468 6520 7475 7274 6c65 0a50 5554 204e  the turtle.PUT N
+00002c40: 4557 2044 4154 4120 4142 4f56 4520 5448  EW DATA ABOVE TH
+00002c50: 4953 204c 494e 452e 0a52 433d 300a 2d2d  IS LINE..RC=0.--
+00002c60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002c70: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
+00002c80: 3530 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  50 -------------
+00002c90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002ca0: 2d0a 5243 3d31 0a2d 2d2d 2d2d 2d2d 2d2d  -.RC=1.---------
+00002cb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002cc0: 2d2d 2d20 5465 7374 2035 3120 2d2d 2d2d  --- Test 51 ----
+00002cd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002ce0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a6f 7665 7220  ----------.over 
+00002cf0: 7468 6520 6c61 7a79 2064 6f67 2e0a 5468  the lazy dog..Th
+00002d00: 6973 2074 696d 6520 6974 206a 756d 7073  is time it jumps
+00002d10: 2061 6e64 206a 756d 7073 2061 6e64 206a   and jumps and j
+00002d20: 756d 7073 2e0a 5468 6973 206c 696e 6520  umps..This line 
+00002d30: 636f 6e74 6169 6e73 205c 4520 616e 6420  contains \E and 
+00002d40: 2872 6567 6578 2920 2a6d 6574 612a 205b  (regex) *meta* [
+00002d50: 6368 6172 6163 7465 7273 5d2e 0a54 6865  characters]..The
+00002d60: 2077 6f72 6420 6973 2063 6174 2069 6e20   word is cat in 
+00002d70: 7468 6973 206c 696e 650a 5468 6520 6361  this line.The ca
+00002d80: 7465 7270 696c 6c61 7220 7361 7420 6f6e  terpillar sat on
+00002d90: 2074 6865 206d 6174 0a54 6865 2073 6e6f   the mat.The sno
+00002da0: 7763 6174 2069 7320 6e6f 7420 616e 2061  wcat is not an a
+00002db0: 6e69 6d61 6c0a 4120 6275 7269 6564 2066  nimal.A buried f
+00002dc0: 656c 696e 6520 696e 2074 6865 2073 796e  eline in the syn
+00002dd0: 6469 6361 7465 0a52 433d 300a 2d2d 2d2d  dicate.RC=0.----
+00002de0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002df0: 2d2d 2d2d 2d2d 2d2d 2054 6573 7420 3532  -------- Test 52
+00002e00: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+00002e10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
+00002e20: 666f 7820 1b5b 313b 3331 6d6a 756d 7073  fox .[1;31mjumps
+00002e30: 1b5b 306d 0a54 6869 7320 7469 6d65 2069  .[0m.This time i
+00002e40: 7420 1b5b 313b 3331 6d6a 756d 7073 1b5b  t .[1;31mjumps.[
+00002e50: 306d 2061 6e64 201b 5b31 3b33 316d 6a75  0m and .[1;31mju
+00002e60: 6d70 731b 5b30 6d20 616e 6420 1b5b 313b  mps.[0m and .[1;
+00002e70: 3331 6d6a 756d 7073 1b5b 306d 2e0a 5243  31mjumps.[0m..RC
+00002e80: 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  =0.-------------
+00002e90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
+00002ea0: 5465 7374 2035 3320 2d2d 2d2d 2d2d 2d2d  Test 53 --------
+00002eb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002ec0: 2d2d 2d2d 2d2d 0a33 3639 3736 2c36 0a33  ------.36976,6.3
+00002ed0: 3639 3934 2c34 0a33 3730 3238 2c34 0a33  6994,4.37028,4.3
+00002ee0: 3730 3730 2c35 0a33 3730 3837 2c34 0a52  7070,5.37087,4.R
+00002ef0: 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  C=0.------------
+00002f00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002f10: 2054 6573 7420 3534 202d 2d2d 2d2d 2d2d   Test 54 -------
+00002f20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002f30: 2d2d 2d2d 2d2d 2d0a 3539 353a 3135 2c36  -------.595:15,6
+00002f40: 0a35 3935 3a33 332c 340a 3539 363a 3238  .595:33,4.596:28
+00002f50: 2c34 0a35 3937 3a31 352c 350a 3539 373a  ,4.597:15,5.597:
+00002f60: 3332 2c34 0a52 433d 300a 2d2d 2d2d 2d2d  32,4.RC=0.------
+00002f70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002f80: 2d2d 2d2d 2d2d 2054 6573 7420 3535 202d  ------ Test 55 -
+00002f90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002fa0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a48 6572  ------------.Her
+00002fb0: 6520 6973 2074 6865 201b 5b31 3b33 316d  e is the .[1;31m
+00002fc0: 7061 7474 6572 6e1b 5b30 6d20 6167 6169  pattern.[0m agai
+00002fd0: 6e2e 0a54 6861 7420 7469 6d65 2069 7420  n..That time it 
+00002fe0: 7761 7320 6f6e 2061 201b 5b31 3b33 316d  was on a .[1;31m
+00002ff0: 6c69 6e65 2062 7920 6974 7365 6c66 1b5b  line by itself.[
+00003000: 306d 2e0a 5468 6973 206c 696e 6520 636f  0m..This line co
+00003010: 6e74 6169 6e73 201b 5b31 3b33 316d 7061  ntains .[1;31mpa
+00003020: 7474 6572 6e1b 5b30 6d20 6e6f 7420 6f6e  ttern.[0m not on
+00003030: 2061 201b 5b31 3b33 316d 6c69 6e65 2062   a .[1;31mline b
+00003040: 7920 6974 7365 6c66 1b5b 306d 2e0a 5243  y itself.[0m..RC
+00003050: 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  =0.-------------
+00003060: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
+00003070: 5465 7374 2035 3620 2d2d 2d2d 2d2d 2d2d  Test 56 --------
+00003080: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003090: 2d2d 2d2d 2d0a 2e2f 7465 7374 6461 7461  -----../testdata
+000030a0: 2f67 7265 7069 6e70 7574 3a34 3536 0a2e  /grepinput:456..
+000030b0: 2f74 6573 7464 6174 612f 6772 6570 696e  /testdata/grepin
+000030c0: 7075 7433 3a30 0a2e 2f74 6573 7464 6174  put3:0../testdat
+000030d0: 612f 6772 6570 696e 7075 7438 3a30 0a2e  a/grepinput8:0..
+000030e0: 2f74 6573 7464 6174 612f 6772 6570 696e  /testdata/grepin
+000030f0: 7075 744d 3a30 0a2e 2f74 6573 7464 6174  putM:0../testdat
+00003100: 612f 6772 6570 696e 7075 7476 3a31 0a2e  a/grepinputv:1..
+00003110: 2f74 6573 7464 6174 612f 6772 6570 696e  /testdata/grepin
+00003120: 7075 7478 3a30 0a52 433d 300a 2d2d 2d2d  putx:0.RC=0.----
+00003130: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003140: 2d2d 2d2d 2d2d 2d2d 2054 6573 7420 3537  -------- Test 57
+00003150: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+00003160: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a2e  --------------..
+00003170: 2f74 6573 7464 6174 612f 6772 6570 696e  /testdata/grepin
+00003180: 7075 743a 3435 360a 2e2f 7465 7374 6461  put:456../testda
+00003190: 7461 2f67 7265 7069 6e70 7574 763a 310a  ta/grepinputv:1.
+000031a0: 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=0.-----------
+000031b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000031c0: 2d20 5465 7374 2035 3820 2d2d 2d2d 2d2d  - Test 58 ------
+000031d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000031e0: 2d2d 2d2d 2d2d 2d0a 5041 5454 4552 4e20  -------.PATTERN 
+000031f0: 6174 2074 6865 2073 7461 7274 206f 6620  at the start of 
+00003200: 6120 6c69 6e65 2e0a 496e 2074 6865 206d  a line..In the m
+00003210: 6964 646c 6520 6f66 2061 206c 696e 652c  iddle of a line,
+00003220: 2050 4154 5445 524e 2061 7070 6561 7273   PATTERN appears
+00003230: 2e0a 4368 6563 6b20 7570 206f 6e20 5041  ..Check up on PA
+00003240: 5454 4552 4e20 6e65 6172 2074 6865 2065  TTERN near the e
+00003250: 6e64 2e0a 5243 3d30 0a2d 2d2d 2d2d 2d2d  nd..RC=0.-------
+00003260: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003270: 2d2d 2d2d 2d20 5465 7374 2035 3920 2d2d  ----- Test 59 --
+00003280: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003290: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 5041 5454  -----------.PATT
+000032a0: 4552 4e20 6174 2074 6865 2073 7461 7274  ERN at the start
+000032b0: 206f 6620 6120 6c69 6e65 2e0a 496e 2074   of a line..In t
+000032c0: 6865 206d 6964 646c 6520 6f66 2061 206c  he middle of a l
+000032d0: 696e 652c 2050 4154 5445 524e 2061 7070  ine, PATTERN app
+000032e0: 6561 7273 2e0a 4368 6563 6b20 7570 206f  ears..Check up o
+000032f0: 6e20 5041 5454 4552 4e20 6e65 6172 2074  n PATTERN near t
+00003300: 6865 2065 6e64 2e0a 5243 3d30 0a2d 2d2d  he end..RC=0.---
+00003310: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003320: 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374 2036  --------- Test 6
+00003330: 3020 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  0 --------------
+00003340: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
+00003350: 5041 5454 4552 4e20 6174 2074 6865 2073  PATTERN at the s
+00003360: 7461 7274 206f 6620 6120 6c69 6e65 2e0a  tart of a line..
+00003370: 496e 2074 6865 206d 6964 646c 6520 6f66  In the middle of
+00003380: 2061 206c 696e 652c 2050 4154 5445 524e   a line, PATTERN
+00003390: 2061 7070 6561 7273 2e0a 4368 6563 6b20   appears..Check 
+000033a0: 7570 206f 6e20 5041 5454 4552 4e20 6e65  up on PATTERN ne
+000033b0: 6172 2074 6865 2065 6e64 2e0a 5243 3d30  ar the end..RC=0
+000033c0: 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .---------------
+000033d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465  ------------- Te
+000033e0: 7374 2036 3120 2d2d 2d2d 2d2d 2d2d 2d2d  st 61 ----------
+000033f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003400: 2d2d 2d0a 5041 5454 4552 4e20 6174 2074  ---.PATTERN at t
+00003410: 6865 2073 7461 7274 206f 6620 6120 6c69  he start of a li
+00003420: 6e65 2e0a 496e 2074 6865 206d 6964 646c  ne..In the middl
+00003430: 6520 6f66 2061 206c 696e 652c 2050 4154  e of a line, PAT
+00003440: 5445 524e 2061 7070 6561 7273 2e0a 4368  TERN appears..Ch
+00003450: 6563 6b20 7570 206f 6e20 5041 5454 4552  eck up on PATTER
+00003460: 4e20 6e65 6172 2074 6865 2065 6e64 2e0a  N near the end..
+00003470: 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=0.-----------
+00003480: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003490: 2d20 5465 7374 2036 3220 2d2d 2d2d 2d2d  - Test 62 ------
+000034a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000034b0: 2d2d 2d2d 2d2d 2d0a 7063 7265 3267 7265  -------.pcre2gre
+000034c0: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+000034d0: 2067 6176 6520 6572 726f 7220 2d34 3720   gave error -47 
+000034e0: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+000034f0: 6578 7420 7468 6174 2073 7461 7274 733a  ext that starts:
+00003500: 0a0a 5468 6973 2069 7320 6120 6669 6c65  ..This is a file
+00003510: 206f 6620 6d69 7363 656c 6c61 6e65 6f75   of miscellaneou
+00003520: 7320 7465 7874 2074 6861 7420 6973 2075  s text that is u
+00003530: 7365 6420 6173 2074 6573 7420 6461 7461  sed as test data
+00003540: 2066 6f72 2063 6865 636b 696e 670a 7468   for checking.th
+00003550: 6174 2074 6865 2070 6372 6567 7265 7020  at the pcregrep 
+00003560: 636f 6d6d 616e 6420 6973 2077 6f72 6b69  command is worki
+00003570: 6e67 2063 6f72 7265 6374 6c79 2e20 5468  ng correctly. Th
+00003580: 6520 6669 6c65 206d 7573 7420 6265 206d  e file must be m
+00003590: 6f72 6520 7468 616e 0a32 344b 6942 206c  ore than.24KiB l
+000035a0: 6f6e 6720 736f 2074 6861 7420 6974 206e  ong so that it n
+000035b0: 6565 6473 206d 6f72 6520 7468 616e 2061  eeds more than a
+000035c0: 2073 696e 676c 6520 7265 0a0a 7063 7265   single re..pcre
+000035d0: 3267 7265 703a 2045 7272 6f72 202d 3436  2grep: Error -46
+000035e0: 2c20 2d34 372c 202d 3533 206f 7220 2d36  , -47, -53 or -6
+000035f0: 3320 6d65 616e 7320 7468 6174 2061 2072  3 means that a r
+00003600: 6573 6f75 7263 6520 6c69 6d69 7420 7761  esource limit wa
+00003610: 7320 6578 6365 6564 6564 2e0a 7063 7265  s exceeded..pcre
+00003620: 3267 7265 703a 2043 6865 636b 2079 6f75  2grep: Check you
+00003630: 7220 7265 6765 7820 666f 7220 6e65 7374  r regex for nest
+00003640: 6564 2075 6e6c 696d 6974 6564 206c 6f6f  ed unlimited loo
+00003650: 7073 2e0a 5243 3d31 0a2d 2d2d 2d2d 2d2d  ps..RC=1.-------
+00003660: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003670: 2d2d 2d2d 2d20 5465 7374 2036 3320 2d2d  ----- Test 63 --
+00003680: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003690: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 7063 7265  -----------.pcre
+000036a0: 3267 7265 703a 2070 6372 6532 5f6d 6174  2grep: pcre2_mat
+000036b0: 6368 2829 2067 6176 6520 6572 726f 7220  ch() gave error 
+000036c0: 2d35 3320 7768 696c 6520 6d61 7463 6869  -53 while matchi
+000036d0: 6e67 2074 6578 7420 7468 6174 2073 7461  ng text that sta
+000036e0: 7274 733a 0a0a 5468 6973 2069 7320 6120  rts:..This is a 
+000036f0: 6669 6c65 206f 6620 6d69 7363 656c 6c61  file of miscella
+00003700: 6e65 6f75 7320 7465 7874 2074 6861 7420  neous text that 
+00003710: 6973 2075 7365 6420 6173 2074 6573 7420  is used as test 
+00003720: 6461 7461 2066 6f72 2063 6865 636b 696e  data for checkin
+00003730: 670a 7468 6174 2074 6865 2070 6372 6567  g.that the pcreg
+00003740: 7265 7020 636f 6d6d 616e 6420 6973 2077  rep command is w
+00003750: 6f72 6b69 6e67 2063 6f72 7265 6374 6c79  orking correctly
+00003760: 2e20 5468 6520 6669 6c65 206d 7573 7420  . The file must 
+00003770: 6265 206d 6f72 6520 7468 616e 0a32 344b  be more than.24K
+00003780: 6942 206c 6f6e 6720 736f 2074 6861 7420  iB long so that 
+00003790: 6974 206e 6565 6473 206d 6f72 6520 7468  it needs more th
+000037a0: 616e 2061 2073 696e 676c 6520 7265 0a0a  an a single re..
+000037b0: 7063 7265 3267 7265 703a 2045 7272 6f72  pcre2grep: Error
+000037c0: 202d 3436 2c20 2d34 372c 202d 3533 206f   -46, -47, -53 o
+000037d0: 7220 2d36 3320 6d65 616e 7320 7468 6174  r -63 means that
+000037e0: 2061 2072 6573 6f75 7263 6520 6c69 6d69   a resource limi
+000037f0: 7420 7761 7320 6578 6365 6564 6564 2e0a  t was exceeded..
+00003800: 7063 7265 3267 7265 703a 2043 6865 636b  pcre2grep: Check
+00003810: 2079 6f75 7220 7265 6765 7820 666f 7220   your regex for 
+00003820: 6e65 7374 6564 2075 6e6c 696d 6974 6564  nested unlimited
+00003830: 206c 6f6f 7073 2e0a 5243 3d31 0a2d 2d2d   loops..RC=1.---
+00003840: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003850: 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374 2036  --------- Test 6
+00003860: 3420 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  4 --------------
 00003870: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003880: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 7065  -------------.pe
-00003890: 6172 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  ar.RC=0.--------
-000038a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000038b0: 2d2d 2d2d 2054 6573 7420 3639 202d 2d2d  ---- Test 69 ---
+00003880: 0a61 7070 6561 7273 0a52 433d 300a 2d2d  .appears.RC=0.--
+00003890: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000038a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
+000038b0: 3635 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  65 -------------
 000038c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000038d0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a31 3a54 6869  ----------.1:Thi
-000038e0: 7320 6973 2061 2073 6563 6f6e 6420 6669  s is a second fi
-000038f0: 6c65 206f 6620 696e 7075 7420 666f 7220  le of input for 
-00003900: 7468 6520 7063 7265 6772 6570 2074 6573  the pcregrep tes
-00003910: 7473 2e0a 323a 0a34 3a0a 353a 5061 7474  ts..2:.4:.5:Patt
-00003920: 6572 6e0a 363a 5468 6174 2074 696d 6520  ern.6:That time 
-00003930: 6974 2077 6173 206f 6e20 6120 6c69 6e65  it was on a line
-00003940: 2062 7920 6974 7365 6c66 2e0a 373a 0a38   by itself..7:.8
-00003950: 3a54 6f20 7061 7420 6f72 206e 6f74 2074  :To pat or not t
-00003960: 6f20 7061 742c 2074 6861 7420 6973 2074  o pat, that is t
-00003970: 6865 2071 7565 7374 696f 6e2e 0a39 3a0a  he question..9:.
-00003980: 3130 3a63 6f6d 706c 6574 6520 7061 6972  10:complete pair
-00003990: 0a31 313a 6f66 206c 696e 6573 0a31 323a  .11:of lines.12:
-000039a0: 0a31 333a 5468 6174 2077 6173 2061 2063  .13:That was a c
-000039b0: 6f6d 706c 6574 6520 7061 6972 0a31 343a  omplete pair.14:
-000039c0: 6f66 206c 696e 6573 2061 6c6c 2062 7920  of lines all by 
-000039d0: 7468 656d 7365 6c76 6573 2e0a 3135 3a0a  themselves..15:.
-000039e0: 3136 3a63 6f6d 706c 6574 6520 7061 6972  16:complete pair
-000039f0: 0a31 373a 6f66 206c 696e 6573 0a31 383a  .17:of lines.18:
-00003a00: 0a31 393a 416e 6420 7468 6572 6520 7468  .19:And there th
-00003a10: 6579 2077 6572 6520 6167 6169 6e2c 2074  ey were again, t
-00003a20: 6f20 6368 6563 6b20 6c69 6e65 206e 756d  o check line num
-00003a30: 6265 7273 2e0a 3230 3a0a 3231 3a6f 6e65  bers..20:.21:one
-00003a40: 0a32 323a 7477 6f0a 3233 3a74 6872 6565  .22:two.23:three
-00003a50: 0a32 343a 666f 7572 0a32 353a 6669 7665  .24:four.25:five
-00003a60: 0a32 363a 7369 780a 3237 3a73 6576 656e  .26:six.27:seven
-00003a70: 0a32 383a 6569 6768 740a 3239 3a6e 696e  .28:eight.29:nin
-00003a80: 650a 3330 3a74 656e 0a33 313a 656c 6576  e.30:ten.31:elev
-00003a90: 656e 0a33 323a 7477 656c 7665 0a33 333a  en.32:twelve.33:
-00003aa0: 7468 6972 7465 656e 0a33 343a 666f 7572  thirteen.34:four
-00003ab0: 7465 656e 0a33 353a 6669 6674 6565 6e0a  teen.35:fifteen.
-00003ac0: 3336 3a73 6978 7465 656e 0a33 373a 7365  36:sixteen.37:se
-00003ad0: 7665 6e74 6565 6e0a 3338 3a65 6967 6874  venteen.38:eight
-00003ae0: 6565 6e0a 3339 3a6e 696e 6574 6565 6e0a  een.39:nineteen.
-00003af0: 3430 3a74 7765 6e74 790a 3431 3a0a 3433  40:twenty.41:.43
-00003b00: 3a54 6869 7320 6973 2074 6865 206c 6173  :This is the las
-00003b10: 7420 6c69 6e65 206f 6620 7468 6973 2066  t line of this f
-00003b20: 696c 652e 0a52 433d 300a 2d2d 2d2d 2d2d  ile..RC=0.------
-00003b30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003b40: 2d2d 2d2d 2d2d 2054 6573 7420 3730 202d  ------ Test 70 -
-00003b50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003b60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a1b 5b31  ------------..[1
-00003b70: 3b33 316d 7472 6970 6c65 3a09 7431 5f74  ;31mtriple:.t1_t
-00003b80: 7874 0973 315f 7461 6709 735f 7478 7409  xt.s1_tag.s_txt.
-00003b90: 705f 7461 6709 705f 7478 7409 6f5f 7461  p_tag.p_txt.o_ta
-00003ba0: 6709 6f5f 7478 740a 0a1b 5b30 6d1b 5b31  g.o_txt...[0m.[1
-00003bb0: 3b33 316d 7472 6970 6c65 3a09 7433 5f74  ;31mtriple:.t3_t
-00003bc0: 7874 0973 325f 7461 6709 735f 7478 7409  xt.s2_tag.s_txt.
-00003bd0: 705f 7461 6709 705f 7478 7409 6f5f 7461  p_tag.p_txt.o_ta
-00003be0: 6709 6f5f 7478 740a 0a1b 5b30 6d1b 5b31  g.o_txt...[0m.[1
-00003bf0: 3b33 316d 7472 6970 6c65 3a09 7434 5f74  ;31mtriple:.t4_t
-00003c00: 7874 0973 315f 7461 6709 735f 7478 7409  xt.s1_tag.s_txt.
-00003c10: 705f 7461 6709 705f 7478 7409 6f5f 7461  p_tag.p_txt.o_ta
-00003c20: 6709 6f5f 7478 740a 0a1b 5b30 6d1b 5b31  g.o_txt...[0m.[1
-00003c30: 3b33 316d 7472 6970 6c65 3a09 7436 5f74  ;31mtriple:.t6_t
-00003c40: 7874 0973 325f 7461 6709 735f 7478 7409  xt.s2_tag.s_txt.
-00003c50: 705f 7461 6709 705f 7478 7409 6f5f 7461  p_tag.p_txt.o_ta
-00003c60: 6709 6f5f 7478 740a 0a1b 5b30 6d52 433d  g.o_txt...[0mRC=
-00003c70: 300a 313a 1b5b 313b 3331 6d74 7269 706c  0.1:.[1;31mtripl
-00003c80: 653a 0974 315f 7478 7409 7331 5f74 6167  e:.t1_txt.s1_tag
-00003c90: 0973 5f74 7874 0970 5f74 6167 0970 5f74  .s_txt.p_tag.p_t
-00003ca0: 7874 096f 5f74 6167 096f 5f74 7874 0a0a  xt.o_tag.o_txt..
-00003cb0: 1b5b 306d 363a 1b5b 313b 3331 6d74 7269  .[0m6:.[1;31mtri
-00003cc0: 706c 653a 0974 335f 7478 7409 7332 5f74  ple:.t3_txt.s2_t
-00003cd0: 6167 0973 5f74 7874 0970 5f74 6167 0970  ag.s_txt.p_tag.p
-00003ce0: 5f74 7874 096f 5f74 6167 096f 5f74 7874  _txt.o_tag.o_txt
-00003cf0: 0a0a 1b5b 306d 383a 1b5b 313b 3331 6d74  ...[0m8:.[1;31mt
-00003d00: 7269 706c 653a 0974 345f 7478 7409 7331  riple:.t4_txt.s1
-00003d10: 5f74 6167 0973 5f74 7874 0970 5f74 6167  _tag.s_txt.p_tag
-00003d20: 0970 5f74 7874 096f 5f74 6167 096f 5f74  .p_txt.o_tag.o_t
-00003d30: 7874 0a0a 1b5b 306d 3133 3a1b 5b31 3b33  xt...[0m13:.[1;3
-00003d40: 316d 7472 6970 6c65 3a09 7436 5f74 7874  1mtriple:.t6_txt
-00003d50: 0973 325f 7461 6709 735f 7478 7409 705f  .s2_tag.s_txt.p_
-00003d60: 7461 6709 705f 7478 7409 6f5f 7461 6709  tag.p_txt.o_tag.
-00003d70: 6f5f 7478 740a 0a1b 5b30 6d52 433d 300a  o_txt...[0mRC=0.
-00003d80: 7472 6970 6c65 3a09 7431 5f74 7874 0973  triple:.t1_txt.s
-00003d90: 315f 7461 6709 735f 7478 7409 705f 7461  1_tag.s_txt.p_ta
-00003da0: 6709 705f 7478 7409 6f5f 7461 6709 6f5f  g.p_txt.o_tag.o_
-00003db0: 7478 740a 0a74 7269 706c 653a 0974 335f  txt..triple:.t3_
-00003dc0: 7478 7409 7332 5f74 6167 0973 5f74 7874  txt.s2_tag.s_txt
-00003dd0: 0970 5f74 6167 0970 5f74 7874 096f 5f74  .p_tag.p_txt.o_t
-00003de0: 6167 096f 5f74 7874 0a0a 7472 6970 6c65  ag.o_txt..triple
-00003df0: 3a09 7434 5f74 7874 0973 315f 7461 6709  :.t4_txt.s1_tag.
-00003e00: 735f 7478 7409 705f 7461 6709 705f 7478  s_txt.p_tag.p_tx
-00003e10: 7409 6f5f 7461 6709 6f5f 7478 740a 0a74  t.o_tag.o_txt..t
-00003e20: 7269 706c 653a 0974 365f 7478 7409 7332  riple:.t6_txt.s2
-00003e30: 5f74 6167 0973 5f74 7874 0970 5f74 6167  _tag.s_txt.p_tag
-00003e40: 0970 5f74 7874 096f 5f74 6167 096f 5f74  .p_txt.o_tag.o_t
-00003e50: 7874 0a0a 5243 3d30 0a31 3a74 7269 706c  xt..RC=0.1:tripl
-00003e60: 653a 0974 315f 7478 7409 7331 5f74 6167  e:.t1_txt.s1_tag
-00003e70: 0973 5f74 7874 0970 5f74 6167 0970 5f74  .s_txt.p_tag.p_t
-00003e80: 7874 096f 5f74 6167 096f 5f74 7874 0a0a  xt.o_tag.o_txt..
-00003e90: 363a 7472 6970 6c65 3a09 7433 5f74 7874  6:triple:.t3_txt
-00003ea0: 0973 325f 7461 6709 735f 7478 7409 705f  .s2_tag.s_txt.p_
-00003eb0: 7461 6709 705f 7478 7409 6f5f 7461 6709  tag.p_txt.o_tag.
-00003ec0: 6f5f 7478 740a 0a38 3a74 7269 706c 653a  o_txt..8:triple:
-00003ed0: 0974 345f 7478 7409 7331 5f74 6167 0973  .t4_txt.s1_tag.s
-00003ee0: 5f74 7874 0970 5f74 6167 0970 5f74 7874  _txt.p_tag.p_txt
-00003ef0: 096f 5f74 6167 096f 5f74 7874 0a0a 3133  .o_tag.o_txt..13
-00003f00: 3a74 7269 706c 653a 0974 365f 7478 7409  :triple:.t6_txt.
-00003f10: 7332 5f74 6167 0973 5f74 7874 0970 5f74  s2_tag.s_txt.p_t
-00003f20: 6167 0970 5f74 7874 096f 5f74 6167 096f  ag.p_txt.o_tag.o
-00003f30: 5f74 7874 0a0a 5243 3d30 0a2d 2d2d 2d2d  _txt..RC=0.-----
-00003f40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003f50: 2d2d 2d2d 2d2d 2d20 5465 7374 2037 3120  ------- Test 71 
-00003f60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003f70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 3031  -------------.01
-00003f80: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
-00003f90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003fa0: 2d2d 2054 6573 7420 3732 202d 2d2d 2d2d  -- Test 72 -----
-00003fb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003fc0: 2d2d 2d2d 2d2d 2d2d 0a1b 5b31 3b33 316d  --------..[1;31m
-00003fd0: 3031 1b5b 306d 3032 3033 3034 3035 3036  01.[0m0203040506
-00003fe0: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
-00003ff0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004000: 2d2d 2054 6573 7420 3733 202d 2d2d 2d2d  -- Test 73 -----
-00004010: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004020: 2d2d 2d2d 2d2d 2d2d 0a1b 5b31 3b33 316d  --------..[1;31m
-00004030: 3031 1b5b 306d 0a52 433d 300a 2d2d 2d2d  01.[0m.RC=0.----
-00004040: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004050: 2d2d 2d2d 2d2d 2d2d 2054 6573 7420 3734  -------- Test 74
-00004060: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
-00004070: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a30  --------------.0
-00004080: 310a 3032 0a52 433d 300a 2d2d 2d2d 2d2d  1.02.RC=0.------
+000038d0: 2d0a 7065 6172 0a52 433d 300a 2d2d 2d2d  -.pear.RC=0.----
+000038e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000038f0: 2d2d 2d2d 2d2d 2d2d 2054 6573 7420 3636  -------- Test 66
+00003900: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+00003910: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
+00003920: 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=0.-----------
+00003930: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003940: 2d20 5465 7374 2036 3720 2d2d 2d2d 2d2d  - Test 67 ------
+00003950: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003960: 2d2d 2d2d 2d2d 2d2d 0a52 433d 300a 2d2d  --------.RC=0.--
+00003970: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003980: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
+00003990: 3638 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  68 -------------
+000039a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000039b0: 2d0a 7065 6172 0a52 433d 300a 2d2d 2d2d  -.pear.RC=0.----
+000039c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000039d0: 2d2d 2d2d 2d2d 2d2d 2054 6573 7420 3639  -------- Test 69
+000039e0: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+000039f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a31  --------------.1
+00003a00: 3a54 6869 7320 6973 2061 2073 6563 6f6e  :This is a secon
+00003a10: 6420 6669 6c65 206f 6620 696e 7075 7420  d file of input 
+00003a20: 666f 7220 7468 6520 7063 7265 6772 6570  for the pcregrep
+00003a30: 2074 6573 7473 2e0a 323a 0a34 3a0a 353a   tests..2:.4:.5:
+00003a40: 5061 7474 6572 6e0a 363a 5468 6174 2074  Pattern.6:That t
+00003a50: 696d 6520 6974 2077 6173 206f 6e20 6120  ime it was on a 
+00003a60: 6c69 6e65 2062 7920 6974 7365 6c66 2e0a  line by itself..
+00003a70: 373a 0a38 3a54 6f20 7061 7420 6f72 206e  7:.8:To pat or n
+00003a80: 6f74 2074 6f20 7061 742c 2074 6861 7420  ot to pat, that 
+00003a90: 6973 2074 6865 2071 7565 7374 696f 6e2e  is the question.
+00003aa0: 0a39 3a0a 3130 3a63 6f6d 706c 6574 6520  .9:.10:complete 
+00003ab0: 7061 6972 0a31 313a 6f66 206c 696e 6573  pair.11:of lines
+00003ac0: 0a31 323a 0a31 333a 5468 6174 2077 6173  .12:.13:That was
+00003ad0: 2061 2063 6f6d 706c 6574 6520 7061 6972   a complete pair
+00003ae0: 0a31 343a 6f66 206c 696e 6573 2061 6c6c  .14:of lines all
+00003af0: 2062 7920 7468 656d 7365 6c76 6573 2e0a   by themselves..
+00003b00: 3135 3a0a 3136 3a63 6f6d 706c 6574 6520  15:.16:complete 
+00003b10: 7061 6972 0a31 373a 6f66 206c 696e 6573  pair.17:of lines
+00003b20: 0a31 383a 0a31 393a 416e 6420 7468 6572  .18:.19:And ther
+00003b30: 6520 7468 6579 2077 6572 6520 6167 6169  e they were agai
+00003b40: 6e2c 2074 6f20 6368 6563 6b20 6c69 6e65  n, to check line
+00003b50: 206e 756d 6265 7273 2e0a 3230 3a0a 3231   numbers..20:.21
+00003b60: 3a6f 6e65 0a32 323a 7477 6f0a 3233 3a74  :one.22:two.23:t
+00003b70: 6872 6565 0a32 343a 666f 7572 0a32 353a  hree.24:four.25:
+00003b80: 6669 7665 0a32 363a 7369 780a 3237 3a73  five.26:six.27:s
+00003b90: 6576 656e 0a32 383a 6569 6768 740a 3239  even.28:eight.29
+00003ba0: 3a6e 696e 650a 3330 3a74 656e 0a33 313a  :nine.30:ten.31:
+00003bb0: 656c 6576 656e 0a33 323a 7477 656c 7665  eleven.32:twelve
+00003bc0: 0a33 333a 7468 6972 7465 656e 0a33 343a  .33:thirteen.34:
+00003bd0: 666f 7572 7465 656e 0a33 353a 6669 6674  fourteen.35:fift
+00003be0: 6565 6e0a 3336 3a73 6978 7465 656e 0a33  een.36:sixteen.3
+00003bf0: 373a 7365 7665 6e74 6565 6e0a 3338 3a65  7:seventeen.38:e
+00003c00: 6967 6874 6565 6e0a 3339 3a6e 696e 6574  ighteen.39:ninet
+00003c10: 6565 6e0a 3430 3a74 7765 6e74 790a 3431  een.40:twenty.41
+00003c20: 3a0a 3433 3a54 6869 7320 6973 2074 6865  :.43:This is the
+00003c30: 206c 6173 7420 6c69 6e65 206f 6620 7468   last line of th
+00003c40: 6973 2066 696c 652e 0a52 433d 300a 2d2d  is file..RC=0.--
+00003c50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003c60: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
+00003c70: 3730 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  70 -------------
+00003c80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003c90: 0a1b 5b31 3b33 316d 7472 6970 6c65 3a09  ..[1;31mtriple:.
+00003ca0: 7431 5f74 7874 0973 315f 7461 6709 735f  t1_txt.s1_tag.s_
+00003cb0: 7478 7409 705f 7461 6709 705f 7478 7409  txt.p_tag.p_txt.
+00003cc0: 6f5f 7461 6709 6f5f 7478 740a 0a1b 5b30  o_tag.o_txt...[0
+00003cd0: 6d1b 5b31 3b33 316d 7472 6970 6c65 3a09  m.[1;31mtriple:.
+00003ce0: 7433 5f74 7874 0973 325f 7461 6709 735f  t3_txt.s2_tag.s_
+00003cf0: 7478 7409 705f 7461 6709 705f 7478 7409  txt.p_tag.p_txt.
+00003d00: 6f5f 7461 6709 6f5f 7478 740a 0a1b 5b30  o_tag.o_txt...[0
+00003d10: 6d1b 5b31 3b33 316d 7472 6970 6c65 3a09  m.[1;31mtriple:.
+00003d20: 7434 5f74 7874 0973 315f 7461 6709 735f  t4_txt.s1_tag.s_
+00003d30: 7478 7409 705f 7461 6709 705f 7478 7409  txt.p_tag.p_txt.
+00003d40: 6f5f 7461 6709 6f5f 7478 740a 0a1b 5b30  o_tag.o_txt...[0
+00003d50: 6d1b 5b31 3b33 316d 7472 6970 6c65 3a09  m.[1;31mtriple:.
+00003d60: 7436 5f74 7874 0973 325f 7461 6709 735f  t6_txt.s2_tag.s_
+00003d70: 7478 7409 705f 7461 6709 705f 7478 7409  txt.p_tag.p_txt.
+00003d80: 6f5f 7461 6709 6f5f 7478 740a 0a1b 5b30  o_tag.o_txt...[0
+00003d90: 6d52 433d 300a 313a 1b5b 313b 3331 6d74  mRC=0.1:.[1;31mt
+00003da0: 7269 706c 653a 0974 315f 7478 7409 7331  riple:.t1_txt.s1
+00003db0: 5f74 6167 0973 5f74 7874 0970 5f74 6167  _tag.s_txt.p_tag
+00003dc0: 0970 5f74 7874 096f 5f74 6167 096f 5f74  .p_txt.o_tag.o_t
+00003dd0: 7874 0a0a 1b5b 306d 363a 1b5b 313b 3331  xt...[0m6:.[1;31
+00003de0: 6d74 7269 706c 653a 0974 335f 7478 7409  mtriple:.t3_txt.
+00003df0: 7332 5f74 6167 0973 5f74 7874 0970 5f74  s2_tag.s_txt.p_t
+00003e00: 6167 0970 5f74 7874 096f 5f74 6167 096f  ag.p_txt.o_tag.o
+00003e10: 5f74 7874 0a0a 1b5b 306d 383a 1b5b 313b  _txt...[0m8:.[1;
+00003e20: 3331 6d74 7269 706c 653a 0974 345f 7478  31mtriple:.t4_tx
+00003e30: 7409 7331 5f74 6167 0973 5f74 7874 0970  t.s1_tag.s_txt.p
+00003e40: 5f74 6167 0970 5f74 7874 096f 5f74 6167  _tag.p_txt.o_tag
+00003e50: 096f 5f74 7874 0a0a 1b5b 306d 3133 3a1b  .o_txt...[0m13:.
+00003e60: 5b31 3b33 316d 7472 6970 6c65 3a09 7436  [1;31mtriple:.t6
+00003e70: 5f74 7874 0973 325f 7461 6709 735f 7478  _txt.s2_tag.s_tx
+00003e80: 7409 705f 7461 6709 705f 7478 7409 6f5f  t.p_tag.p_txt.o_
+00003e90: 7461 6709 6f5f 7478 740a 0a1b 5b30 6d52  tag.o_txt...[0mR
+00003ea0: 433d 300a 7472 6970 6c65 3a09 7431 5f74  C=0.triple:.t1_t
+00003eb0: 7874 0973 315f 7461 6709 735f 7478 7409  xt.s1_tag.s_txt.
+00003ec0: 705f 7461 6709 705f 7478 7409 6f5f 7461  p_tag.p_txt.o_ta
+00003ed0: 6709 6f5f 7478 740a 0a74 7269 706c 653a  g.o_txt..triple:
+00003ee0: 0974 335f 7478 7409 7332 5f74 6167 0973  .t3_txt.s2_tag.s
+00003ef0: 5f74 7874 0970 5f74 6167 0970 5f74 7874  _txt.p_tag.p_txt
+00003f00: 096f 5f74 6167 096f 5f74 7874 0a0a 7472  .o_tag.o_txt..tr
+00003f10: 6970 6c65 3a09 7434 5f74 7874 0973 315f  iple:.t4_txt.s1_
+00003f20: 7461 6709 735f 7478 7409 705f 7461 6709  tag.s_txt.p_tag.
+00003f30: 705f 7478 7409 6f5f 7461 6709 6f5f 7478  p_txt.o_tag.o_tx
+00003f40: 740a 0a74 7269 706c 653a 0974 365f 7478  t..triple:.t6_tx
+00003f50: 7409 7332 5f74 6167 0973 5f74 7874 0970  t.s2_tag.s_txt.p
+00003f60: 5f74 6167 0970 5f74 7874 096f 5f74 6167  _tag.p_txt.o_tag
+00003f70: 096f 5f74 7874 0a0a 5243 3d30 0a31 3a74  .o_txt..RC=0.1:t
+00003f80: 7269 706c 653a 0974 315f 7478 7409 7331  riple:.t1_txt.s1
+00003f90: 5f74 6167 0973 5f74 7874 0970 5f74 6167  _tag.s_txt.p_tag
+00003fa0: 0970 5f74 7874 096f 5f74 6167 096f 5f74  .p_txt.o_tag.o_t
+00003fb0: 7874 0a0a 363a 7472 6970 6c65 3a09 7433  xt..6:triple:.t3
+00003fc0: 5f74 7874 0973 325f 7461 6709 735f 7478  _txt.s2_tag.s_tx
+00003fd0: 7409 705f 7461 6709 705f 7478 7409 6f5f  t.p_tag.p_txt.o_
+00003fe0: 7461 6709 6f5f 7478 740a 0a38 3a74 7269  tag.o_txt..8:tri
+00003ff0: 706c 653a 0974 345f 7478 7409 7331 5f74  ple:.t4_txt.s1_t
+00004000: 6167 0973 5f74 7874 0970 5f74 6167 0970  ag.s_txt.p_tag.p
+00004010: 5f74 7874 096f 5f74 6167 096f 5f74 7874  _txt.o_tag.o_txt
+00004020: 0a0a 3133 3a74 7269 706c 653a 0974 365f  ..13:triple:.t6_
+00004030: 7478 7409 7332 5f74 6167 0973 5f74 7874  txt.s2_tag.s_txt
+00004040: 0970 5f74 6167 0970 5f74 7874 096f 5f74  .p_tag.p_txt.o_t
+00004050: 6167 096f 5f74 7874 0a0a 5243 3d30 0a2d  ag.o_txt..RC=0.-
+00004060: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004070: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
+00004080: 2037 3120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   71 ------------
 00004090: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000040a0: 2d2d 2d2d 2d2d 2054 6573 7420 3735 202d  ------ Test 75 -
+000040a0: 2d0a 3031 0a52 433d 300a 2d2d 2d2d 2d2d  -.01.RC=0.------
 000040b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000040c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a1b 5b31  ------------..[1
-000040d0: 3b33 316d 3031 1b5b 306d 1b5b 313b 3331  ;31m01.[0m.[1;31
-000040e0: 6d30 321b 5b30 6d30 3330 3430 3530 360a  m02.[0m03040506.
-000040f0: 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=0.-----------
-00004100: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004110: 2d20 5465 7374 2037 3620 2d2d 2d2d 2d2d  - Test 76 ------
-00004120: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004130: 2d2d 2d2d 2d2d 2d0a 1b5b 313b 3331 6d30  -------..[1;31m0
-00004140: 311b 5b30 6d0a 1b5b 313b 3331 6d30 321b  1.[0m..[1;31m02.
-00004150: 5b30 6d0a 5243 3d30 0a2d 2d2d 2d2d 2d2d  [0m.RC=0.-------
+000040c0: 2d2d 2d2d 2d2d 2054 6573 7420 3732 202d  ------ Test 72 -
+000040d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000040e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a1b 5b31  ------------..[1
+000040f0: 3b33 316d 3031 1b5b 306d 3032 3033 3034  ;31m01.[0m020304
+00004100: 3035 3036 0a52 433d 300a 2d2d 2d2d 2d2d  0506.RC=0.------
+00004110: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004120: 2d2d 2d2d 2d2d 2054 6573 7420 3733 202d  ------ Test 73 -
+00004130: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004140: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a1b 5b31  ------------..[1
+00004150: 3b33 316d 3031 1b5b 306d 0a52 433d 300a  ;31m01.[0m.RC=0.
 00004160: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004170: 2d2d 2d2d 2d20 5465 7374 2037 3720 2d2d  ----- Test 77 --
-00004180: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004190: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 3031 0a30  -----------.01.0
-000041a0: 330a 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d  3.RC=0.---------
+00004170: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573  ------------ Tes
+00004180: 7420 3734 202d 2d2d 2d2d 2d2d 2d2d 2d2d  t 74 -----------
+00004190: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000041a0: 2d2d 0a30 310a 3032 0a52 433d 300a 2d2d  --.01.02.RC=0.--
 000041b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000041c0: 2d2d 2d20 5465 7374 2037 3820 2d2d 2d2d  --- Test 78 ----
-000041d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000041e0: 2d2d 2d2d 2d2d 2d2d 2d0a 1b5b 313b 3331  ---------..[1;31
-000041f0: 6d30 311b 5b30 6d30 321b 5b31 3b33 316d  m01.[0m02.[1;31m
-00004200: 3033 1b5b 306d 3034 3035 3036 0a52 433d  03.[0m040506.RC=
-00004210: 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  0.--------------
-00004220: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
-00004230: 6573 7420 3739 202d 2d2d 2d2d 2d2d 2d2d  est 79 ---------
+000041c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
+000041d0: 3735 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  75 -------------
+000041e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000041f0: 0a1b 5b31 3b33 316d 3031 1b5b 306d 1b5b  ..[1;31m01.[0m.[
+00004200: 313b 3331 6d30 321b 5b30 6d30 3330 3430  1;31m02.[0m03040
+00004210: 3530 360a 5243 3d30 0a2d 2d2d 2d2d 2d2d  506.RC=0.-------
+00004220: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004230: 2d2d 2d2d 2d20 5465 7374 2037 3620 2d2d  ----- Test 76 --
 00004240: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004250: 2d2d 2d2d 0a1b 5b31 3b33 316d 3031 1b5b  ----..[1;31m01.[
-00004260: 306d 0a1b 5b31 3b33 316d 3033 1b5b 306d  0m..[1;31m03.[0m
-00004270: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
+00004250: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 1b5b 313b  -----------..[1;
+00004260: 3331 6d30 311b 5b30 6d0a 1b5b 313b 3331  31m01.[0m..[1;31
+00004270: 6d30 321b 5b30 6d0a 5243 3d30 0a2d 2d2d  m02.[0m.RC=0.---
 00004280: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004290: 2d2d 2054 6573 7420 3830 202d 2d2d 2d2d  -- Test 80 -----
-000042a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000042b0: 2d2d 2d2d 2d2d 2d2d 0a30 310a 5243 3d30  --------.01.RC=0
-000042c0: 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .---------------
-000042d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465  ------------- Te
-000042e0: 7374 2038 3120 2d2d 2d2d 2d2d 2d2d 2d2d  st 81 ----------
+00004290: 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374 2037  --------- Test 7
+000042a0: 3720 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  7 --------------
+000042b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
+000042c0: 3031 0a30 330a 5243 3d30 0a2d 2d2d 2d2d  01.03.RC=0.-----
+000042d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000042e0: 2d2d 2d2d 2d2d 2d20 5465 7374 2037 3820  ------- Test 78 
 000042f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004300: 2d2d 2d0a 1b5b 313b 3331 6d30 311b 5b30  ---..[1;31m01.[0
-00004310: 6d30 3230 3330 3430 3530 360a 5243 3d30  m0203040506.RC=0
-00004320: 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .---------------
-00004330: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465  ------------- Te
-00004340: 7374 2038 3220 2d2d 2d2d 2d2d 2d2d 2d2d  st 82 ----------
-00004350: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004360: 2d2d 2d0a 1b5b 313b 3331 6d30 311b 5b30  ---..[1;31m01.[0
-00004370: 6d0a 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d  m.RC=0.---------
-00004380: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004390: 2d2d 2d20 5465 7374 2038 3320 2d2d 2d2d  --- Test 83 ----
+00004300: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 1b5b  -------------..[
+00004310: 313b 3331 6d30 311b 5b30 6d30 321b 5b31  1;31m01.[0m02.[1
+00004320: 3b33 316d 3033 1b5b 306d 3034 3035 3036  ;31m03.[0m040506
+00004330: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
+00004340: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004350: 2d2d 2054 6573 7420 3739 202d 2d2d 2d2d  -- Test 79 -----
+00004360: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004370: 2d2d 2d2d 2d2d 2d2d 0a1b 5b31 3b33 316d  --------..[1;31m
+00004380: 3031 1b5b 306d 0a1b 5b31 3b33 316d 3033  01.[0m..[1;31m03
+00004390: 1b5b 306d 0a52 433d 300a 2d2d 2d2d 2d2d  .[0m.RC=0.------
 000043a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000043b0: 2d2d 2d2d 2d2d 2d2d 2d0a 7063 7265 3267  ---------.pcre2g
-000043c0: 7265 703a 206c 696e 6520 3420 6f66 2066  rep: line 4 of f
-000043d0: 696c 6520 2e2f 7465 7374 6461 7461 2f67  ile ./testdata/g
-000043e0: 7265 7069 6e70 7574 3320 6973 2074 6f6f  repinput3 is too
-000043f0: 206c 6f6e 6720 666f 7220 7468 6520 696e   long for the in
-00004400: 7465 726e 616c 2062 7566 6665 720a 7063  ternal buffer.pc
-00004410: 7265 3267 7265 703a 2074 6865 206d 6178  re2grep: the max
-00004420: 696d 756d 2062 7566 6665 7220 7369 7a65  imum buffer size
-00004430: 2069 7320 3130 300a 7063 7265 3267 7265   is 100.pcre2gre
-00004440: 703a 2075 7365 2074 6865 202d 2d6d 6178  p: use the --max
-00004450: 2d62 7566 6665 722d 7369 7a65 206f 7074  -buffer-size opt
-00004460: 696f 6e20 746f 2063 6861 6e67 6520 6974  ion to change it
-00004470: 0a52 433d 320a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=2.----------
-00004480: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004490: 2d2d 2054 6573 7420 3834 202d 2d2d 2d2d  -- Test 84 -----
+000043b0: 2d2d 2d2d 2d2d 2054 6573 7420 3830 202d  ------ Test 80 -
+000043c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000043d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a30 310a  ------------.01.
+000043e0: 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=0.-----------
+000043f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004400: 2d20 5465 7374 2038 3120 2d2d 2d2d 2d2d  - Test 81 ------
+00004410: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004420: 2d2d 2d2d 2d2d 2d0a 1b5b 313b 3331 6d30  -------..[1;31m0
+00004430: 311b 5b30 6d30 3230 3330 3430 3530 360a  1.[0m0203040506.
+00004440: 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=0.-----------
+00004450: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004460: 2d20 5465 7374 2038 3220 2d2d 2d2d 2d2d  - Test 82 ------
+00004470: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004480: 2d2d 2d2d 2d2d 2d0a 1b5b 313b 3331 6d30  -------..[1;31m0
+00004490: 311b 5b30 6d0a 5243 3d30 0a2d 2d2d 2d2d  1.[0m.RC=0.-----
 000044a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000044b0: 2d2d 2d2d 2d2d 2d2d 0a74 6573 7464 6174  --------.testdat
-000044c0: 612f 6772 6570 696e 7075 7476 3a66 6f78  a/grepinputv:fox
-000044d0: 206a 756d 7073 0a74 6573 7464 6174 612f   jumps.testdata/
-000044e0: 6772 6570 696e 7075 7478 3a63 6f6d 706c  grepinputx:compl
-000044f0: 6574 6520 7061 6972 0a74 6573 7464 6174  ete pair.testdat
-00004500: 612f 6772 6570 696e 7075 7478 3a54 6861  a/grepinputx:Tha
-00004510: 7420 7761 7320 6120 636f 6d70 6c65 7465  t was a complete
-00004520: 2070 6169 720a 7465 7374 6461 7461 2f67   pair.testdata/g
-00004530: 7265 7069 6e70 7574 783a 636f 6d70 6c65  repinputx:comple
-00004540: 7465 2070 6169 720a 7465 7374 6461 7461  te pair.testdata
-00004550: 2f67 7265 7069 6e70 7574 333a 7472 6970  /grepinput3:trip
-00004560: 6c65 3a09 7437 5f74 7874 0973 315f 7461  le:.t7_txt.s1_ta
-00004570: 6709 735f 7478 7409 705f 7461 6709 705f  g.s_txt.p_tag.p_
-00004580: 7478 7409 6f5f 7461 6709 6f5f 7478 740a  txt.o_tag.o_txt.
-00004590: 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=0.-----------
+000044b0: 2d2d 2d2d 2d2d 2d20 5465 7374 2038 3320  ------- Test 83 
+000044c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000044d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 7063  -------------.pc
+000044e0: 7265 3267 7265 703a 206c 696e 6520 3420  re2grep: line 4 
+000044f0: 6f66 2066 696c 6520 2e2f 7465 7374 6461  of file ./testda
+00004500: 7461 2f67 7265 7069 6e70 7574 3320 6973  ta/grepinput3 is
+00004510: 2074 6f6f 206c 6f6e 6720 666f 7220 7468   too long for th
+00004520: 6520 696e 7465 726e 616c 2062 7566 6665  e internal buffe
+00004530: 720a 7063 7265 3267 7265 703a 2074 6865  r.pcre2grep: the
+00004540: 206d 6178 696d 756d 2062 7566 6665 7220   maximum buffer 
+00004550: 7369 7a65 2069 7320 3130 300a 7063 7265  size is 100.pcre
+00004560: 3267 7265 703a 2075 7365 2074 6865 202d  2grep: use the -
+00004570: 2d6d 6178 2d62 7566 6665 722d 7369 7a65  -max-buffer-size
+00004580: 206f 7074 696f 6e20 746f 2063 6861 6e67   option to chang
+00004590: 6520 6974 0a52 433d 320a 2d2d 2d2d 2d2d  e it.RC=2.------
 000045a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000045b0: 2d20 5465 7374 2038 3520 2d2d 2d2d 2d2d  - Test 85 ------
+000045b0: 2d2d 2d2d 2d2d 2054 6573 7420 3834 202d  ------ Test 84 -
 000045c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000045d0: 2d2d 2d2d 2d2d 2d0a 2e2f 7465 7374 6461  -------../testda
-000045e0: 7461 2f67 7265 7069 6e70 7574 333a 4c6f  ta/grepinput3:Lo
-000045f0: 7265 6d20 6970 7375 6d20 646f 6c6f 7220  rem ipsum dolor 
-00004600: 7369 7420 616d 6574 2c20 636f 6e73 6563  sit amet, consec
-00004610: 7465 7475 7220 6164 6970 6973 6963 696e  tetur adipisicin
-00004620: 6720 656c 6974 2c20 7365 6420 646f 2065  g elit, sed do e
-00004630: 6975 736d 6f64 2074 656d 706f 7220 696e  iusmod tempor in
-00004640: 6369 6469 6475 6e74 2075 7420 6c61 626f  cididunt ut labo
-00004650: 7265 2065 7420 646f 6c6f 7265 206d 6167  re et dolore mag
-00004660: 6e61 2061 6c69 7175 612e 2055 7420 656e  na aliqua. Ut en
-00004670: 696d 2061 6420 6d69 6e69 6d20 7665 6e69  im ad minim veni
-00004680: 616d 2c20 7175 6973 206e 6f73 7472 7564  am, quis nostrud
-00004690: 2065 7865 7263 6974 6174 696f 6e20 756c   exercitation ul
-000046a0: 6c61 6d63 6f20 6c61 626f 7269 7320 6e69  lamco laboris ni
-000046b0: 7369 2075 7420 616c 6971 7569 7020 6578  si ut aliquip ex
-000046c0: 2065 6120 636f 6d6d 6f64 6f20 636f 6e73   ea commodo cons
-000046d0: 6571 7561 742e 2044 7569 7320 6175 7465  equat. Duis aute
-000046e0: 2069 7275 7265 2064 6f6c 6f72 2069 6e20   irure dolor in 
-000046f0: 7265 7072 6568 656e 6465 7269 7420 696e  reprehenderit in
-00004700: 2076 6f6c 7570 7461 7465 2076 656c 6974   voluptate velit
-00004710: 2065 7373 6520 6369 6c6c 756d 2064 6f6c   esse cillum dol
-00004720: 6f72 6520 6575 2066 7567 6961 7420 6e75  ore eu fugiat nu
-00004730: 6c6c 6120 7061 7269 6174 7572 2e20 4578  lla pariatur. Ex
-00004740: 6365 7074 6575 7220 7369 6e74 206f 6363  cepteur sint occ
-00004750: 6165 6361 7420 6375 7069 6461 7461 7420  aecat cupidatat 
-00004760: 6e6f 6e20 7072 6f69 6465 6e74 2c20 7375  non proident, su
-00004770: 6e74 2069 6e20 6375 6c70 6120 7175 6920  nt in culpa qui 
-00004780: 6f66 6669 6369 6120 6465 7365 7275 6e74  officia deserunt
-00004790: 206d 6f6c 6c69 7420 616e 696d 2069 6420   mollit anim id 
-000047a0: 6573 7420 6c61 626f 7275 6d2e 0a52 433d  est laborum..RC=
-000047b0: 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  0.--------------
-000047c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
-000047d0: 6573 7420 3836 202d 2d2d 2d2d 2d2d 2d2d  est 86 ---------
-000047e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000047f0: 2d2d 2d2d 0a42 696e 6172 7920 6669 6c65  ----.Binary file
-00004800: 202e 2f74 6573 7464 6174 612f 6772 6570   ./testdata/grep
-00004810: 6269 6e61 7279 206d 6174 6368 6573 0a52  binary matches.R
-00004820: 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  C=0.------------
-00004830: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004840: 2054 6573 7420 3837 202d 2d2d 2d2d 2d2d   Test 87 -------
-00004850: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004860: 2d2d 2d2d 2d2d 0a52 433d 310a 2d2d 2d2d  ------.RC=1.----
-00004870: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004880: 2d2d 2d2d 2d2d 2d2d 2054 6573 7420 3838  -------- Test 88
-00004890: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
-000048a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a42  --------------.B
-000048b0: 696e 6172 7920 6669 6c65 202e 2f74 6573  inary file ./tes
-000048c0: 7464 6174 612f 6772 6570 6269 6e61 7279  tdata/grepbinary
-000048d0: 206d 6174 6368 6573 0a52 433d 300a 2d2d   matches.RC=0.--
+000045d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a74 6573  ------------.tes
+000045e0: 7464 6174 612f 6772 6570 696e 7075 7476  tdata/grepinputv
+000045f0: 3a66 6f78 206a 756d 7073 0a74 6573 7464  :fox jumps.testd
+00004600: 6174 612f 6772 6570 696e 7075 7478 3a63  ata/grepinputx:c
+00004610: 6f6d 706c 6574 6520 7061 6972 0a74 6573  omplete pair.tes
+00004620: 7464 6174 612f 6772 6570 696e 7075 7478  tdata/grepinputx
+00004630: 3a54 6861 7420 7761 7320 6120 636f 6d70  :That was a comp
+00004640: 6c65 7465 2070 6169 720a 7465 7374 6461  lete pair.testda
+00004650: 7461 2f67 7265 7069 6e70 7574 783a 636f  ta/grepinputx:co
+00004660: 6d70 6c65 7465 2070 6169 720a 7465 7374  mplete pair.test
+00004670: 6461 7461 2f67 7265 7069 6e70 7574 333a  data/grepinput3:
+00004680: 7472 6970 6c65 3a09 7437 5f74 7874 0973  triple:.t7_txt.s
+00004690: 315f 7461 6709 735f 7478 7409 705f 7461  1_tag.s_txt.p_ta
+000046a0: 6709 705f 7478 7409 6f5f 7461 6709 6f5f  g.p_txt.o_tag.o_
+000046b0: 7478 740a 5243 3d30 0a2d 2d2d 2d2d 2d2d  txt.RC=0.-------
+000046c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000046d0: 2d2d 2d2d 2d20 5465 7374 2038 3520 2d2d  ----- Test 85 --
+000046e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000046f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2e2f 7465  -----------../te
+00004700: 7374 6461 7461 2f67 7265 7069 6e70 7574  stdata/grepinput
+00004710: 333a 4c6f 7265 6d20 6970 7375 6d20 646f  3:Lorem ipsum do
+00004720: 6c6f 7220 7369 7420 616d 6574 2c20 636f  lor sit amet, co
+00004730: 6e73 6563 7465 7475 7220 6164 6970 6973  nsectetur adipis
+00004740: 6963 696e 6720 656c 6974 2c20 7365 6420  icing elit, sed 
+00004750: 646f 2065 6975 736d 6f64 2074 656d 706f  do eiusmod tempo
+00004760: 7220 696e 6369 6469 6475 6e74 2075 7420  r incididunt ut 
+00004770: 6c61 626f 7265 2065 7420 646f 6c6f 7265  labore et dolore
+00004780: 206d 6167 6e61 2061 6c69 7175 612e 2055   magna aliqua. U
+00004790: 7420 656e 696d 2061 6420 6d69 6e69 6d20  t enim ad minim 
+000047a0: 7665 6e69 616d 2c20 7175 6973 206e 6f73  veniam, quis nos
+000047b0: 7472 7564 2065 7865 7263 6974 6174 696f  trud exercitatio
+000047c0: 6e20 756c 6c61 6d63 6f20 6c61 626f 7269  n ullamco labori
+000047d0: 7320 6e69 7369 2075 7420 616c 6971 7569  s nisi ut aliqui
+000047e0: 7020 6578 2065 6120 636f 6d6d 6f64 6f20  p ex ea commodo 
+000047f0: 636f 6e73 6571 7561 742e 2044 7569 7320  consequat. Duis 
+00004800: 6175 7465 2069 7275 7265 2064 6f6c 6f72  aute irure dolor
+00004810: 2069 6e20 7265 7072 6568 656e 6465 7269   in reprehenderi
+00004820: 7420 696e 2076 6f6c 7570 7461 7465 2076  t in voluptate v
+00004830: 656c 6974 2065 7373 6520 6369 6c6c 756d  elit esse cillum
+00004840: 2064 6f6c 6f72 6520 6575 2066 7567 6961   dolore eu fugia
+00004850: 7420 6e75 6c6c 6120 7061 7269 6174 7572  t nulla pariatur
+00004860: 2e20 4578 6365 7074 6575 7220 7369 6e74  . Excepteur sint
+00004870: 206f 6363 6165 6361 7420 6375 7069 6461   occaecat cupida
+00004880: 7461 7420 6e6f 6e20 7072 6f69 6465 6e74  tat non proident
+00004890: 2c20 7375 6e74 2069 6e20 6375 6c70 6120  , sunt in culpa 
+000048a0: 7175 6920 6f66 6669 6369 6120 6465 7365  qui officia dese
+000048b0: 7275 6e74 206d 6f6c 6c69 7420 616e 696d  runt mollit anim
+000048c0: 2069 6420 6573 7420 6c61 626f 7275 6d2e   id est laborum.
+000048d0: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
 000048e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000048f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
-00004900: 3839 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  89 -------------
-00004910: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004920: 0a52 433d 310a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=1.----------
-00004930: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004940: 2d2d 2054 6573 7420 3930 202d 2d2d 2d2d  -- Test 90 -----
+000048f0: 2d2d 2054 6573 7420 3836 202d 2d2d 2d2d  -- Test 86 -----
+00004900: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004910: 2d2d 2d2d 2d2d 2d2d 0a42 696e 6172 7920  --------.Binary 
+00004920: 6669 6c65 202e 2f74 6573 7464 6174 612f  file ./testdata/
+00004930: 6772 6570 6269 6e61 7279 206d 6174 6368  grepbinary match
+00004940: 6573 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  es.RC=0.--------
 00004950: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004960: 2d2d 2d2d 2d2d 2d2d 0a52 433d 310a 2d2d  --------.RC=1.--
+00004960: 2d2d 2d2d 2054 6573 7420 3837 202d 2d2d  ---- Test 87 ---
 00004970: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004980: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
-00004990: 3931 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  91 -------------
-000049a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000049b0: 0a54 6865 2071 7569 636b 2062 726f 776e  .The quick brown
-000049c0: 2066 0078 206a 756d 7073 206f 7665 7220   f.x jumps over 
-000049d0: 7468 6520 6c61 7a79 2064 6f67 2e0a 5243  the lazy dog..RC
-000049e0: 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  =0.-------------
-000049f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
-00004a00: 5465 7374 2039 3220 2d2d 2d2d 2d2d 2d2d  Test 92 --------
-00004a10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004a20: 2d2d 2d2d 2d0a 5468 6520 7175 6963 6b20  -----.The quick 
-00004a30: 6272 6f77 6e20 6600 7820 6a75 6d70 7320  brown f.x jumps 
-00004a40: 6f76 6572 2074 6865 206c 617a 7920 646f  over the lazy do
-00004a50: 672e 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  g..RC=0.--------
-00004a60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004a70: 2d2d 2d2d 2054 6573 7420 3933 202d 2d2d  ---- Test 93 ---
-00004a80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004a90: 2d2d 2d2d 2d2d 2d2d 2d2d 0a54 6865 2071  ----------.The q
-00004aa0: 7569 636b 2062 726f 776e 2066 0078 206a  uick brown f.x j
-00004ab0: 756d 7073 206f 7665 7220 7468 6520 6c61  umps over the la
-00004ac0: 7a79 2064 6f67 2e0a 5243 3d30 0a2d 2d2d  zy dog..RC=0.---
-00004ad0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004ae0: 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374 2039  --------- Test 9
-00004af0: 3420 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  4 --------------
-00004b00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
-00004b10: 2e2f 7465 7374 6461 7461 2f67 7265 7069  ./testdata/grepi
-00004b20: 6e70 7574 380a 2e2f 7465 7374 6461 7461  nput8../testdata
-00004b30: 2f67 7265 7069 6e70 7574 780a 5243 3d30  /grepinputx.RC=0
-00004b40: 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .---------------
-00004b50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465  ------------- Te
-00004b60: 7374 2039 3520 2d2d 2d2d 2d2d 2d2d 2d2d  st 95 ----------
-00004b70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004b80: 2d2d 2d0a 7465 7374 6461 7461 2f67 7265  ---.testdata/gre
-00004b90: 7069 6e70 7574 783a 636f 6d70 6c65 7465  pinputx:complete
-00004ba0: 2070 6169 720a 7465 7374 6461 7461 2f67   pair.testdata/g
-00004bb0: 7265 7069 6e70 7574 783a 5468 6174 2077  repinputx:That w
-00004bc0: 6173 2061 2063 6f6d 706c 6574 6520 7061  as a complete pa
-00004bd0: 6972 0a74 6573 7464 6174 612f 6772 6570  ir.testdata/grep
-00004be0: 696e 7075 7478 3a63 6f6d 706c 6574 6520  inputx:complete 
-00004bf0: 7061 6972 0a52 433d 300a 2d2d 2d2d 2d2d  pair.RC=0.------
-00004c00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004c10: 2d2d 2d2d 2d2d 2054 6573 7420 3936 202d  ------ Test 96 -
+00004980: 2d2d 2d2d 2d2d 2d2d 2d2d 0a52 433d 310a  ----------.RC=1.
+00004990: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000049a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573  ------------ Tes
+000049b0: 7420 3838 202d 2d2d 2d2d 2d2d 2d2d 2d2d  t 88 -----------
+000049c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000049d0: 2d2d 0a42 696e 6172 7920 6669 6c65 202e  --.Binary file .
+000049e0: 2f74 6573 7464 6174 612f 6772 6570 6269  /testdata/grepbi
+000049f0: 6e61 7279 206d 6174 6368 6573 0a52 433d  nary matches.RC=
+00004a00: 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  0.--------------
+00004a10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
+00004a20: 6573 7420 3839 202d 2d2d 2d2d 2d2d 2d2d  est 89 ---------
+00004a30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004a40: 2d2d 2d2d 0a52 433d 310a 2d2d 2d2d 2d2d  ----.RC=1.------
+00004a50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004a60: 2d2d 2d2d 2d2d 2054 6573 7420 3930 202d  ------ Test 90 -
+00004a70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004a80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a52 433d  ------------.RC=
+00004a90: 310a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  1.--------------
+00004aa0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
+00004ab0: 6573 7420 3931 202d 2d2d 2d2d 2d2d 2d2d  est 91 ---------
+00004ac0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004ad0: 2d2d 2d2d 0a54 6865 2071 7569 636b 2062  ----.The quick b
+00004ae0: 726f 776e 2066 0078 206a 756d 7073 206f  rown f.x jumps o
+00004af0: 7665 7220 7468 6520 6c61 7a79 2064 6f67  ver the lazy dog
+00004b00: 2e0a 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d  ..RC=0.---------
+00004b10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004b20: 2d2d 2d20 5465 7374 2039 3220 2d2d 2d2d  --- Test 92 ----
+00004b30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004b40: 2d2d 2d2d 2d2d 2d2d 2d0a 5468 6520 7175  ---------.The qu
+00004b50: 6963 6b20 6272 6f77 6e20 6600 7820 6a75  ick brown f.x ju
+00004b60: 6d70 7320 6f76 6572 2074 6865 206c 617a  mps over the laz
+00004b70: 7920 646f 672e 0a52 433d 300a 2d2d 2d2d  y dog..RC=0.----
+00004b80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004b90: 2d2d 2d2d 2d2d 2d2d 2054 6573 7420 3933  -------- Test 93
+00004ba0: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+00004bb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a54  --------------.T
+00004bc0: 6865 2071 7569 636b 2062 726f 776e 2066  he quick brown f
+00004bd0: 0078 206a 756d 7073 206f 7665 7220 7468  .x jumps over th
+00004be0: 6520 6c61 7a79 2064 6f67 2e0a 5243 3d30  e lazy dog..RC=0
+00004bf0: 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .---------------
+00004c00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465  ------------- Te
+00004c10: 7374 2039 3420 2d2d 2d2d 2d2d 2d2d 2d2d  st 94 ----------
 00004c20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004c30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a2e 2f74  ------------../t
-00004c40: 6573 7464 6174 612f 6772 6570 696e 7075  estdata/grepinpu
-00004c50: 7433 0a2e 2f74 6573 7464 6174 612f 6772  t3../testdata/gr
-00004c60: 6570 696e 7075 7438 0a2e 2f74 6573 7464  epinput8../testd
-00004c70: 6174 612f 6772 6570 696e 7075 7478 0a52  ata/grepinputx.R
-00004c80: 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  C=0.------------
+00004c30: 2d2d 2d0a 2e2f 7465 7374 6461 7461 2f67  ---../testdata/g
+00004c40: 7265 7069 6e70 7574 380a 2e2f 7465 7374  repinput8../test
+00004c50: 6461 7461 2f67 7265 7069 6e70 7574 780a  data/grepinputx.
+00004c60: 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=0.-----------
+00004c70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004c80: 2d20 5465 7374 2039 3520 2d2d 2d2d 2d2d  - Test 95 ------
 00004c90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004ca0: 2054 6573 7420 3937 202d 2d2d 2d2d 2d2d   Test 97 -------
-00004cb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004cc0: 2d2d 2d2d 2d2d 0a2e 2f74 6573 7464 6174  ------../testdat
-00004cd0: 612f 6772 6570 696e 7075 7433 0a2e 2f74  a/grepinput3../t
-00004ce0: 6573 7464 6174 612f 6772 6570 696e 7075  estdata/grepinpu
-00004cf0: 7478 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  tx.RC=0.--------
-00004d00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004d10: 2d2d 2d2d 2054 6573 7420 3938 202d 2d2d  ---- Test 98 ---
+00004ca0: 2d2d 2d2d 2d2d 2d0a 7465 7374 6461 7461  -------.testdata
+00004cb0: 2f67 7265 7069 6e70 7574 783a 636f 6d70  /grepinputx:comp
+00004cc0: 6c65 7465 2070 6169 720a 7465 7374 6461  lete pair.testda
+00004cd0: 7461 2f67 7265 7069 6e70 7574 783a 5468  ta/grepinputx:Th
+00004ce0: 6174 2077 6173 2061 2063 6f6d 706c 6574  at was a complet
+00004cf0: 6520 7061 6972 0a74 6573 7464 6174 612f  e pair.testdata/
+00004d00: 6772 6570 696e 7075 7478 3a63 6f6d 706c  grepinputx:compl
+00004d10: 6574 6520 7061 6972 0a52 433d 300a 2d2d  ete pair.RC=0.--
 00004d20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004d30: 2d2d 2d2d 2d2d 2d2d 2d2d 0a2e 2f74 6573  ----------../tes
-00004d40: 7464 6174 612f 6772 6570 696e 7075 7478  tdata/grepinputx
-00004d50: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
-00004d60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004d70: 2d2d 2054 6573 7420 3939 202d 2d2d 2d2d  -- Test 99 -----
-00004d80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004d90: 2d2d 2d2d 2d2d 2d2d 0a2e 2f74 6573 7464  --------../testd
-00004da0: 6174 612f 6772 6570 696e 7075 7433 0a2e  ata/grepinput3..
-00004db0: 2f74 6573 7464 6174 612f 6772 6570 696e  /testdata/grepin
-00004dc0: 7075 7478 0a52 433d 300a 2d2d 2d2d 2d2d  putx.RC=0.------
+00004d30: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
+00004d40: 3936 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  96 -------------
+00004d50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004d60: 0a2e 2f74 6573 7464 6174 612f 6772 6570  ../testdata/grep
+00004d70: 696e 7075 7433 0a2e 2f74 6573 7464 6174  input3../testdat
+00004d80: 612f 6772 6570 696e 7075 7438 0a2e 2f74  a/grepinput8../t
+00004d90: 6573 7464 6174 612f 6772 6570 696e 7075  estdata/grepinpu
+00004da0: 7478 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  tx.RC=0.--------
+00004db0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004dc0: 2d2d 2d2d 2054 6573 7420 3937 202d 2d2d  ---- Test 97 ---
 00004dd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004de0: 2d2d 2d2d 2d2d 2054 6573 7420 3130 3020  ------ Test 100 
-00004df0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004e00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a2e  --------------..
-00004e10: 2f74 6573 7464 6174 612f 6772 6570 696e  /testdata/grepin
-00004e20: 7075 743a 7a65 726f 7468 652e 0a2e 2f74  put:zerothe.../t
-00004e30: 6573 7464 6174 612f 6772 6570 696e 7075  estdata/grepinpu
-00004e40: 743a 7a65 726f 610a 2e2f 7465 7374 6461  t:zeroa../testda
-00004e50: 7461 2f67 7265 7069 6e70 7574 3a7a 6572  ta/grepinput:zer
-00004e60: 6f74 6865 2e0a 5243 3d30 0a2d 2d2d 2d2d  othe..RC=0.-----
-00004e70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004e80: 2d2d 2d2d 2d2d 2d20 5465 7374 2031 3031  ------- Test 101
-00004e90: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
-00004ea0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
-00004eb0: 2e2f 7465 7374 6461 7461 2f67 7265 7069  ./testdata/grepi
-00004ec0: 6e70 7574 3a1b 5b31 3b33 316d 2e1b 5b30  nput:.[1;31m..[0
-00004ed0: 6d7c 1b5b 313b 3331 6d7a 6572 6f1b 5b30  m|.[1;31mzero.[0
-00004ee0: 6d7c 1b5b 313b 3331 6d74 6865 1b5b 306d  m|.[1;31mthe.[0m
-00004ef0: 7c1b 5b31 3b33 316d 2e1b 5b30 6d0a 2e2f  |.[1;31m..[0m../
-00004f00: 7465 7374 6461 7461 2f67 7265 7069 6e70  testdata/grepinp
-00004f10: 7574 3a1b 5b31 3b33 316d 7a65 726f 1b5b  ut:.[1;31mzero.[
-00004f20: 306d 7c1b 5b31 3b33 316d 611b 5b30 6d0a  0m|.[1;31ma.[0m.
-00004f30: 2e2f 7465 7374 6461 7461 2f67 7265 7069  ./testdata/grepi
-00004f40: 6e70 7574 3a1b 5b31 3b33 316d 2e1b 5b30  nput:.[1;31m..[0
-00004f50: 6d7c 1b5b 313b 3331 6d7a 6572 6f1b 5b30  m|.[1;31mzero.[0
-00004f60: 6d7c 1b5b 313b 3331 6d74 6865 1b5b 306d  m|.[1;31mthe.[0m
-00004f70: 7c1b 5b31 3b33 316d 2e1b 5b30 6d0a 5243  |.[1;31m..[0m.RC
-00004f80: 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  =0.-------------
-00004f90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
-00004fa0: 5465 7374 2031 3032 202d 2d2d 2d2d 2d2d  Test 102 -------
-00004fb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004fc0: 2d2d 2d2d 2d2d 0a32 3a0a 353a 0a37 3a0a  ------.2:.5:.7:.
-00004fd0: 393a 0a31 323a 0a31 343a 0a52 433d 300a  9:.12:.14:.RC=0.
-00004fe0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00004ff0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573  ------------ Tes
-00005000: 7420 3130 3320 2d2d 2d2d 2d2d 2d2d 2d2d  t 103 ----------
-00005010: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005020: 2d2d 2d0a 5243 3d30 0a2d 2d2d 2d2d 2d2d  ---.RC=0.-------
-00005030: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005040: 2d2d 2d2d 2d20 5465 7374 2031 3034 202d  ----- Test 104 -
-00005050: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005060: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a32 3a0a  ------------.2:.
-00005070: 353a 0a37 3a0a 393a 0a31 323a 0a31 343a  5:.7:.9:.12:.14:
-00005080: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
-00005090: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000050a0: 2d2d 2054 6573 7420 3130 3520 2d2d 2d2d  -- Test 105 ----
+00004de0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a2e 2f74 6573  ----------../tes
+00004df0: 7464 6174 612f 6772 6570 696e 7075 7433  tdata/grepinput3
+00004e00: 0a2e 2f74 6573 7464 6174 612f 6772 6570  ../testdata/grep
+00004e10: 696e 7075 7478 0a52 433d 300a 2d2d 2d2d  inputx.RC=0.----
+00004e20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004e30: 2d2d 2d2d 2d2d 2d2d 2054 6573 7420 3938  -------- Test 98
+00004e40: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+00004e50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a2e  --------------..
+00004e60: 2f74 6573 7464 6174 612f 6772 6570 696e  /testdata/grepin
+00004e70: 7075 7478 0a52 433d 300a 2d2d 2d2d 2d2d  putx.RC=0.------
+00004e80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004e90: 2d2d 2d2d 2d2d 2054 6573 7420 3939 202d  ------ Test 99 -
+00004ea0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004eb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a2e 2f74  ------------../t
+00004ec0: 6573 7464 6174 612f 6772 6570 696e 7075  estdata/grepinpu
+00004ed0: 7433 0a2e 2f74 6573 7464 6174 612f 6772  t3../testdata/gr
+00004ee0: 6570 696e 7075 7478 0a52 433d 300a 2d2d  epinputx.RC=0.--
+00004ef0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004f00: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
+00004f10: 3130 3020 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  100 ------------
+00004f20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004f30: 2d2d 0a2e 2f74 6573 7464 6174 612f 6772  --../testdata/gr
+00004f40: 6570 696e 7075 743a 7a65 726f 7468 652e  epinput:zerothe.
+00004f50: 0a2e 2f74 6573 7464 6174 612f 6772 6570  ../testdata/grep
+00004f60: 696e 7075 743a 7a65 726f 610a 2e2f 7465  input:zeroa../te
+00004f70: 7374 6461 7461 2f67 7265 7069 6e70 7574  stdata/grepinput
+00004f80: 3a7a 6572 6f74 6865 2e0a 5243 3d30 0a2d  :zerothe..RC=0.-
+00004f90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004fa0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
+00004fb0: 2031 3031 202d 2d2d 2d2d 2d2d 2d2d 2d2d   101 -----------
+00004fc0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004fd0: 2d2d 2d0a 2e2f 7465 7374 6461 7461 2f67  ---../testdata/g
+00004fe0: 7265 7069 6e70 7574 3a1b 5b31 3b33 316d  repinput:.[1;31m
+00004ff0: 2e1b 5b30 6d7c 1b5b 313b 3331 6d7a 6572  ..[0m|.[1;31mzer
+00005000: 6f1b 5b30 6d7c 1b5b 313b 3331 6d74 6865  o.[0m|.[1;31mthe
+00005010: 1b5b 306d 7c1b 5b31 3b33 316d 2e1b 5b30  .[0m|.[1;31m..[0
+00005020: 6d0a 2e2f 7465 7374 6461 7461 2f67 7265  m../testdata/gre
+00005030: 7069 6e70 7574 3a1b 5b31 3b33 316d 7a65  pinput:.[1;31mze
+00005040: 726f 1b5b 306d 7c1b 5b31 3b33 316d 611b  ro.[0m|.[1;31ma.
+00005050: 5b30 6d0a 2e2f 7465 7374 6461 7461 2f67  [0m../testdata/g
+00005060: 7265 7069 6e70 7574 3a1b 5b31 3b33 316d  repinput:.[1;31m
+00005070: 2e1b 5b30 6d7c 1b5b 313b 3331 6d7a 6572  ..[0m|.[1;31mzer
+00005080: 6f1b 5b30 6d7c 1b5b 313b 3331 6d74 6865  o.[0m|.[1;31mthe
+00005090: 1b5b 306d 7c1b 5b31 3b33 316d 2e1b 5b30  .[0m|.[1;31m..[0
+000050a0: 6d0a 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d  m.RC=0.---------
 000050b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000050c0: 2d2d 2d2d 2d2d 2d2d 2d0a 7472 6970 6c65  ---------.triple
-000050d0: 3a09 7431 5f74 7874 0973 315f 7461 6709  :.t1_txt.s1_tag.
-000050e0: 735f 7478 7409 705f 7461 6709 705f 7478  s_txt.p_tag.p_tx
-000050f0: 7409 6f5f 7461 6709 6f5f 7478 740a 0a74  t.o_tag.o_txt..t
-00005100: 7269 706c 653a 0974 325f 7478 7409 7331  riple:.t2_txt.s1
-00005110: 5f74 6167 0973 5f74 7874 0970 5f74 6167  _tag.s_txt.p_tag
-00005120: 0970 5f74 7874 096f 5f74 6167 090a 4c6f  .p_txt.o_tag..Lo
-00005130: 7265 6d20 1b5b 313b 3331 6d69 7073 756d  rem .[1;31mipsum
-00005140: 1b5b 306d 2064 6f6c 6f72 2073 6974 2061  .[0m dolor sit a
-00005150: 6d65 742c 2063 6f6e 7365 6374 6574 7572  met, consectetur
-00005160: 2061 6469 7069 7369 6369 6e67 2065 6c69   adipisicing eli
-00005170: 742c 2073 6564 2064 6f20 6569 7573 6d6f  t, sed do eiusmo
-00005180: 6420 7465 6d70 6f72 2069 6e63 6964 6964  d tempor incidid
-00005190: 756e 7420 7574 206c 6162 6f72 6520 6574  unt ut labore et
-000051a0: 2064 6f6c 6f72 6520 6d61 676e 6120 616c   dolore magna al
-000051b0: 6971 7561 2e20 5574 2065 6e69 6d20 6164  iqua. Ut enim ad
-000051c0: 206d 696e 696d 2076 656e 6961 6d2c 2071   minim veniam, q
-000051d0: 7569 7320 6e6f 7374 7275 6420 6578 6572  uis nostrud exer
-000051e0: 6369 7461 7469 6f6e 2075 6c6c 616d 636f  citation ullamco
-000051f0: 206c 6162 6f72 6973 206e 6973 6920 7574   laboris nisi ut
-00005200: 2061 6c69 7175 6970 2065 7820 6561 2063   aliquip ex ea c
-00005210: 6f6d 6d6f 646f 2063 6f6e 7365 7175 6174  ommodo consequat
-00005220: 2e20 4475 6973 2061 7574 6520 6972 7572  . Duis aute irur
-00005230: 6520 646f 6c6f 7220 696e 2072 6570 7265  e dolor in repre
-00005240: 6865 6e64 6572 6974 2069 6e20 766f 6c75  henderit in volu
-00005250: 7074 6174 6520 7665 6c69 7420 6573 7365  ptate velit esse
-00005260: 2063 696c 6c75 6d20 646f 6c6f 7265 2065   cillum dolore e
-00005270: 7520 6675 6769 6174 206e 756c 6c61 2070  u fugiat nulla p
-00005280: 6172 6961 7475 722e 2045 7863 6570 7465  ariatur. Excepte
-00005290: 7572 2073 696e 7420 6f63 6361 6563 6174  ur sint occaecat
-000052a0: 2063 7570 6964 6174 6174 206e 6f6e 2070   cupidatat non p
-000052b0: 726f 6964 656e 742c 2073 756e 7420 696e  roident, sunt in
-000052c0: 2063 756c 7061 2071 7569 206f 6666 6963   culpa qui offic
-000052d0: 6961 2064 6573 6572 756e 7420 6d6f 6c6c  ia deserunt moll
-000052e0: 6974 2061 6e69 6d20 6964 2065 7374 206c  it anim id est l
-000052f0: 6162 6f72 756d 2e0a 0a74 7269 706c 653a  aborum...triple:
-00005300: 0974 335f 7478 7409 7332 5f74 6167 0973  .t3_txt.s2_tag.s
-00005310: 5f74 7874 0970 5f74 6167 0970 5f74 7874  _txt.p_tag.p_txt
-00005320: 096f 5f74 6167 096f 5f74 7874 0a0a 7472  .o_tag.o_txt..tr
-00005330: 6970 6c65 3a09 7434 5f74 7874 0973 315f  iple:.t4_txt.s1_
-00005340: 7461 6709 735f 7478 7409 705f 7461 6709  tag.s_txt.p_tag.
-00005350: 705f 7478 7409 6f5f 7461 6709 6f5f 7478  p_txt.o_tag.o_tx
-00005360: 740a 0a74 7269 706c 653a 0974 355f 7478  t..triple:.t5_tx
-00005370: 7409 7331 5f74 6167 0973 5f74 7874 0970  t.s1_tag.s_txt.p
-00005380: 5f74 6167 0970 5f74 7874 096f 5f74 6167  _tag.p_txt.o_tag
-00005390: 090a 6f5f 7478 740a 0a74 7269 706c 653a  ..o_txt..triple:
-000053a0: 0974 365f 7478 7409 7332 5f74 6167 0973  .t6_txt.s2_tag.s
-000053b0: 5f74 7874 0970 5f74 6167 0970 5f74 7874  _txt.p_tag.p_txt
-000053c0: 096f 5f74 6167 096f 5f74 7874 0a0a 7472  .o_tag.o_txt..tr
-000053d0: 6970 6c65 3a09 7437 5f74 7874 0973 315f  iple:.t7_txt.s1_
-000053e0: 7461 6709 735f 7478 7409 705f 7461 6709  tag.s_txt.p_tag.
-000053f0: 705f 7478 7409 6f5f 7461 6709 6f5f 7478  p_txt.o_tag.o_tx
-00005400: 740a 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d  t.RC=0.---------
-00005410: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005420: 2d2d 2d20 5465 7374 2031 3036 202d 2d2d  --- Test 106 ---
-00005430: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005440: 2d2d 2d2d 2d2d 2d2d 2d2d 0a61 0a52 433d  ----------.a.RC=
-00005450: 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  0.--------------
-00005460: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
-00005470: 6573 7420 3130 3720 2d2d 2d2d 2d2d 2d2d  est 107 --------
-00005480: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005490: 2d2d 2d2d 2d0a 313a 302c 310a 323a 302c  -----.1:0,1.2:0,
-000054a0: 310a 323a 312c 310a 323a 322c 310a 323a  1.2:1,1.2:2,1.2:
-000054b0: 332c 310a 323a 342c 310a 5243 3d30 0a2d  3,1.2:4,1.RC=0.-
-000054c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000054d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
-000054e0: 2031 3038 202d 2d2d 2d2d 2d2d 2d2d 2d2d   108 -----------
-000054f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005500: 2d2d 2d0a 5243 3d30 0a2d 2d2d 2d2d 2d2d  ---.RC=0.-------
-00005510: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005520: 2d2d 2d2d 2d20 5465 7374 2031 3039 202d  ----- Test 109 -
+000050c0: 2d2d 2d20 5465 7374 2031 3032 202d 2d2d  --- Test 102 ---
+000050d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000050e0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a32 3a0a 353a  ----------.2:.5:
+000050f0: 0a37 3a0a 393a 0a31 323a 0a31 343a 0a52  .7:.9:.12:.14:.R
+00005100: 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  C=0.------------
+00005110: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005120: 2054 6573 7420 3130 3320 2d2d 2d2d 2d2d   Test 103 ------
+00005130: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005140: 2d2d 2d2d 2d2d 2d0a 5243 3d30 0a2d 2d2d  -------.RC=0.---
+00005150: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005160: 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374 2031  --------- Test 1
+00005170: 3034 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  04 -------------
+00005180: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005190: 0a32 3a0a 353a 0a37 3a0a 393a 0a31 323a  .2:.5:.7:.9:.12:
+000051a0: 0a31 343a 0a52 433d 300a 2d2d 2d2d 2d2d  .14:.RC=0.------
+000051b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000051c0: 2d2d 2d2d 2d2d 2054 6573 7420 3130 3520  ------ Test 105 
+000051d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000051e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 7472  -------------.tr
+000051f0: 6970 6c65 3a09 7431 5f74 7874 0973 315f  iple:.t1_txt.s1_
+00005200: 7461 6709 735f 7478 7409 705f 7461 6709  tag.s_txt.p_tag.
+00005210: 705f 7478 7409 6f5f 7461 6709 6f5f 7478  p_txt.o_tag.o_tx
+00005220: 740a 0a74 7269 706c 653a 0974 325f 7478  t..triple:.t2_tx
+00005230: 7409 7331 5f74 6167 0973 5f74 7874 0970  t.s1_tag.s_txt.p
+00005240: 5f74 6167 0970 5f74 7874 096f 5f74 6167  _tag.p_txt.o_tag
+00005250: 090a 4c6f 7265 6d20 1b5b 313b 3331 6d69  ..Lorem .[1;31mi
+00005260: 7073 756d 1b5b 306d 2064 6f6c 6f72 2073  psum.[0m dolor s
+00005270: 6974 2061 6d65 742c 2063 6f6e 7365 6374  it amet, consect
+00005280: 6574 7572 2061 6469 7069 7369 6369 6e67  etur adipisicing
+00005290: 2065 6c69 742c 2073 6564 2064 6f20 6569   elit, sed do ei
+000052a0: 7573 6d6f 6420 7465 6d70 6f72 2069 6e63  usmod tempor inc
+000052b0: 6964 6964 756e 7420 7574 206c 6162 6f72  ididunt ut labor
+000052c0: 6520 6574 2064 6f6c 6f72 6520 6d61 676e  e et dolore magn
+000052d0: 6120 616c 6971 7561 2e20 5574 2065 6e69  a aliqua. Ut eni
+000052e0: 6d20 6164 206d 696e 696d 2076 656e 6961  m ad minim venia
+000052f0: 6d2c 2071 7569 7320 6e6f 7374 7275 6420  m, quis nostrud 
+00005300: 6578 6572 6369 7461 7469 6f6e 2075 6c6c  exercitation ull
+00005310: 616d 636f 206c 6162 6f72 6973 206e 6973  amco laboris nis
+00005320: 6920 7574 2061 6c69 7175 6970 2065 7820  i ut aliquip ex 
+00005330: 6561 2063 6f6d 6d6f 646f 2063 6f6e 7365  ea commodo conse
+00005340: 7175 6174 2e20 4475 6973 2061 7574 6520  quat. Duis aute 
+00005350: 6972 7572 6520 646f 6c6f 7220 696e 2072  irure dolor in r
+00005360: 6570 7265 6865 6e64 6572 6974 2069 6e20  eprehenderit in 
+00005370: 766f 6c75 7074 6174 6520 7665 6c69 7420  voluptate velit 
+00005380: 6573 7365 2063 696c 6c75 6d20 646f 6c6f  esse cillum dolo
+00005390: 7265 2065 7520 6675 6769 6174 206e 756c  re eu fugiat nul
+000053a0: 6c61 2070 6172 6961 7475 722e 2045 7863  la pariatur. Exc
+000053b0: 6570 7465 7572 2073 696e 7420 6f63 6361  epteur sint occa
+000053c0: 6563 6174 2063 7570 6964 6174 6174 206e  ecat cupidatat n
+000053d0: 6f6e 2070 726f 6964 656e 742c 2073 756e  on proident, sun
+000053e0: 7420 696e 2063 756c 7061 2071 7569 206f  t in culpa qui o
+000053f0: 6666 6963 6961 2064 6573 6572 756e 7420  fficia deserunt 
+00005400: 6d6f 6c6c 6974 2061 6e69 6d20 6964 2065  mollit anim id e
+00005410: 7374 206c 6162 6f72 756d 2e0a 0a74 7269  st laborum...tri
+00005420: 706c 653a 0974 335f 7478 7409 7332 5f74  ple:.t3_txt.s2_t
+00005430: 6167 0973 5f74 7874 0970 5f74 6167 0970  ag.s_txt.p_tag.p
+00005440: 5f74 7874 096f 5f74 6167 096f 5f74 7874  _txt.o_tag.o_txt
+00005450: 0a0a 7472 6970 6c65 3a09 7434 5f74 7874  ..triple:.t4_txt
+00005460: 0973 315f 7461 6709 735f 7478 7409 705f  .s1_tag.s_txt.p_
+00005470: 7461 6709 705f 7478 7409 6f5f 7461 6709  tag.p_txt.o_tag.
+00005480: 6f5f 7478 740a 0a74 7269 706c 653a 0974  o_txt..triple:.t
+00005490: 355f 7478 7409 7331 5f74 6167 0973 5f74  5_txt.s1_tag.s_t
+000054a0: 7874 0970 5f74 6167 0970 5f74 7874 096f  xt.p_tag.p_txt.o
+000054b0: 5f74 6167 090a 6f5f 7478 740a 0a74 7269  _tag..o_txt..tri
+000054c0: 706c 653a 0974 365f 7478 7409 7332 5f74  ple:.t6_txt.s2_t
+000054d0: 6167 0973 5f74 7874 0970 5f74 6167 0970  ag.s_txt.p_tag.p
+000054e0: 5f74 7874 096f 5f74 6167 096f 5f74 7874  _txt.o_tag.o_txt
+000054f0: 0a0a 7472 6970 6c65 3a09 7437 5f74 7874  ..triple:.t7_txt
+00005500: 0973 315f 7461 6709 735f 7478 7409 705f  .s1_tag.s_txt.p_
+00005510: 7461 6709 705f 7478 7409 6f5f 7461 6709  tag.p_txt.o_tag.
+00005520: 6f5f 7478 740a 5243 3d30 0a2d 2d2d 2d2d  o_txt.RC=0.-----
 00005530: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005540: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a52 433d  ------------.RC=
-00005550: 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  0.--------------
-00005560: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
-00005570: 6573 7420 3131 3020 2d2d 2d2d 2d2d 2d2d  est 110 --------
+00005540: 2d2d 2d2d 2d2d 2d20 5465 7374 2031 3036  ------- Test 106
+00005550: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+00005560: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a61  --------------.a
+00005570: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
 00005580: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005590: 2d2d 2d2d 2d0a 6d61 7463 6820 313a 0a20  -----.match 1:. 
-000055a0: 610a 2f31 2f61 0a6d 6174 6368 2032 3a0a  a./1/a.match 2:.
-000055b0: 2062 0a2f 322f 620a 6d61 7463 6820 333a   b./2/b.match 3:
-000055c0: 0a20 630a 2f33 2f63 0a6d 6174 6368 2034  . c./3/c.match 4
-000055d0: 3a0a 2064 0a2f 342f 640a 6d61 7463 6820  :. d./4/d.match 
-000055e0: 353a 0a20 650a 2f35 2f65 0a52 433d 300a  5:. e./5/e.RC=0.
-000055f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005600: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573  ------------ Tes
-00005610: 7420 3131 3120 2d2d 2d2d 2d2d 2d2d 2d2d  t 111 ----------
-00005620: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005630: 2d2d 2d0a 3630 373a 302c 3132 0a36 3039  ---.607:0,12.609
-00005640: 3a30 2c31 320a 3631 313a 302c 3132 0a36  :0,12.611:0,12.6
-00005650: 3133 3a30 2c31 320a 3631 353a 302c 3132  13:0,12.615:0,12
-00005660: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
-00005670: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005680: 2d2d 2054 6573 7420 3131 3220 2d2d 2d2d  -- Test 112 ----
-00005690: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000056a0: 2d2d 2d2d 2d2d 2d2d 2d0a 3337 3137 322c  ---------.37172,
-000056b0: 3132 0a33 3731 3834 2c31 320a 3337 3139  12.37184,12.3719
-000056c0: 362c 3132 0a33 3732 3038 2c31 320a 3337  6,12.37208,12.37
-000056d0: 3232 302c 3132 0a52 433d 300a 2d2d 2d2d  220,12.RC=0.----
-000056e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000056f0: 2d2d 2d2d 2d2d 2d2d 2054 6573 7420 3131  -------- Test 11
-00005700: 3320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  3 --------------
-00005710: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
-00005720: 3438 300a 5243 3d30 0a2d 2d2d 2d2d 2d2d  480.RC=0.-------
-00005730: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005740: 2d2d 2d2d 2d20 5465 7374 2031 3134 202d  ----- Test 114 -
-00005750: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005760: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a74 6573  ------------.tes
-00005770: 7464 6174 612f 6772 6570 696e 7075 743a  tdata/grepinput:
-00005780: 3436 390a 7465 7374 6461 7461 2f67 7265  469.testdata/gre
-00005790: 7069 6e70 7574 333a 300a 7465 7374 6461  pinput3:0.testda
-000057a0: 7461 2f67 7265 7069 6e70 7574 383a 300a  ta/grepinput8:0.
-000057b0: 7465 7374 6461 7461 2f67 7265 7069 6e70  testdata/grepinp
-000057c0: 7574 4d3a 320a 7465 7374 6461 7461 2f67  utM:2.testdata/g
-000057d0: 7265 7069 6e70 7574 763a 330a 7465 7374  repinputv:3.test
-000057e0: 6461 7461 2f67 7265 7069 6e70 7574 783a  data/grepinputx:
-000057f0: 360a 544f 5441 4c3a 3438 300a 5243 3d30  6.TOTAL:480.RC=0
-00005800: 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .---------------
-00005810: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465  ------------- Te
-00005820: 7374 2031 3135 202d 2d2d 2d2d 2d2d 2d2d  st 115 ---------
+00005590: 2d2d 2054 6573 7420 3130 3720 2d2d 2d2d  -- Test 107 ----
+000055a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000055b0: 2d2d 2d2d 2d2d 2d2d 2d0a 313a 302c 310a  ---------.1:0,1.
+000055c0: 323a 302c 310a 323a 312c 310a 323a 322c  2:0,1.2:1,1.2:2,
+000055d0: 310a 323a 332c 310a 323a 342c 310a 5243  1.2:3,1.2:4,1.RC
+000055e0: 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  =0.-------------
+000055f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
+00005600: 5465 7374 2031 3038 202d 2d2d 2d2d 2d2d  Test 108 -------
+00005610: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005620: 2d2d 2d2d 2d2d 2d0a 5243 3d30 0a2d 2d2d  -------.RC=0.---
+00005630: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005640: 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374 2031  --------- Test 1
+00005650: 3039 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  09 -------------
+00005660: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005670: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
+00005680: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005690: 2d2d 2054 6573 7420 3131 3020 2d2d 2d2d  -- Test 110 ----
+000056a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000056b0: 2d2d 2d2d 2d2d 2d2d 2d0a 6d61 7463 6820  ---------.match 
+000056c0: 313a 0a20 610a 2f31 2f61 0a6d 6174 6368  1:. a./1/a.match
+000056d0: 2032 3a0a 2062 0a2f 322f 620a 6d61 7463   2:. b./2/b.matc
+000056e0: 6820 333a 0a20 630a 2f33 2f63 0a6d 6174  h 3:. c./3/c.mat
+000056f0: 6368 2034 3a0a 2064 0a2f 342f 640a 6d61  ch 4:. d./4/d.ma
+00005700: 7463 6820 353a 0a20 650a 2f35 2f65 0a52  tch 5:. e./5/e.R
+00005710: 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  C=0.------------
+00005720: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005730: 2054 6573 7420 3131 3120 2d2d 2d2d 2d2d   Test 111 ------
+00005740: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005750: 2d2d 2d2d 2d2d 2d0a 3630 373a 302c 3132  -------.607:0,12
+00005760: 0a36 3039 3a30 2c31 320a 3631 313a 302c  .609:0,12.611:0,
+00005770: 3132 0a36 3133 3a30 2c31 320a 3631 353a  12.613:0,12.615:
+00005780: 302c 3132 0a52 433d 300a 2d2d 2d2d 2d2d  0,12.RC=0.------
+00005790: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000057a0: 2d2d 2d2d 2d2d 2054 6573 7420 3131 3220  ------ Test 112 
+000057b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000057c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 3337  -------------.37
+000057d0: 3137 322c 3132 0a33 3731 3834 2c31 320a  172,12.37184,12.
+000057e0: 3337 3139 362c 3132 0a33 3732 3038 2c31  37196,12.37208,1
+000057f0: 320a 3337 3232 302c 3132 0a52 433d 300a  2.37220,12.RC=0.
+00005800: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005810: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573  ------------ Tes
+00005820: 7420 3131 3320 2d2d 2d2d 2d2d 2d2d 2d2d  t 113 ----------
 00005830: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005840: 2d2d 2d2d 0a74 6573 7464 6174 612f 6772  ----.testdata/gr
-00005850: 6570 696e 7075 743a 3436 390a 7465 7374  epinput:469.test
-00005860: 6461 7461 2f67 7265 7069 6e70 7574 4d3a  data/grepinputM:
-00005870: 320a 7465 7374 6461 7461 2f67 7265 7069  2.testdata/grepi
-00005880: 6e70 7574 763a 330a 7465 7374 6461 7461  nputv:3.testdata
-00005890: 2f67 7265 7069 6e70 7574 783a 360a 544f  /grepinputx:6.TO
-000058a0: 5441 4c3a 3438 300a 5243 3d30 0a2d 2d2d  TAL:480.RC=0.---
-000058b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000058c0: 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374 2031  --------- Test 1
-000058d0: 3136 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  16 -------------
-000058e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000058f0: 0a34 3738 0a52 433d 300a 2d2d 2d2d 2d2d  .478.RC=0.------
-00005900: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005910: 2d2d 2d2d 2d2d 2054 6573 7420 3131 3720  ------ Test 117 
-00005920: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005930: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 3436  -------------.46
-00005940: 390a 300a 300a 320a 330a 360a 3438 300a  9.0.0.2.3.6.480.
-00005950: 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=0.-----------
-00005960: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005970: 2d20 5465 7374 2031 3138 202d 2d2d 2d2d  - Test 118 -----
-00005980: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005990: 2d2d 2d2d 2d2d 2d2d 0a74 6573 7464 6174  --------.testdat
-000059a0: 612f 6772 6570 696e 7075 7433 0a74 6573  a/grepinput3.tes
-000059b0: 7464 6174 612f 6772 6570 696e 7075 7438  tdata/grepinput8
-000059c0: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
-000059d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000059e0: 2d2d 2054 6573 7420 3131 3920 2d2d 2d2d  -- Test 119 ----
-000059f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005a00: 2d2d 2d2d 2d2d 2d2d 2d0a 3132 330a 3435  ---------.123.45
-00005a10: 360a 3738 390a 2d2d 2d0a 6162 630a 6465  6.789.---.abc.de
-00005a20: 660a 7879 7a0a 2d2d 2d0a 5243 3d30 0a2d  f.xyz.---.RC=0.-
-00005a30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005a40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
-00005a50: 2031 3230 202d 2d2d 2d2d 2d2d 2d2d 2d2d   120 -----------
-00005a60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005a70: 2d2d 2d0a 2e2f 7465 7374 6461 7461 2f67  ---../testdata/g
-00005a80: 7265 7069 6e70 7574 3a74 6865 2062 696e  repinput:the bin
-00005a90: 6172 7920 7a65 726f 2e3a 7a65 726f 7468  ary zero.:zeroth
-00005aa0: 652e 0a2e 2f74 6573 7464 6174 612f 6772  e.../testdata/gr
-00005ab0: 6570 696e 7075 743a 6120 6269 6e61 7279  epinput:a binary
-00005ac0: 207a 6572 6f3a 7a65 726f 610a 2e2f 7465   zero:zeroa../te
-00005ad0: 7374 6461 7461 2f67 7265 7069 6e70 7574  stdata/grepinput
-00005ae0: 3a74 6865 2062 696e 6172 7920 7a65 726f  :the binary zero
-00005af0: 2e3a 7a65 726f 7468 652e 0a52 433d 300a  .:zerothe..RC=0.
-00005b00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005b10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573  ------------ Tes
-00005b20: 7420 3132 3120 2d2d 2d2d 2d2d 2d2d 2d2d  t 121 ----------
-00005b30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005b40: 2d2d 2d0a 5468 6973 206c 696e 6520 636f  ---.This line co
-00005b50: 6e74 6169 6e73 205c 4520 616e 6420 2872  ntains \E and (r
-00005b60: 6567 6578 2920 2a6d 6574 612a 205b 6368  egex) *meta* [ch
-00005b70: 6172 6163 7465 7273 5d2e 0a52 433d 300a  aracters]..RC=0.
+00005840: 2d2d 2d0a 3438 300a 5243 3d30 0a2d 2d2d  ---.480.RC=0.---
+00005850: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005860: 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374 2031  --------- Test 1
+00005870: 3134 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  14 -------------
+00005880: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005890: 0a74 6573 7464 6174 612f 6772 6570 696e  .testdata/grepin
+000058a0: 7075 743a 3436 390a 7465 7374 6461 7461  put:469.testdata
+000058b0: 2f67 7265 7069 6e70 7574 333a 300a 7465  /grepinput3:0.te
+000058c0: 7374 6461 7461 2f67 7265 7069 6e70 7574  stdata/grepinput
+000058d0: 383a 300a 7465 7374 6461 7461 2f67 7265  8:0.testdata/gre
+000058e0: 7069 6e70 7574 4d3a 320a 7465 7374 6461  pinputM:2.testda
+000058f0: 7461 2f67 7265 7069 6e70 7574 763a 330a  ta/grepinputv:3.
+00005900: 7465 7374 6461 7461 2f67 7265 7069 6e70  testdata/grepinp
+00005910: 7574 783a 360a 544f 5441 4c3a 3438 300a  utx:6.TOTAL:480.
+00005920: 5243 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=0.-----------
+00005930: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005940: 2d20 5465 7374 2031 3135 202d 2d2d 2d2d  - Test 115 -----
+00005950: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005960: 2d2d 2d2d 2d2d 2d2d 0a74 6573 7464 6174  --------.testdat
+00005970: 612f 6772 6570 696e 7075 743a 3436 390a  a/grepinput:469.
+00005980: 7465 7374 6461 7461 2f67 7265 7069 6e70  testdata/grepinp
+00005990: 7574 4d3a 320a 7465 7374 6461 7461 2f67  utM:2.testdata/g
+000059a0: 7265 7069 6e70 7574 763a 330a 7465 7374  repinputv:3.test
+000059b0: 6461 7461 2f67 7265 7069 6e70 7574 783a  data/grepinputx:
+000059c0: 360a 544f 5441 4c3a 3438 300a 5243 3d30  6.TOTAL:480.RC=0
+000059d0: 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .---------------
+000059e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465  ------------- Te
+000059f0: 7374 2031 3136 202d 2d2d 2d2d 2d2d 2d2d  st 116 ---------
+00005a00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005a10: 2d2d 2d2d 0a34 3738 0a52 433d 300a 2d2d  ----.478.RC=0.--
+00005a20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005a30: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
+00005a40: 3131 3720 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  117 ------------
+00005a50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005a60: 2d0a 3436 390a 300a 300a 320a 330a 360a  -.469.0.0.2.3.6.
+00005a70: 3438 300a 5243 3d30 0a2d 2d2d 2d2d 2d2d  480.RC=0.-------
+00005a80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005a90: 2d2d 2d2d 2d20 5465 7374 2031 3138 202d  ----- Test 118 -
+00005aa0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005ab0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a74 6573  ------------.tes
+00005ac0: 7464 6174 612f 6772 6570 696e 7075 7433  tdata/grepinput3
+00005ad0: 0a74 6573 7464 6174 612f 6772 6570 696e  .testdata/grepin
+00005ae0: 7075 7438 0a52 433d 300a 2d2d 2d2d 2d2d  put8.RC=0.------
+00005af0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005b00: 2d2d 2d2d 2d2d 2054 6573 7420 3131 3920  ------ Test 119 
+00005b10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005b20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 3132  -------------.12
+00005b30: 330a 3435 360a 3738 390a 2d2d 2d0a 6162  3.456.789.---.ab
+00005b40: 630a 6465 660a 7879 7a0a 2d2d 2d0a 5243  c.def.xyz.---.RC
+00005b50: 3d30 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  =0.-------------
+00005b60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
+00005b70: 5465 7374 2031 3230 202d 2d2d 2d2d 2d2d  Test 120 -------
 00005b80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005b90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573  ------------ Tes
-00005ba0: 7420 3132 3220 2d2d 2d2d 2d2d 2d2d 2d2d  t 122 ----------
-00005bb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005bc0: 2d2d 2d0a 6f76 6572 2074 6865 206c 617a  ---.over the laz
-00005bd0: 7920 646f 672e 0a54 6865 2077 6f72 6420  y dog..The word 
-00005be0: 6973 2063 6174 2069 6e20 7468 6973 206c  is cat in this l
-00005bf0: 696e 650a 5243 3d30 0a2d 2d2d 2d2d 2d2d  ine.RC=0.-------
-00005c00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005c10: 2d2d 2d2d 2d20 5465 7374 2031 3233 202d  ----- Test 123 -
-00005c20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005c30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a6f 7665  ------------.ove
-00005c40: 7220 7468 6520 6c61 7a79 2064 6f67 2e0a  r the lazy dog..
-00005c50: 5468 6520 776f 7264 2069 7320 6361 7420  The word is cat 
-00005c60: 696e 2074 6869 7320 6c69 6e65 0a52 433d  in this line.RC=
-00005c70: 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  0.--------------
-00005c80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
-00005c90: 6573 7420 3132 3420 2d2d 2d2d 2d2d 2d2d  est 124 --------
-00005ca0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005cb0: 2d2d 2d2d 2d0a 333a 1b5b 313b 3331 6d73  -----.3:.[1;31ms
-00005cc0: 7461 7274 2065 6e64 1b5b 306d 2069 6e20  tart end.[0m in 
-00005cd0: 6265 7477 6565 6e20 1b5b 313b 3331 6d73  between .[1;31ms
-00005ce0: 7461 7274 0a65 6e64 1b5b 306d 2061 6e64  tart.end.[0m and
-00005cf0: 2066 6f6c 6c6f 7769 6e67 0a37 3a1b 5b31   following.7:.[1
-00005d00: 3b33 316d 7374 6172 7420 656e 641b 5b30  ;31mstart end.[0
-00005d10: 6d20 696e 2062 6574 7765 656e 201b 5b31  m in between .[1
-00005d20: 3b33 316d 7374 6172 740a 656e 641b 5b30  ;31mstart.end.[0
-00005d30: 6d20 616e 6420 666f 6c6c 6f77 696e 6720  m and following 
-00005d40: 1b5b 313b 3331 6d73 7461 7274 0a65 6e64  .[1;31mstart.end
-00005d50: 1b5b 306d 206f 7468 6572 2073 7475 6666  .[0m other stuff
-00005d60: 0a31 313a 1b5b 313b 3331 6d73 7461 7274  .11:.[1;31mstart
-00005d70: 2065 6e64 1b5b 306d 2069 6e20 6265 7477   end.[0m in betw
-00005d80: 6565 6e20 1b5b 313b 3331 6d73 7461 7274  een .[1;31mstart
-00005d90: 0a0a 656e 641b 5b30 6d0a 3136 3a1b 5b31  ..end.[0m.16:.[1
-00005da0: 3b33 316d 7374 6172 7420 656e 641b 5b30  ;31mstart end.[0
-00005db0: 6d20 696e 2062 6574 7765 656e 201b 5b31  m in between .[1
-00005dc0: 3b33 316d 7374 6172 740a 656e 641b 5b30  ;31mstart.end.[0
-00005dd0: 6d0a 5243 3d30 0a33 3a1b 5b31 3b33 316d  m.RC=0.3:.[1;31m
-00005de0: 7374 6172 7420 656e 641b 5b30 6d20 696e  start end.[0m in
-00005df0: 2062 6574 7765 656e 201b 5b31 3b33 316d   between .[1;31m
-00005e00: 7374 6172 740a 656e 641b 5b30 6d20 616e  start.end.[0m an
-00005e10: 6420 666f 6c6c 6f77 696e 670a 352d 4f74  d following.5-Ot
-00005e20: 6865 7220 7374 7566 660a 362d 0a37 3a1b  her stuff.6-.7:.
-00005e30: 5b31 3b33 316d 7374 6172 7420 656e 641b  [1;31mstart end.
-00005e40: 5b30 6d20 696e 2062 6574 7765 656e 201b  [0m in between .
-00005e50: 5b31 3b33 316d 7374 6172 740a 656e 641b  [1;31mstart.end.
-00005e60: 5b30 6d20 616e 6420 666f 6c6c 6f77 696e  [0m and followin
-00005e70: 6720 1b5b 313b 3331 6d73 7461 7274 0a65  g .[1;31mstart.e
-00005e80: 6e64 1b5b 306d 206f 7468 6572 2073 7475  nd.[0m other stu
-00005e90: 6666 0a31 302d 0a31 313a 1b5b 313b 3331  ff.10-.11:.[1;31
-00005ea0: 6d73 7461 7274 2065 6e64 1b5b 306d 2069  mstart end.[0m i
-00005eb0: 6e20 6265 7477 6565 6e20 1b5b 313b 3331  n between .[1;31
-00005ec0: 6d73 7461 7274 0a0a 656e 641b 5b30 6d0a  mstart..end.[0m.
-00005ed0: 3134 2d0a 3135 2d2a 2a20 5468 6573 6520  14-.15-** These 
-00005ee0: 7477 6f20 6c69 6e65 7320 6d75 7374 2062  two lines must b
-00005ef0: 6520 6c61 7374 2e0a 3136 3a1b 5b31 3b33  e last..16:.[1;3
-00005f00: 316d 7374 6172 7420 656e 641b 5b30 6d20  1mstart end.[0m 
-00005f10: 696e 2062 6574 7765 656e 201b 5b31 3b33  in between .[1;3
-00005f20: 316d 7374 6172 740a 656e 641b 5b30 6d0a  1mstart.end.[0m.
-00005f30: 5243 3d30 0a33 3a73 7461 7274 2065 6e64  RC=0.3:start end
-00005f40: 2069 6e20 6265 7477 6565 6e20 7374 6172   in between star
-00005f50: 740a 656e 6420 616e 6420 666f 6c6c 6f77  t.end and follow
-00005f60: 696e 670a 373a 7374 6172 7420 656e 6420  ing.7:start end 
-00005f70: 696e 2062 6574 7765 656e 2073 7461 7274  in between start
-00005f80: 0a65 6e64 2061 6e64 2066 6f6c 6c6f 7769  .end and followi
-00005f90: 6e67 2073 7461 7274 0a65 6e64 206f 7468  ng start.end oth
-00005fa0: 6572 2073 7475 6666 0a31 313a 7374 6172  er stuff.11:star
-00005fb0: 7420 656e 6420 696e 2062 6574 7765 656e  t end in between
-00005fc0: 2073 7461 7274 0a0a 656e 640a 3136 3a73   start..end.16:s
-00005fd0: 7461 7274 2065 6e64 2069 6e20 6265 7477  tart end in betw
-00005fe0: 6565 6e20 7374 6172 740a 656e 640a 5243  een start.end.RC
-00005ff0: 3d30 0a33 3a73 7461 7274 2065 6e64 2069  =0.3:start end i
-00006000: 6e20 6265 7477 6565 6e20 7374 6172 740a  n between start.
-00006010: 656e 6420 616e 6420 666f 6c6c 6f77 696e  end and followin
-00006020: 670a 352d 4f74 6865 7220 7374 7566 660a  g.5-Other stuff.
-00006030: 362d 0a37 3a73 7461 7274 2065 6e64 2069  6-.7:start end i
-00006040: 6e20 6265 7477 6565 6e20 7374 6172 740a  n between start.
-00006050: 656e 6420 616e 6420 666f 6c6c 6f77 696e  end and followin
-00006060: 6720 7374 6172 740a 656e 6420 6f74 6865  g start.end othe
-00006070: 7220 7374 7566 660a 3130 2d0a 3131 3a73  r stuff.10-.11:s
-00006080: 7461 7274 2065 6e64 2069 6e20 6265 7477  tart end in betw
-00006090: 6565 6e20 7374 6172 740a 0a65 6e64 0a31  een start..end.1
-000060a0: 342d 0a31 352d 2a2a 2054 6865 7365 2074  4-.15-** These t
-000060b0: 776f 206c 696e 6573 206d 7573 7420 6265  wo lines must be
-000060c0: 206c 6173 742e 0a31 363a 7374 6172 7420   last..16:start 
-000060d0: 656e 6420 696e 2062 6574 7765 656e 2073  end in between s
-000060e0: 7461 7274 0a65 6e64 0a52 433d 300a 2d2d  tart.end.RC=0.--
-000060f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006100: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
-00006110: 3132 3520 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  125 ------------
-00006120: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006130: 2d0a 1b5b 313b 3331 6d61 1b5b 306d 1b5b  -..[1;31ma.[0m.[
-00006140: 313b 3331 6d62 1b5b 306d 1b5b 313b 3331  1;31mb.[0m.[1;31
-00006150: 6d63 1b5b 306d 1b5b 313b 3331 6d64 1b5b  mc.[0m.[1;31md.[
-00006160: 306d 0a52 433d 300a 1b5b 313b 3331 6d61  0m.RC=0..[1;31ma
-00006170: 1b5b 306d 1b5b 313b 3331 6d62 1b5b 306d  .[0m.[1;31mb.[0m
-00006180: 1b5b 313b 3331 6d63 1b5b 306d 1b5b 313b  .[1;31mc.[0m.[1;
-00006190: 3331 6d64 1b5b 306d 0a52 433d 300a 1b5b  31md.[0m.RC=0..[
-000061a0: 313b 3331 6d61 1b5b 306d 621b 5b31 3b33  1;31ma.[0mb.[1;3
-000061b0: 316d 631b 5b30 6d64 0a52 433d 300a 1b5b  1mc.[0md.RC=0..[
-000061c0: 313b 3331 6d61 1b5b 306d 621b 5b31 3b33  1;31ma.[0mb.[1;3
-000061d0: 316d 631b 5b30 6d64 0a52 433d 300a 2d2d  1mc.[0md.RC=0.--
-000061e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000061f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
-00006200: 3132 3620 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  126 ------------
-00006210: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006220: 2d0a 4142 4300 5859 5a0a 5243 3d30 0a2d  -.ABC.XYZ.RC=0.-
-00006230: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006240: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
-00006250: 2031 3237 202d 2d2d 2d2d 2d2d 2d2d 2d2d   127 -----------
-00006260: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006270: 2d2d 0a70 6174 7465 726e 0a52 433d 300a  --.pattern.RC=0.
-00006280: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006290: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573  ------------ Tes
-000062a0: 7420 3132 3820 2d2d 2d2d 2d2d 2d2d 2d2d  t 128 ----------
-000062b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000062c0: 2d2d 2d0a 7063 7265 3267 7265 703a 2052  ---.pcre2grep: R
-000062d0: 6571 7565 7374 6564 2067 726f 7570 2031  equested group 1
-000062e0: 2063 616e 6e6f 7420 6265 2063 6170 7475   cannot be captu
-000062f0: 7265 642e 0a70 6372 6532 6772 6570 3a20  red..pcre2grep: 
-00006300: 5573 6520 2d2d 6f6d 2d63 6170 7475 7265  Use --om-capture
-00006310: 2074 6f20 696e 6372 6561 7365 2074 6865   to increase the
-00006320: 2073 697a 6520 6f66 2074 6865 2063 6170   size of the cap
-00006330: 7475 7265 2076 6563 746f 722e 0a52 433d  ture vector..RC=
-00006340: 320a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  2.--------------
-00006350: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
-00006360: 6573 7420 3132 3920 2d2d 2d2d 2d2d 2d2d  est 129 --------
-00006370: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006380: 2d2d 2d2d 2d0a 5468 6520 7175 6963 6b20  -----.The quick 
-00006390: 6272 6f77 6e20 666f 7820 6a75 6d70 7320  brown fox jumps 
-000063a0: 6f76 6572 2074 6865 206c 617a 7920 646f  over the lazy do
-000063b0: 672e 2054 6865 2071 7569 636b 2062 726f  g. The quick bro
-000063c0: 776e 2066 6f78 206a 756d 7073 206f 7665  wn fox jumps ove
-000063d0: 7220 7468 650a 6c61 7a79 2064 6f67 2e20  r the.lazy dog. 
-000063e0: 5468 6520 7175 6963 6b20 6272 6f77 6e20  The quick brown 
-000063f0: 666f 7820 6a75 6d70 7320 6f76 6572 2074  fox jumps over t
-00006400: 6865 206c 617a 7920 646f 672e 2054 6865  he lazy dog. The
-00006410: 2071 7569 636b 2062 726f 776e 2066 6f78   quick brown fox
-00006420: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
-00006430: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006440: 2d2d 2054 6573 7420 3133 3020 2d2d 2d2d  -- Test 130 ----
-00006450: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006460: 2d2d 2d2d 2d2d 2d2d 2d0a 666f 780a 666f  ---------.fox.fo
-00006470: 780a 666f 780a 666f 780a 5243 3d30 0a2d  x.fox.fox.RC=0.-
-00006480: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006490: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
-000064a0: 2031 3331 202d 2d2d 2d2d 2d2d 2d2d 2d2d   131 -----------
-000064b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000064c0: 2d2d 0a32 0a52 433d 300a 2d2d 2d2d 2d2d  --.2.RC=0.------
-000064d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000064e0: 2d2d 2d2d 2d2d 2054 6573 7420 3133 3220  ------ Test 132 
-000064f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006500: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 6d61  -------------.ma
-00006510: 7463 6820 313a 0a20 610a 6d61 7463 6820  tch 1:. a.match 
-00006520: 323a 0a20 620a 2d2d 2d0a 2061 0a52 433d  2:. b.---. a.RC=
-00006530: 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  0.--------------
-00006540: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
-00006550: 6573 7420 3133 3320 2d2d 2d2d 2d2d 2d2d  est 133 --------
-00006560: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006570: 2d2d 2d2d 2d0a 6d61 7463 6820 313a 0a20  -----.match 1:. 
-00006580: 610a 6d61 7463 6820 323a 0a20 620a 2d2d  a.match 2:. b.--
-00006590: 2d0a 6d61 7463 6820 323a 0a20 620a 6d61  -.match 2:. b.ma
-000065a0: 7463 6820 333a 0a20 630a 5243 3d30 0a2d  tch 3:. c.RC=0.-
-000065b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000065c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
-000065d0: 2031 3334 202d 2d2d 2d2d 2d2d 2d2d 2d2d   134 -----------
-000065e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000065f0: 2d2d 0a3d 4142 3343 4435 3d0a 5243 3d30  --.=AB3CD5=.RC=0
-00006600: 0a                                       .
+00005b90: 2d2d 2d2d 2d2d 2d0a 2e2f 7465 7374 6461  -------../testda
+00005ba0: 7461 2f67 7265 7069 6e70 7574 3a74 6865  ta/grepinput:the
+00005bb0: 2062 696e 6172 7920 7a65 726f 2e3a 7a65   binary zero.:ze
+00005bc0: 726f 7468 652e 0a2e 2f74 6573 7464 6174  rothe.../testdat
+00005bd0: 612f 6772 6570 696e 7075 743a 6120 6269  a/grepinput:a bi
+00005be0: 6e61 7279 207a 6572 6f3a 7a65 726f 610a  nary zero:zeroa.
+00005bf0: 2e2f 7465 7374 6461 7461 2f67 7265 7069  ./testdata/grepi
+00005c00: 6e70 7574 3a74 6865 2062 696e 6172 7920  nput:the binary 
+00005c10: 7a65 726f 2e3a 7a65 726f 7468 652e 0a52  zero.:zerothe..R
+00005c20: 433d 300a 7468 6520 6269 6e61 7279 207a  C=0.the binary z
+00005c30: 6572 6f2e 3a07 081b 0c0d 090b 0a52 433d  ero.:........RC=
+00005c40: 300a 7063 7265 3267 7265 703a 2045 7272  0.pcre2grep: Err
+00005c50: 6f72 2069 6e20 6f75 7470 7574 2074 6578  or in output tex
+00005c60: 7420 6174 206f 6666 7365 7420 323a 2064  t at offset 2: d
+00005c70: 6563 696d 616c 206e 756d 6265 7220 6578  ecimal number ex
+00005c80: 7065 6374 6564 0a52 433d 320a 7063 7265  pected.RC=2.pcre
+00005c90: 3267 7265 703a 2045 7272 6f72 2069 6e20  2grep: Error in 
+00005ca0: 6f75 7470 7574 2074 6578 7420 6174 206f  output text at o
+00005cb0: 6666 7365 7420 333a 206e 6f20 6368 6172  ffset 3: no char
+00005cc0: 6163 7465 7220 6166 7465 7220 240a 5243  acter after $.RC
+00005cd0: 3d32 0a70 6372 6532 6772 6570 3a20 4572  =2.pcre2grep: Er
+00005ce0: 726f 7220 696e 206f 7574 7075 7420 7465  ror in output te
+00005cf0: 7874 2061 7420 6f66 6673 6574 2038 3a20  xt at offset 8: 
+00005d00: 746f 6f20 6d61 6e79 2068 6578 2064 6967  too many hex dig
+00005d10: 6974 730a 5243 3d32 0a70 6372 6532 6772  its.RC=2.pcre2gr
+00005d20: 6570 3a20 4572 726f 7220 696e 206f 7574  ep: Error in out
+00005d30: 7075 7420 7465 7874 2061 7420 6f66 6673  put text at offs
+00005d40: 6574 2035 3a20 6d69 7373 696e 6720 636c  et 5: missing cl
+00005d50: 6f73 696e 6720 6272 6163 650a 5243 3d32  osing brace.RC=2
+00005d60: 0a70 6372 6532 6772 6570 3a20 4572 726f  .pcre2grep: Erro
+00005d70: 7220 696e 206f 7574 7075 7420 7465 7874  r in output text
+00005d80: 2061 7420 6f66 6673 6574 2037 3a20 636f   at offset 7: co
+00005d90: 6465 2070 6f69 6e74 2067 7265 6174 6572  de point greater
+00005da0: 2074 6861 6e20 3078 6666 2069 7320 696e   than 0xff is in
+00005db0: 7661 6c69 640a 5243 3d32 0a2d 2d2d 2d2d  valid.RC=2.-----
+00005dc0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005dd0: 2d2d 2d2d 2d2d 2d20 5465 7374 2031 3231  ------- Test 121
+00005de0: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+00005df0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a54  --------------.T
+00005e00: 6869 7320 6c69 6e65 2063 6f6e 7461 696e  his line contain
+00005e10: 7320 5c45 2061 6e64 2028 7265 6765 7829  s \E and (regex)
+00005e20: 202a 6d65 7461 2a20 5b63 6861 7261 6374   *meta* [charact
+00005e30: 6572 735d 2e0a 5243 3d30 0a2d 2d2d 2d2d  ers]..RC=0.-----
+00005e40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005e50: 2d2d 2d2d 2d2d 2d20 5465 7374 2031 3232  ------- Test 122
+00005e60: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+00005e70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a6f  --------------.o
+00005e80: 7665 7220 7468 6520 6c61 7a79 2064 6f67  ver the lazy dog
+00005e90: 2e0a 5468 6520 776f 7264 2069 7320 6361  ..The word is ca
+00005ea0: 7420 696e 2074 6869 7320 6c69 6e65 0a52  t in this line.R
+00005eb0: 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  C=0.------------
+00005ec0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005ed0: 2054 6573 7420 3132 3320 2d2d 2d2d 2d2d   Test 123 ------
+00005ee0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005ef0: 2d2d 2d2d 2d2d 2d0a 6f76 6572 2074 6865  -------.over the
+00005f00: 206c 617a 7920 646f 672e 0a54 6865 2077   lazy dog..The w
+00005f10: 6f72 6420 6973 2063 6174 2069 6e20 7468  ord is cat in th
+00005f20: 6973 206c 696e 650a 5243 3d30 0a2d 2d2d  is line.RC=0.---
+00005f30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005f40: 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374 2031  --------- Test 1
+00005f50: 3234 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  24 -------------
+00005f60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005f70: 0a33 3a1b 5b31 3b33 316d 7374 6172 7420  .3:.[1;31mstart 
+00005f80: 656e 641b 5b30 6d20 696e 2062 6574 7765  end.[0m in betwe
+00005f90: 656e 201b 5b31 3b33 316d 7374 6172 740a  en .[1;31mstart.
+00005fa0: 656e 641b 5b30 6d20 616e 6420 666f 6c6c  end.[0m and foll
+00005fb0: 6f77 696e 670a 373a 1b5b 313b 3331 6d73  owing.7:.[1;31ms
+00005fc0: 7461 7274 2065 6e64 1b5b 306d 2069 6e20  tart end.[0m in 
+00005fd0: 6265 7477 6565 6e20 1b5b 313b 3331 6d73  between .[1;31ms
+00005fe0: 7461 7274 0a65 6e64 1b5b 306d 2061 6e64  tart.end.[0m and
+00005ff0: 2066 6f6c 6c6f 7769 6e67 201b 5b31 3b33   following .[1;3
+00006000: 316d 7374 6172 740a 656e 641b 5b30 6d20  1mstart.end.[0m 
+00006010: 6f74 6865 7220 7374 7566 660a 3131 3a1b  other stuff.11:.
+00006020: 5b31 3b33 316d 7374 6172 7420 656e 641b  [1;31mstart end.
+00006030: 5b30 6d20 696e 2062 6574 7765 656e 201b  [0m in between .
+00006040: 5b31 3b33 316d 7374 6172 740a 0a65 6e64  [1;31mstart..end
+00006050: 1b5b 306d 0a31 363a 1b5b 313b 3331 6d73  .[0m.16:.[1;31ms
+00006060: 7461 7274 2065 6e64 1b5b 306d 2069 6e20  tart end.[0m in 
+00006070: 6265 7477 6565 6e20 1b5b 313b 3331 6d73  between .[1;31ms
+00006080: 7461 7274 0a65 6e64 1b5b 306d 0a52 433d  tart.end.[0m.RC=
+00006090: 300a 333a 1b5b 313b 3331 6d73 7461 7274  0.3:.[1;31mstart
+000060a0: 2065 6e64 1b5b 306d 2069 6e20 6265 7477   end.[0m in betw
+000060b0: 6565 6e20 1b5b 313b 3331 6d73 7461 7274  een .[1;31mstart
+000060c0: 0a65 6e64 1b5b 306d 2061 6e64 2066 6f6c  .end.[0m and fol
+000060d0: 6c6f 7769 6e67 0a35 2d4f 7468 6572 2073  lowing.5-Other s
+000060e0: 7475 6666 0a36 2d0a 373a 1b5b 313b 3331  tuff.6-.7:.[1;31
+000060f0: 6d73 7461 7274 2065 6e64 1b5b 306d 2069  mstart end.[0m i
+00006100: 6e20 6265 7477 6565 6e20 1b5b 313b 3331  n between .[1;31
+00006110: 6d73 7461 7274 0a65 6e64 1b5b 306d 2061  mstart.end.[0m a
+00006120: 6e64 2066 6f6c 6c6f 7769 6e67 201b 5b31  nd following .[1
+00006130: 3b33 316d 7374 6172 740a 656e 641b 5b30  ;31mstart.end.[0
+00006140: 6d20 6f74 6865 7220 7374 7566 660a 3130  m other stuff.10
+00006150: 2d0a 3131 3a1b 5b31 3b33 316d 7374 6172  -.11:.[1;31mstar
+00006160: 7420 656e 641b 5b30 6d20 696e 2062 6574  t end.[0m in bet
+00006170: 7765 656e 201b 5b31 3b33 316d 7374 6172  ween .[1;31mstar
+00006180: 740a 0a65 6e64 1b5b 306d 0a31 342d 0a31  t..end.[0m.14-.1
+00006190: 352d 2a2a 2054 6865 7365 2074 776f 206c  5-** These two l
+000061a0: 696e 6573 206d 7573 7420 6265 206c 6173  ines must be las
+000061b0: 742e 0a31 363a 1b5b 313b 3331 6d73 7461  t..16:.[1;31msta
+000061c0: 7274 2065 6e64 1b5b 306d 2069 6e20 6265  rt end.[0m in be
+000061d0: 7477 6565 6e20 1b5b 313b 3331 6d73 7461  tween .[1;31msta
+000061e0: 7274 0a65 6e64 1b5b 306d 0a52 433d 300a  rt.end.[0m.RC=0.
+000061f0: 333a 7374 6172 7420 656e 6420 696e 2062  3:start end in b
+00006200: 6574 7765 656e 2073 7461 7274 0a65 6e64  etween start.end
+00006210: 2061 6e64 2066 6f6c 6c6f 7769 6e67 0a37   and following.7
+00006220: 3a73 7461 7274 2065 6e64 2069 6e20 6265  :start end in be
+00006230: 7477 6565 6e20 7374 6172 740a 656e 6420  tween start.end 
+00006240: 616e 6420 666f 6c6c 6f77 696e 6720 7374  and following st
+00006250: 6172 740a 656e 6420 6f74 6865 7220 7374  art.end other st
+00006260: 7566 660a 3131 3a73 7461 7274 2065 6e64  uff.11:start end
+00006270: 2069 6e20 6265 7477 6565 6e20 7374 6172   in between star
+00006280: 740a 0a65 6e64 0a31 363a 7374 6172 7420  t..end.16:start 
+00006290: 656e 6420 696e 2062 6574 7765 656e 2073  end in between s
+000062a0: 7461 7274 0a65 6e64 0a52 433d 300a 333a  tart.end.RC=0.3:
+000062b0: 7374 6172 7420 656e 6420 696e 2062 6574  start end in bet
+000062c0: 7765 656e 2073 7461 7274 0a65 6e64 2061  ween start.end a
+000062d0: 6e64 2066 6f6c 6c6f 7769 6e67 0a35 2d4f  nd following.5-O
+000062e0: 7468 6572 2073 7475 6666 0a36 2d0a 373a  ther stuff.6-.7:
+000062f0: 7374 6172 7420 656e 6420 696e 2062 6574  start end in bet
+00006300: 7765 656e 2073 7461 7274 0a65 6e64 2061  ween start.end a
+00006310: 6e64 2066 6f6c 6c6f 7769 6e67 2073 7461  nd following sta
+00006320: 7274 0a65 6e64 206f 7468 6572 2073 7475  rt.end other stu
+00006330: 6666 0a31 302d 0a31 313a 7374 6172 7420  ff.10-.11:start 
+00006340: 656e 6420 696e 2062 6574 7765 656e 2073  end in between s
+00006350: 7461 7274 0a0a 656e 640a 3134 2d0a 3135  tart..end.14-.15
+00006360: 2d2a 2a20 5468 6573 6520 7477 6f20 6c69  -** These two li
+00006370: 6e65 7320 6d75 7374 2062 6520 6c61 7374  nes must be last
+00006380: 2e0a 3136 3a73 7461 7274 2065 6e64 2069  ..16:start end i
+00006390: 6e20 6265 7477 6565 6e20 7374 6172 740a  n between start.
+000063a0: 656e 640a 5243 3d30 0a2d 2d2d 2d2d 2d2d  end.RC=0.-------
+000063b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000063c0: 2d2d 2d2d 2d20 5465 7374 2031 3235 202d  ----- Test 125 -
+000063d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000063e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a1b 5b31  ------------..[1
+000063f0: 3b33 316d 611b 5b30 6d1b 5b31 3b33 316d  ;31ma.[0m.[1;31m
+00006400: 621b 5b30 6d1b 5b31 3b33 316d 631b 5b30  b.[0m.[1;31mc.[0
+00006410: 6d1b 5b31 3b33 316d 641b 5b30 6d0a 5243  m.[1;31md.[0m.RC
+00006420: 3d30 0a1b 5b31 3b33 316d 611b 5b30 6d1b  =0..[1;31ma.[0m.
+00006430: 5b31 3b33 316d 621b 5b30 6d1b 5b31 3b33  [1;31mb.[0m.[1;3
+00006440: 316d 631b 5b30 6d1b 5b31 3b33 316d 641b  1mc.[0m.[1;31md.
+00006450: 5b30 6d0a 5243 3d30 0a1b 5b31 3b33 316d  [0m.RC=0..[1;31m
+00006460: 611b 5b30 6d62 1b5b 313b 3331 6d63 1b5b  a.[0mb.[1;31mc.[
+00006470: 306d 640a 5243 3d30 0a1b 5b31 3b33 316d  0md.RC=0..[1;31m
+00006480: 611b 5b30 6d62 1b5b 313b 3331 6d63 1b5b  a.[0mb.[1;31mc.[
+00006490: 306d 640a 5243 3d30 0a1b 5b31 3b32 306d  0md.RC=0..[1;20m
+000064a0: 611b 5b30 6d62 1b5b 313b 3230 6d63 1b5b  a.[0mb.[1;20mc.[
+000064b0: 306d 640a 5243 3d30 0a2d 2d2d 2d2d 2d2d  0md.RC=0.-------
+000064c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000064d0: 2d2d 2d2d 2d20 5465 7374 2031 3236 202d  ----- Test 126 -
+000064e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000064f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a41 4243  ------------.ABC
+00006500: 0058 595a 0a52 433d 300a 7063 7265 3267  .XYZ.RC=0.pcre2g
+00006510: 7265 703a 2045 7272 6f72 2069 6e20 7265  rep: Error in re
+00006520: 6765 7820 696e 206c 696e 6520 3220 6f66  gex in line 2 of
+00006530: 2074 6573 7474 656d 7031 6772 6570 2061   testtemp1grep a
+00006540: 7420 6f66 6673 6574 2034 3a20 756e 6d61  t offset 4: unma
+00006550: 7463 6865 6420 636c 6f73 696e 6720 7061  tched closing pa
+00006560: 7265 6e74 6865 7369 730a 5243 3d32 0a2d  renthesis.RC=2.-
+00006570: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006580: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
+00006590: 2031 3237 202d 2d2d 2d2d 2d2d 2d2d 2d2d   127 -----------
+000065a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000065b0: 2d2d 0a70 6174 7465 726e 0a52 433d 300a  --.pattern.RC=0.
+000065c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000065d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573  ------------ Tes
+000065e0: 7420 3132 3820 2d2d 2d2d 2d2d 2d2d 2d2d  t 128 ----------
+000065f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006600: 2d2d 2d0a 7063 7265 3267 7265 703a 2052  ---.pcre2grep: R
+00006610: 6571 7565 7374 6564 2067 726f 7570 2031  equested group 1
+00006620: 2063 616e 6e6f 7420 6265 2063 6170 7475   cannot be captu
+00006630: 7265 642e 0a70 6372 6532 6772 6570 3a20  red..pcre2grep: 
+00006640: 5573 6520 2d2d 6f6d 2d63 6170 7475 7265  Use --om-capture
+00006650: 2074 6f20 696e 6372 6561 7365 2074 6865   to increase the
+00006660: 2073 697a 6520 6f66 2074 6865 2063 6170   size of the cap
+00006670: 7475 7265 2076 6563 746f 722e 0a52 433d  ture vector..RC=
+00006680: 320a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  2.--------------
+00006690: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
+000066a0: 6573 7420 3132 3920 2d2d 2d2d 2d2d 2d2d  est 129 --------
+000066b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000066c0: 2d2d 2d2d 2d0a 5468 6520 7175 6963 6b20  -----.The quick 
+000066d0: 6272 6f77 6e20 666f 7820 6a75 6d70 7320  brown fox jumps 
+000066e0: 6f76 6572 2074 6865 206c 617a 7920 646f  over the lazy do
+000066f0: 672e 2054 6865 2071 7569 636b 2062 726f  g. The quick bro
+00006700: 776e 2066 6f78 206a 756d 7073 206f 7665  wn fox jumps ove
+00006710: 7220 7468 650a 6c61 7a79 2064 6f67 2e20  r the.lazy dog. 
+00006720: 5468 6520 7175 6963 6b20 6272 6f77 6e20  The quick brown 
+00006730: 666f 7820 6a75 6d70 7320 6f76 6572 2074  fox jumps over t
+00006740: 6865 206c 617a 7920 646f 672e 2054 6865  he lazy dog. The
+00006750: 2071 7569 636b 2062 726f 776e 2066 6f78   quick brown fox
+00006760: 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d  .RC=0.----------
+00006770: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006780: 2d2d 2054 6573 7420 3133 3020 2d2d 2d2d  -- Test 130 ----
+00006790: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000067a0: 2d2d 2d2d 2d2d 2d2d 2d0a 666f 780a 666f  ---------.fox.fo
+000067b0: 780a 666f 780a 666f 780a 5243 3d30 0a2d  x.fox.fox.RC=0.-
+000067c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000067d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
+000067e0: 2031 3331 202d 2d2d 2d2d 2d2d 2d2d 2d2d   131 -----------
+000067f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006800: 2d2d 0a32 0a52 433d 300a 2d2d 2d2d 2d2d  --.2.RC=0.------
+00006810: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006820: 2d2d 2d2d 2d2d 2054 6573 7420 3133 3220  ------ Test 132 
+00006830: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006840: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 6d61  -------------.ma
+00006850: 7463 6820 313a 0a20 610a 6d61 7463 6820  tch 1:. a.match 
+00006860: 323a 0a20 620a 2d2d 2d0a 2061 0a52 433d  2:. b.---. a.RC=
+00006870: 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  0.--------------
+00006880: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054  -------------- T
+00006890: 6573 7420 3133 3320 2d2d 2d2d 2d2d 2d2d  est 133 --------
+000068a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000068b0: 2d2d 2d2d 2d0a 6d61 7463 6820 313a 0a20  -----.match 1:. 
+000068c0: 610a 6d61 7463 6820 323a 0a20 620a 2d2d  a.match 2:. b.--
+000068d0: 2d0a 6d61 7463 6820 323a 0a20 620a 6d61  -.match 2:. b.ma
+000068e0: 7463 6820 333a 0a20 630a 5243 3d30 0a2d  tch 3:. c.RC=0.-
+000068f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006900: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
+00006910: 2031 3334 202d 2d2d 2d2d 2d2d 2d2d 2d2d   134 -----------
+00006920: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006930: 2d2d 0a28 7374 616e 6461 7264 2069 6e70  --.(standard inp
+00006940: 7574 293a 323a 3d41 4233 4344 353d 0a52  ut):2:=AB3CD5=.R
+00006950: 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  C=0.------------
+00006960: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006970: 2054 6573 7420 3133 3520 2d2d 2d2d 2d2d   Test 135 ------
+00006980: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006990: 2d2d 2d2d 2d2d 2d0a 2e2f 7465 7374 6461  -------../testda
+000069a0: 7461 2f67 7265 7069 6e70 7574 7640 5468  ta/grepinputv@Th
+000069b0: 6520 776f 7264 2069 7320 6361 7420 696e  e word is cat in
+000069c0: 2074 6869 7320 6c69 6e65 0a52 433d 300a   this line.RC=0.
+000069d0: 2e2f 7465 7374 6461 7461 2f67 7265 7069  ./testdata/grepi
+000069e0: 6e70 7574 7640 2e2f 7465 7374 6461 7461  nputv@./testdata
+000069f0: 2f67 7265 7069 6e70 7574 7640 5243 3d30  /grepinputv@RC=0
+00006a00: 0a2e 2f74 6573 7464 6174 612f 6772 6570  ../testdata/grep
+00006a10: 696e 7075 7476 4054 6869 7320 6c69 6e65  inputv@This line
+00006a20: 2063 6f6e 7461 696e 7320 5c45 2061 6e64   contains \E and
+00006a30: 2028 7265 6765 7829 202a 6d65 7461 2a20   (regex) *meta* 
+00006a40: 5b63 6861 7261 6374 6572 735d 2e0a 2e2f  [characters].../
+00006a50: 7465 7374 6461 7461 2f67 7265 7069 6e70  testdata/grepinp
+00006a60: 7574 7640 5468 6520 776f 7264 2069 7320  utv@The word is 
+00006a70: 6361 7420 696e 2074 6869 7320 6c69 6e65  cat in this line
+00006a80: 0a2e 2f74 6573 7464 6174 612f 6772 6570  ../testdata/grep
+00006a90: 696e 7075 7476 4054 6865 2063 6174 6572  inputv@The cater
+00006aa0: 7069 6c6c 6172 2073 6174 206f 6e20 7468  pillar sat on th
+00006ab0: 6520 6d61 740a 5243 3d30 0a74 6573 7464  e mat.RC=0.testd
+00006ac0: 6174 612f 6772 6570 696e 7075 744d 0033  ata/grepinputM.3
+00006ad0: 3a73 7461 7274 2065 6e64 2069 6e20 6265  :start end in be
+00006ae0: 7477 6565 6e20 7374 6172 740a 656e 6420  tween start.end 
+00006af0: 616e 6420 666f 6c6c 6f77 696e 670a 7465  and following.te
+00006b00: 7374 6461 7461 2f67 7265 7069 6e70 7574  stdata/grepinput
+00006b10: 4d00 373a 7374 6172 7420 656e 6420 696e  M.7:start end in
+00006b20: 2062 6574 7765 656e 2073 7461 7274 0a65   between start.e
+00006b30: 6e64 2061 6e64 2066 6f6c 6c6f 7769 6e67  nd and following
+00006b40: 2073 7461 7274 0a65 6e64 206f 7468 6572   start.end other
+00006b50: 2073 7475 6666 0a74 6573 7464 6174 612f   stuff.testdata/
+00006b60: 6772 6570 696e 7075 744d 0031 313a 7374  grepinputM.11:st
+00006b70: 6172 7420 656e 6420 696e 2062 6574 7765  art end in betwe
+00006b80: 656e 2073 7461 7274 0a0a 656e 640a 7465  en start..end.te
+00006b90: 7374 6461 7461 2f67 7265 7069 6e70 7574  stdata/grepinput
+00006ba0: 4d00 3136 3a73 7461 7274 2065 6e64 2069  M.16:start end i
+00006bb0: 6e20 6265 7477 6565 6e20 7374 6172 740a  n between start.
+00006bc0: 656e 640a 5243 3d30 0a2d 2d2d 2d2d 2d2d  end.RC=0.-------
+00006bd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006be0: 2d2d 2d2d 2d20 5465 7374 2031 3336 202d  ----- Test 136 -
+00006bf0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006c00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a70 6372  ------------.pcr
+00006c10: 6532 6772 6570 3a20 4d61 6c66 6f72 6d65  e2grep: Malforme
+00006c20: 6420 6e75 6d62 6572 2022 314d 4b22 2061  d number "1MK" a
+00006c30: 6674 6572 202d 6d0a 5573 6167 653a 2070  fter -m.Usage: p
+00006c40: 6372 6532 6772 6570 205b 2d41 6142 4363  cre2grep [-AaBCc
+00006c50: 4464 6546 6648 6849 696c 4c4d 6d4e 6e4f  DdeFfHhIilLMmNnO
+00006c60: 6f71 7273 7475 5556 7677 785a 5d20 5b6c  oqrstuUVvwxZ] [l
+00006c70: 6f6e 6720 6f70 7469 6f6e 735d 205b 7061  ong options] [pa
+00006c80: 7474 6572 6e5d 205b 6669 6c65 735d 0a54  ttern] [files].T
+00006c90: 7970 6520 2270 6372 6532 6772 6570 202d  ype "pcre2grep -
+00006ca0: 2d68 656c 7022 2066 6f72 206d 6f72 6520  -help" for more 
+00006cb0: 696e 666f 726d 6174 696f 6e20 616e 6420  information and 
+00006cc0: 7468 6520 6c6f 6e67 206f 7074 696f 6e73  the long options
+00006cd0: 2e0a 5243 3d32 0a70 6372 6532 6772 6570  ..RC=2.pcre2grep
+00006ce0: 3a20 4d61 6c66 6f72 6d65 6420 6e75 6d62  : Malformed numb
+00006cf0: 6572 2022 314d 4b22 2061 6674 6572 202d  er "1MK" after -
+00006d00: 2d6d 6178 2d63 6f75 6e74 0a55 7361 6765  -max-count.Usage
+00006d10: 3a20 7063 7265 3267 7265 7020 5b2d 4161  : pcre2grep [-Aa
+00006d20: 4243 6344 6465 4666 4868 4969 6c4c 4d6d  BCcDdeFfHhIilLMm
+00006d30: 4e6e 4f6f 7172 7374 7555 5676 7778 5a5d  NnOoqrstuUVvwxZ]
+00006d40: 205b 6c6f 6e67 206f 7074 696f 6e73 5d20   [long options] 
+00006d50: 5b70 6174 7465 726e 5d20 5b66 696c 6573  [pattern] [files
+00006d60: 5d0a 5479 7065 2022 7063 7265 3267 7265  ].Type "pcre2gre
+00006d70: 7020 2d2d 6865 6c70 2220 666f 7220 6d6f  p --help" for mo
+00006d80: 7265 2069 6e66 6f72 6d61 7469 6f6e 2061  re information a
+00006d90: 6e64 2074 6865 206c 6f6e 6720 6f70 7469  nd the long opti
+00006da0: 6f6e 732e 0a52 433d 320a 2d2d 2d2d 2d2d  ons..RC=2.------
+00006db0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006dc0: 2d2d 2d2d 2d2d 2054 6573 7420 3133 3720  ------ Test 137 
+00006dd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006de0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 4c61  -------------.La
+00006df0: 7374 206c 696e 650a 6861 7320 6e6f 206e  st line.has no n
+00006e00: 6577 6c69 6e65 0a52 433d 300a 2d2d 2d2d  ewline.RC=0.----
+00006e10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006e20: 2d2d 2d2d 2d2d 2d2d 2054 6573 7420 3133  -------- Test 13
+00006e30: 3820 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  8 --------------
+00006e40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
+00006e50: 7063 7265 3267 7265 703a 2070 6372 6532  pcre2grep: pcre2
+00006e60: 5f6d 6174 6368 2829 2067 6176 6520 6572  _match() gave er
+00006e70: 726f 7220 2d36 3320 7768 696c 6520 6d61  ror -63 while ma
+00006e80: 7463 6869 6e67 2074 6869 7320 7465 7874  tching this text
+00006e90: 3a0a 0a41 6243 0a0a 7063 7265 3267 7265  :..AbC..pcre2gre
+00006ea0: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+00006eb0: 2067 6176 6520 6572 726f 7220 2d36 3320   gave error -63 
+00006ec0: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+00006ed0: 6869 7320 7465 7874 3a0a 0a41 6243 0a0a  his text:..AbC..
+00006ee0: 7063 7265 3267 7265 703a 2070 6372 6532  pcre2grep: pcre2
+00006ef0: 5f6d 6174 6368 2829 2067 6176 6520 6572  _match() gave er
+00006f00: 726f 7220 2d36 3320 7768 696c 6520 6d61  ror -63 while ma
+00006f10: 7463 6869 6e67 2074 6869 7320 7465 7874  tching this text
+00006f20: 3a0a 0a41 6243 0a0a 7063 7265 3267 7265  :..AbC..pcre2gre
+00006f30: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+00006f40: 2067 6176 6520 6572 726f 7220 2d36 3320   gave error -63 
+00006f50: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+00006f60: 6869 7320 7465 7874 3a0a 0a41 6243 0a0a  his text:..AbC..
+00006f70: 7063 7265 3267 7265 703a 2070 6372 6532  pcre2grep: pcre2
+00006f80: 5f6d 6174 6368 2829 2067 6176 6520 6572  _match() gave er
+00006f90: 726f 7220 2d36 3320 7768 696c 6520 6d61  ror -63 while ma
+00006fa0: 7463 6869 6e67 2074 6869 7320 7465 7874  tching this text
+00006fb0: 3a0a 0a41 6243 0a0a 7063 7265 3267 7265  :..AbC..pcre2gre
+00006fc0: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+00006fd0: 2067 6176 6520 6572 726f 7220 2d36 3320   gave error -63 
+00006fe0: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+00006ff0: 6869 7320 7465 7874 3a0a 0a41 6243 0a0a  his text:..AbC..
+00007000: 7063 7265 3267 7265 703a 2070 6372 6532  pcre2grep: pcre2
+00007010: 5f6d 6174 6368 2829 2067 6176 6520 6572  _match() gave er
+00007020: 726f 7220 2d36 3320 7768 696c 6520 6d61  ror -63 while ma
+00007030: 7463 6869 6e67 2074 6869 7320 7465 7874  tching this text
+00007040: 3a0a 0a41 6243 0a0a 7063 7265 3267 7265  :..AbC..pcre2gre
+00007050: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+00007060: 2067 6176 6520 6572 726f 7220 2d36 3320   gave error -63 
+00007070: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+00007080: 6869 7320 7465 7874 3a0a 0a41 6243 0a0a  his text:..AbC..
+00007090: 7063 7265 3267 7265 703a 2070 6372 6532  pcre2grep: pcre2
+000070a0: 5f6d 6174 6368 2829 2067 6176 6520 6572  _match() gave er
+000070b0: 726f 7220 2d36 3320 7768 696c 6520 6d61  ror -63 while ma
+000070c0: 7463 6869 6e67 2074 6869 7320 7465 7874  tching this text
+000070d0: 3a0a 0a41 6243 0a0a 7063 7265 3267 7265  :..AbC..pcre2gre
+000070e0: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+000070f0: 2067 6176 6520 6572 726f 7220 2d36 3320   gave error -63 
+00007100: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+00007110: 6869 7320 7465 7874 3a0a 0a41 6243 0a0a  his text:..AbC..
+00007120: 7063 7265 3267 7265 703a 2070 6372 6532  pcre2grep: pcre2
+00007130: 5f6d 6174 6368 2829 2067 6176 6520 6572  _match() gave er
+00007140: 726f 7220 2d36 3320 7768 696c 6520 6d61  ror -63 while ma
+00007150: 7463 6869 6e67 2074 6869 7320 7465 7874  tching this text
+00007160: 3a0a 0a41 6243 0a0a 7063 7265 3267 7265  :..AbC..pcre2gre
+00007170: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+00007180: 2067 6176 6520 6572 726f 7220 2d36 3320   gave error -63 
+00007190: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+000071a0: 6869 7320 7465 7874 3a0a 0a41 6243 0a0a  his text:..AbC..
+000071b0: 7063 7265 3267 7265 703a 2070 6372 6532  pcre2grep: pcre2
+000071c0: 5f6d 6174 6368 2829 2067 6176 6520 6572  _match() gave er
+000071d0: 726f 7220 2d36 3320 7768 696c 6520 6d61  ror -63 while ma
+000071e0: 7463 6869 6e67 2074 6869 7320 7465 7874  tching this text
+000071f0: 3a0a 0a41 6243 0a0a 7063 7265 3267 7265  :..AbC..pcre2gre
+00007200: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+00007210: 2067 6176 6520 6572 726f 7220 2d36 3320   gave error -63 
+00007220: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+00007230: 6869 7320 7465 7874 3a0a 0a41 6243 0a0a  his text:..AbC..
+00007240: 7063 7265 3267 7265 703a 2070 6372 6532  pcre2grep: pcre2
+00007250: 5f6d 6174 6368 2829 2067 6176 6520 6572  _match() gave er
+00007260: 726f 7220 2d36 3320 7768 696c 6520 6d61  ror -63 while ma
+00007270: 7463 6869 6e67 2074 6869 7320 7465 7874  tching this text
+00007280: 3a0a 0a41 6243 0a0a 7063 7265 3267 7265  :..AbC..pcre2gre
+00007290: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+000072a0: 2067 6176 6520 6572 726f 7220 2d36 3320   gave error -63 
+000072b0: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+000072c0: 6869 7320 7465 7874 3a0a 0a41 6243 0a0a  his text:..AbC..
+000072d0: 7063 7265 3267 7265 703a 2070 6372 6532  pcre2grep: pcre2
+000072e0: 5f6d 6174 6368 2829 2067 6176 6520 6572  _match() gave er
+000072f0: 726f 7220 2d36 3320 7768 696c 6520 6d61  ror -63 while ma
+00007300: 7463 6869 6e67 2074 6869 7320 7465 7874  tching this text
+00007310: 3a0a 0a41 6243 0a0a 7063 7265 3267 7265  :..AbC..pcre2gre
+00007320: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+00007330: 2067 6176 6520 6572 726f 7220 2d36 3320   gave error -63 
+00007340: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+00007350: 6869 7320 7465 7874 3a0a 0a41 6243 0a0a  his text:..AbC..
+00007360: 7063 7265 3267 7265 703a 2070 6372 6532  pcre2grep: pcre2
+00007370: 5f6d 6174 6368 2829 2067 6176 6520 6572  _match() gave er
+00007380: 726f 7220 2d36 3320 7768 696c 6520 6d61  ror -63 while ma
+00007390: 7463 6869 6e67 2074 6869 7320 7465 7874  tching this text
+000073a0: 3a0a 0a41 6243 0a0a 7063 7265 3267 7265  :..AbC..pcre2gre
+000073b0: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+000073c0: 2067 6176 6520 6572 726f 7220 2d36 3320   gave error -63 
+000073d0: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+000073e0: 6869 7320 7465 7874 3a0a 0a41 6243 0a0a  his text:..AbC..
+000073f0: 7063 7265 3267 7265 703a 2070 6372 6532  pcre2grep: pcre2
+00007400: 5f6d 6174 6368 2829 2067 6176 6520 6572  _match() gave er
+00007410: 726f 7220 2d36 3320 7768 696c 6520 6d61  ror -63 while ma
+00007420: 7463 6869 6e67 2074 6869 7320 7465 7874  tching this text
+00007430: 3a0a 0a41 6243 0a0a 7063 7265 3267 7265  :..AbC..pcre2gre
+00007440: 703a 2070 6372 6532 5f6d 6174 6368 2829  p: pcre2_match()
+00007450: 2067 6176 6520 6572 726f 7220 2d36 3320   gave error -63 
+00007460: 7768 696c 6520 6d61 7463 6869 6e67 2074  while matching t
+00007470: 6869 7320 7465 7874 3a0a 0a41 6243 0a0a  his text:..AbC..
+00007480: 7063 7265 3267 7265 703a 2054 6f6f 206d  pcre2grep: Too m
+00007490: 616e 7920 6572 726f 7273 202d 2061 6261  any errors - aba
+000074a0: 6e64 6f6e 6564 2e0a 7063 7265 3267 7265  ndoned..pcre2gre
+000074b0: 703a 2045 7272 6f72 202d 3436 2c20 2d34  p: Error -46, -4
+000074c0: 372c 202d 3533 206f 7220 2d36 3320 6d65  7, -53 or -63 me
+000074d0: 616e 7320 7468 6174 2061 2072 6573 6f75  ans that a resou
+000074e0: 7263 6520 6c69 6d69 7420 7761 7320 6578  rce limit was ex
+000074f0: 6365 6564 6564 2e0a 7063 7265 3267 7265  ceeded..pcre2gre
+00007500: 703a 2043 6865 636b 2079 6f75 7220 7265  p: Check your re
+00007510: 6765 7820 666f 7220 6e65 7374 6564 2075  gex for nested u
+00007520: 6e6c 696d 6974 6564 206c 6f6f 7073 2e0a  nlimited loops..
+00007530: 5243 3d32 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=2.-----------
+00007540: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007550: 2d20 5465 7374 2031 3339 202d 2d2d 2d2d  - Test 139 -----
+00007560: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007570: 2d2d 2d2d 2d2d 2d2d 0a66 6f78 206a 756d  --------.fox jum
+00007580: 7073 0a52 433d 300a 2d2d 2d2d 2d2d 2d2d  ps.RC=0.--------
+00007590: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000075a0: 2d2d 2d2d 2054 6573 7420 3134 3020 2d2d  ---- Test 140 --
+000075b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000075c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 5468 6520  -----------.The 
+000075d0: 7175 6963 6b20 6272 6f77 6e0a 666f 7820  quick brown.fox 
+000075e0: 6a75 6d70 730a 5243 3d30 0a2d 2d2d 2d2d  jumps.RC=0.-----
+000075f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007600: 2d2d 2d2d 2d2d 2d20 5465 7374 2031 3431  ------- Test 141
+00007610: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+00007620: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a28  --------------.(
+00007630: 7374 616e 6461 7264 2069 6e70 7574 293a  standard input):
+00007640: 5468 6973 2069 7320 6120 6c69 6e65 2066  This is a line f
+00007650: 726f 6d20 7374 6469 6e2e 0a52 433d 300a  rom stdin..RC=0.
+00007660: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007670: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573  ------------ Tes
+00007680: 7420 3134 3220 2d2d 2d2d 2d2d 2d2d 2d2d  t 142 ----------
+00007690: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000076a0: 2d2d 2d0a 7063 7265 3267 7265 703a 2046  ---.pcre2grep: F
+000076b0: 6169 6c65 6420 746f 206f 7065 6e20 2f64  ailed to open /d
+000076c0: 6f65 732f 6e6f 742f 6578 6973 743a 204e  oes/not/exist: N
+000076d0: 6f20 7375 6368 2066 696c 6520 6f72 2064  o such file or d
+000076e0: 6972 6563 746f 7279 0a52 433d 320a 2d2d  irectory.RC=2.--
+000076f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007700: 2d2d 2d2d 2d2d 2d2d 2d2d 2054 6573 7420  ---------- Test 
+00007710: 3134 3320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  143 ------------
+00007720: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007730: 2d0a 666f 7820 6a75 6d70 730a 5468 6520  -.fox jumps.The 
+00007740: 776f 7264 2069 7320 6361 7420 696e 2074  word is cat in t
+00007750: 6869 7320 6c69 6e65 0a54 6865 2063 6174  his line.The cat
+00007760: 6572 7069 6c6c 6172 2073 6174 206f 6e20  erpillar sat on 
+00007770: 7468 6520 6d61 740a 5468 6520 736e 6f77  the mat.The snow
+00007780: 6361 7420 6973 206e 6f74 2061 6e20 616e  cat is not an an
+00007790: 696d 616c 0a41 2062 7572 6965 6420 6665  imal.A buried fe
+000077a0: 6c69 6e65 2069 6e20 7468 6520 7379 6e64  line in the synd
+000077b0: 6963 6174 650a 5243 3d30 0a2d 2d2d 2d2d  icate.RC=0.-----
+000077c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000077d0: 2d2d 2d2d 2d2d 2d20 5465 7374 2031 3434  ------- Test 144
+000077e0: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+000077f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a70  --------------.p
+00007800: 6372 6532 6772 6570 3a20 4661 696c 6564  cre2grep: Failed
+00007810: 2074 6f20 6f70 656e 202f 6e6f 6e2f 6578   to open /non/ex
+00007820: 6973 743a 204e 6f20 7375 6368 2066 696c  ist: No such fil
+00007830: 6520 6f72 2064 6972 6563 746f 7279 0a52  e or directory.R
+00007840: 433d 320a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  C=2.------------
+00007850: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007860: 2054 6573 7420 3134 3520 2d2d 2d2d 2d2d   Test 145 ------
+00007870: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007880: 2d2d 2d2d 2d2d 2d0a 5468 6520 7175 6963  -------.The quic
+00007890: 6b20 6272 6f77 6e0a 666f 7820 6a75 6d70  k brown.fox jump
+000078a0: 730a 6f76 6572 2074 6865 206c 617a 7920  s.over the lazy 
+000078b0: 646f 672e 0a54 6869 7320 7469 6d65 2069  dog..This time i
+000078c0: 7420 6a75 6d70 7320 616e 6420 6a75 6d70  t jumps and jump
+000078d0: 7320 616e 6420 6a75 6d70 732e 0a54 6869  s and jumps..Thi
+000078e0: 7320 6c69 6e65 2063 6f6e 7461 696e 7320  s line contains 
+000078f0: 5c45 2061 6e64 2028 7265 6765 7829 202a  \E and (regex) *
+00007900: 6d65 7461 2a20 5b63 6861 7261 6374 6572  meta* [character
+00007910: 735d 2e0a 5468 6520 776f 7264 2069 7320  s]..The word is 
+00007920: 6361 7420 696e 2074 6869 7320 6c69 6e65  cat in this line
+00007930: 0a54 6865 2063 6174 6572 7069 6c6c 6172  .The caterpillar
+00007940: 2073 6174 206f 6e20 7468 6520 6d61 740a   sat on the mat.
+00007950: 5468 6520 736e 6f77 6361 7420 6973 206e  The snowcat is n
+00007960: 6f74 2061 6e20 616e 696d 616c 0a41 2062  ot an animal.A b
+00007970: 7572 6965 6420 6665 6c69 6e65 2069 6e20  uried feline in 
+00007980: 7468 6520 7379 6e64 6963 6174 650a 0d52  the syndicate..R
+00007990: 433d 300a 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  C=0.------------
+000079a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000079b0: 2054 6573 7420 3134 3620 2d2d 2d2d 2d2d   Test 146 ------
+000079c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000079d0: 2d2d 2d2d 2d2d 2d0a 2873 7461 6e64 6172  -------.(standar
+000079e0: 6420 696e 7075 7429 3a41 3132 3342 0a52  d input):A123B.R
+000079f0: 433d 300a 4131 3233 420a 666f 7820 6a75  C=0.A123B.fox ju
+00007a00: 6d70 730a 5243 3d30 0a55 7361 6765 3a20  mps.RC=0.Usage: 
+00007a10: 7063 7265 3267 7265 7020 5b2d 4161 4243  pcre2grep [-AaBC
+00007a20: 6344 6465 4666 4868 4969 6c4c 4d6d 4e6e  cDdeFfHhIilLMmNn
+00007a30: 4f6f 7172 7374 7555 5676 7778 5a5d 205b  OoqrstuUVvwxZ] [
+00007a40: 6c6f 6e67 206f 7074 696f 6e73 5d20 5b70  long options] [p
+00007a50: 6174 7465 726e 5d20 5b66 696c 6573 5d0a  attern] [files].
+00007a60: 5479 7065 2022 7063 7265 3267 7265 7020  Type "pcre2grep 
+00007a70: 2d2d 6865 6c70 2220 666f 7220 6d6f 7265  --help" for more
+00007a80: 2069 6e66 6f72 6d61 7469 6f6e 2061 6e64   information and
+00007a90: 2074 6865 206c 6f6e 6720 6f70 7469 6f6e   the long option
+00007aa0: 732e 0a52 433d 320a 2d2d 2d2d 2d2d 2d2d  s..RC=2.--------
+00007ab0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007ac0: 2d2d 2d2d 2054 6573 7420 3134 3720 2d2d  ---- Test 147 --
+00007ad0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007ae0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 7063 7265  -----------.pcre
+00007af0: 3267 7265 703a 2046 6169 6c65 6420 746f  2grep: Failed to
+00007b00: 206f 7065 6e20 2d6e 6f6e 6669 6c65 3a20   open -nonfile: 
+00007b10: 4e6f 2073 7563 6820 6669 6c65 206f 7220  No such file or 
+00007b20: 6469 7265 6374 6f72 790a 5243 3d32 0a2d  directory.RC=2.-
+00007b30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007b40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 5465 7374  ----------- Test
+00007b50: 2031 3438 202d 2d2d 2d2d 2d2d 2d2d 2d2d   148 -----------
+00007b60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007b70: 2d2d 0a70 6372 6532 6772 6570 3a20 556e  --.pcre2grep: Un
+00007b80: 6b6e 6f77 6e20 6f70 7469 6f6e 202d 2d6e  known option --n
+00007b90: 6f6e 6578 6973 740a 5573 6167 653a 2070  onexist.Usage: p
+00007ba0: 6372 6532 6772 6570 205b 2d41 6142 4363  cre2grep [-AaBCc
+00007bb0: 4464 6546 6648 6849 696c 4c4d 6d4e 6e4f  DdeFfHhIilLMmNnO
+00007bc0: 6f71 7273 7475 5556 7677 785a 5d20 5b6c  oqrstuUVvwxZ] [l
+00007bd0: 6f6e 6720 6f70 7469 6f6e 735d 205b 7061  ong options] [pa
+00007be0: 7474 6572 6e5d 205b 6669 6c65 735d 0a54  ttern] [files].T
+00007bf0: 7970 6520 2270 6372 6532 6772 6570 202d  ype "pcre2grep -
+00007c00: 2d68 656c 7022 2066 6f72 206d 6f72 6520  -help" for more 
+00007c10: 696e 666f 726d 6174 696f 6e20 616e 6420  information and 
+00007c20: 7468 6520 6c6f 6e67 206f 7074 696f 6e73  the long options
+00007c30: 2e0a 5243 3d32 0a70 6372 6532 6772 6570  ..RC=2.pcre2grep
+00007c40: 3a20 556e 6b6e 6f77 6e20 6f70 7469 6f6e  : Unknown option
+00007c50: 206c 6574 7465 7220 272d 2720 696e 2022   letter '-' in "
+00007c60: 2d6e 2d6e 2d62 6164 220a 5573 6167 653a  -n-n-bad".Usage:
+00007c70: 2070 6372 6532 6772 6570 205b 2d41 6142   pcre2grep [-AaB
+00007c80: 4363 4464 6546 6648 6849 696c 4c4d 6d4e  CcDdeFfHhIilLMmN
+00007c90: 6e4f 6f71 7273 7475 5556 7677 785a 5d20  nOoqrstuUVvwxZ] 
+00007ca0: 5b6c 6f6e 6720 6f70 7469 6f6e 735d 205b  [long options] [
+00007cb0: 7061 7474 6572 6e5d 205b 6669 6c65 735d  pattern] [files]
+00007cc0: 0a54 7970 6520 2270 6372 6532 6772 6570  .Type "pcre2grep
+00007cd0: 202d 2d68 656c 7022 2066 6f72 206d 6f72   --help" for mor
+00007ce0: 6520 696e 666f 726d 6174 696f 6e20 616e  e information an
+00007cf0: 6420 7468 6520 6c6f 6e67 206f 7074 696f  d the long optio
+00007d00: 6e73 2e0a 5243 3d32 0a70 6372 6532 6772  ns..RC=2.pcre2gr
+00007d10: 6570 3a20 4461 7461 206d 6973 7369 6e67  ep: Data missing
+00007d20: 2061 6674 6572 202d 2d63 6f6e 7465 7874   after --context
+00007d30: 0a55 7361 6765 3a20 7063 7265 3267 7265  .Usage: pcre2gre
+00007d40: 7020 5b2d 4161 4243 6344 6465 4666 4868  p [-AaBCcDdeFfHh
+00007d50: 4969 6c4c 4d6d 4e6e 4f6f 7172 7374 7555  IilLMmNnOoqrstuU
+00007d60: 5676 7778 5a5d 205b 6c6f 6e67 206f 7074  VvwxZ] [long opt
+00007d70: 696f 6e73 5d20 5b70 6174 7465 726e 5d20  ions] [pattern] 
+00007d80: 5b66 696c 6573 5d0a 5479 7065 2022 7063  [files].Type "pc
+00007d90: 7265 3267 7265 7020 2d2d 6865 6c70 2220  re2grep --help" 
+00007da0: 666f 7220 6d6f 7265 2069 6e66 6f72 6d61  for more informa
+00007db0: 7469 6f6e 2061 6e64 2074 6865 206c 6f6e  tion and the lon
+00007dc0: 6720 6f70 7469 6f6e 732e 0a52 433d 320a  g options..RC=2.
+00007dd0: 7063 7265 3267 7265 703a 2043 616e 6e6f  pcre2grep: Canno
+00007de0: 7420 6d69 7820 2d2d 6f6e 6c79 2d6d 6174  t mix --only-mat
+00007df0: 6368 696e 672c 202d 2d6f 7574 7075 742c  ching, --output,
+00007e00: 202d 2d66 696c 652d 6f66 6673 6574 7320   --file-offsets 
+00007e10: 616e 642f 6f72 202d 2d6c 696e 652d 6f66  and/or --line-of
+00007e20: 6673 6574 730a 5573 6167 653a 2070 6372  fsets.Usage: pcr
+00007e30: 6532 6772 6570 205b 2d41 6142 4363 4464  e2grep [-AaBCcDd
+00007e40: 6546 6648 6849 696c 4c4d 6d4e 6e4f 6f71  eFfHhIilLMmNnOoq
+00007e50: 7273 7475 5556 7677 785a 5d20 5b6c 6f6e  rstuUVvwxZ] [lon
+00007e60: 6720 6f70 7469 6f6e 735d 205b 7061 7474  g options] [patt
+00007e70: 6572 6e5d 205b 6669 6c65 735d 0a54 7970  ern] [files].Typ
+00007e80: 6520 2270 6372 6532 6772 6570 202d 2d68  e "pcre2grep --h
+00007e90: 656c 7022 2066 6f72 206d 6f72 6520 696e  elp" for more in
+00007ea0: 666f 726d 6174 696f 6e20 616e 6420 7468  formation and th
+00007eb0: 6520 6c6f 6e67 206f 7074 696f 6e73 2e0a  e long options..
+00007ec0: 5243 3d32 0a70 6372 6532 6772 6570 3a20  RC=2.pcre2grep: 
+00007ed0: 556e 6b6e 6f77 6e20 636f 6c6f 7572 2073  Unknown colour s
+00007ee0: 6574 7469 6e67 2022 6261 6476 616c 7565  etting "badvalue
+00007ef0: 220a 5243 3d32 0a70 6372 6532 6772 6570  ".RC=2.pcre2grep
+00007f00: 3a20 496e 7661 6c69 6420 6e65 776c 696e  : Invalid newlin
+00007f10: 6520 7370 6563 6966 6965 7220 2262 6164  e specifier "bad
+00007f20: 7661 6c75 6522 0a52 433d 320a 7063 7265  value".RC=2.pcre
+00007f30: 3267 7265 703a 2049 6e76 616c 6964 2076  2grep: Invalid v
+00007f40: 616c 7565 2022 6261 6476 616c 7565 2220  alue "badvalue" 
+00007f50: 666f 7220 2d64 0a52 433d 320a 7063 7265  for -d.RC=2.pcre
+00007f60: 3267 7265 703a 2049 6e76 616c 6964 2076  2grep: Invalid v
+00007f70: 616c 7565 2022 6261 6476 616c 7565 2220  alue "badvalue" 
+00007f80: 666f 7220 2d44 0a52 433d 320a 7063 7265  for -D.RC=2.pcre
+00007f90: 3267 7265 703a 202d 2d62 7566 6665 722d  2grep: --buffer-
+00007fa0: 7369 7a65 206d 7573 7420 6265 2067 7265  size must be gre
+00007fb0: 6174 6572 2074 6861 6e20 7a65 726f 0a52  ater than zero.R
+00007fc0: 433d 320a 7063 7265 3267 7265 703a 2045  C=2.pcre2grep: E
+00007fd0: 7272 6f72 2069 6e20 2d2d 6578 636c 7564  rror in --exclud
+00007fe0: 6520 7265 6765 7820 6174 206f 6666 7365  e regex at offse
+00007ff0: 7420 373a 206d 6973 7369 6e67 2063 6c6f  t 7: missing clo
+00008000: 7369 6e67 2070 6172 656e 7468 6573 6973  sing parenthesis
+00008010: 0a52 433d 320a 7063 7265 3267 7265 703a  .RC=2.pcre2grep:
+00008020: 2046 6169 6c65 6420 746f 206f 7065 6e20   Failed to open 
+00008030: 2f6e 6f6e 2f65 7869 7374 3a20 4e6f 2073  /non/exist: No s
+00008040: 7563 6820 6669 6c65 206f 7220 6469 7265  uch file or dire
+00008050: 6374 6f72 790a 5243 3d32 0a70 6372 6532  ctory.RC=2.pcre2
+00008060: 6772 6570 3a20 4661 696c 6564 2074 6f20  grep: Failed to 
+00008070: 6f70 656e 202f 6e6f 6e2f 6578 6973 743a  open /non/exist:
+00008080: 204e 6f20 7375 6368 2066 696c 6520 6f72   No such file or
+00008090: 2064 6972 6563 746f 7279 0a52 433d 320a   directory.RC=2.
+000080a0: 7063 7265 3267 7265 703a 2046 6169 6c65  pcre2grep: Faile
+000080b0: 6420 746f 206f 7065 6e20 2f6e 6f6e 2f65  d to open /non/e
+000080c0: 7869 7374 3a20 4e6f 2073 7563 6820 6669  xist: No such fi
+000080d0: 6c65 206f 7220 6469 7265 6374 6f72 790a  le or directory.
+000080e0: 5243 3d32 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=2.-----------
+000080f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00008100: 2d20 5465 7374 2031 3439 202d 2d2d 2d2d  - Test 149 -----
+00008110: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00008120: 2d2d 2d2d 2d2d 2d2d 0a42 696e 6172 7920  --------.Binary 
+00008130: 6669 6c65 202e 2f74 6573 7464 6174 612f  file ./testdata/
+00008140: 6772 6570 6269 6e61 7279 206d 6174 6368  grepbinary match
+00008150: 6573 0a52 433d 300a 7063 7265 3267 7265  es.RC=0.pcre2gre
+00008160: 703a 2075 6e6b 6e6f 776e 2076 616c 7565  p: unknown value
+00008170: 2022 7772 6f6e 6722 2066 6f72 2062 696e   "wrong" for bin
+00008180: 6172 792d 6669 6c65 730a 5573 6167 653a  ary-files.Usage:
+00008190: 2070 6372 6532 6772 6570 205b 2d41 6142   pcre2grep [-AaB
+000081a0: 4363 4464 6546 6648 6849 696c 4c4d 6d4e  CcDdeFfHhIilLMmN
+000081b0: 6e4f 6f71 7273 7475 5556 7677 785a 5d20  nOoqrstuUVvwxZ] 
+000081c0: 5b6c 6f6e 6720 6f70 7469 6f6e 735d 205b  [long options] [
+000081d0: 7061 7474 6572 6e5d 205b 6669 6c65 735d  pattern] [files]
+000081e0: 0a54 7970 6520 2270 6372 6532 6772 6570  .Type "pcre2grep
+000081f0: 202d 2d68 656c 7022 2066 6f72 206d 6f72   --help" for mor
+00008200: 6520 696e 666f 726d 6174 696f 6e20 616e  e information an
+00008210: 6420 7468 6520 6c6f 6e67 206f 7074 696f  d the long optio
+00008220: 6e73 2e0a 5243 3d32 0a2d 2d2d 2d2d 2d2d  ns..RC=2.-------
+00008230: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00008240: 2d2d 2d2d 2d20 5465 7374 2031 3530 202d  ----- Test 150 -
+00008250: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00008260: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a70 6372  ------------.pcr
+00008270: 6532 6772 6570 3a20 4661 696c 6564 2074  e2grep: Failed t
+00008280: 6f20 7365 7420 6c6f 6361 6c65 2062 6164  o set locale bad
+00008290: 6c6f 6361 6c65 2028 6f62 7461 696e 6564  locale (obtained
+000082a0: 2066 726f 6d20 4c43 5f43 5459 5045 290a   from LC_CTYPE).
+000082b0: 5243 3d32 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  RC=2.-----------
+000082c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000082d0: 2d20 5465 7374 2031 3531 202d 2d2d 2d2d  - Test 151 -----
+000082e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000082f0: 2d2d 2d2d 2d2d 2d2d 0a1b 5b31 3b33 316d  --------..[1;31m
+00008300: 5468 651b 5b30 6d20 7175 6963 6b20 6272  The.[0m quick br
+00008310: 6f77 6e0a 1b5b 313b 3331 6d54 6865 2077  own..[1;31mThe w
+00008320: 6f1b 5b30 6d72 6420 6973 2063 6174 2069  o.[0mrd is cat i
+00008330: 6e20 1b5b 313b 3331 6d74 6869 731b 5b30  n .[1;31mthis.[0
+00008340: 6d20 6c69 6e65 0a1b 5b31 3b33 316d 5468  m line..[1;31mTh
+00008350: 651b 5b30 6d20 6361 7465 7270 696c 6c61  e.[0m caterpilla
+00008360: 7220 7361 7420 6f6e 2074 6865 206d 6174  r sat on the mat
+00008370: 0a1b 5b31 3b33 316d 5468 651b 5b30 6d20  ..[1;31mThe.[0m 
+00008380: 736e 6f77 6361 7420 6973 206e 6f74 2061  snowcat is not a
+00008390: 6e20 616e 696d 616c 0a                   n animal.
```

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/grepoutput8` & `pcre2-0.2.0/src/libpcre2/testdata/grepoutput8`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/grepoutputC` & `pcre2-0.2.0/src/libpcre2/testdata/grepoutputC`

 * *Files 9% similar despite different names*

```diff
@@ -1,42 +1,60 @@
 Arg1: [T] [he ] [ ] Arg2: |T| () () (0)
-Arg1: [T] [his] [s] Arg2: |T| () () (0)
-Arg1: [T] [his] [s] Arg2: |T| () () (0)
-Arg1: [T] [he ] [ ] Arg2: |T| () () (0)
-Arg1: [T] [he ] [ ] Arg2: |T| () () (0)
-Arg1: [T] [he ] [ ] Arg2: |T| () () (0)
 The quick brown
+Arg1: [T] [his] [s] Arg2: |T| () () (0)
 This time it jumps and jumps and jumps.
+Arg1: [T] [his] [s] Arg2: |T| () () (0)
 This line contains \E and (regex) *meta* [characters].
+Arg1: [T] [he ] [ ] Arg2: |T| () () (0)
 The word is cat in this line
+Arg1: [T] [he ] [ ] Arg2: |T| () () (0)
 The caterpillar sat on the mat
+Arg1: [T] [he ] [ ] Arg2: |T| () () (0)
 The snowcat is not an animal
 Arg1: [qu] [qu]
+The quick brown
 Arg1: [ t] [ t]
+This time it jumps and jumps and jumps.
 Arg1: [ l] [ l]
+This line contains \E and (regex) *meta* [characters].
 Arg1: [wo] [wo]
+The word is cat in this line
 Arg1: [ca] [ca]
+The caterpillar sat on the mat
 Arg1: [sn] [sn]
+The snowcat is not an animal
+0:T
 The quick brown
+0:T
 This time it jumps and jumps and jumps.
+0:T
 This line contains \E and (regex) *meta* [characters].
+0:T
 The word is cat in this line
+0:T
 The caterpillar sat on the mat
+0:T
 The snowcat is not an animal
 0:T
+
 The quick brown
 0:T
+
 This time it jumps and jumps and jumps.
 0:T
+
 This line contains \E and (regex) *meta* [characters].
 0:T
+
 The word is cat in this line
 0:T
+
 The caterpillar sat on the mat
 0:T
+
 The snowcat is not an animal
 T
 T
 T
 T
 T
 T
```

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/grepoutputCN` & `pcre2-0.2.0/src/libpcre2/testdata/grepoutputCN`

 * *Files 2% similar despite different names*

```diff
@@ -18,14 +18,20 @@
 This line contains \E and (regex) *meta* [characters].
 0:T
 The word is cat in this line
 0:T
 The caterpillar sat on the mat
 0:T
 The snowcat is not an animal
+The quick brown
+This time it jumps and jumps and jumps.
+This line contains \E and (regex) *meta* [characters].
+The word is cat in this line
+The caterpillar sat on the mat
+The snowcat is not an animal
 T
 T
 T
 T
 T
 T
 0:T:AA
```

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testbtables` & `pcre2-0.2.0/src/libpcre2/testdata/testbtables`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput1` & `pcre2-0.2.0/src/libpcre2/testdata/testinput1`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput10` & `pcre2-0.2.0/src/libpcre2/testdata/testinput10`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput11` & `pcre2-0.2.0/src/libpcre2/testdata/testinput11`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput12` & `pcre2-0.2.0/src/libpcre2/testdata/testinput12`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput14` & `pcre2-0.2.0/src/libpcre2/testdata/testinput14`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput15` & `pcre2-0.2.0/src/libpcre2/testdata/testinput15`

 * *Files 6% similar despite different names*

```diff
@@ -2,46 +2,52 @@
 #
 # (1) Tests of the match-limiting features. The results are different for
 # interpretive or JIT matching, so this test should not be run with JIT. The
 # same tests are run using JIT in test 17.
 
 # (2) Other tests that must not be run with JIT.
 
+# This test is first so that it doesn't inherit a large enough heap frame 
+# vector from a previous test.
+
+/(*LIMIT_HEAP=21)\[(a)]{60}/expand
+    \[a]{60}
+
 /(a+)*zz/I
-  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaazzbbbbbb\=find_limits
-  aaaaaaaaaaaaaz\=find_limits
+  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaazzbbbbbb\=find_limits_noheap
+  aaaaaaaaaaaaaz\=find_limits_noheap
 
 !((?:\s|//.*\\n|/[*](?:\\n|.)*?[*]/)*)!I
-   /* this is a C style comment */\=find_limits
+   /* this is a C style comment */\=find_limits_noheap
 
 /^(?>a)++/
-    aa\=find_limits
-    aaaaaaaaa\=find_limits
+    aa\=find_limits_noheap
+    aaaaaaaaa\=find_limits_noheap
 
 /(a)(?1)++/
-    aa\=find_limits
-    aaaaaaaaa\=find_limits
+    aa\=find_limits_noheap
+    aaaaaaaaa\=find_limits_noheap
 
 /a(?:.)*?a/ims
-    abbbbbbbbbbbbbbbbbbbbba\=find_limits
+    abbbbbbbbbbbbbbbbbbbbba\=find_limits_noheap
 
 /a(?:.(*THEN))*?a/ims
-    abbbbbbbbbbbbbbbbbbbbba\=find_limits
+    abbbbbbbbbbbbbbbbbbbbba\=find_limits_noheap
 
 /a(?:.(*THEN:ABC))*?a/ims
-    abbbbbbbbbbbbbbbbbbbbba\=find_limits
+    abbbbbbbbbbbbbbbbbbbbba\=find_limits_noheap
 
 /^(?>a+)(?>b+)(?>c+)(?>d+)(?>e+)/
-     aabbccddee\=find_limits
+     aabbccddee\=find_limits_noheap
 
 /^(?>(a+))(?>(b+))(?>(c+))(?>(d+))(?>(e+))/
-     aabbccddee\=find_limits
+     aabbccddee\=find_limits_noheap
 
 /^(?>(a+))(?>b+)(?>(c+))(?>d+)(?>(e+))/
-     aabbccddee\=find_limits
+     aabbccddee\=find_limits_noheap
 
 /(*LIMIT_MATCH=12bc)abc/
 
 /(*LIMIT_MATCH=4294967290)abc/
 
 /(*LIMIT_DEPTH=4294967280)abc/I
 
@@ -224,15 +230,12 @@
     abc\=callout_fail=1
 
 # This test breaks the JIT stack limit
 
 /(|]+){2,2452}/
     (|]+){2,2452}
 
-/(*LIMIT_HEAP=21)\[(a)]{60}/expand
-    \[a]{60}
-
 /b(?<!ax)(?!cx)/allusedtext
     abc
     abcz
 
 # End of testinput15
```

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput17` & `pcre2-0.2.0/src/libpcre2/testdata/testinput17`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput18` & `pcre2-0.2.0/src/libpcre2/testdata/testinput18`

 * *Files 4% similar despite different names*

```diff
@@ -135,9 +135,13 @@
     123ace
     123ace\=posix_startend=2:6
 
 //posix
 \= Expect errors
     \=null_subject
     abc\=null_subject
+    
+/(*LIMIT_HEAP=0)xx/posix
+\= Expect error
+    xxxx 
 
 # End of testdata/testinput18
```

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput2` & `pcre2-0.2.0/src/libpcre2/testdata/testinput2`

 * *Files 0% similar despite different names*

```diff
@@ -6394,9 +6394,16 @@
 00018f90: 6163 653d 5b32 305d 0a20 2020 203e 5858  ace=[20].    >XX
 00018fa0: 3c5c 3d6e 756c 6c5f 7265 706c 6163 656d  <\=null_replacem
 00018fb0: 656e 740a 0a23 202d 2d2d 2d2d 2d2d 2d2d  ent..# ---------
 00018fc0: 200a 0a2f 5b41 615d 7b32 7d2f 4249 0a20   ../[Aa]{2}/BI. 
 00018fd0: 2020 2061 6162 6364 0a0a 2f41 7b32 7d2f     aabcd../A{2}/
 00018fe0: 6942 490a 2020 2020 6161 6263 640a 0a2f  iBI.    aabcd../
 00018ff0: 5b41 615d 7b32 2c33 7d2f 4249 0a20 2020  [Aa]{2,3}/BI.   
-00019000: 2061 6162 6364 0a0a 2320 456e 6420 6f66   aabcd..# End of
-00019010: 2074 6573 7469 6e70 7574 320a             testinput2.
+00019000: 2061 6162 6364 0a0a 2d2d 0a20 2020 205c   aabcd..--.    \
+00019010: 5b58 5d7b 2d31 307d 0a20 2020 200a 2320  [X]{-10}.    .# 
+00019020: 4368 6563 6b20 696d 706f 7369 7469 6f6e  Check imposition
+00019030: 206f 6620 6d61 7869 6d75 6d20 6279 206d   of maximum by m
+00019040: 6174 6368 5f64 6174 615f 6372 6561 7465  atch_data_create
+00019050: 2829 2e0a 0a2f 6162 6364 2f0a 2020 2020  ().../abcd/.    
+00019060: 6162 6364 5c3d 6f76 6563 746f 723d 3635  abcd\=ovector=65
+00019070: 3533 360a 0a23 2045 6e64 206f 6620 7465  536..# End of te
+00019080: 7374 696e 7075 7432 0a                   stinput2.
```

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput20` & `pcre2-0.2.0/src/libpcre2/testdata/testinput20`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput22` & `pcre2-0.2.0/src/libpcre2/testdata/testinput22`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput24` & `pcre2-0.2.0/src/libpcre2/testdata/testinput24`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput25` & `pcre2-0.2.0/src/libpcre2/testdata/testinput25`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput26` & `pcre2-0.2.0/src/libpcre2/testdata/testinput26`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput3` & `pcre2-0.2.0/src/libpcre2/testdata/testinput3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput4` & `pcre2-0.2.0/src/libpcre2/testdata/testinput4`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput5` & `pcre2-0.2.0/src/libpcre2/testdata/testinput5`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput6` & `pcre2-0.2.0/src/libpcre2/testdata/testinput6`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput7` & `pcre2-0.2.0/src/libpcre2/testdata/testinput7`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput8` & `pcre2-0.2.0/src/libpcre2/testdata/testinput8`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinput9` & `pcre2-0.2.0/src/libpcre2/testdata/testinput9`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testinputEBC` & `pcre2-0.2.0/src/libpcre2/testdata/testinputEBC`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput1` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput1`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput10` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput10`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput11-16` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput11-16`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput11-32` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput11-32`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput12-16` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput12-16`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput12-32` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput12-32`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput14-16` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput14-16`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput14-32` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput14-32`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput14-8` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput14-8`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput15` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput15`

 * *Files 10% similar despite different names*

```diff
@@ -2,111 +2,105 @@
 #
 # (1) Tests of the match-limiting features. The results are different for
 # interpretive or JIT matching, so this test should not be run with JIT. The
 # same tests are run using JIT in test 17.
 
 # (2) Other tests that must not be run with JIT.
 
+# This test is first so that it doesn't inherit a large enough heap frame 
+# vector from a previous test.
+
+/(*LIMIT_HEAP=21)\[(a)]{60}/expand
+    \[a]{60}
+Failed: error -63: heap limit exceeded
+
 /(a+)*zz/I
 Capture group count = 1
 Starting code units: a z 
 Last code unit = 'z'
 Subject length lower bound = 2
-  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaazzbbbbbb\=find_limits
-Minimum heap limit = 0
+  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaazzbbbbbb\=find_limits_noheap
 Minimum match limit = 7
 Minimum depth limit = 7
  0: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaazz
  1: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
-  aaaaaaaaaaaaaz\=find_limits
-Minimum heap limit = 0
+  aaaaaaaaaaaaaz\=find_limits_noheap
 Minimum match limit = 20481
 Minimum depth limit = 30
 No match
 
 !((?:\s|//.*\\n|/[*](?:\\n|.)*?[*]/)*)!I
 Capture group count = 1
 May match empty string
 Subject length lower bound = 0
-   /* this is a C style comment */\=find_limits
-Minimum heap limit = 0
+   /* this is a C style comment */\=find_limits_noheap
 Minimum match limit = 64
 Minimum depth limit = 7
  0: /* this is a C style comment */
  1: /* this is a C style comment */
 
 /^(?>a)++/
-    aa\=find_limits
-Minimum heap limit = 0
+    aa\=find_limits_noheap
 Minimum match limit = 5
 Minimum depth limit = 3
  0: aa
-    aaaaaaaaa\=find_limits
-Minimum heap limit = 0
+    aaaaaaaaa\=find_limits_noheap
 Minimum match limit = 12
 Minimum depth limit = 3
  0: aaaaaaaaa
 
 /(a)(?1)++/
-    aa\=find_limits
-Minimum heap limit = 0
+    aa\=find_limits_noheap
 Minimum match limit = 7
 Minimum depth limit = 5
  0: aa
  1: a
-    aaaaaaaaa\=find_limits
-Minimum heap limit = 0
+    aaaaaaaaa\=find_limits_noheap
 Minimum match limit = 21
 Minimum depth limit = 5
  0: aaaaaaaaa
  1: a
 
 /a(?:.)*?a/ims
-    abbbbbbbbbbbbbbbbbbbbba\=find_limits
-Minimum heap limit = 0
+    abbbbbbbbbbbbbbbbbbbbba\=find_limits_noheap
 Minimum match limit = 24
 Minimum depth limit = 3
  0: abbbbbbbbbbbbbbbbbbbbba
 
 /a(?:.(*THEN))*?a/ims
-    abbbbbbbbbbbbbbbbbbbbba\=find_limits
-Minimum heap limit = 0
+    abbbbbbbbbbbbbbbbbbbbba\=find_limits_noheap
 Minimum match limit = 66
 Minimum depth limit = 45
  0: abbbbbbbbbbbbbbbbbbbbba
 
 /a(?:.(*THEN:ABC))*?a/ims
-    abbbbbbbbbbbbbbbbbbbbba\=find_limits
-Minimum heap limit = 0
+    abbbbbbbbbbbbbbbbbbbbba\=find_limits_noheap
 Minimum match limit = 66
 Minimum depth limit = 45
  0: abbbbbbbbbbbbbbbbbbbbba
 
 /^(?>a+)(?>b+)(?>c+)(?>d+)(?>e+)/
-     aabbccddee\=find_limits
-Minimum heap limit = 0
+     aabbccddee\=find_limits_noheap
 Minimum match limit = 7
 Minimum depth limit = 7
  0: aabbccddee
 
 /^(?>(a+))(?>(b+))(?>(c+))(?>(d+))(?>(e+))/
-     aabbccddee\=find_limits
-Minimum heap limit = 0
+     aabbccddee\=find_limits_noheap
 Minimum match limit = 12
 Minimum depth limit = 12
  0: aabbccddee
  1: aa
  2: bb
  3: cc
  4: dd
  5: ee
 
 /^(?>(a+))(?>b+)(?>(c+))(?>d+)(?>(e+))/
-     aabbccddee\=find_limits
-Minimum heap limit = 0
+     aabbccddee\=find_limits_noheap
 Minimum match limit = 10
 Minimum depth limit = 10
  0: aabbccddee
  1: aa
  2: cc
  3: ee
 
@@ -517,18 +511,14 @@
 # This test breaks the JIT stack limit
 
 /(|]+){2,2452}/
     (|]+){2,2452}
  0: 
  1: 
 
-/(*LIMIT_HEAP=21)\[(a)]{60}/expand
-    \[a]{60}
-Failed: error -63: heap limit exceeded
-
 /b(?<!ax)(?!cx)/allusedtext
     abc
  0: abc
     < >
     abcz
  0: abcz
     < >>
```

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput17` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput17`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput18` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput18`

 * *Files 3% similar despite different names*

```diff
@@ -217,9 +217,14 @@
 
 //posix
 \= Expect errors
     \=null_subject
 No match: POSIX code 16: bad argument
     abc\=null_subject
 No match: POSIX code 16: bad argument
+    
+/(*LIMIT_HEAP=0)xx/posix
+\= Expect error
+    xxxx 
+No match: POSIX code 14: failed to get memory
 
 # End of testdata/testinput18
```

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput19` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput19`

 * *Files 19% similar despite different names*

```diff
@@ -1,25 +1,30 @@
 # This set of tests is run only with the 8-bit library. It tests the POSIX
 # interface with UTF/UCP support, which is supported only with the 8-bit
 # library. This test should not be run with JIT (which is not available for the
 # POSIX interface).
-    
+
 #pattern posix
 
 /a\x{1234}b/utf
     a\x{1234}b
  0: a\x{1234}b
 
 /\w/
 \= Expect no match
     +++\x{c2}
 No match: POSIX code 17: match failed
 
 /\w/ucp
     +++\x{c2}
  0: \xc2
-    
+
 /"^AB" 00 "\x{1234}$"/hex,utf
-    AB\x{00}\x{1234}\=posix_startend=0:6 
+    AB\x{00}\x{1234}\=posix_startend=0:6
  0: AB\x{00}\x{1234}
-    
+
+/\w/utf
+\= Expect UTF error
+    A\xabB
+No match: POSIX code 16: bad argument
+
 # End of testdata/testinput19
```

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput2` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput2`

 * *Files 0% similar despite different names*

```diff
@@ -23338,32 +23338,42 @@
 0005b290: 6e74 203d 2030 0a46 6972 7374 2063 6f64  nt = 0.First cod
 0005b2a0: 6520 756e 6974 203d 2027 4127 2028 6361  e unit = 'A' (ca
 0005b2b0: 7365 6c65 7373 290a 4c61 7374 2063 6f64  seless).Last cod
 0005b2c0: 6520 756e 6974 203d 2027 4127 2028 6361  e unit = 'A' (ca
 0005b2d0: 7365 6c65 7373 290a 5375 626a 6563 7420  seless).Subject 
 0005b2e0: 6c65 6e67 7468 206c 6f77 6572 2062 6f75  length lower bou
 0005b2f0: 6e64 203d 2032 0a20 2020 2061 6162 6364  nd = 2.    aabcd
-0005b300: 0a20 303a 2061 610a 0a23 2045 6e64 206f  . 0: aa..# End o
-0005b310: 6620 7465 7374 696e 7075 7432 0a45 7272  f testinput2.Err
-0005b320: 6f72 202d 3730 3a20 5043 5245 325f 4552  or -70: PCRE2_ER
-0005b330: 524f 525f 4241 4444 4154 4120 2875 6e6b  ROR_BADDATA (unk
-0005b340: 6e6f 776e 2065 7272 6f72 206e 756d 6265  nown error numbe
-0005b350: 7229 0a45 7272 6f72 202d 3632 3a20 6261  r).Error -62: ba
-0005b360: 6420 7365 7269 616c 697a 6564 2064 6174  d serialized dat
-0005b370: 610a 4572 726f 7220 2d32 3a20 7061 7274  a.Error -2: part
-0005b380: 6961 6c20 6d61 7463 680a 4572 726f 7220  ial match.Error 
-0005b390: 2d31 3a20 6e6f 206d 6174 6368 0a45 7272  -1: no match.Err
-0005b3a0: 6f72 2030 3a20 5043 5245 325f 4552 524f  or 0: PCRE2_ERRO
-0005b3b0: 525f 4241 4444 4154 4120 2875 6e6b 6e6f  R_BADDATA (unkno
-0005b3c0: 776e 2065 7272 6f72 206e 756d 6265 7229  wn error number)
-0005b3d0: 0a45 7272 6f72 2031 3030 3a20 6e6f 2065  .Error 100: no e
-0005b3e0: 7272 6f72 0a45 7272 6f72 2031 3031 3a20  rror.Error 101: 
-0005b3f0: 5c20 6174 2065 6e64 206f 6620 7061 7474  \ at end of patt
-0005b400: 6572 6e0a 4572 726f 7220 3139 313a 2050  ern.Error 191: P
-0005b410: 4352 4532 5f45 5854 5241 5f41 4c4c 4f57  CRE2_EXTRA_ALLOW
-0005b420: 5f53 5552 524f 4741 5445 5f45 5343 4150  _SURROGATE_ESCAP
-0005b430: 4553 2069 7320 6e6f 7420 616c 6c6f 7765  ES is not allowe
-0005b440: 6420 696e 2055 5446 2d31 3620 6d6f 6465  d in UTF-16 mode
-0005b450: 0a45 7272 6f72 2032 3030 3a20 5043 5245  .Error 200: PCRE
-0005b460: 325f 4552 524f 525f 4241 4444 4154 4120  2_ERROR_BADDATA 
-0005b470: 2875 6e6b 6e6f 776e 2065 7272 6f72 206e  (unknown error n
-0005b480: 756d 6265 7229 0a                        umber).
+0005b300: 0a20 303a 2061 610a 0a2d 2d0a 2020 2020  . 0: aa..--.    
+0005b310: 5c5b 585d 7b2d 3130 7d0a 2a2a 205a 6572  \[X]{-10}.** Zer
+0005b320: 6f20 6f72 206e 6567 6174 6976 6520 7265  o or negative re
+0005b330: 7065 6174 206e 6f74 2061 6c6c 6f77 6564  peat not allowed
+0005b340: 0a20 2020 200a 2320 4368 6563 6b20 696d  .    .# Check im
+0005b350: 706f 7369 7469 6f6e 206f 6620 6d61 7869  position of maxi
+0005b360: 6d75 6d20 6279 206d 6174 6368 5f64 6174  mum by match_dat
+0005b370: 615f 6372 6561 7465 2829 2e0a 0a2f 6162  a_create().../ab
+0005b380: 6364 2f0a 2020 2020 6162 6364 5c3d 6f76  cd/.    abcd\=ov
+0005b390: 6563 746f 723d 3635 3533 360a 2030 3a20  ector=65536. 0: 
+0005b3a0: 6162 6364 0a0a 2320 456e 6420 6f66 2074  abcd..# End of t
+0005b3b0: 6573 7469 6e70 7574 320a 4572 726f 7220  estinput2.Error 
+0005b3c0: 2d37 303a 2050 4352 4532 5f45 5252 4f52  -70: PCRE2_ERROR
+0005b3d0: 5f42 4144 4441 5441 2028 756e 6b6e 6f77  _BADDATA (unknow
+0005b3e0: 6e20 6572 726f 7220 6e75 6d62 6572 290a  n error number).
+0005b3f0: 4572 726f 7220 2d36 323a 2062 6164 2073  Error -62: bad s
+0005b400: 6572 6961 6c69 7a65 6420 6461 7461 0a45  erialized data.E
+0005b410: 7272 6f72 202d 323a 2070 6172 7469 616c  rror -2: partial
+0005b420: 206d 6174 6368 0a45 7272 6f72 202d 313a   match.Error -1:
+0005b430: 206e 6f20 6d61 7463 680a 4572 726f 7220   no match.Error 
+0005b440: 303a 2050 4352 4532 5f45 5252 4f52 5f42  0: PCRE2_ERROR_B
+0005b450: 4144 4441 5441 2028 756e 6b6e 6f77 6e20  ADDATA (unknown 
+0005b460: 6572 726f 7220 6e75 6d62 6572 290a 4572  error number).Er
+0005b470: 726f 7220 3130 303a 206e 6f20 6572 726f  ror 100: no erro
+0005b480: 720a 4572 726f 7220 3130 313a 205c 2061  r.Error 101: \ a
+0005b490: 7420 656e 6420 6f66 2070 6174 7465 726e  t end of pattern
+0005b4a0: 0a45 7272 6f72 2031 3931 3a20 5043 5245  .Error 191: PCRE
+0005b4b0: 325f 4558 5452 415f 414c 4c4f 575f 5355  2_EXTRA_ALLOW_SU
+0005b4c0: 5252 4f47 4154 455f 4553 4341 5045 5320  RROGATE_ESCAPES 
+0005b4d0: 6973 206e 6f74 2061 6c6c 6f77 6564 2069  is not allowed i
+0005b4e0: 6e20 5554 462d 3136 206d 6f64 650a 4572  n UTF-16 mode.Er
+0005b4f0: 726f 7220 3230 303a 2050 4352 4532 5f45  ror 200: PCRE2_E
+0005b500: 5252 4f52 5f42 4144 4441 5441 2028 756e  RROR_BADDATA (un
+0005b510: 6b6e 6f77 6e20 6572 726f 7220 6e75 6d62  known error numb
+0005b520: 6572 290a                                er).
```

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput20` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput20`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput21` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput21`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput22-16` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput22-16`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput22-32` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput22-32`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput22-8` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput22-8`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput24` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput24`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput25` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput25`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput26` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput26`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput3` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput3A` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput3A`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput3B` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput3B`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput4` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput4`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput5` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput5`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput6` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput6`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput7` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput7`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput8-16-2` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput8-16-2`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput8-16-3` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput8-16-3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput8-16-4` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput8-16-4`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput8-32-2` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput8-32-2`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput8-32-3` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput8-32-3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput8-32-4` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput8-32-4`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput8-8-2` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput8-8-2`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput8-8-3` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput8-8-3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput8-8-4` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput8-8-4`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutput9` & `pcre2-0.2.0/src/libpcre2/testdata/testoutput9`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/testoutputEBC` & `pcre2-0.2.0/src/libpcre2/testdata/testoutputEBC`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/wintestinput3` & `pcre2-0.2.0/src/libpcre2/testdata/wintestinput3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/libpcre2/testdata/wintestoutput3` & `pcre2-0.2.0/src/libpcre2/testdata/wintestoutput3`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/pcre2/CMakeLists.txt` & `pcre2-0.2.0/src/pcre2/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/pcre2/consts.pyx` & `pcre2-0.2.0/src/pcre2/consts.pyx`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/pcre2/exceptions.pyx` & `pcre2-0.2.0/src/pcre2/exceptions.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -27,15 +27,15 @@
             raise LibraryError(
                 get_error_message_rc,
                 context_msg=f"Could not retrieve message for error code {get_error_message_rc}."
             )
 
         msg = errormsg_buf.decode("utf-8").capitalize()
         if context_msg:
-            msg = msg + ". " + context_msg
+            msg = context_msg + ". " + msg
 
         super().__init__(msg)
         self.errorcode = errorcode
 
 
 class CompileError(LibraryError):
     """ Raised when pattern is malformed or is otherwise unable to be
```

### Comparing `pcre2-0.1.0/src/pcre2/libpcre2.pxd` & `pcre2-0.2.0/src/pcre2/libpcre2.pxd`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/pcre2/match.pxd` & `pcre2-0.2.0/src/pcre2/match.pxd`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/pcre2/match.pyx` & `pcre2-0.2.0/src/pcre2/match.pyx`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/pcre2/methods.pyx` & `pcre2-0.2.0/src/pcre2/methods.pyx`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/pcre2/pattern.pxd` & `pcre2-0.2.0/src/pcre2/pattern.pxd`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/pcre2/pattern.pyx` & `pcre2-0.2.0/src/pcre2/pattern.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -170,14 +170,20 @@
     @property
     def jit_size(self):
         """ If the compiled pattern was successfully JIT compiled, return the
         size of the JIT compiled code, otherwise return zero.
         """
         return Pattern._info_size(self._code, PCRE2_INFO_JITSIZE)
 
+    @property
+    def min_length(self):
+        """ Returns the minimum number of characters of matching subject strings.
+        """
+        return Pattern._info_uint(self._code, PCRE2_INFO_MINLENGTH)
+
     
     @property
     def name_count(self):
         """ Returns the number of named capture groups.
         """
         return Pattern._info_uint(self._code, PCRE2_INFO_NAMECOUNT)
```

### Comparing `pcre2-0.1.0/src/pcre2/scanner.pxd` & `pcre2-0.2.0/src/pcre2/scanner.pxd`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/pcre2/scanner.pyx` & `pcre2-0.2.0/src/pcre2/scanner.pyx`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/pcre2/utils.pyx` & `pcre2-0.2.0/src/pcre2/utils.pyx`

 * *Files identical despite different names*

### Comparing `pcre2-0.1.0/src/pcre2.egg-info/PKG-INFO` & `pcre2-0.2.0/src/pcre2.egg-info/PKG-INFO`

 * *Files 19% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pcre2
-Version: 0.1.0
+Version: 0.2.0
 Summary: Python bindings for the PCRE2 regular expression library
 Home-page: https://github.com/grtetrault/pcre2.py
 Author: Garrett Tetrault
 License: BSD 3-Clause License
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: BSD License
@@ -22,52 +22,57 @@
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 # PCRE2.py: Python bindings for the PCRE2 regular expression library
 
 This project contains Python bindings for [PCRE2](https://github.com/PCRE2Project/pcre2).
 PCRE2 is the revised API for the Perl-compatible regular expressions (PCRE) library created by Philip Hazel.
-For source code, see the [official PCRE2 repository](https://github.com/PCRE2Project/pcre2).
+For original source code, see the [official PCRE2 repository](https://github.com/PCRE2Project/pcre2).
 
 ## Installation
 
 From PyPI:
 ```
 pip install pcre2
 ```
 
-If a wheel is not available for your platform, the source for PCRE2 is downloaded over HTTP from [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases/) and built. Building requires:
+If a wheel is not available for your platform, the module will be built from source.
+Building requires:
 
-* `autoconf`
+* `cmake`
 * C compiler toolchain, such as `gcc` and `make`
 * `libtool`
 * Python headers
 
 ## Usage
 
 Regular expressions are compiled with `pcre2.compile()` which accepts both unicode strings and bytes-like objects.
 This returns a `Pattern` object.
 Expressions can be compiled with a number of options (combined with the bitwise-or operator) and can be JIT compiled,
 
 ```python
 >>> import pcre2
 >>> expr = r'(?<head>\w+)\s+(?<tail>\w+)'
 >>> patn = pcre2.compile(expr, options=pcre2.I, jit=True)
->>> patn.jit_compile()  # Patterns can also be JIT compiled after initialization.
+>>> # Patterns can also be JIT compiled after initialization.
+>>> patn.jit_compile()
 ```
 
 Inspection of `Pattern` objects is done as follows,
 
 ```python
 >>> patn.jit_size
 980
 >>> patn.name_dict()
 {1: 'head', 2: 'tail'}
 >>> patn.options
 524296
+>>> # Deeper inspection into options is available.
+>>> pcre2.CompileOption.decompose(patn.options)
+[<CompileOption.CASELESS: 0x8>, <CompileOption.UTF: 0x80000>]
 ```
 
 Once compiled, `Pattern` objects can be used to match against strings.
 Matching return a `Match` object, which has several functions to view results,
 
 ```python
 >>> subj = 'foo bar buzz bazz'
@@ -86,31 +91,44 @@
 'bar foo buzz bazz'
 >>> patn.substitute(repl, subj, options=pcre2.G) # Global substitutions are also supported.
 'bar foo bazz buzz'
 >>> match.expand(repl)
 'bar foo buzz bazz'
 ```
 
-Additionally, `Pattern` objects support for scanning over subjects for all non-overlapping matches,
+Additionally, `Pattern` objects support scanning over subjects for all non-overlapping matches,
 
 ```python
 >>> for match in patn.scan(subj):
 ...     print(match.substring('head'))
 ...
 foo
 buzz
 ```
 
 ## Performance
 
-PCRE2 provides aa fast regular expression library, particularly with JIT compilation enabled.
+PCRE2 provides a fast regular expression library, particularly with JIT compilation enabled.
 Below are the `regex-redux` benchmark results included in this repository,
 
 | Script              | Number of runs | Total time | Real time  | User time   | System time   |
 | ------------------- | -------------- | ---------- | ---------- | ----------- | ------------- |
-| `vanilla.py `       |             10 |     51.470 |      5.147 |      11.409 |         0.533 |
-| `hand_optimized.py` |             10 |     12.310 |      1.231 |       2.484 |         0.212 |
-| `pcre2_module.py`   |             10 |     14.040 |      1.404 |       2.309 |         0.548 |
+| `baseline.py`       |             10 |      3.020 |      0.302 |       0.020 |         0.086 |
+| `vanilla.py`        |             10 |     51.380 |      5.138 |      11.408 |         0.529 |
+| `hand_optimized.py` |             10 |     13.190 |      1.319 |       2.846 |         0.344 |
+| `pcre2_module.py`   |             10 |     13.670 |      1.367 |       2.269 |         0.532 |
  
+Script descriptions are as follows,
+
+| Script              | Description                                                          |
+| ------------------- | -------------------------------------------------------------------- |
+| `baseline.py`       | Reads input file and outputs stored expected output                  |
+| `vanilla.py`        | Pure Python version                                                  |
+| `hand_optimized.py` | Manually written Python `ctypes` bindings for shared PCRE2 C library |
+| `pcre2_module.py`   | Implementation using Python bindings written here                    |
+
 Tests were performed on an M2 Macbook Air.
+Note that to run benchmarks locally, [Git LFS](https://git-lfs.com/) must be installed to download the input dataset.
+Additionally, a Python virtual environment must be created, and the package built
+with `make init` and `make build` respectively.
 For more information on this benchmark, see [The Computer Language Benchmarks Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/regexredux.html).
 See source code of benchmark scripts for details and original sources.
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: pcre2 Version: 0.1.0 Summary: Python bindings for
+Metadata-Version: 2.1 Name: pcre2 Version: 0.2.0 Summary: Python bindings for
 the PCRE2 regular expression library Home-page: https://github.com/grtetrault/
 pcre2.py Author: Garrett Tetrault License: BSD 3-Clause License Classifier:
 Development Status :: 3 - Alpha Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: BSD License Classifier: Programming
 Language :: C Classifier: Programming Language :: Cython Classifier:
 Programming Language :: Python :: 3.6 Classifier: Programming Language ::
 Python :: 3.7 Classifier: Programming Language :: Python :: 3.8 Classifier:
@@ -10,43 +10,55 @@
 Python :: 3.10 Classifier: Programming Language :: Python :: 3.11 Classifier:
 Operating System :: MacOS :: MacOS X Classifier: Operating System :: POSIX ::
 Linux Classifier: Operating System :: Microsoft :: Windows Description-Content-
 Type: text/markdown License-File: LICENSE # PCRE2.py: Python bindings for the
 PCRE2 regular expression library This project contains Python bindings for
 [PCRE2](https://github.com/PCRE2Project/pcre2). PCRE2 is the revised API for
 the Perl-compatible regular expressions (PCRE) library created by Philip Hazel.
-For source code, see the [official PCRE2 repository](https://github.com/
-PCRE2Project/pcre2). ## Installation From PyPI: ``` pip install pcre2 ``` If a
-wheel is not available for your platform, the source for PCRE2 is downloaded
-over HTTP from [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases/
-) and built. Building requires: * `autoconf` * C compiler toolchain, such as
+For original source code, see the [official PCRE2 repository](https://
+github.com/PCRE2Project/pcre2). ## Installation From PyPI: ``` pip install
+pcre2 ``` If a wheel is not available for your platform, the module will be
+built from source. Building requires: * `cmake` * C compiler toolchain, such as
 `gcc` and `make` * `libtool` * Python headers ## Usage Regular expressions are
 compiled with `pcre2.compile()` which accepts both unicode strings and bytes-
 like objects. This returns a `Pattern` object. Expressions can be compiled with
 a number of options (combined with the bitwise-or operator) and can be JIT
 compiled, ```python >>> import pcre2 >>> expr = r'(?
-\w+)\s+(?\w+)' >>> patn = pcre2.compile(expr, options=pcre2.I, jit=True) >>>
-patn.jit_compile() # Patterns can also be JIT compiled after initialization.
+\w+)\s+(?\w+)' >>> patn = pcre2.compile(expr, options=pcre2.I, jit=True) >>> #
+Patterns can also be JIT compiled after initialization. >>> patn.jit_compile()
 ``` Inspection of `Pattern` objects is done as follows, ```python >>>
 patn.jit_size 980 >>> patn.name_dict() {1: 'head', 2: 'tail'} >>> patn.options
-524296 ``` Once compiled, `Pattern` objects can be used to match against
-strings. Matching return a `Match` object, which has several functions to view
-results, ```python >>> subj = 'foo bar buzz bazz' >>> match = patn.match(subj)
->>> match.substring() 'foo bar' >>> match.start(), match.end() (8, 17) ```
-Substitution is also supported, both from `Pattern` and `Match` objects,
-```python >>> repl = '$2 $1' >>> patn.substitute(repl, subj) 'bar foo buzz
-bazz' >>> patn.substitute(repl, subj, options=pcre2.G) # Global substitutions
-are also supported. 'bar foo bazz buzz' >>> match.expand(repl) 'bar foo buzz
-bazz' ``` Additionally, `Pattern` objects support for scanning over subjects
-for all non-overlapping matches, ```python >>> for match in patn.scan(subj):
-... print(match.substring('head')) ... foo buzz ``` ## Performance PCRE2
-provides aa fast regular expression library, particularly with JIT compilation
-enabled. Below are the `regex-redux` benchmark results included in this
-repository, | Script | Number of runs | Total time | Real time | User time |
-System time | | ------------------- | -------------- | ---------- | ---------
-- | ----------- | ------------- | | `vanilla.py ` | 10 | 51.470 | 5.147 |
-11.409 | 0.533 | | `hand_optimized.py` | 10 | 12.310 | 1.231 | 2.484 | 0.212 |
-| `pcre2_module.py` | 10 | 14.040 | 1.404 | 2.309 | 0.548 | Tests were
-performed on an M2 Macbook Air. For more information on this benchmark, see
-[The Computer Language Benchmarks Game](https://benchmarksgame-
-team.pages.debian.net/benchmarksgame/performance/regexredux.html). See source
-code of benchmark scripts for details and original sources.
+524296 >>> # Deeper inspection into options is available. >>>
+pcre2.CompileOption.decompose(patn.options) [
+CASELESS: 0x8>,
+UTF: 0x80000>] ``` Once compiled, `Pattern` objects can be used to match
+against strings. Matching return a `Match` object, which has several functions
+to view results, ```python >>> subj = 'foo bar buzz bazz' >>> match =
+patn.match(subj) >>> match.substring() 'foo bar' >>> match.start(), match.end()
+(8, 17) ``` Substitution is also supported, both from `Pattern` and `Match`
+objects, ```python >>> repl = '$2 $1' >>> patn.substitute(repl, subj) 'bar foo
+buzz bazz' >>> patn.substitute(repl, subj, options=pcre2.G) # Global
+substitutions are also supported. 'bar foo bazz buzz' >>> match.expand(repl)
+'bar foo buzz bazz' ``` Additionally, `Pattern` objects support scanning over
+subjects for all non-overlapping matches, ```python >>> for match in patn.scan
+(subj): ... print(match.substring('head')) ... foo buzz ``` ## Performance
+PCRE2 provides a fast regular expression library, particularly with JIT
+compilation enabled. Below are the `regex-redux` benchmark results included in
+this repository, | Script | Number of runs | Total time | Real time | User time
+| System time | | ------------------- | -------------- | ---------- | ---------
+- | ----------- | ------------- | | `baseline.py` | 10 | 3.020 | 0.302 | 0.020
+| 0.086 | | `vanilla.py` | 10 | 51.380 | 5.138 | 11.408 | 0.529 | |
+`hand_optimized.py` | 10 | 13.190 | 1.319 | 2.846 | 0.344 | | `pcre2_module.py`
+| 10 | 13.670 | 1.367 | 2.269 | 0.532 | Script descriptions are as follows, |
+Script | Description | | ------------------- | --------------------------------
+------------------------------------ | | `baseline.py` | Reads input file and
+outputs stored expected output | | `vanilla.py` | Pure Python version | |
+`hand_optimized.py` | Manually written Python `ctypes` bindings for shared
+PCRE2 C library | | `pcre2_module.py` | Implementation using Python bindings
+written here | Tests were performed on an M2 Macbook Air. Note that to run
+benchmarks locally, [Git LFS](https://git-lfs.com/) must be installed to
+download the input dataset. Additionally, a Python virtual environment must be
+created, and the package built with `make init` and `make build` respectively.
+For more information on this benchmark, see [The Computer Language Benchmarks
+Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/
+regexredux.html). See source code of benchmark scripts for details and original
+sources.
```

### Comparing `pcre2-0.1.0/src/pcre2.egg-info/SOURCES.txt` & `pcre2-0.2.0/src/pcre2.egg-info/SOURCES.txt`

 * *Files 11% similar despite different names*

```diff
@@ -2,48 +2,56 @@
 LICENSE
 Makefile
 README.md
 pyproject.toml
 setup.py
 requirements/build-requirements.txt
 requirements/test-requirements.txt
+src/libpcre2/.bazelrc
 src/libpcre2/.git
 src/libpcre2/.gitignore
 src/libpcre2/132html
 src/libpcre2/AUTHORS
+src/libpcre2/BUILD.bazel
 src/libpcre2/CMakeLists.txt
 src/libpcre2/COPYING
 src/libpcre2/ChangeLog
 src/libpcre2/CheckMan
 src/libpcre2/CleanTxt
 src/libpcre2/Detrail
 src/libpcre2/HACKING
 src/libpcre2/LICENCE
+src/libpcre2/MODULE.bazel
 src/libpcre2/Makefile.am
 src/libpcre2/NEWS
 src/libpcre2/NON-AUTOTOOLS-BUILD
 src/libpcre2/PrepareRelease
 src/libpcre2/README
 src/libpcre2/README.md
 src/libpcre2/RunGrepTest
 src/libpcre2/RunGrepTest.bat
 src/libpcre2/RunTest
 src/libpcre2/RunTest.bat
+src/libpcre2/WORKSPACE.bazel
 src/libpcre2/autogen.sh
 src/libpcre2/config-cmake.h.in
 src/libpcre2/configure.ac
 src/libpcre2/index.md
 src/libpcre2/libpcre2-16.pc.in
 src/libpcre2/libpcre2-32.pc.in
 src/libpcre2/libpcre2-8.pc.in
 src/libpcre2/libpcre2-posix.pc.in
 src/libpcre2/pcre2-config.in
 src/libpcre2/pcre2_fuzzer.dict
 src/libpcre2/pcre2_fuzzer.options
 src/libpcre2/perltest.sh
+src/libpcre2/.github/workflows/build.yml
+src/libpcre2/.github/workflows/cifuzz.yml
+src/libpcre2/.github/workflows/codeql.yml
+src/libpcre2/.github/workflows/scorecards.yml
 src/libpcre2/cmake/COPYING-CMAKE-SCRIPTS
 src/libpcre2/cmake/FindEditline.cmake
 src/libpcre2/cmake/FindPackageHandleStandardArgs.cmake
 src/libpcre2/cmake/FindReadline.cmake
 src/libpcre2/cmake/pcre2-config-version.cmake.in
 src/libpcre2/cmake/pcre2-config.cmake.in
 src/libpcre2/doc/index.html.src
@@ -314,14 +322,15 @@
 src/libpcre2/src/pcre2_ucptables.c
 src/libpcre2/src/pcre2_valid_utf.c
 src/libpcre2/src/pcre2_xclass.c
 src/libpcre2/src/pcre2demo.c
 src/libpcre2/src/pcre2grep.c
 src/libpcre2/src/pcre2posix.c
 src/libpcre2/src/pcre2posix.h
+src/libpcre2/src/pcre2posix_test.c
 src/libpcre2/src/pcre2test.c
 src/libpcre2/src/sljit/sljitConfig.h
 src/libpcre2/src/sljit/sljitConfigInternal.h
 src/libpcre2/src/sljit/sljitExecAllocator.c
 src/libpcre2/src/sljit/sljitLir.c
 src/libpcre2/src/sljit/sljitLir.h
 src/libpcre2/src/sljit/sljitNativeARM_32.c
@@ -329,37 +338,46 @@
 src/libpcre2/src/sljit/sljitNativeARM_T2_32.c
 src/libpcre2/src/sljit/sljitNativeMIPS_32.c
 src/libpcre2/src/sljit/sljitNativeMIPS_64.c
 src/libpcre2/src/sljit/sljitNativeMIPS_common.c
 src/libpcre2/src/sljit/sljitNativePPC_32.c
 src/libpcre2/src/sljit/sljitNativePPC_64.c
 src/libpcre2/src/sljit/sljitNativePPC_common.c
+src/libpcre2/src/sljit/sljitNativeRISCV_32.c
+src/libpcre2/src/sljit/sljitNativeRISCV_64.c
+src/libpcre2/src/sljit/sljitNativeRISCV_common.c
 src/libpcre2/src/sljit/sljitNativeS390X.c
-src/libpcre2/src/sljit/sljitNativeSPARC_32.c
-src/libpcre2/src/sljit/sljitNativeSPARC_common.c
 src/libpcre2/src/sljit/sljitNativeX86_32.c
 src/libpcre2/src/sljit/sljitNativeX86_64.c
 src/libpcre2/src/sljit/sljitNativeX86_common.c
 src/libpcre2/src/sljit/sljitProtExecAllocator.c
 src/libpcre2/src/sljit/sljitUtils.c
 src/libpcre2/src/sljit/sljitWXExecAllocator.c
 src/libpcre2/testdata/grepbinary
 src/libpcre2/testdata/grepfilelist
 src/libpcre2/testdata/grepinput
 src/libpcre2/testdata/grepinput3
 src/libpcre2/testdata/grepinput8
+src/libpcre2/testdata/grepinputC.bz2
+src/libpcre2/testdata/grepinputC.gz
 src/libpcre2/testdata/grepinputM
 src/libpcre2/testdata/grepinputv
 src/libpcre2/testdata/grepinputx
 src/libpcre2/testdata/greplist
+src/libpcre2/testdata/grepnot.bz2
 src/libpcre2/testdata/grepoutput
 src/libpcre2/testdata/grepoutput8
 src/libpcre2/testdata/grepoutputC
 src/libpcre2/testdata/grepoutputCN
+src/libpcre2/testdata/grepoutputCNU
+src/libpcre2/testdata/grepoutputCU
+src/libpcre2/testdata/grepoutputCbz2
+src/libpcre2/testdata/grepoutputCgz
 src/libpcre2/testdata/grepoutputN
+src/libpcre2/testdata/grepoutputUN
 src/libpcre2/testdata/greppatN4
 src/libpcre2/testdata/testbtables
 src/libpcre2/testdata/testinput1
 src/libpcre2/testdata/testinput10
 src/libpcre2/testdata/testinput11
 src/libpcre2/testdata/testinput12
 src/libpcre2/testdata/testinput13
@@ -381,14 +399,15 @@
 src/libpcre2/testdata/testinput4
 src/libpcre2/testdata/testinput5
 src/libpcre2/testdata/testinput6
 src/libpcre2/testdata/testinput7
 src/libpcre2/testdata/testinput8
 src/libpcre2/testdata/testinput9
 src/libpcre2/testdata/testinputEBC
+src/libpcre2/testdata/testinputheap
 src/libpcre2/testdata/testoutput1
 src/libpcre2/testdata/testoutput10
 src/libpcre2/testdata/testoutput11-16
 src/libpcre2/testdata/testoutput11-32
 src/libpcre2/testdata/testoutput12-16
 src/libpcre2/testdata/testoutput12-32
 src/libpcre2/testdata/testoutput13
@@ -424,14 +443,17 @@
 src/libpcre2/testdata/testoutput8-32-3
 src/libpcre2/testdata/testoutput8-32-4
 src/libpcre2/testdata/testoutput8-8-2
 src/libpcre2/testdata/testoutput8-8-3
 src/libpcre2/testdata/testoutput8-8-4
 src/libpcre2/testdata/testoutput9
 src/libpcre2/testdata/testoutputEBC
+src/libpcre2/testdata/testoutputheap-16
+src/libpcre2/testdata/testoutputheap-32
+src/libpcre2/testdata/testoutputheap-8
 src/libpcre2/testdata/valgrind-jit.supp
 src/libpcre2/testdata/wintestinput3
 src/libpcre2/testdata/wintestoutput3
 src/pcre2/CMakeLists.txt
 src/pcre2/__init__.py
 src/pcre2/consts.pxd
 src/pcre2/consts.pyx
@@ -447,8 +469,10 @@
 src/pcre2/scanner.pxd
 src/pcre2/scanner.pyx
 src/pcre2/utils.pxd
 src/pcre2/utils.pyx
 src/pcre2.egg-info/PKG-INFO
 src/pcre2.egg-info/SOURCES.txt
 src/pcre2.egg-info/dependency_links.txt
-src/pcre2.egg-info/top_level.txt
+src/pcre2.egg-info/top_level.txt
+tests/test_match.py
+tests/test_pattern.py
```

