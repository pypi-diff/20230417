# Comparing `tmp/Metadata_Magic-0.3.2-py3-none-any.whl.zip` & `tmp/Metadata_Magic-0.4.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,42 @@
-Zip file size: 67325 bytes, number of entries: 40
--rw-rw-r--  2.0 unx       23 b- defN 23-Feb-07 03:13 metadata_magic/__init__.py
--rw-rw-r--  2.0 unx       23 b- defN 23-Feb-07 03:13 metadata_magic/main/__init__.py
--rw-rw-r--  2.0 unx     2997 b- defN 23-Feb-07 03:13 metadata_magic/main/meta_finder.py
--rw-rw-r--  2.0 unx    11588 b- defN 23-Mar-02 23:00 metadata_magic/main/meta_reader.py
--rw-rw-r--  2.0 unx       23 b- defN 23-Feb-07 03:13 metadata_magic/main/comic_archive/__init__.py
--rw-rw-r--  2.0 unx    15253 b- defN 23-Mar-02 23:00 metadata_magic/main/comic_archive/comic_archive.py
--rw-rw-r--  2.0 unx    10964 b- defN 23-Mar-02 23:00 metadata_magic/main/comic_archive/comic_xml.py
--rw-rw-r--  2.0 unx     8011 b- defN 23-Mar-02 23:00 metadata_magic/main/comic_archive/series_info.py
--rw-rw-r--  2.0 unx       23 b- defN 23-Mar-02 23:00 metadata_magic/main/epub/__init__.py
--rw-rw-r--  2.0 unx    21962 b- defN 23-Mar-18 21:14 metadata_magic/main/epub/epub.py
--rw-rw-r--  2.0 unx       23 b- defN 23-Feb-07 03:13 metadata_magic/main/error_finding/__init__.py
--rw-rw-r--  2.0 unx     2115 b- defN 23-Feb-07 03:13 metadata_magic/main/error_finding/missing_media.py
--rw-rw-r--  2.0 unx     2137 b- defN 23-Feb-07 03:13 metadata_magic/main/error_finding/missing_metadata.py
--rw-rw-r--  2.0 unx       23 b- defN 23-Feb-07 03:13 metadata_magic/main/rename/__init__.py
--rw-rw-r--  2.0 unx     2632 b- defN 23-Feb-07 03:13 metadata_magic/main/rename/rename_jsons.py
--rw-rw-r--  2.0 unx     3198 b- defN 23-Feb-07 03:13 metadata_magic/main/rename/rename_tools.py
--rw-rw-r--  2.0 unx     7793 b- defN 23-Mar-02 23:00 metadata_magic/main/rename/sort_rename.py
--rw-rw-r--  2.0 unx       23 b- defN 23-Feb-07 03:13 metadata_magic/test/__init__.py
--rw-rw-r--  2.0 unx     1468 b- defN 23-Mar-02 23:00 metadata_magic/test/temp_file_tools.py
--rw-rw-r--  2.0 unx     4245 b- defN 23-Feb-07 03:13 metadata_magic/test/test_meta_finder.py
--rw-rw-r--  2.0 unx    22279 b- defN 23-Mar-02 23:00 metadata_magic/test/test_meta_reader.py
--rw-rw-r--  2.0 unx       23 b- defN 23-Feb-07 03:13 metadata_magic/test/comic_archive/__init__.py
--rw-rw-r--  2.0 unx    16978 b- defN 23-Mar-02 23:00 metadata_magic/test/comic_archive/test_comic_archive.py
--rw-rw-r--  2.0 unx    19772 b- defN 23-Mar-02 23:00 metadata_magic/test/comic_archive/test_comic_xml.py
--rw-rw-r--  2.0 unx     8856 b- defN 23-Mar-02 23:00 metadata_magic/test/comic_archive/test_series_info.py
--rw-rw-r--  2.0 unx       23 b- defN 23-Mar-02 23:00 metadata_magic/test/epub/__init__.py
--rw-rw-r--  2.0 unx    26206 b- defN 23-Mar-18 21:14 metadata_magic/test/epub/test_epub.py
--rw-rw-r--  2.0 unx       23 b- defN 23-Feb-07 03:13 metadata_magic/test/error_finding/__init__.py
--rw-rw-r--  2.0 unx     1545 b- defN 23-Feb-07 03:13 metadata_magic/test/error_finding/test_missing_media.py
--rw-rw-r--  2.0 unx     1587 b- defN 23-Feb-07 03:13 metadata_magic/test/error_finding/test_missing_metadata.py
--rw-rw-r--  2.0 unx       23 b- defN 23-Feb-07 03:13 metadata_magic/test/rename/__init__.py
--rw-rw-r--  2.0 unx     2553 b- defN 23-Feb-07 03:13 metadata_magic/test/rename/test_rename_jsons.py
--rw-rw-r--  2.0 unx     4581 b- defN 23-Feb-07 03:13 metadata_magic/test/rename/test_rename_tools.py
--rw-rw-r--  2.0 unx    10127 b- defN 23-Mar-02 23:00 metadata_magic/test/rename/test_sort_rename.py
--rw-rw-r--  2.0 unx    35149 b- defN 23-Mar-29 16:57 Metadata_Magic-0.3.2.dist-info/LICENSE
--rw-rw-r--  2.0 unx     5758 b- defN 23-Mar-29 16:57 Metadata_Magic-0.3.2.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Mar-29 16:57 Metadata_Magic-0.3.2.dist-info/WHEEL
--rw-rw-r--  2.0 unx      476 b- defN 23-Mar-29 16:57 Metadata_Magic-0.3.2.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       15 b- defN 23-Mar-29 16:57 Metadata_Magic-0.3.2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3903 b- defN 23-Mar-29 16:57 Metadata_Magic-0.3.2.dist-info/RECORD
-40 files, 254493 bytes uncompressed, 60875 bytes compressed:  76.1%
+Zip file size: 70574 bytes, number of entries: 40
+-rw-r--r--  2.0 unx       23 b- defN 23-Apr-17 16:48 metadata_magic/__init__.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Apr-17 16:48 metadata_magic/main/__init__.py
+-rw-r--r--  2.0 unx     2997 b- defN 23-Apr-17 16:48 metadata_magic/main/meta_finder.py
+-rw-r--r--  2.0 unx    11588 b- defN 23-Apr-17 16:48 metadata_magic/main/meta_reader.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Apr-17 16:48 metadata_magic/main/comic_archive/__init__.py
+-rw-r--r--  2.0 unx    15253 b- defN 23-Apr-17 16:48 metadata_magic/main/comic_archive/comic_archive.py
+-rw-r--r--  2.0 unx    10964 b- defN 23-Apr-17 16:48 metadata_magic/main/comic_archive/comic_xml.py
+-rw-r--r--  2.0 unx     8011 b- defN 23-Apr-17 16:48 metadata_magic/main/comic_archive/series_info.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Apr-17 16:48 metadata_magic/main/epub/__init__.py
+-rw-r--r--  2.0 unx    32390 b- defN 23-Apr-17 17:00 metadata_magic/main/epub/epub.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Apr-17 16:48 metadata_magic/main/error_finding/__init__.py
+-rw-r--r--  2.0 unx     2115 b- defN 23-Apr-17 16:48 metadata_magic/main/error_finding/missing_media.py
+-rw-r--r--  2.0 unx     2137 b- defN 23-Apr-17 16:48 metadata_magic/main/error_finding/missing_metadata.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Apr-17 16:48 metadata_magic/main/rename/__init__.py
+-rw-r--r--  2.0 unx     2632 b- defN 23-Apr-17 16:48 metadata_magic/main/rename/rename_jsons.py
+-rw-r--r--  2.0 unx     3198 b- defN 23-Apr-17 16:48 metadata_magic/main/rename/rename_tools.py
+-rw-r--r--  2.0 unx     7793 b- defN 23-Apr-17 16:48 metadata_magic/main/rename/sort_rename.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Apr-17 16:48 metadata_magic/test/__init__.py
+-rw-r--r--  2.0 unx     1468 b- defN 23-Apr-17 16:48 metadata_magic/test/temp_file_tools.py
+-rw-r--r--  2.0 unx     4245 b- defN 23-Apr-17 16:48 metadata_magic/test/test_meta_finder.py
+-rw-r--r--  2.0 unx    22279 b- defN 23-Apr-17 16:48 metadata_magic/test/test_meta_reader.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Apr-17 16:48 metadata_magic/test/comic_archive/__init__.py
+-rw-r--r--  2.0 unx    16978 b- defN 23-Apr-17 16:48 metadata_magic/test/comic_archive/test_comic_archive.py
+-rw-r--r--  2.0 unx    19772 b- defN 23-Apr-17 16:48 metadata_magic/test/comic_archive/test_comic_xml.py
+-rw-r--r--  2.0 unx     8856 b- defN 23-Apr-17 16:48 metadata_magic/test/comic_archive/test_series_info.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Apr-17 16:48 metadata_magic/test/epub/__init__.py
+-rw-r--r--  2.0 unx    40512 b- defN 23-Apr-17 17:00 metadata_magic/test/epub/test_epub.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Apr-17 16:48 metadata_magic/test/error_finding/__init__.py
+-rw-r--r--  2.0 unx     1545 b- defN 23-Apr-17 16:48 metadata_magic/test/error_finding/test_missing_media.py
+-rw-r--r--  2.0 unx     1587 b- defN 23-Apr-17 16:48 metadata_magic/test/error_finding/test_missing_metadata.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Apr-17 16:48 metadata_magic/test/rename/__init__.py
+-rw-r--r--  2.0 unx     2553 b- defN 23-Apr-17 16:48 metadata_magic/test/rename/test_rename_jsons.py
+-rw-r--r--  2.0 unx     4581 b- defN 23-Apr-17 16:48 metadata_magic/test/rename/test_rename_tools.py
+-rw-r--r--  2.0 unx    10127 b- defN 23-Apr-17 16:48 metadata_magic/test/rename/test_sort_rename.py
+-rw-r--r--  2.0 unx    35149 b- defN 23-Apr-17 17:14 Metadata_Magic-0.4.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     5734 b- defN 23-Apr-17 17:14 Metadata_Magic-0.4.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-17 17:14 Metadata_Magic-0.4.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx      476 b- defN 23-Apr-17 17:14 Metadata_Magic-0.4.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       15 b- defN 23-Apr-17 17:14 Metadata_Magic-0.4.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3903 b- defN 23-Apr-17 17:14 Metadata_Magic-0.4.1.dist-info/RECORD
+40 files, 279203 bytes uncompressed, 64124 bytes compressed:  77.0%
```

## zipnote {}

```diff
@@ -96,26 +96,26 @@
 
 Filename: metadata_magic/test/rename/test_rename_tools.py
 Comment: 
 
 Filename: metadata_magic/test/rename/test_sort_rename.py
 Comment: 
 
-Filename: Metadata_Magic-0.3.2.dist-info/LICENSE
+Filename: Metadata_Magic-0.4.1.dist-info/LICENSE
 Comment: 
 
-Filename: Metadata_Magic-0.3.2.dist-info/METADATA
+Filename: Metadata_Magic-0.4.1.dist-info/METADATA
 Comment: 
 
-Filename: Metadata_Magic-0.3.2.dist-info/WHEEL
+Filename: Metadata_Magic-0.4.1.dist-info/WHEEL
 Comment: 
 
-Filename: Metadata_Magic-0.3.2.dist-info/entry_points.txt
+Filename: Metadata_Magic-0.4.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: Metadata_Magic-0.3.2.dist-info/top_level.txt
+Filename: Metadata_Magic-0.4.1.dist-info/top_level.txt
 Comment: 
 
-Filename: Metadata_Magic-0.3.2.dist-info/RECORD
+Filename: Metadata_Magic-0.4.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## metadata_magic/main/epub/epub.py

```diff
@@ -1,68 +1,31 @@
 #!/usr/bin/env python3
 
 from argparse import ArgumentParser
-from ebooklib.epub import EpubBook, EpubHtml, EpubItem, EpubNav, EpubNcx, Link, Section, write_epub
 from html_string_tools.main.html_string_tools import get_extension, regex_replace
 from metadata_magic.main.comic_archive.comic_archive import create_cbz
 from metadata_magic.main.comic_archive.comic_archive import get_temp_dir
 from metadata_magic.main.comic_archive.comic_xml import generate_info_from_jsons
 from metadata_magic.main.rename.sort_rename import sort_alphanum
 from metadata_magic.test.temp_file_tools import create_text_file
 from metadata_magic.test.temp_file_tools import read_text_file
 from os import getcwd, listdir, mkdir
-from os.path import abspath, basename, exists, join
+from os.path import abspath, basename, exists, isdir, join, relpath
 from PIL import Image, UnidentifiedImageError
 from python_print_tools.main.python_print_tools import color_print
 from re import sub as resub
 from re import findall
 from shutil import copy
+from tqdm import tqdm
 from typing import List
 from xml.etree.ElementTree import indent as xml_indent
 from xml.etree.ElementTree import Element, SubElement
 from xml.etree.ElementTree import fromstring as xml_from_string
 from xml.etree.ElementTree import tostring as xml_to_string
-
-class DvkEpubHtml(EpubHtml):
-    def __init__(self, uid=None, file_name='', media_type='', content=None, title='',
-                 lang=None, direction=None, media_overlay=None, media_duration=None):
-        super().__init__(uid, file_name, media_type, content, title,
-                 lang, direction, media_overlay, media_duration)
-        self.metas = []
-    
-    def get_content(self, default=None):
-        # Get the default content
-        original_xml = super().get_content(default).decode("UTF-8")
-        original_xml = resub("\\s*<\\?xml[^>]*>\\s*", "", original_xml)
-        original_xml = resub("\\s*<!DOCTYPE[^>]*>\\s*", "", original_xml)
-        original_xml = resub("\\s*<html[^>]*>", "<html>", original_xml)
-        # Parse xml
-        base = xml_from_string(original_xml)
-        attributes = {"xmlns":"http://www.w3.org/1999/xhtml"}
-        attributes["xmlns:epub"] = "http://www.idpf.org/2007/ops"
-        attributes["epub:prefix"] = "z3998: http://www.daisy.org/z3998/2012/vocab/structure/#"
-        attributes["lang"] = "en"
-        attributes["xml:lang"] = "en"
-        base.attrib = attributes
-        # Add meta tags
-        myhead = base.find("head")
-        for meta in self.metas:
-            meta_el = SubElement(myhead, "meta")
-            meta_el.attrib = meta
-        # Return the xml
-        xml_indent(base, space="   ")
-        xml = xml_to_string(base).decode("UTF-8")
-        xml = f"<?xml version='1.0' encoding='utf-8'?>\n<!DOCTYPE html>\n{xml}"
-        return xml.encode("UTF-8")
-
-    def add_meta(self, **kwgs):
-        self.metas.append(kwgs)
-
-    def get_metas(self):
-        return (meta for meta in self.metas)
+from zipfile import ZipFile, ZIP_DEFLATED, ZIP_STORED
 
 def newline_to_tag(lines:str) -> str:
     """
     Returns a string with number of <br/> tags equal to length of lines.
     <br/> tags are represented as "{{{br}}}" to be replaced in final XHTML.
     
     :param lines: String of new line characters
@@ -74,25 +37,64 @@
     for i in range(0, len(lines)):
         tags = tags + "{{{br}}}"
     return tags
 
 def get_title_from_file(file:str) -> str:
     """
     Gets an id/title for a file from the filename.
-
     :param file: File path or file name
     :type file: str, required
     :return: ID/title
     :rtype: str
     """
     regex = "^\\s*\\[[^\\]]+\\]\\s*|\\s*\\.[^\\.]{1,5}$"
     title = resub(regex, "", basename(file))
     return title
 
-def create_image_page(image_file) -> str:
+def format_xhtml(html:str, title:str, head_tags:List[dict]=[], indent:bool=True) -> str:
+    """
+    Creates text for an epub XHTML content file with given html string in the body
+    
+    :param html: String in HTML format
+    :type html: str, required
+    :param title: Title to use in the XHTML head
+    :type title: str, required
+    :param indent: Whether to add indents to the XHTML file, defaults to True
+    :type indent: bool, optional
+    :return: XHTML text
+    :rtype: str
+    """
+    # Set the base element for the XHTML 
+    base = Element("html")
+    base.attrib = {"xmlns":"http://www.w3.org/1999/xhtml"}
+    # Create the head subelement
+    head = SubElement(base, "head")
+    title_element = SubElement(head, "title")
+    title_element.text = title
+    meta = SubElement(head, "meta")
+    meta.attrib = {"charset":"utf-8"}
+    # Add given elements to head
+    for head_tag in head_tags:
+        head_element = SubElement(head, head_tag["type"])
+        head_element.attrib = head_tag["params"]
+    # Add stylesheet to head
+    link = SubElement(head, "link")
+    link.attrib = {"rel":"stylesheet", "href":"../style/epubstyle.css", "type":"text/css"}
+    # Parse the given html text and add to body
+    final_html = resub("^\\s+|\\s+$|\\n", "", html)
+    body = xml_from_string(f"<body>{final_html}</body>")
+    base.append(body)
+    # Set indents to make the XML more readable
+    if indent:
+        xml_indent(base, space="   ")
+    # Get xml as string
+    xml = xml_to_string(base).decode("UTF-8")
+    return f"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n{xml}"
+
+def create_image_page(image_file, indent:bool=True) -> str:
     """
     Returns a epub formatted XHTML page containing a single full page image.
     
     :param image_file: Path to the image file to include on the page
     :type image_file: str, required
     :param indent: Whether to add indents to the XHTML file, defaults to True
     :type indent: bool, optional
@@ -102,61 +104,57 @@
     # Load image
     try:
         full_path = abspath(image_file)
         image = Image.open(full_path)
         width, height = image.size
     except (FileNotFoundError, UnidentifiedImageError): return None
     # Create image container
-    base = Element("body")
-    container = SubElement(base, "div")
+    container = Element("div")
     container.attrib = {"class":"image-page-container"}
     # Create the image element
     filename = basename(full_path)
     title = get_title_from_file(full_path)
     img_element = SubElement(container, "img")
     attributes = {"class":"vertical-image-page", "src":f"../images/{filename}", "alt":title}
     if width > height:
         attributes["class"] = "horizontal-image-page"
     img_element.attrib = attributes
-    xml = xml_to_string(base).decode("UTF-8")
-    # Create DvkEpubHtml
-    filename = filename[:len(filename) - len(get_extension(filename))]
-    chapter = DvkEpubHtml(title=title, file_name=f"content/{filename}.xhtml", lang='en')
-    chapter.set_content(xml)
-    chapter.add_link(href="../style/epubstyle.css", rel="stylesheet", type="text/css")
-    # Add size limiting meta tag
-    chapter.add_meta(content=f"width={width}, height={height}", name="viewport")
+    xml = xml_to_string(container).decode("UTF-8")
+    # Add size limited meta tag
+    tag = {"type":"meta"}
+    tag["params"] = {"content":f"width={width}, height={height}", "name":"viewport"}
     # Return EpubHtml
-    return chapter
+    return format_xhtml(xml, title, [tag], indent)
 
-def txt_to_xhtml(txt_file:str) -> str:
+def txt_to_xhtml(txt_file:str, indent:bool=True) -> str:
     """
     Creates text for an epub XHTML content file from a given txt file.
     
     :param txt_file: Path to a txt file.
     :type txt_file: str, required
+    :param indent: Whether to add indents to the XHTML file, defaults to True
+    :type indent: bool, optional
     :return: XHTML text
     :rtype: str
     """
     # Read text file
     full_path = abspath(txt_file)
     content = read_text_file(full_path)
     # Replace long string of newlines
     content = regex_replace(newline_to_tag, "\\n\\n\\n+", content)
     # Split by new lines
     paragraphs = content.split("\n\n")
     # Create paragraph elements
-    body = Element("body")
-    text_container = SubElement(body, "div")
+    text_container = Element("div")
     text_container.attrib = {"class":"text-container"}
     for paragraph in paragraphs:
         p_element = SubElement(text_container, "p")
         p_element.text = paragraph.replace("\n","{{{br}}}")
     # Get xml as string
-    xml = xml_to_string(body).decode("UTF-8")
+    xml = xml_to_string(text_container).decode("UTF-8")
     # Remove misformatted tags
     xml = xml.replace("{{{br}}}", "<br/>")
     xml = xml.replace("{{br}}", "<br/>")
     xml = xml.replace("{{i}}", "<i>")
     xml = xml.replace("{{/i}}", "</i>")
     xml = xml.replace("{{b}}", "<b>")
     xml = xml.replace("{{/b}}", "</b>")
@@ -165,27 +163,23 @@
     xml = resub("<\\/b>\\s+(?=[,.?!])", "</b>", xml)
     xml = resub("\\s+<\\/i>", "</i>", xml)
     xml = resub("\\s+<\\/b>", "</b>", xml)
     # Get the title for the file
     title = get_title_from_file(full_path)
     filename = basename(full_path)
     filename = filename[:len(filename) - len(get_extension(full_path))]
-    # Create EpubHtml
-    chapter = EpubHtml(title=title, file_name=f"content/{filename}.xhtml", lang='en')
-    chapter.set_content(xml)
-    chapter.add_link(href="../style/epubstyle.css", rel="stylesheet", type="text/css")
-    # Return the EpubHtml
-    return chapter
+    # Return XHTML
+    return format_xhtml(xml, title, indent=indent)
 
-def get_style() -> str:
+def create_style_file(file_path:str):
     """
     Creates the default css stylesheet for the epub book.
     
-    :return: CSS style sheet 
-    :rtype: str
+    :param file_path: Path to save the stylesheet to
+    :type file_path: str, required
     """
     # Body Style
     style = ""
     style = f"{style}body {{\n"
     style = f"{style}    margin: 0px 0px 0px 0px;\n"
     style = f"{style}}}\n\n"
     # Header style
@@ -223,70 +217,267 @@
     style = f"{style}    height: auto;\n"
     style = f"{style}    margin: auto auto auto auto;\n"
     style = f"{style}}}\n\n"
     # Image Page Container
     style = f"{style}.image-page-container {{\n"
     style = f"{style}    height: 100vh;\n"
     style = f"{style}}}"
-    # Return style
-    return style
+    # Create file
+    full_path = abspath(file_path)
+    create_text_file(full_path, style)
 
-def create_metadata(metadata:dict) -> EpubBook:
+def create_nav_file(xhtmls:List[str], file_path:str, title:str, indent:bool=True):
     """
-    Creates an EpubBook object with the given metadata.
-    Metadata is the same as used for the get_comic_xml function.
+    Creates the Table of Contents nav file for the epub file.
+    
+    :param xhtmls: List of XHTML files to include in the contents
+    :type xhtmls: str, required
+    :param file_path: Path of the file to save to
+    :type file_path: str, required
+    :param title: Title to use for the nav file
+    :type title: str, required
+    :param indent: Whether to add indents to the XML file, defaults to True
+    :type indent: bool, optional
+    """
+    # Create base of navigation file
+    attributes = {"xmlns":"http://www.w3.org/1999/xhtml"}
+    attributes["xmlns:epub"] = "http://www.idpf.org/2007/ops"
+    attributes["lang"] = "en"
+    attributes["xml:lang"] = "en"
+    base = Element("html")
+    base.attrib = attributes
+    # Create navigation head
+    head = SubElement(base, "head")
+    meta = SubElement(head, "meta")
+    meta.attrib = {"charset":"utf-8"}
+    title_element = SubElement(head, "title")
+    title_element.text = title
+    # Create navigation body and header
+    body = SubElement(base, "body")
+    h1 = SubElement(body, "h1")
+    h1.text = title
+    # Create nav element
+    nav = SubElement(body, "nav")
+    nav.attrib = {"epub:type":"toc", "id":"toc"}
+    ol = SubElement(nav, "ol")
+    # Create entries for each XHTML file
+    for xhtml in xhtmls:
+        # Get title
+        filename = basename(xhtml)
+        name = get_title_from_file(filename)
+        # Create list item
+        li = SubElement(ol, "li")
+        a = SubElement(li, "a")
+        a.text = name
+        a.attrib = {"href":f"content/{filename}"}
+    # Set indents to make the XML more readable
+    if indent:
+        xml_indent(base, space="   ")
+    # Get xml as string
+    xml = xml_to_string(base).decode("UTF-8")
+    xml = f"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n{xml}"
+    # Write XML
+    full_path = abspath(file_path)
+    create_text_file(full_path, xml)
+
+def create_ncx_file(xhtmls:List[str], file_path:str, title:str, uid:str, indent:bool=True):
+    """
+    Creates the Table of Contents ncx file for the epub file.
+    
+    :param xhtmls: List of XHTML files to include in the contents
+    :type xhtmls: str, required
+    :param file_path: Path of the file to save to
+    :type file_path: str, required
+    :param title: Title to use for the nav file
+    :type title: str, required
+    :param uid: ID to use for the contents file
+    :type uid: str, required
+    :param indent: Whether to add indents to the XML file, defaults to True
+    :type indent: bool, optional
+    """
+    # Create base of ncx file
+    attributes = {"xmlns":"http://www.daisy.org/z3986/2005/ncx/"}
+    attributes["version"] = "2005-1"
+    base = Element("ncx")
+    base.attrib = attributes
+    # Create ncx head
+    head = SubElement(base, "head")
+    uid_element = SubElement(head, "meta")
+    uid_element.attrib = {"content":uid, "name":"dtb:uid"}
+    depth = SubElement(head, "meta")
+    depth.attrib = {"content":"0", "name":"dtb:depth"}
+    pcount = SubElement(head, "meta")
+    pcount.attrib = {"content":"0", "name":"dtb:totalPageCount"}
+    number = SubElement(head, "meta")
+    number.attrib = {"content":"0", "name":"dtb:maxPageNumber"}
+    # Create title tag
+    title_element = SubElement(base, "docTitle")
+    title_text = SubElement(title_element, "text")
+    title_text.text = title
+    # Create nav map
+    nav_map = SubElement(base, "navMap")
+    for xhtml in xhtmls:
+        nav_point = SubElement(nav_map, "navPoint")
+        nav_point.attrib = {"id":get_title_from_file(xhtml) + "-xhtml"}
+        nav_label = SubElement(nav_point, "navLabel")
+        nav_text = SubElement(nav_label, "text")
+        nav_text.text = get_title_from_file(xhtml)
+        content = SubElement(nav_point, "content")
+        content.text = "content/" + str(basename(xhtml))
+    # Set indents to make the XML more readable
+    if indent:
+        xml_indent(base, space="   ")
+    # Get xml as string
+    xml = xml_to_string(base).decode("UTF-8")
+    xml = f"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n{xml}"
+    # Write XML
+    full_path = abspath(file_path)
+    create_text_file(full_path, xml)
+
+def create_manifest(files:List[str]) -> str:
+    """
+    Create the manifest section for the epub package file.
+    Uses all given files, and adds nav file by default.
+    
+    :param files: List of files to link in the manifest section
+    :type files: list[str], required
+    :return: Manifest section in xml format
+    :rtype: str
+    """
+    # Create the manifest base
+    base = Element("manifest")
+    # Add the nav file as item
+    nav_item = SubElement(base, "item")
+    nav_item.attrib = {"href":"nav.xhtml", "id":"toc", "media-type":"application/xhtml+xml", "properties":"nav"}
+    # Add files as items
+    for file in files:
+        filename = basename(file)
+        extension = get_extension(filename)
+        media_type = ""
+        # Get the file mimetype
+        if extension == ".xhtml":
+            media_type = "application/xhtml+xml"
+            attributes = {"href":f"content/{filename}"}
+        elif extension == ".jpeg" or extension == ".jpg":
+            media_type = "image/jpeg"
+            attributes = {"href":f"images/{filename}"}
+        elif extension == ".png":
+            media_type = "image/png"
+            attributes = {"href":f"images/{filename}"}
+        elif extension == ".svg":
+            media_type = "image/svg+xml"
+            attributes = {"href":f"images/{filename}"}
+        # Create item
+        attributes["id"] = get_title_from_file(filename) + "-" + extension[1:]
+        attributes["media-type"] = media_type
+        item = SubElement(base, "item")
+        item.attrib = attributes
+    # Add css file
+    css_item = SubElement(base, "item")
+    css_item.attrib = {"href":"style/epubstyle.css", "id":"epubstyle-css", "media-type":"text/css"}
+    # Get xml as string
+    xml = xml_to_string(base).decode("UTF-8")
+    return xml
 
-    :param metadata: Metadata dictionary
+def create_metadata_xml(metadata:dict) -> str:
+    """
+    Creates the metadata section for the epub package file based on given metadata.
+    
+    :param metadata: Metadata dict, same as given for cbz ComicInfo functions
     :type metadata: dict, required
-    :return: EpubBook object containing metadata
-    :rtype: EpubBook
+    :return: Metadata section in xml format
+    :rtype: str
     """
-    # Create book
-    book = EpubBook()
+    # Create the metadata base
+    base = Element("metadata")
+    base.attrib = {"xmlns:dc":"http://purl.org/dc/elements/1.1/"}
     # Set the language
-    book.set_language("en")
+    language = SubElement(base, "dc:language")
+    language.text = "en"
     # Set the identifier
+    identifier = SubElement(base, "dc:identifier")
     if metadata["url"] is not None:
-        book.set_identifier(metadata["url"])
+        identifier.text = metadata["url"]
     else:
-        book.set_identifier(metadata["title"].lower())
+        identifier.text = metadata["title"].lower()
     # Set the title
-    book.set_title(metadata["title"])
-    # Set the description
-    if metadata["description"] is not None:
-        book.add_metadata("DC", "description", metadata["description"])
-    # Add Authors
+    title = SubElement(base, "dc:title")
+    title.text = metadata["title"]
+    # Add author(s)
     try:
         authors = metadata["writer"].split(",")
     except AttributeError: authors = []
     for i in range(0, len(authors)):
-        book.add_author(authors[i], role="aut", uid=f"author{i}")
-    # Add Illustrator(s)
+        # Add creator tag
+        author_id = "author" + str(i+1)
+        creator = SubElement(base, "dc:creator")
+        creator.attrib = {"id":author_id}
+        creator.text = authors[i]
+        # Add role tag
+        role = SubElement(base, "meta")
+        role.attrib = {"refines":f"#{author_id}", "property":"role", "scheme":"marc:relators"}
+        role.text = "aut"
+    # Add illustrator(s)
     try:
         illustrators = metadata["artist"].split(",")
     except AttributeError: illustrators = []
     for i in range(0, len(illustrators)):
-        book.add_author(illustrators[i], role="ill", uid=f"illustrator{i}")
-    # Add Cover Artist(s)
+        # Add creator tag
+        illustrator_id = "illustrator" + str(i+1)
+        creator = SubElement(base, "dc:creator")
+        creator.attrib = {"id":illustrator_id}
+        creator.text = illustrators[i]
+        # Add role tag
+        role = SubElement(base, "meta")
+        role.attrib = {"refines":f"#{illustrator_id}", "property":"role", "scheme":"marc:relators"}
+        role.text = "ill"
+    # Add cover artist(s)
     try:
         covartists = metadata["cover_artist"].split(",")
     except AttributeError: covartists = []
     for i in range(0, len(covartists)):
-        book.add_author(covartists[i], role="cov", uid=f"covartist{i}")
-    # Add publisher
+        # Add creator tag
+        cover_id = "covartist" + str(i+1)
+        creator = SubElement(base, "dc:creator")
+        creator.attrib = {"id":cover_id}
+        creator.text = covartists[i]
+        # Add role tag
+        role = SubElement(base, "meta")
+        role.attrib = {"refines":f"#{cover_id}", "property":"role", "scheme":"marc:relators"}
+        role.text = "cov"
+    # Set the description
+    if metadata["description"] is not None:
+        description = SubElement(base, "dc:description")
+        description.text = metadata["description"]
+    # Set the publisher
     if metadata["publisher"] is not None:
-        book.add_metadata("DC", "publisher", metadata["publisher"])
-    # Add date
-    if metadata["date"] is not None:
-        book.add_metadata("DC", "date", metadata["date"] + "T00:00:00+00:00")
+        publisher = SubElement(base, "dc:publisher")
+        publisher.text = metadata["publisher"]
+    # Set the series info
+    if metadata["series"] is not None:
+        series_title = SubElement(base, "meta")
+        series_title.attrib = {"property":"belongs-to-collection", "id":"series-title"}
+        series_title.text = metadata["series"]
+        collection_type = SubElement(base, "meta")
+        collection_type.attrib = {"refines":"series-title", "property":"collection-type"}
+        collection_type.text = "series"
+        try:
+            num = float(metadata["series_number"])
+            series_number = SubElement(base, "meta")
+            series_number.attrib = {"refines":"series-title", "property":"group-position"}
+            series_number.text = metadata["series_number"]
+        except (TypeError, ValueError): pass
     # Set the score
+    tag_string = metadata["tags"]
     try:
         score = int(metadata["score"])
         if score > -1 and score < 6:
-            book.add_metadata(None, "meta", str(float(score * 2)), {"property":"calibre:rating"})
+            score_element = SubElement(base, "meta")
+            score_element.attrib = {"property":"calibre:rating"}
+            score_element.text = str(float(score * 2))
     except (TypeError, ValueError): pass
     # Set the tags
     tag_string = metadata["tags"]
     try:
         # Add score as star rating in tags
         score = int(metadata["score"])
         if score > 0 and score < 6:
@@ -298,131 +489,175 @@
             else:
                 tag_string = f"{stars},{tag_string}"
     except (TypeError, ValueError): pass
     try:
         tags = tag_string.split(",")
     except AttributeError: tags = []
     for tag in tags:
-        book.add_metadata("DC", "subject", tag)
-    # Add series info
-    if metadata["series"] is not None:
-        attribs = {"property":"belongs-to-collection", "id":"series-title"}
-        book.add_metadata(None, "meta", metadata["series"], attribs)
-        attribs = {"refines":"#series-title", "property":"collection-type"}
-        book.add_metadata(None, "meta", "series", attribs)
-        try:
-            num = float(metadata["series_number"])
-            attribs = {"refines":"#series-title", "property":"group-position"}
-            book.add_metadata(None, "meta", metadata["series_number"], attribs)
-        except (TypeError, ValueError): pass
-    # Return ebook with metadata
-    return book
+        subject = SubElement(base, "dc:subject")
+        subject.text = tag
+    # Set the date
+    date = "0000-00-00T00:00:00+00:00"
+    if metadata["date"] is not None:
+        date = metadata["date"] + "T00:00:00+00:00"
+    modified = SubElement(base, "meta")
+    modified.attrib = {"property":"dcterms:modified"}
+    modified.text = date
+    date_element = SubElement(base, "dc:date")
+    date_element.text = date
+    # Get xml as string
+    xml = xml_to_string(base).decode("UTF-8")
+    return xml
 
-def get_items(directory:str) -> List[EpubItem]:
+def create_epub_files(directory:str, metadata:dict):
     """
-    Creates a list of items to include in epub based on files in a given directory.
-
-    :param directory: Directory to search for files within
+    Creates the nav.xhtml and package.opf files required for an epub archive.
+    Saves files in the given directory.
+    Searches for files to include in spine and manifest from ./content directory within given directory.
+    
+    :param directory: Directory in which to save files
     :type directory: str, required
-    :return: List of EpubItems
-    :rtype: list[EpubItem]
+    :param metadata: Metadata to use when creating the file
+    :type metadata: dict, required
     """
-    # Get list of files in directory
+    # Get list of files in the content directory
     full_directory = abspath(directory)
-    files = sort_alphanum(listdir(full_directory))
-    # Run through files
-    items = []
-    for file in files:
-        # Read file
-        full_file = abspath(join(full_directory, file))
-        with open(full_file, "rb") as infile:
-            contents = infile.read()
-        # Create item
-        item = EpubItem(uid=basename(full_file).replace(".","-"),
-                    file_name="original/"+basename(full_file),
-                    content=contents)
-        # Copy image
-        if item.get_type() == 1:
-            title = get_title_from_file(full_file)
-            image = EpubItem(uid=title,
-                        file_name="images/"+basename(full_file),
-                        content=contents)
-            items.append(image)
-        items.append(item)
-    # Add style file
-    css = EpubItem(uid="epubstyle",
-                file_name="style/epubstyle.css",
-                media_type="text/css",
-                content=get_style())
-    items.append(css)
-    # Return items
-    return items
-
-def get_chapters(directory:str) -> List[EpubHtml]:
-    """
-    Returns a list of EpubHtml objects for each chapter of the epub.
-    Creates XHTML chapter files for each text file and image in a given directory.
+    content_dir = abspath(join(directory, "content"))
+    content_files = sort_alphanum(listdir(content_dir))
+    # Get list of files in the images directory
+    image_dir = abspath(join(directory, "images"))
+    image_files = sort_alphanum(listdir(image_dir))
+    # Get the manifest and metadata sections
+    files = []
+    files.extend(content_files)
+    files.extend(image_files)
+    manifest = create_manifest(files)
+    meta_xml = create_metadata_xml(metadata)
+    # Create nav file
+    nav_file = abspath(join(full_directory, "nav.xhtml"))
+    create_nav_file(content_files, nav_file, metadata["title"], True)
+    # Create ncx file
+    uid = metadata["url"]
+    if uid is None:
+        uid = metadata["title"]
+    ncx_file = abspath(join(full_directory, "toc.ncx"))
+    create_ncx_file(content_files, ncx_file, metadata["title"], uid, True)
+    # Create the content xml contents
+    base = Element("package")
+    base.attrib = {"xmlns":"http://www.idpf.org/2007/opf", "unique-identifier":"uid", "version":"3.0"}
+    base.append(xml_from_string(meta_xml))
+    base.append(xml_from_string(manifest))
+    spine = SubElement(base, "spine")
+    for file in content_files:
+        # Create spine items
+        itemref = SubElement(spine, "itemref")
+        itemref.attrib = {"idref":get_title_from_file(file) + "-xhtml"}
+    # Save content xml to file
+    xml_indent(base, space="   ")
+    xml = xml_to_string(base).decode("UTF-8")
+    xml = f"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n{xml}"
+    package_file = abspath(join(full_directory, "content.opf"))
+    create_text_file(package_file, xml)
 
-    :param directory: Directory to search for files within
-    :type directory: str, required
-    :return: List of EpubHtml objects for each chapter
-    :rtype: list[EpubHtml]
-    """
-    # Get list of files in directory
-    full_directory = abspath(directory)
-    files = sort_alphanum(listdir(full_directory))
-    # Run through files
-    chapters = []
-    for file in files:
-        # Get the XML body
-        xml = None
-        full_file = abspath(join(full_directory, file))
-        extension = get_extension(full_file)
-        if extension == ".txt":
-            chapter = txt_to_xhtml(full_file)
-            chapters.append(chapter)
-            continue
-        if extension == ".jpg" or extension == ".jpeg" or extension == ".png":
-            chapter = create_image_page(full_file)
-            if chapter is not None:
-                chapters.append(chapter)
-    # Return chapters
-    return chapters
+def zip_epub(directory:str, epub_file):
+    try:
+        # Get list of files in the directory
+        full_directory = abspath(directory)
+        files = listdir(full_directory)
+        for i in range(0, len(files)):
+            files[i] = abspath(join(full_directory, files[i]))
+        # Expand list of files to include subdirectories
+        for file in files:
+            if isdir(file):
+                sub_files = listdir(file)
+                for i in range(0, len(sub_files)):
+                    files.append(abspath(join(file, sub_files[i])))
+        # Create empty epub file
+        with ZipFile(epub_file, "w", compression=ZIP_DEFLATED, compresslevel=8) as out_file:
+            out_file.writestr('mimetype', 'application/epub+zip', compress_type=ZIP_STORED)
+        assert exists(epub_file)
+        # Write contents of directory to epub file
+        for file in tqdm(files):
+            relative = relpath(file, full_directory)
+            with ZipFile(epub_file, "a", compression=ZIP_DEFLATED, compresslevel=8) as out_file:
+                if not isdir(file):
+                    out_file.write(file, relative, compress_type=ZIP_DEFLATED, compresslevel=8)
+        # Return the path of the written epub archive
+        return epub_file
+    except FileNotFoundError:
+        return None
 
 def create_epub(directory:str, metadata:dict) -> str:
     """
     Creates an epub archive from the text and images in a given directory.
     
     :param directory: Directory in which to pull text and images
     :type directory: str, required
     :param metadata: Metadata to use for the epub file
     :type metadata: dict, required
     :return: Path to the newly created epub file
     :rtype: str
     """
     # Get the path of the epub file to create
-    full_directory = abspath(directory)
-    epub_file = abspath(join(full_directory, basename(full_directory) + ".epub"))
-    # Get book from metadata
-    book = create_metadata(metadata)
-    # Get XHTMLs and base content    
-    chapters = get_chapters(full_directory)
-    items = get_items(full_directory)
-    # Add items to the book
-    for chapter in chapters:
-        book.add_item(chapter)
-    for item in items:
-        book.add_item(item)
-    # Add spine and table of contents
-    book.spine = chapters
-    book.toc = chapters
-    book.add_item(EpubNcx())
-    book.add_item(EpubNav())
-    # Write book
-    write_epub(epub_file, book)
+    input_directory = abspath(directory)
+    epub_file = abspath(join(input_directory, basename(input_directory)+".epub"))
+    # Create temporary directory to save contents into
+    temp_dir = get_temp_dir("dvk-metamagic-epub")
+    # Create container
+    meta_dir = abspath(join(temp_dir, "META-INF"))
+    mkdir(meta_dir)
+    base = Element("container")
+    base.attrib = {"xmlns":"urn:oasis:names:tc:opendocument:xmlns:container", "version":"1.0"}
+    rootfiles = SubElement(base, "rootfiles")
+    rootfile = SubElement(rootfiles, "rootfile")
+    rootfile.attrib = {"media-type":"application/oebps-package+xml", "full-path":"EPUB/content.opf"}
+    xml_indent(base, space="   ")
+    xml = xml_to_string(base).decode("UTF-8")
+    xml = f"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n{xml}"
+    container_file = abspath(join(meta_dir, "container.xml"))
+    create_text_file(container_file, xml)
+    # Get list of all contents of the given directory
+    files = listdir(input_directory)
+    for i in range(0, len(files)):
+        files[i] = abspath(join(input_directory, files[i]))
+    # Copy all files into folder to contain all original unaltered files
+    epub_folder = abspath(join(temp_dir, "EPUB"))
+    mkdir(epub_folder)
+    original_folder = abspath(join(epub_folder, "original"))
+    mkdir(original_folder)
+    for file in files:
+        copy(file, abspath(join(original_folder, basename(file))))
+    # Create style sheet
+    style_folder = abspath(join(epub_folder, "style"))
+    mkdir(style_folder)
+    create_style_file(abspath(join(style_folder, "epubstyle.css")))
+    # Copy all images and convert all text to XHTML for the content folder
+    content_folder = abspath(join(epub_folder, "content"))
+    mkdir(content_folder)
+    image_folder = abspath(join(epub_folder, "images"))
+    mkdir(image_folder)
+    for file in files:
+        filename = basename(file)
+        extension = get_extension(filename)
+        if extension == ".txt":
+            # Create text extension
+            filename = filename[:len(filename) - len(extension)] + ".xhtml"
+            xml = txt_to_xhtml(file, True)
+            create_text_file(abspath(join(content_folder, filename)), xml)
+        if extension == ".png" or extension == ".jpg" or extension == ".jpeg" or extension == ".svg":
+            # Copy image file
+            copy(file, abspath(join(image_folder, filename)))
+            # Create image page
+            filename = filename[:len(filename) - len(extension)] + ".xhtml"
+            xml = create_image_page(file)
+            create_text_file(abspath(join(content_folder, filename)), xml)
+    # Create the package and nav files
+    create_epub_files(epub_folder, metadata)
+    # Zip files and copy to epub
+    zip_epub(temp_dir, epub_file)
     return epub_file
     
 def user_create_epub(path:str,
                 rp_description:bool=False,
                 rp_date:bool=False,
                 rp_artists:bool=False,
                 rp_publisher:bool=False,
```

## metadata_magic/test/epub/test_epub.py

```diff
@@ -1,26 +1,28 @@
 #!/usr/bin/env python3
 
-from ebooklib.epub import EpubHtml
 from os import mkdir, listdir
 from os.path import abspath, basename, exists, isdir, join
-from PIL import Image
 from metadata_magic.main.comic_archive.comic_archive import get_temp_dir
 from metadata_magic.main.comic_archive.comic_xml import get_empty_metadata
-from metadata_magic.main.epub.epub import get_chapters
-from metadata_magic.main.epub.epub import get_items
-from metadata_magic.main.epub.epub import get_style
-from metadata_magic.main.epub.epub import get_title_from_file
 from metadata_magic.main.epub.epub import create_epub
+from metadata_magic.main.epub.epub import create_epub_files
 from metadata_magic.main.epub.epub import create_image_page
-from metadata_magic.main.epub.epub import create_metadata
+from metadata_magic.main.epub.epub import create_nav_file
+from metadata_magic.main.epub.epub import create_ncx_file
+from metadata_magic.main.epub.epub import create_manifest
+from metadata_magic.main.epub.epub import create_metadata_xml
+from metadata_magic.main.epub.epub import create_style_file
+from metadata_magic.main.epub.epub import get_title_from_file
+from metadata_magic.main.epub.epub import format_xhtml
 from metadata_magic.main.epub.epub import newline_to_tag
 from metadata_magic.main.epub.epub import txt_to_xhtml
 from metadata_magic.main.rename.sort_rename import sort_alphanum
 from metadata_magic.test.temp_file_tools import create_text_file, read_text_file
+from PIL import Image
 from zipfile import ZipFile
 
 def test_newline_to_tag():
     """
     Tests the newline_to_tag function.
     """
     assert newline_to_tag("\n") == "{{{br}}}"
@@ -38,14 +40,67 @@
     filename = abspath(join(temp_file, "[00] Image  .png"))
     assert get_title_from_file(filename) == "Image"
     filename = abspath(join(temp_file, "[This is a thing] Cover"))
     assert get_title_from_file(filename) == "Cover"
     filename = abspath(join(temp_file, "none"))
     assert get_title_from_file(filename) == "none"
 
+def test_format_xhtml():
+    """
+    Tests the format_xhtml function.
+    """
+    # Test single tag
+    start = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">"
+    head = "<head><title>Title!</title><meta charset=\"utf-8\" />"
+    head = f"{head}<link rel=\"stylesheet\" href=\"../style/epubstyle.css\" type=\"text/css\" /></head>"
+    html = "<p>This is a simple test &amp; stuff</p>"
+    xhtml = format_xhtml(html, "Title!", indent=False)
+    assert xhtml == f"{start}{head}<body><p>This is a simple test &amp; stuff</p></body></html>"
+    # Test with multiple tags
+    html = "<p>Multiple</p><p>Paragraphs!!!</p>"
+    xhtml = format_xhtml(html, "Title!", indent=False)
+    assert xhtml == f"{start}{head}<body><p>Multiple</p><p>Paragraphs!!!</p></body></html>"
+    # Test with no tags
+    head = "<head><title>Title thing.</title><meta charset=\"utf-8\" />"
+    head = f"{head}<link rel=\"stylesheet\" href=\"../style/epubstyle.css\" type=\"text/css\" /></head>"
+    html = "This is a thing.<br/><br/>Final thing."
+    xhtml = format_xhtml(html, "Title thing.", indent=False)
+    assert xhtml == f"{start}{head}<body>This is a thing.<br /><br />Final thing.</body></html>"
+    # Test with spaces and newlines
+    html = "  <p>  This is a thing!  </p>\n  <div> Another </div> "
+    xhtml = format_xhtml(html, "Title thing.", indent=False)
+    assert xhtml == f"{start}{head}<body><p>  This is a thing!  </p>  <div> Another </div></body></html>"
+    # Test header tags
+    html="<p>bleh</p>"
+    tags = [{"type":"thing", "params":{"class":"name"}}, {"type":"meta", "params":{"item":"other"}}]
+    xhtml = format_xhtml(html, "Name", tags, indent=False)
+    compare = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    compare = f"{compare}<html xmlns=\"http://www.w3.org/1999/xhtml\"><head>"
+    compare = f"{compare}<title>Name</title><meta charset=\"utf-8\" />"
+    compare = f"{compare}<thing class=\"name\" /><meta item=\"other\" />"
+    compare = f"{compare}<link rel=\"stylesheet\" href=\"../style/epubstyle.css\" type=\"text/css\" />"
+    compare = f"{compare}</head><body><p>bleh</p></body></html>"
+    assert xhtml == compare
+    # Test adding indent
+    html = "<p>These</p><p>Are</p><p>Paragraphs!</p>"
+    xhtml = format_xhtml(html, "New", indent=True)
+    xml = f"{start}\n"
+    xml = f"{xml}   <head>\n"
+    xml = f"{xml}      <title>New</title>\n"
+    xml = f"{xml}      <meta charset=\"utf-8\" />\n"
+    xml = f"{xml}      <link rel=\"stylesheet\" href=\"../style/epubstyle.css\" type=\"text/css\" />\n"
+    xml = f"{xml}   </head>\n"
+    xml = f"{xml}   <body>\n"
+    xml = f"{xml}      <p>These</p>\n"
+    xml = f"{xml}      <p>Are</p>\n"
+    xml = f"{xml}      <p>Paragraphs!</p>\n"
+    xml = f"{xml}   </body>\n"
+    xml = f"{xml}</html>"
+    assert xml == xhtml
+
 def test_create_image_page():
     """
     Tests the create_image_page function.
     """
     # Create image files
     temp_dir = get_temp_dir()
     png_file = abspath(join(temp_dir, "[00] Cover.png"))
@@ -53,125 +108,174 @@
     png_image = Image.new("RGB", (360, 480), color=(255,0,0))
     jpg_image = Image.new("RGB", (500, 300), color=(0,255,0))
     png_image.save(png_file)
     jpg_image.save(jpg_file)
     assert exists(png_file)
     assert exists(jpg_file)
     # Test with vertical image
-    chapter = create_image_page(png_file)
-    body = "<body><div class=\"image-page-container\">"
-    body = f"{body}<img class=\"vertical-image-page\" "
-    body = f"{body}src=\"../images/[00] Cover.png\" alt=\"Cover\" />"
-    body = f"{body}</div></body>"
-    assert chapter.content == body
-    links = []
-    for link in chapter.get_links(): links.append(link)
-    assert links == [{"href":"../style/epubstyle.css", "rel":"stylesheet", "type":"text/css"}]
-    metas = []
-    for meta in chapter.get_metas(): metas.append(meta)
-    assert metas == [{"content":"width=360, height=480", "name":"viewport"}]
+    chapter = create_image_page(png_file, False)
+    body = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    body = f"{body}<html xmlns=\"http://www.w3.org/1999/xhtml\">"
+    body = f"{body}<head><title>Cover</title><meta charset=\"utf-8\" />"
+    body = f"{body}<meta content=\"width=360, height=480\" name=\"viewport\" />"
+    body = f"{body}<link rel=\"stylesheet\" href=\"../style/epubstyle.css\" type=\"text/css\" />"
+    body = f"{body}</head><body><div class=\"image-page-container\">"
+    body = f"{body}<img class=\"vertical-image-page\" src=\"../images/[00] Cover.png\" alt=\"Cover\" />"
+    body = f"{body}</div></body></html>"
+    assert chapter == body
     # Test with horizontal image
-    chapter = create_image_page(jpg_file)
-    body = "<body><div class=\"image-page-container\">"
+    chapter = create_image_page(jpg_file, False)
+    body = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    body = f"{body}<html xmlns=\"http://www.w3.org/1999/xhtml\">"
+    body = f"{body}<head><title>thing</title><meta charset=\"utf-8\" />"
+    body = f"{body}<meta content=\"width=500, height=300\" name=\"viewport\" />"
+    body = f"{body}<link rel=\"stylesheet\" href=\"../style/epubstyle.css\" type=\"text/css\" />"
+    body = f"{body}</head><body><div class=\"image-page-container\">"
     body = f"{body}<img class=\"horizontal-image-page\" src=\"../images/thing.jpg\" alt=\"thing\" />"
-    body = f"{body}</div></body>"
-    assert chapter.content == body
-    links = []
-    for link in chapter.get_links(): links.append(link)
-    assert links == [{"href":"../style/epubstyle.css", "rel":"stylesheet", "type":"text/css"}]
-    metas = []
-    for meta in chapter.get_metas(): metas.append(meta)
-    assert metas == [{"content":"width=500, height=300", "name":"viewport"}]
+    body = f"{body}</div></body></html>"
+    assert chapter == body
     # Test with invalid image file
     text_file = abspath(join(temp_dir, "thing.png"))
     create_text_file(text_file, "Some Text")
     assert exists(text_file)
     assert create_image_page(text_file) is None
     assert create_image_page("/non/existant/thing.png") is None
+    # Test with indents
+    chapter = create_image_page(jpg_file, True)
+    body = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    body = f"{body}<html xmlns=\"http://www.w3.org/1999/xhtml\">\n"
+    body = f"{body}   <head>\n"
+    body = f"{body}      <title>thing</title>\n"
+    body = f"{body}      <meta charset=\"utf-8\" />\n"
+    body = f"{body}      <meta content=\"width=500, height=300\" name=\"viewport\" />\n"
+    body = f"{body}      <link rel=\"stylesheet\" href=\"../style/epubstyle.css\" type=\"text/css\" />\n"
+    body = f"{body}   </head>\n"
+    body = f"{body}   <body>\n"
+    body = f"{body}      <div class=\"image-page-container\">\n"
+    body = f"{body}         <img class=\"horizontal-image-page\" src=\"../images/thing.jpg\" alt=\"thing\" />\n"
+    body = f"{body}      </div>\n"
+    body = f"{body}   </body>\n"
+    body = f"{body}</html>"
+    assert chapter == body
 
 def test_txt_to_xhtml():
     """
     Tests the txt_to_xhtml function.
     """
     # Test a single paragraph
     temp_dir = get_temp_dir()
     text_file = abspath(join(temp_dir, "Text.txt"))
     text = "This is a simple sentence!"
     create_text_file(text_file, text)
     assert exists(text_file)
-    chapter = txt_to_xhtml(text_file)
-    assert isinstance(chapter, EpubHtml)
-    body = "<body><div class=\"text-container\">"
-    body = f"{body}<p>This is a simple sentence!</p></div></body>"
-    assert chapter.content == body
+    chapter = txt_to_xhtml(text_file, indent=False)
+    head = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    head = f"{head}<html xmlns=\"http://www.w3.org/1999/xhtml\"><head>"
+    head = f"{head}<title>Text</title><meta charset=\"utf-8\" />"
+    head = f"{head}<link rel=\"stylesheet\" href=\"../style/epubstyle.css\" type=\"text/css\" />"
+    head = f"{head}</head>"
+    body = f"{head}<body><div class=\"text-container\">"
+    body = f"{body}<p>This is a simple sentence!</p></div></body></html>"
+    assert chapter == body
     # Test multiple paragraphs
     text = "Different paragraphs!\n\nHow cool!"
     create_text_file(text_file, text)
-    chapter = txt_to_xhtml(text_file)
-    assert isinstance(chapter, EpubHtml)
-    body = "<body><div class=\"text-container\">"
-    body = f"{body}<p>Different paragraphs!</p><p>How cool!</p></div></body>"
-    assert chapter.content == body
+    chapter = txt_to_xhtml(text_file, False)
+    body = f"{head}<body><div class=\"text-container\">"
+    body = f"{body}<p>Different paragraphs!</p><p>How cool!</p></div></body></html>"
+    assert chapter == body
     # Test single new line character
     text = "More text!\nAnd This & That..."
     create_text_file(text_file, text)
-    chapter = txt_to_xhtml(text_file)
-    body = "<body><div class=\"text-container\">"
-    body = f"{body}<p>More text!<br/>And This &amp; That...</p></div></body>"
-    assert chapter.content == body
+    chapter = txt_to_xhtml(text_file, False)
+    body = f"{head}<body><div class=\"text-container\">"
+    body = f"{body}<p>More text!<br />And This &amp; That...</p></div></body></html>"
+    assert chapter == body
     # Test new lines and separate paragraphs
     text = "Paragraph\n\nOther\nText!\n\nFinal\nParagraph..."
     create_text_file(text_file, text)
-    chapter = txt_to_xhtml(text_file)
-    body = "<body><div class=\"text-container\">"
-    body = f"{body}<p>Paragraph</p><p>Other<br/>Text!</p>"
-    body = f"{body}<p>Final<br/>Paragraph...</p></div></body>"
-    assert chapter.content == body
+    chapter = txt_to_xhtml(text_file, False)
+    body = f"{head}<body><div class=\"text-container\">"
+    body = f"{body}<p>Paragraph</p><p>Other<br />Text!</p>"
+    body = f"{body}<p>Final<br />Paragraph...</p></div></body></html>"
+    assert chapter == body
     # Test with more than one two new lines
     text = "Thing\n\n\nOther"
     create_text_file(text_file, text)
-    chapter = txt_to_xhtml(text_file)
+    chapter = txt_to_xhtml(text_file, False)
     body = "<body><div class=\"text-container\"><p>Thing<br/><br/><br/>Other</p></div></body>"
-    assert chapter.content == body
+    body = f"{head}<body><div class=\"text-container\">"
+    body = f"{body}<p>Thing<br /><br /><br />Other</p></div></body></html>"
+    assert chapter == body
     text = "Thing\n\n\nOther\n\nParagraph\n\n\n\nNext"
     create_text_file(text_file, text)
-    chapter = txt_to_xhtml(text_file)
-    body = "<body><div class=\"text-container\">"
-    body = f"{body}<p>Thing<br/><br/><br/>Other</p>"
-    body = f"{body}<p>Paragraph<br/><br/><br/><br/>Next</p></div></body>"
-    assert chapter.content == body
+    chapter = txt_to_xhtml(text_file, False)
+    body = f"{head}<body><div class=\"text-container\">"
+    body = f"{body}<p>Thing<br /><br /><br />Other</p>"
+    body = f"{body}<p>Paragraph<br /><br /><br /><br />Next</p></div></body></html>"
+    assert chapter == body
     # Test removing text stand-ins for HTML tags
     text = "{{i}}Title{{/i}}{{br}}{{b}}Thing{{/b}}"
     create_text_file(text_file, text)
-    chapter = txt_to_xhtml(text_file)
-    body = "<body><div class=\"text-container\"><p><i>Title</i><br/><b>Thing</b></p></div></body>"
-    assert chapter.content == body
+    chapter = txt_to_xhtml(text_file, False)
+    body = f"{head}<body><div class=\"text-container\">"
+    body = f"{body}<p><i>Title</i><br /><b>Thing</b></p></div></body></html>"
+    assert chapter == body
     # Remove dangling paragraph tags
     text = "Text  \n\nThing {{br}} {{br}}"
     create_text_file(text_file, text)
-    chapter = txt_to_xhtml(text_file)
-    body = "<body><div class=\"text-container\"><p>Text</p><p>Thing</p></div></body>"
-    assert chapter.content == body
+    chapter = txt_to_xhtml(text_file, False)
+    body = f"{head}<body><div class=\"text-container\">"
+    body = f"{body}<p>Text</p><p>Thing</p></div></body></html>"
+    assert chapter == body
     # Remove dangling italic/bold tags tags
     text = "This is a {{b}}fine{{/b}} sentence."
     create_text_file(text_file, text)
-    chapter = txt_to_xhtml(text_file)
-    body = "<body><div class=\"text-container\"><p>This is a <b>fine</b> sentence.</p></div></body>"
-    assert chapter.content == body
+    chapter = txt_to_xhtml(text_file, False)
+    body = f"{head}<body><div class=\"text-container\">"
+    body = f"{body}<p>This is a <b>fine</b> sentence.</p></div></body></html>"
+    assert chapter == body
     text = "Some {{b}}words {{/b}} , should {{i}}change{{/i}}  ."
     create_text_file(text_file, text)
-    chapter = txt_to_xhtml(text_file)
-    body = "<body><div class=\"text-container\"><p>Some <b>words</b>, should <i>change</i>.</p></div></body>"
-    assert chapter.content == body
+    chapter = txt_to_xhtml(text_file, False)
+    body = f"{head}<body><div class=\"text-container\">"
+    body = f"{body}<p>Some <b>words</b>, should <i>change</i>.</p></div></body></html>"
+    assert chapter == body
+    # Test with indent
+    text = "These are...\n\nwords."
+    text_file = abspath(join(temp_dir, "[01] New Thing.txt"))
+    create_text_file(text_file, text)
+    chapter = txt_to_xhtml(text_file, True)
+    body = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    body = f"{body}<html xmlns=\"http://www.w3.org/1999/xhtml\">\n"
+    body = f"{body}   <head>\n"
+    body = f"{body}      <title>New Thing</title>\n"
+    body = f"{body}      <meta charset=\"utf-8\" />\n"
+    body = f"{body}      <link rel=\"stylesheet\" href=\"../style/epubstyle.css\" type=\"text/css\" />\n"
+    body = f"{body}   </head>\n"
+    body = f"{body}   <body>\n"
+    body = f"{body}      <div class=\"text-container\">\n"
+    body = f"{body}         <p>These are...</p>\n"
+    body = f"{body}         <p>words.</p>\n"
+    body = f"{body}      </div>\n"
+    body = f"{body}   </body>\n"
+    body = f"{body}</html>"
+    assert chapter == body
 
-def test_get_style():
+def test_create_style_file():
     """
     Tests the create_style_file function()
     """
-    style = get_style()
+    temp_dir = get_temp_dir()
+    css_file = abspath(join(temp_dir, "epubstyle.css"))
+    assert not exists(css_file)
+    create_style_file(css_file)
+    assert exists(css_file)
+    # Test contents of the css file
+    style = read_text_file(css_file)
     compare = "body {\n"
     compare = f"{compare}    margin: 0px 0px 0px 0px;\n"
     compare = f"{compare}}}\n\n"
     compare = f"{compare}.header {{\n"
     compare = f"{compare}    width: 100%;\n"
     compare = f"{compare}    font-size: 2em;\n"
     compare = f"{compare}    line-height: 1.5em;\n"
@@ -201,310 +305,426 @@
     compare = f"{compare}    margin: auto auto auto auto;\n"
     compare = f"{compare}}}\n\n"
     compare = f"{compare}.image-page-container {{\n"
     compare = f"{compare}    height: 100vh;\n"
     compare = f"{compare}}}"
     assert style == compare
 
-def test_create_metadata():
+def test_create_nav_file():
+    """
+    Tests the create_nav_file function.
+    """
+    # Test creating nav file
+    xhtmls = []
+    temp_dir = get_temp_dir()
+    xhtmls.append(abspath(join(temp_dir, "[00] Cover.xhtml")))
+    xhtmls.append(abspath(join(temp_dir, "Chapter 1.xhtml")))
+    xhtmls.append(abspath(join(temp_dir, "Chapter 2.xhtml")))
+    xhtmls.append(abspath(join(temp_dir, "Epilogues.xhtml")))
+    nav_file = abspath(join(temp_dir, "nav.xhtml"))
+    assert not exists(nav_file)
+    create_nav_file(xhtmls, nav_file, "Name of thing!", False)
+    assert exists(nav_file)
+    content = read_text_file(nav_file)
+    compare = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    compare = f"{compare}<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" lang=\"en\" xml:lang=\"en\">"
+    compare = f"{compare}<head><meta charset=\"utf-8\" /><title>Name of thing!</title></head>"
+    compare = f"{compare}<body><h1>Name of thing!</h1><nav epub:type=\"toc\" id=\"toc\">"
+    compare = f"{compare}<ol><li><a href=\"content/[00] Cover.xhtml\">Cover</a></li>"
+    compare = f"{compare}<li><a href=\"content/Chapter 1.xhtml\">Chapter 1</a></li>"
+    compare = f"{compare}<li><a href=\"content/Chapter 2.xhtml\">Chapter 2</a></li>"
+    compare = f"{compare}<li><a href=\"content/Epilogues.xhtml\">Epilogues</a></li>"
+    compare = f"{compare}</ol></nav></body></html>"
+    assert content == compare
+    # Test creating nav file with indents
+    xhtmls = [abspath(join(temp_dir, "[3] Cover.xhtml"))]
+    create_nav_file(xhtmls, nav_file, "Other thing", True)
+    content = read_text_file(nav_file)
+    compare = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    compare = f"{compare}<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" lang=\"en\" xml:lang=\"en\">\n"
+    compare = f"{compare}   <head>\n"
+    compare = f"{compare}      <meta charset=\"utf-8\" />\n"
+    compare = f"{compare}      <title>Other thing</title>\n"
+    compare = f"{compare}   </head>\n"
+    compare = f"{compare}   <body>\n"
+    compare = f"{compare}      <h1>Other thing</h1>\n"
+    compare = f"{compare}      <nav epub:type=\"toc\" id=\"toc\">\n"
+    compare = f"{compare}         <ol>\n"
+    compare = f"{compare}            <li>\n"
+    compare = f"{compare}               <a href=\"content/[3] Cover.xhtml\">Cover</a>\n"
+    compare = f"{compare}            </li>\n"
+    compare = f"{compare}         </ol>\n"
+    compare = f"{compare}      </nav>\n"
+    compare = f"{compare}   </body>\n"
+    compare = f"{compare}</html>"
+    assert content == compare
+
+def test_create_ncx_file():
+    """
+    Tests the create_ncx_file function.
+    """
+    # Test creating ncx file
+    xhtmls = []
+    temp_dir = get_temp_dir()
+    xhtmls.append(abspath(join(temp_dir, "[00] Cover.xhtml")))
+    xhtmls.append(abspath(join(temp_dir, "Chapter 1.xhtml")))
+    xhtmls.append(abspath(join(temp_dir, "Chapter 2.xhtml")))
+    xhtmls.append(abspath(join(temp_dir, "Epilogues.xhtml")))
+    ncx_file = abspath(join(temp_dir, "toc.ncx"))
+    assert not exists(ncx_file)
+    create_ncx_file(xhtmls, ncx_file, "Name of thing!", "UNIQUE-id", False)
+    assert exists(ncx_file)
+    content = read_text_file(ncx_file)
+    compare = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    compare = f"{compare}<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">"
+    compare = f"{compare}<head><meta content=\"UNIQUE-id\" name=\"dtb:uid\" />"
+    compare = f"{compare}<meta content=\"0\" name=\"dtb:depth\" />"
+    compare = f"{compare}<meta content=\"0\" name=\"dtb:totalPageCount\" />"
+    compare = f"{compare}<meta content=\"0\" name=\"dtb:maxPageNumber\" /></head>"
+    compare = f"{compare}<docTitle><text>Name of thing!</text></docTitle><navMap>"
+    compare = f"{compare}<navPoint id=\"Cover-xhtml\"><navLabel><text>Cover</text></navLabel>"
+    compare = f"{compare}<content>content/[00] Cover.xhtml</content></navPoint>"
+    compare = f"{compare}<navPoint id=\"Chapter 1-xhtml\"><navLabel><text>Chapter 1</text></navLabel>"
+    compare = f"{compare}<content>content/Chapter 1.xhtml</content></navPoint>"
+    compare = f"{compare}<navPoint id=\"Chapter 2-xhtml\"><navLabel><text>Chapter 2</text></navLabel>"
+    compare = f"{compare}<content>content/Chapter 2.xhtml</content></navPoint>"
+    compare = f"{compare}<navPoint id=\"Epilogues-xhtml\"><navLabel><text>Epilogues</text></navLabel>"
+    compare = f"{compare}<content>content/Epilogues.xhtml</content></navPoint></navMap></ncx>"
+    assert content == compare
+    # Test creating ncx file with indents
+    xhtmls = [abspath(join(temp_dir, "[3] Cover.xhtml"))]
+    create_ncx_file(xhtmls, ncx_file, "Other thing", "new-uid", True)
+    content = read_text_file(ncx_file)
+    compare = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    compare = f"{compare}<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n"
+    compare = f"{compare}   <head>\n"
+    compare = f"{compare}      <meta content=\"new-uid\" name=\"dtb:uid\" />\n"
+    compare = f"{compare}      <meta content=\"0\" name=\"dtb:depth\" />\n"
+    compare = f"{compare}      <meta content=\"0\" name=\"dtb:totalPageCount\" />\n"
+    compare = f"{compare}      <meta content=\"0\" name=\"dtb:maxPageNumber\" />\n"
+    compare = f"{compare}   </head>\n"
+    compare = f"{compare}   <docTitle>\n"
+    compare = f"{compare}      <text>Other thing</text>\n"
+    compare = f"{compare}   </docTitle>\n"
+    compare = f"{compare}   <navMap>\n"
+    compare = f"{compare}      <navPoint id=\"Cover-xhtml\">\n"
+    compare = f"{compare}         <navLabel>\n"
+    compare = f"{compare}            <text>Cover</text>\n"
+    compare = f"{compare}         </navLabel>\n"
+    compare = f"{compare}         <content>content/[3] Cover.xhtml</content>\n"
+    compare = f"{compare}      </navPoint>\n"
+    compare = f"{compare}   </navMap>\n"
+    compare = f"{compare}</ncx>"
+    assert content == compare
+
+def test_create_manifest():
+    """
+    Tests the create_manifest function.
+    """
+    files = []
+    temp_dir = get_temp_dir()
+    files.append(abspath(join(temp_dir, "[03] Cover.xhtml")))
+    files.append(abspath(join(temp_dir, "Picture.png")))
+    files.append(abspath(join(temp_dir, "[02] Jpeg!.jpg")))
+    files.append(abspath(join(temp_dir, "Thing.svg")))
+    manifest = create_manifest(files)
+    compare = "<manifest>"
+    compare = f"{compare}<item href=\"nav.xhtml\" id=\"toc\" media-type=\"application/xhtml+xml\" properties=\"nav\" />"
+    compare = f"{compare}<item href=\"content/[03] Cover.xhtml\" id=\"Cover-xhtml\" media-type=\"application/xhtml+xml\" />"
+    compare = f"{compare}<item href=\"images/Picture.png\" id=\"Picture-png\" media-type=\"image/png\" />"
+    compare = f"{compare}<item href=\"images/[02] Jpeg!.jpg\" id=\"Jpeg!-jpg\" media-type=\"image/jpeg\" />"
+    compare = f"{compare}<item href=\"images/Thing.svg\" id=\"Thing-svg\" media-type=\"image/svg+xml\" />"
+    compare = f"{compare}<item href=\"style/epubstyle.css\" id=\"epubstyle-css\" media-type=\"text/css\" />"
+    compare = f"{compare}</manifest>"
+    assert manifest == compare
+
+def test_create_metadata_xml():
     """
     Tests the create_metadata_xml function.
     """
-    # Test setting title for the book
+    # Test setting title in the XML file
+    start = "<metadata xmlns:dc=\"http://purl.org/dc/elements/1.1/\"><dc:language>en</dc:language>"
+    end = "<meta property=\"dcterms:modified\">0000-00-00T00:00:00+00:00</meta>"
+    end = f"{end}<dc:date>0000-00-00T00:00:00+00:00</dc:date></metadata>"
     meta = get_empty_metadata()
     meta["title"] = "This's a title\\'"
-    book = create_metadata(meta)
-    title = book.get_metadata("DC", "title")
-    assert title == [("This's a title\\'", None)]
-    identifier = book.get_metadata("DC", "identifier")
-    assert identifier == [("this's a title\\'", {"id":"id"})]
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<dc:identifier>this's a title\\'</dc:identifier>"
+    compare = f"{compare}<dc:title>This's a title\\'</dc:title>{end}"
+    assert xml == compare
     # Test setting identifier in the XML file
-    meta = get_empty_metadata()
-    meta["url"] = "this/is/a/test"
-    meta["title"] = "Title."
-    book = create_metadata(meta)
-    title = book.get_metadata("DC", "title")
-    assert title == [("Title.", None)]
-    identifier = book.get_metadata("DC", "identifier")
-    assert identifier == [("this/is/a/test", {"id":"id"})]
-    # Test that language is set
-    language = book.get_metadata("DC", "language")
-    assert language == [("en", None)]
+    base_meta = get_empty_metadata()
+    base_meta["url"] = "this/is/a/test"
+    base_meta["title"] = "Title."
+    start = f"{start}<dc:identifier>this/is/a/test</dc:identifier>"
+    start = f"{start}<dc:title>Title.</dc:title>"
+    xml = create_metadata_xml(base_meta)
+    assert xml == f"{start}{end}"
     # Test setting description in the XML file
+    meta = base_meta
     meta["description"] = "Description of the thing."
-    book = create_metadata(meta)
-    description = book.get_metadata("DC", "description")
-    assert description == [("Description of the thing.", None)]
+    xml = create_metadata_xml(meta)
+    assert xml == f"{start}<dc:description>Description of the thing.</dc:description>{end}"
     meta["description"] = "'Tis this & That's >.<"
-    book = create_metadata(meta)
-    description = book.get_metadata("DC", "description")
-    assert description == [("'Tis this & That's >.<", None)]
+    xml = create_metadata_xml(meta)
+    assert xml == f"{start}<dc:description>'Tis this &amp; That's &gt;.&lt;</dc:description>{end}"
     # Test setting writer() in XML file
     meta["description"] = None
     meta["writer"] = "Person!"
-    book = create_metadata(meta)
-    writers = book.get_metadata("DC", "creator")
-    refines = book.get_metadata(None, "meta")
-    assert writers == [("Person!", {"id":"author0"})]
-    assert refines == [("aut", {"refines":"#author0", "property":"role", "scheme":"marc:relators"})]
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<dc:creator id=\"author1\">Person!</dc:creator>"
+    compare = f"{compare}<meta refines=\"#author1\" property=\"role\" scheme=\"marc:relators\">aut</meta>"
+    assert xml == f"{compare}{end}"
     meta["writer"] = "More,People"
-    book = create_metadata(meta)
-    writers = book.get_metadata("DC", "creator")
-    refines = book.get_metadata(None, "meta")
-    assert len(writers) == 2
-    assert writers[0] == ("More", {"id":"author0"})
-    assert writers[1] == ("People", {"id":"author1"})
-    assert len(refines) == 2
-    assert refines[0] == ("aut", {"refines":"#author0", "property":"role", "scheme":"marc:relators"})
-    assert refines[1] == ("aut", {"refines":"#author1", "property":"role", "scheme":"marc:relators"})
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<dc:creator id=\"author1\">More</dc:creator>"
+    compare = f"{compare}<meta refines=\"#author1\" property=\"role\" scheme=\"marc:relators\">aut</meta>"
+    compare = f"{compare}<dc:creator id=\"author2\">People</dc:creator>"
+    compare = f"{compare}<meta refines=\"#author2\" property=\"role\" scheme=\"marc:relators\">aut</meta>"
+    assert xml == f"{compare}{end}"
     # Test setting cover artist in XML file
     meta["writer"] = None
     meta["cover_artist"] = "Guest"
-    book = create_metadata(meta)
-    writers = book.get_metadata("DC", "creator")
-    refines = book.get_metadata(None, "meta")
-    assert writers == [("Guest", {"id":"covartist0"})]
-    assert refines == [("cov", {"refines":"#covartist0", "property":"role", "scheme":"marc:relators"})]
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<dc:creator id=\"covartist1\">Guest</dc:creator>"
+    compare = f"{compare}<meta refines=\"#covartist1\" property=\"role\" scheme=\"marc:relators\">cov</meta>"
+    assert xml == f"{compare}{end}"
     meta["cover_artist"] = "Other,Folks"
-    book = create_metadata(meta)
-    writers = book.get_metadata("DC", "creator")
-    refines = book.get_metadata(None, "meta")
-    assert len(writers) == 2
-    assert writers[0] == ("Other", {"id":"covartist0"})
-    assert writers[1] == ("Folks", {"id":"covartist1"})
-    assert len(refines) == 2
-    assert refines[0] == ("cov", {"refines":"#covartist0", "property":"role", "scheme":"marc:relators"})
-    assert refines[1] == ("cov", {"refines":"#covartist1", "property":"role", "scheme":"marc:relators"})
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<dc:creator id=\"covartist1\">Other</dc:creator>"
+    compare = f"{compare}<meta refines=\"#covartist1\" property=\"role\" scheme=\"marc:relators\">cov</meta>"
+    compare = f"{compare}<dc:creator id=\"covartist2\">Folks</dc:creator>"
+    compare = f"{compare}<meta refines=\"#covartist2\" property=\"role\" scheme=\"marc:relators\">cov</meta>"
+    assert xml == f"{compare}{end}"
     # Test setting illustrator in XML file
     meta["cover_artist"] = None
     meta["artist"] = "Bleh"
-    book = create_metadata(meta)
-    writers = book.get_metadata("DC", "creator")
-    refines = book.get_metadata(None, "meta")
-    assert writers == [("Bleh", {"id":"illustrator0"})]
-    assert refines == [("ill", {"refines":"#illustrator0", "property":"role", "scheme":"marc:relators"})]
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<dc:creator id=\"illustrator1\">Bleh</dc:creator>"
+    compare = f"{compare}<meta refines=\"#illustrator1\" property=\"role\" scheme=\"marc:relators\">ill</meta>"
+    assert xml == f"{compare}{end}"
     meta["artist"] = "Other,Artist"
-    book = create_metadata(meta)
-    writers = book.get_metadata("DC", "creator")
-    refines = book.get_metadata(None, "meta")
-    assert len(writers) == 2
-    assert writers[0] == ("Other", {"id":"illustrator0"})
-    assert writers[1] == ("Artist", {"id":"illustrator1"})
-    assert len(refines) == 2
-    assert refines[0] == ("ill", {"refines":"#illustrator0", "property":"role", "scheme":"marc:relators"})
-    assert refines[1] == ("ill", {"refines":"#illustrator1", "property":"role", "scheme":"marc:relators"})
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<dc:creator id=\"illustrator1\">Other</dc:creator>"
+    compare = f"{compare}<meta refines=\"#illustrator1\" property=\"role\" scheme=\"marc:relators\">ill</meta>"
+    compare = f"{compare}<dc:creator id=\"illustrator2\">Artist</dc:creator>"
+    compare = f"{compare}<meta refines=\"#illustrator2\" property=\"role\" scheme=\"marc:relators\">ill</meta>"
+    assert xml == f"{compare}{end}"
     # Test setting publisher in XML file
     meta["artist"] = None
     meta["publisher"] = "Company"
-    book = create_metadata(meta)
-    publisher = book.get_metadata("DC", "publisher")
-    assert publisher == [("Company", None)]
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<dc:publisher>Company</dc:publisher>{end}"
+    assert xml == compare
     # Test setting date in the XML file
     meta["publisher"] = None
     meta["date"] = "2023-01-15"
-    book = create_metadata(meta)
-    date = book.get_metadata("DC", "date")
-    assert date == [("2023-01-15T00:00:00+00:00", None)]
+    xml = create_metadata_xml(meta)
+    end = "<meta property=\"dcterms:modified\">2023-01-15T00:00:00+00:00</meta>"
+    end = f"{end}<dc:date>2023-01-15T00:00:00+00:00</dc:date></metadata>"
+    assert xml == f"{start}{end}"
     meta["date"] = "2014-12-08"
-    book = create_metadata(meta)
-    date = book.get_metadata("DC", "date")
-    assert date == [("2014-12-08T00:00:00+00:00", None)]
+    xml = create_metadata_xml(meta)
+    end = "<meta property=\"dcterms:modified\">2014-12-08T00:00:00+00:00</meta>"
+    end = f"{end}<dc:date>2014-12-08T00:00:00+00:00</dc:date></metadata>"
+    assert xml == f"{start}{end}"
     # Test setting series info in the XML file
     meta["series"] = "Name!!"
     meta["series_number"] = "2.5"
     meta["series_total"] = "5"
-    book = create_metadata(meta)
-    series = book.get_metadata(None, "meta")
-    assert len(series) == 3
-    assert series[0] == ("Name!!", {"id":"series-title", "property":"belongs-to-collection"})
-    assert series[1] == ("series", {"refines":"#series-title", "property":"collection-type"})
-    assert series[2] == ("2.5", {"refines":"#series-title", "property":"group-position"})
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<meta property=\"belongs-to-collection\" id=\"series-title\">Name!!</meta>"
+    compare = f"{compare}<meta refines=\"series-title\" property=\"collection-type\">series</meta>"
+    compare = f"{compare}<meta refines=\"series-title\" property=\"group-position\">2.5</meta>{end}"
+    assert xml == compare
     # Test setting invalid series number
-    meta["series"] = "New Series"
     meta["series_number"] = "NotNumber"
-    book = create_metadata(meta)
-    series = book.get_metadata(None, "meta")
-    assert len(series) == 2
-    assert series[0] == ("New Series", {"id":"series-title", "property":"belongs-to-collection"})
-    assert series[1] == ("series", {"refines":"#series-title", "property":"collection-type"})
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<meta property=\"belongs-to-collection\" id=\"series-title\">Name!!</meta>"
+    compare = f"{compare}<meta refines=\"series-title\" property=\"collection-type\">series</meta>{end}"
+    assert xml == compare
     # Test setting tags in XML file
     meta["series"] = None
     meta["series_number"] = None
     meta["tags"] = "Some,Tags,&,stuff"
-    book = create_metadata(meta)
-    tags = book.get_metadata("DC", "subject")
-    assert len(tags) == 4
-    assert tags[0] == ("Some", None)
-    assert tags[1] == ("Tags", None)
-    assert tags[2] == ("&", None)
-    assert tags[3] == ("stuff", None)
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<dc:subject>Some</dc:subject>"
+    compare = f"{compare}<dc:subject>Tags</dc:subject>"
+    compare = f"{compare}<dc:subject>&amp;</dc:subject>"
+    compare = f"{compare}<dc:subject>stuff</dc:subject>{end}"
+    assert xml == compare
     # Test setting the score in the XML file
     meta["tags"] = None
     meta["score"] = "0"
-    book = create_metadata(meta)
-    scores = book.get_metadata(None, "meta")
-    assert scores == [("0.0", {"property":"calibre:rating"})]
+    xml = create_metadata_xml(meta)
+    assert xml == f"{start}<meta property=\"calibre:rating\">0.0</meta>{end}"
     meta["score"] = "2"
-    book = create_metadata(meta)
-    scores = book.get_metadata(None, "meta")
-    tags = book.get_metadata("DC", "subject")
-    assert scores == [("4.0", {"property":"calibre:rating"})]
-    assert tags == [("★★", None)]
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<meta property=\"calibre:rating\">4.0</meta>"
+    compare = f"{compare}<dc:subject>&#9733;&#9733;</dc:subject>{end}"
+    assert xml == compare
     meta["score"] = "5"
-    book = create_metadata(meta)
-    scores = book.get_metadata(None, "meta")
-    tags = book.get_metadata("DC", "subject")
-    assert scores == [("10.0", {"property":"calibre:rating"})]
-    assert tags == [("★★★★★", None)]
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<meta property=\"calibre:rating\">10.0</meta>"
+    compare = f"{compare}<dc:subject>&#9733;&#9733;&#9733;&#9733;&#9733;</dc:subject>{end}"
+    assert xml == compare
     # Test setting invalid score in XML file
     meta["score"] = "Blah"
-    book = create_metadata(meta)
-    try:
-        scores = book.get_metadata(None, "meta")
-        assert 1 == 0
-    except KeyError: pass
-    assert book.get_metadata("DC", "subject") == []
+    xml = create_metadata_xml(meta)
+    assert xml == f"{start}{end}"
     meta["score"] = "6"
-    book = create_metadata(meta)
-    try:
-        scores = book.get_metadata(None, "meta")
-        assert 1 == 0
-    except KeyError: pass
-    assert book.get_metadata("DC", "subject") == []
+    xml = create_metadata_xml(meta)
+    assert xml == f"{start}{end}"
     meta["score"] = "-3"
-    book = create_metadata(meta)
-    try:
-        scores = book.get_metadata(None, "meta")
-        assert 1 == 0
-    except KeyError: pass
-    assert book.get_metadata("DC", "subject") == []
+    xml = create_metadata_xml(meta)
+    assert xml == f"{start}{end}"
     # Test adding score as tags
     meta["tags"] = "These,are,things"
     meta["score"] = "3"
-    book = create_metadata(meta)
-    scores = book.get_metadata(None, "meta")
-    tags = book.get_metadata("DC", "subject")
-    assert scores == [("6.0", {"property":"calibre:rating"})]
-    assert len(tags) == 4
-    assert tags[0] == ("★★★", None)
-    assert tags[1] == ("These", None)
-    assert tags[2] == ("are", None)
-    assert tags[3] == ("things", None)
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<meta property=\"calibre:rating\">6.0</meta>"
+    compare = f"{compare}<dc:subject>&#9733;&#9733;&#9733;</dc:subject>"
+    compare = f"{compare}<dc:subject>These</dc:subject>"
+    compare = f"{compare}<dc:subject>are</dc:subject>"
+    compare = f"{compare}<dc:subject>things</dc:subject>{end}"
+    assert xml == compare
     meta["score"] = "5"
     meta["tags"] = None
-    book = create_metadata(meta)
-    scores = book.get_metadata(None, "meta")
-    tags = book.get_metadata("DC", "subject")
-    assert scores == [("10.0", {"property":"calibre:rating"})]
-    assert tags == [("★★★★★", None)]
+    xml = create_metadata_xml(meta)
+    compare = f"{start}<meta property=\"calibre:rating\">10.0</meta>"
+    compare = f"{compare}<dc:subject>&#9733;&#9733;&#9733;&#9733;&#9733;</dc:subject>{end}"
+    assert xml == compare
     meta["score"] = "0"
-    book = create_metadata(meta)
-    scores = book.get_metadata(None, "meta")
-    tags = book.get_metadata("DC", "subject")
-    assert scores == [("0.0", {"property":"calibre:rating"})]
+    xml = create_metadata_xml(meta)
+    assert xml == f"{start}<meta property=\"calibre:rating\">0.0</meta>{end}"
 
-def test_get_items():
+def test_create_epub_files():
     """
-    Tests the get_items function.
+    Tests the create_epub_files function.
     """
     # Create test files
     temp_dir = get_temp_dir()
-    json = abspath(join(temp_dir, "Text.json"))
-    text = abspath(join(temp_dir, "Text.txt"))
-    png = abspath(join(temp_dir, "[00] Cover.png"))
-    jpeg = abspath(join(temp_dir, "Image.jpeg"))
-    create_text_file(json, "Not")
-    create_text_file(text, "Really")
-    create_text_file(png, "That")
-    create_text_file(jpeg, "Important")
-    assert exists(json)
-    assert exists(text)
-    assert exists(png)
-    assert exists(jpeg)
-    # Get EpubItems
-    items = get_items(temp_dir)
-    assert len(items) == 7
-    assert items[0].get_name() == "images/[00] Cover.png"
-    assert items[0].get_id() == "Cover"
-    assert items[0].get_content() == b"That"
-    assert items[1].get_name() == "original/[00] Cover.png"
-    assert items[1].get_id() == "[00] Cover-png"
-    assert items[2].get_name() == "images/Image.jpeg"
-    assert items[2].get_id() == "Image"
-    assert items[3].get_name() == "original/Image.jpeg"
-    assert items[3].get_id() == "Image-jpeg"
-    assert items[4].get_name() == "original/Text.json"
-    assert items[4].get_id() == "Text-json"
-    assert items[5].get_name() == "original/Text.txt"
-    assert items[5].get_id() == "Text-txt"
-    assert items[6].get_name() == "style/epubstyle.css"
-    assert items[6].get_id() == "epubstyle"
-    assert items[6].get_content() == get_style()
+    content = abspath(join(temp_dir, "content"))
+    images = abspath(join(temp_dir, "images"))
+    mkdir(content)
+    mkdir(images)
+    assert isdir(content) and exists(content)
+    cover_page = abspath(join(content, "[00] Cover.xhtml"))
+    chapter_page = abspath(join(content, "[01] Chapter1.xhtml"))
+    cover_image = abspath(join(images, "cover.png"))
+    internal_image = abspath(join(images, "other.jpeg"))
+    create_text_file(cover_page, "Doesn't")
+    create_text_file(chapter_page, "Really")
+    create_text_file(cover_image, "Matter")
+    create_text_file(internal_image, "To Me")
+    assert exists(cover_page)
+    assert exists(chapter_page)
+    assert exists(cover_image)
+    assert exists(internal_image)
+    # Create content file
+    metadata = get_empty_metadata()
+    metadata["title"] = "Experimental Title"
+    metadata["url"] = "thing/page/"
+    metadata["date"] = "2020-04-02"
+    nav_file = abspath(join(temp_dir, "nav.xhtml"))
+    ncx_file = abspath(join(temp_dir, "toc.ncx"))
+    content_file = abspath(join(temp_dir, "content.opf"))
+    create_epub_files(temp_dir, metadata)
+    # Test that nav file is correct
+    assert exists(nav_file)
+    contents = read_text_file(nav_file)
+    compare = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    compare = f"{compare}<html xmlns=\"http://www.w3.org/1999/xhtml\" "
+    compare = f"{compare}xmlns:epub=\"http://www.idpf.org/2007/ops\" lang=\"en\" xml:lang=\"en\">\n"
+    compare = f"{compare}   <head>\n"
+    compare = f"{compare}      <meta charset=\"utf-8\" />\n"
+    compare = f"{compare}      <title>Experimental Title</title>\n"
+    compare = f"{compare}   </head>\n"
+    compare = f"{compare}   <body>\n"
+    compare = f"{compare}      <h1>Experimental Title</h1>\n"
+    compare = f"{compare}      <nav epub:type=\"toc\" id=\"toc\">\n"
+    compare = f"{compare}         <ol>\n"
+    compare = f"{compare}            <li>\n"
+    compare = f"{compare}               <a href=\"content/[00] Cover.xhtml\">Cover</a>\n"
+    compare = f"{compare}            </li>\n"
+    compare = f"{compare}            <li>\n"
+    compare = f"{compare}               <a href=\"content/[01] Chapter1.xhtml\">Chapter1</a>\n"
+    compare = f"{compare}            </li>\n"
+    compare = f"{compare}         </ol>\n"
+    compare = f"{compare}      </nav>\n"
+    compare = f"{compare}   </body>\n"
+    compare = f"{compare}</html>"
+    assert contents == compare
+    # Test that ncx file is correct
+    assert exists(ncx_file)
+    contents = read_text_file(ncx_file)
+    compare = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    compare = f"{compare}<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n"
+    compare = f"{compare}   <head>\n"
+    compare = f"{compare}      <meta content=\"thing/page/\" name=\"dtb:uid\" />\n"
+    compare = f"{compare}      <meta content=\"0\" name=\"dtb:depth\" />\n"
+    compare = f"{compare}      <meta content=\"0\" name=\"dtb:totalPageCount\" />\n"
+    compare = f"{compare}      <meta content=\"0\" name=\"dtb:maxPageNumber\" />\n"
+    compare = f"{compare}   </head>\n"
+    compare = f"{compare}   <docTitle>\n"
+    compare = f"{compare}      <text>Experimental Title</text>\n"
+    compare = f"{compare}   </docTitle>\n"
+    compare = f"{compare}   <navMap>\n"
+    compare = f"{compare}      <navPoint id=\"Cover-xhtml\">\n"
+    compare = f"{compare}         <navLabel>\n"
+    compare = f"{compare}            <text>Cover</text>\n"
+    compare = f"{compare}         </navLabel>\n"
+    compare = f"{compare}         <content>content/[00] Cover.xhtml</content>\n"
+    compare = f"{compare}      </navPoint>\n"
+    compare = f"{compare}      <navPoint id=\"Chapter1-xhtml\">\n"
+    compare = f"{compare}         <navLabel>\n"
+    compare = f"{compare}            <text>Chapter1</text>\n"
+    compare = f"{compare}         </navLabel>\n"
+    compare = f"{compare}         <content>content/[01] Chapter1.xhtml</content>\n"
+    compare = f"{compare}      </navPoint>\n"
+    compare = f"{compare}   </navMap>\n"
+    compare = f"{compare}</ncx>"
+    assert contents == compare
+    # Test that package file is correct
+    assert exists(content_file)
+    contents = read_text_file(content_file)
+    compare = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    compare = f"{compare}<package xmlns:dc=\"http://purl.org/dc/elements/1.1/\" "
+    compare = f"{compare}xmlns=\"http://www.idpf.org/2007/opf\" unique-identifier=\"uid\" version=\"3.0\">\n"
+    compare = f"{compare}   <metadata>\n"
+    compare = f"{compare}      <dc:language>en</dc:language>\n"
+    compare = f"{compare}      <dc:identifier>thing/page/</dc:identifier>\n"
+    compare = f"{compare}      <dc:title>Experimental Title</dc:title>\n"
+    compare = f"{compare}      <meta property=\"dcterms:modified\">2020-04-02T00:00:00+00:00</meta>\n"
+    compare = f"{compare}      <dc:date>2020-04-02T00:00:00+00:00</dc:date>\n"
+    compare = f"{compare}   </metadata>\n"
+    compare = f"{compare}   <manifest>\n"
+    compare = f"{compare}      <item href=\"nav.xhtml\" id=\"toc\" media-type=\"application/xhtml+xml\" properties=\"nav\" />\n"
+    compare = f"{compare}      <item href=\"content/[00] Cover.xhtml\" id=\"Cover-xhtml\" media-type=\"application/xhtml+xml\" />\n"
+    compare = f"{compare}      <item href=\"content/[01] Chapter1.xhtml\" id=\"Chapter1-xhtml\" media-type=\"application/xhtml+xml\" />\n"
+    compare = f"{compare}      <item href=\"images/cover.png\" id=\"cover-png\" media-type=\"image/png\" />\n"
+    compare = f"{compare}      <item href=\"images/other.jpeg\" id=\"other-jpeg\" media-type=\"image/jpeg\" />\n"
+    compare = f"{compare}      <item href=\"style/epubstyle.css\" id=\"epubstyle-css\" media-type=\"text/css\" />\n"
+    compare = f"{compare}   </manifest>\n"
+    compare = f"{compare}   <spine>\n"
+    compare = f"{compare}      <itemref idref=\"Cover-xhtml\" />\n"
+    compare = f"{compare}      <itemref idref=\"Chapter1-xhtml\" />\n"
+    compare = f"{compare}   </spine>\n"
+    compare = f"{compare}</package>"
+    assert contents == compare
 
-def test_get_chapters():
+def test_create_epub():
     """
-    Tests the get_chapters function.
+    Tests the create_epub function.
     """
     # Create test files
     temp_dir = get_temp_dir()
-    json = abspath(join(temp_dir, "Text.json"))
-    text = abspath(join(temp_dir, "Text.txt"))
-    png_file = abspath(join(temp_dir, "[00] Cover.png"))
-    jpg_file = abspath(join(temp_dir, "Image.jpeg"))
-    invalid = abspath(join(temp_dir, "invalid.png"))
-    create_text_file(json, "blah")
-    create_text_file(text, "Actually important!")
-    create_text_file(invalid, "THING")
-    png_image = Image.new("RGB", (100, 200), color=(255,0,0))
-    jpg_image = Image.new("RGB", (500, 300), color=(0,255,0))
-    png_image.save(png_file)
-    jpg_image.save(jpg_file)
-    assert exists(json)
-    assert exists(text)
-    assert exists(png_file)
-    assert exists(jpg_file)
-    assert exists(invalid)
-    # Get html chapters
-    chapters = get_chapters(temp_dir)
-    assert len(chapters) == 3
-    assert chapters[0].get_name() == "content/[00] Cover.xhtml"
-    assert chapters[0].title == "Cover"
-    body = "<body><div class=\"image-page-container\">"
-    body = f"{body}<img class=\"vertical-image-page\" "
-    body = f"{body}src=\"../images/[00] Cover.png\" alt=\"Cover\" /></div></body>"
-    assert chapters[0].content == body
-    links = []
-    for link in chapters[0].get_links(): links.append(link)
-    assert links == [{"href":"../style/epubstyle.css", "rel":"stylesheet", "type":"text/css"}]
-    metas = []
-    for meta in chapters[0].get_metas(): metas.append(meta)
-    assert metas == [{'content': 'width=100, height=200', 'name': 'viewport'}]
-    assert chapters[1].get_name() == "content/Image.xhtml"
-    assert chapters[1].title == "Image"
-    body = "<body><div class=\"image-page-container\">"
-    body = f"{body}<img class=\"horizontal-image-page\" src=\"../images/Image.jpeg\" "
-    body = f"{body}alt=\"Image\" /></div></body>"
-    assert chapters[1].content == body
-    metas = []
-    for meta in chapters[1].get_metas(): metas.append(meta)
-    assert metas == [{'content': 'width=500, height=300', 'name': 'viewport'}]
-    assert chapters[2].get_name() == "content/Text.xhtml"
-    assert chapters[2].title == "Text"
-    body = "<body><div class=\"text-container\"><p>Actually important!</p></div></body>"
-    assert chapters[2].content == body
-    links = []
-    for link in chapters[2].get_links(): links.append(link)
-    assert links == [{"href":"../style/epubstyle.css", "rel":"stylesheet", "type":"text/css"}]
-
-def test_create_epub():
-    # Create test files
-    temp_dir = get_temp_dir()
     json = abspath(join(temp_dir, "blah.json"))
     text_page = abspath(join(temp_dir, "Text.txt"))
-    cover_file = abspath(join(temp_dir, "00.png"))
+    cover_file = abspath(join(temp_dir, "[00] Cover.png"))
     internal_file = abspath(join(temp_dir, "Other.jpeg"))
     create_text_file(json, "Some thing")
     create_text_file(text_page, "This is some text!!!")
     cover_image = Image.new("RGB", (100, 200), color=(255,0,0))
     internal_image = Image.new("RGB", (500, 300), color=(0,255,0))
     cover_image.save(cover_file)
     internal_image.save(internal_file)
@@ -528,60 +748,54 @@
     # Check the contents of the EPUB folder
     epub_dir = abspath(join(extract_dir, "EPUB"))
     files = sort_alphanum(listdir(epub_dir))
     assert files == ["content", "content.opf", "images", "nav.xhtml", "original", "style", "toc.ncx"]
     # Check the contents of the "original" folder
     original_folder = abspath(join(epub_dir, "original"))
     files = sort_alphanum(listdir(original_folder))
-    assert files == ["00.png", "blah.json", "Other.jpeg", "Text.txt"]
+    assert files == ["[00] Cover.png", "blah.json", "Other.jpeg", "Text.txt"]
     # Check the contents of the "content" folder
     content_folder = abspath(join(epub_dir, "content"))
     files = sort_alphanum(listdir(content_folder))
-    assert files == ["00.xhtml", "Other.xhtml", "Text.xhtml"]
+    assert files == ["[00] Cover.xhtml", "Other.xhtml", "Text.xhtml"]
     # Check the contents of the cover image xhtml
-    xml = read_text_file(abspath(join(content_folder, "00.xhtml")))
-    compare = "<?xml version='1.0' encoding='utf-8'?>\n"
-    compare = f"{compare}<!DOCTYPE html>\n"
-    compare = f"{compare}<html xmlns=\"http://www.w3.org/1999/xhtml\" "
-    compare = f"{compare}xmlns:epub=\"http://www.idpf.org/2007/ops\" "
-    compare = f"{compare}epub:prefix=\"z3998: http://www.daisy.org/z3998/2012/vocab/structure/#\" "
-    compare = f"{compare}lang=\"en\" xml:lang=\"en\">\n"
+    xml = read_text_file(abspath(join(content_folder, "[00] Cover.xhtml")))
+    compare = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    compare = f"{compare}<html xmlns=\"http://www.w3.org/1999/xhtml\">\n"
     compare = f"{compare}   <head>\n"
-    compare = f"{compare}      <title>00</title>\n"
-    compare = f"{compare}      <link href=\"../style/epubstyle.css\" rel=\"stylesheet\" type=\"text/css\" />\n"
+    compare = f"{compare}      <title>Cover</title>\n"
+    compare = f"{compare}      <meta charset=\"utf-8\" />\n"
     compare = f"{compare}      <meta content=\"width=100, height=200\" name=\"viewport\" />\n"
+    compare = f"{compare}      <link rel=\"stylesheet\" href=\"../style/epubstyle.css\" type=\"text/css\" />\n"
     compare = f"{compare}   </head>\n"
     compare = f"{compare}   <body>\n"
     compare = f"{compare}      <div class=\"image-page-container\">\n"
-    compare = f"{compare}         <img class=\"vertical-image-page\" src=\"../images/00.png\" alt=\"00\" />\n"
+    compare = f"{compare}         <img class=\"vertical-image-page\" src=\"../images/[00] Cover.png\" alt=\"Cover\" />\n"
     compare = f"{compare}      </div>\n"
     compare = f"{compare}   </body>\n"
     compare = f"{compare}</html>"
     assert xml == compare
     # Check the contents of the other image xhtml
     xml = read_text_file(abspath(join(content_folder, "Other.xhtml")))
-    compare = "<?xml version='1.0' encoding='utf-8'?>\n"
-    compare = f"{compare}<!DOCTYPE html>\n"
-    compare = f"{compare}<html xmlns=\"http://www.w3.org/1999/xhtml\" "
-    compare = f"{compare}xmlns:epub=\"http://www.idpf.org/2007/ops\" "
-    compare = f"{compare}epub:prefix=\"z3998: http://www.daisy.org/z3998/2012/vocab/structure/#\" "
-    compare = f"{compare}lang=\"en\" xml:lang=\"en\">\n"
+    compare = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+    compare = f"{compare}<html xmlns=\"http://www.w3.org/1999/xhtml\">\n"
     compare = f"{compare}   <head>\n"
     compare = f"{compare}      <title>Other</title>\n"
-    compare = f"{compare}      <link href=\"../style/epubstyle.css\" rel=\"stylesheet\" type=\"text/css\" />\n"
+    compare = f"{compare}      <meta charset=\"utf-8\" />\n"
     compare = f"{compare}      <meta content=\"width=500, height=300\" name=\"viewport\" />\n"
+    compare = f"{compare}      <link rel=\"stylesheet\" href=\"../style/epubstyle.css\" type=\"text/css\" />\n"
     compare = f"{compare}   </head>\n"
     compare = f"{compare}   <body>\n"
     compare = f"{compare}      <div class=\"image-page-container\">\n"
     compare = f"{compare}         <img class=\"horizontal-image-page\" src=\"../images/Other.jpeg\" alt=\"Other\" />\n"
     compare = f"{compare}      </div>\n"
     compare = f"{compare}   </body>\n"
     compare = f"{compare}</html>"
     assert xml == compare
     # Check the contents of the "images" folder
     content_folder = abspath(join(epub_dir, "images"))
     files = sort_alphanum(listdir(content_folder))
-    assert files == ["00.png", "Other.jpeg"]
+    assert files == ["[00] Cover.png", "Other.jpeg"]
     # Check the contents of the "style" folder
     content_folder = abspath(join(epub_dir, "style"))
     files = sort_alphanum(listdir(content_folder))
     assert files == ["epubstyle.css"]
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## Comparing `Metadata_Magic-0.3.2.dist-info/LICENSE` & `Metadata_Magic-0.4.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `Metadata_Magic-0.3.2.dist-info/METADATA` & `Metadata_Magic-0.4.1.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,24 @@
 Metadata-Version: 2.1
 Name: Metadata-Magic
-Version: 0.3.2
+Version: 0.4.1
 Summary: Utility for managing metadata.
 Home-page: https://github.com/Drakovek/MetadataMagic
 Author: Drakovek
 Author-email: DrakovekMail@gmail.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.9
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: EbookLib
+Requires-Dist: tqdm
 Requires-Dist: HTML-String-Tools
 Requires-Dist: Pillow
 Requires-Dist: Python-Print-Tools
-Requires-Dist: tqdm
 
 # MetadataMagic
 
 MetadataMagic is a command line utility for managing media and their respective metadata. This includes cleaning up naming for `.json` metadata as downloaded by applications such as [gallery-dl](https://github.com/mikf/gallery-dl) and [yt-dlp](https://github.com/yt-dlp/yt-dlp), as well as packaging media and metadata together into archive formats such as `.cbz`.
 
 - [Installation](#installation)
 - [Scripts](#scripts)
```

## Comparing `Metadata_Magic-0.3.2.dist-info/RECORD` & `Metadata_Magic-0.4.1.dist-info/RECORD`

 * *Files 19% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 metadata_magic/main/meta_finder.py,sha256=uAqPChgpcz2dRw4AT9gjBN7sl80Wge5dfIAtnGRKq78,2997
 metadata_magic/main/meta_reader.py,sha256=IXZtlEJpVscNG2xpcO5BoyI2ZDVPNOn8qZzKUZiRYYk,11588
 metadata_magic/main/comic_archive/__init__.py,sha256=1oLL20yLB1GL9IbFiZD8OReDqiCpFr-yetIR6x1cNkI,23
 metadata_magic/main/comic_archive/comic_archive.py,sha256=7GGcEguHe6StRwZPPvaT5zDIP9jctjrPC0FEnP4ds5M,15253
 metadata_magic/main/comic_archive/comic_xml.py,sha256=YXNwotSA-LLPsSdO50MXqAB-PPiNhILqjn9gzOKOF48,10964
 metadata_magic/main/comic_archive/series_info.py,sha256=egGWHL2yTVv4HXNPM0G_C5MtvgWoMzj_PkwKrxvSkmU,8011
 metadata_magic/main/epub/__init__.py,sha256=1oLL20yLB1GL9IbFiZD8OReDqiCpFr-yetIR6x1cNkI,23
-metadata_magic/main/epub/epub.py,sha256=x4sj5dg37erp3sKPR20o3D3MRvF2rovPRWdAsbY8NKo,21962
+metadata_magic/main/epub/epub.py,sha256=HVULVNIkwmr8hGhXUm5lpUCQ6GOuKQnD8hHE9Hl9uJA,32390
 metadata_magic/main/error_finding/__init__.py,sha256=1oLL20yLB1GL9IbFiZD8OReDqiCpFr-yetIR6x1cNkI,23
 metadata_magic/main/error_finding/missing_media.py,sha256=gziABuhFrn97HmNuhllNFrKemi1af5xZxrvObFA-a-o,2115
 metadata_magic/main/error_finding/missing_metadata.py,sha256=kpPSMIcWBpkOhSt617DYpmOp00TXSAU8IRzdHb9obDM,2137
 metadata_magic/main/rename/__init__.py,sha256=1oLL20yLB1GL9IbFiZD8OReDqiCpFr-yetIR6x1cNkI,23
 metadata_magic/main/rename/rename_jsons.py,sha256=-gWlJ6G99lmRNWtJ8dBP5LfxA16IeKIRLXT4_U30-3c,2632
 metadata_magic/main/rename/rename_tools.py,sha256=IxVYA61YcIPfocELVm6L1SvFpr850Q6KzBCS_h15lmU,3198
 metadata_magic/main/rename/sort_rename.py,sha256=dRsXHzBEtAd0-CthaNY0nFa9as_I29KPM9ChfXE4jls,7793
@@ -20,21 +20,21 @@
 metadata_magic/test/test_meta_finder.py,sha256=TbimBk30oHsZ4jAY_kL1m1aIFQ-XXZ-aoqgzgZwTACk,4245
 metadata_magic/test/test_meta_reader.py,sha256=smDFIUXvYOc1hDS1i__03FUVMd24RiVA0L4UAUHJoLo,22279
 metadata_magic/test/comic_archive/__init__.py,sha256=1oLL20yLB1GL9IbFiZD8OReDqiCpFr-yetIR6x1cNkI,23
 metadata_magic/test/comic_archive/test_comic_archive.py,sha256=5U3y1SheEYb7L7dRFJLHxDR2QFJYgBsnBWljiAmvsO8,16978
 metadata_magic/test/comic_archive/test_comic_xml.py,sha256=c91DzRX-Gx9EnWb42-1VO8w-8303PeMeP7-aPfHiym4,19772
 metadata_magic/test/comic_archive/test_series_info.py,sha256=lDROyxeXAwXe2OGL1UmpIP6NxP-5yyXi1HCRbOlAs30,8856
 metadata_magic/test/epub/__init__.py,sha256=1oLL20yLB1GL9IbFiZD8OReDqiCpFr-yetIR6x1cNkI,23
-metadata_magic/test/epub/test_epub.py,sha256=AvGeStR7AC0L9rGxXkSp5cjT3KRWWcdNPhk1Z65QPsk,26206
+metadata_magic/test/epub/test_epub.py,sha256=JFLk6d1cdzu9CrYvouqDDqSM8yB9z5Ge1x6ZV0sNLMM,40512
 metadata_magic/test/error_finding/__init__.py,sha256=1oLL20yLB1GL9IbFiZD8OReDqiCpFr-yetIR6x1cNkI,23
 metadata_magic/test/error_finding/test_missing_media.py,sha256=5VqspBlJZV7sgh4z-KUHpsblGSkixVpS3_RNTyNaaqQ,1545
 metadata_magic/test/error_finding/test_missing_metadata.py,sha256=3vO289fMXfEaLEM8ncLLUE-Mq2WqsmmuSfRRRXpn6vc,1587
 metadata_magic/test/rename/__init__.py,sha256=1oLL20yLB1GL9IbFiZD8OReDqiCpFr-yetIR6x1cNkI,23
 metadata_magic/test/rename/test_rename_jsons.py,sha256=8OBkP63SfdOE4AK9BsBw0XlXoZttDyOAzIflRHzwvMc,2553
 metadata_magic/test/rename/test_rename_tools.py,sha256=4AIdJHogwfM2IX0owpIxAufrxBECtAX6CMLuhOMXFmo,4581
 metadata_magic/test/rename/test_sort_rename.py,sha256=8tMO1GZpe_iai0gKIOOkX14RIk2XtHZygj65I-d2oR0,10127
-Metadata_Magic-0.3.2.dist-info/LICENSE,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
-Metadata_Magic-0.3.2.dist-info/METADATA,sha256=IpuXmgp61wEceuqnOi2oToNk6cpodmAuNbPStGXvwsI,5758
-Metadata_Magic-0.3.2.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-Metadata_Magic-0.3.2.dist-info/entry_points.txt,sha256=i7pIJvJCMrPk6dSYCBwv6YZN6LDfG5wv4l1MSXC2ioE,476
-Metadata_Magic-0.3.2.dist-info/top_level.txt,sha256=xiXw1Za6sizhihwckAr1UAU5GxhrzpKEd6cIPCRmuT0,15
-Metadata_Magic-0.3.2.dist-info/RECORD,,
+Metadata_Magic-0.4.1.dist-info/LICENSE,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
+Metadata_Magic-0.4.1.dist-info/METADATA,sha256=frQjyFeyw_bJAPE6ufL4iKYsQ_XTCKDCGL24oyss5PA,5734
+Metadata_Magic-0.4.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+Metadata_Magic-0.4.1.dist-info/entry_points.txt,sha256=i7pIJvJCMrPk6dSYCBwv6YZN6LDfG5wv4l1MSXC2ioE,476
+Metadata_Magic-0.4.1.dist-info/top_level.txt,sha256=xiXw1Za6sizhihwckAr1UAU5GxhrzpKEd6cIPCRmuT0,15
+Metadata_Magic-0.4.1.dist-info/RECORD,,
```

